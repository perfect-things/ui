var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/vanilla-swipe/lib/types/index.js
var require_types = __commonJS({
  "node_modules/vanilla-swipe/lib/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TraceDirectionKey = exports.Direction = exports.Axis = void 0;
    var TraceDirectionKey;
    exports.TraceDirectionKey = TraceDirectionKey;
    (function(TraceDirectionKey2) {
      TraceDirectionKey2["NEGATIVE"] = "NEGATIVE";
      TraceDirectionKey2["POSITIVE"] = "POSITIVE";
      TraceDirectionKey2["NONE"] = "NONE";
    })(TraceDirectionKey || (exports.TraceDirectionKey = TraceDirectionKey = {}));
    var Direction;
    exports.Direction = Direction;
    (function(Direction2) {
      Direction2["TOP"] = "TOP";
      Direction2["LEFT"] = "LEFT";
      Direction2["RIGHT"] = "RIGHT";
      Direction2["BOTTOM"] = "BOTTOM";
      Direction2["NONE"] = "NONE";
    })(Direction || (exports.Direction = Direction = {}));
    var Axis;
    exports.Axis = Axis;
    (function(Axis2) {
      Axis2["X"] = "x";
      Axis2["Y"] = "y";
    })(Axis || (exports.Axis = Axis = {}));
  }
});

// node_modules/vanilla-swipe/lib/utils/calculateDirection.js
var require_calculateDirection = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/calculateDirection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.calculateDirection = calculateDirection;
    var _types = require_types();
    function calculateDirection(trace) {
      var direction;
      var negative = _types.TraceDirectionKey.NEGATIVE;
      var positive = _types.TraceDirectionKey.POSITIVE;
      var current = trace[trace.length - 1];
      var previous = trace[trace.length - 2] || 0;
      if (trace.every(function(i) {
        return i === 0;
      })) {
        return _types.TraceDirectionKey.NONE;
      }
      direction = current > previous ? positive : negative;
      if (current === 0) {
        direction = previous < 0 ? positive : negative;
      }
      return direction;
    }
  }
});

// node_modules/vanilla-swipe/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.resolveAxisDirection = exports.getDirectionValue = exports.getDirectionKey = exports.getDifference = void 0;
    var _types = require_types();
    var getDirectionKey = function getDirectionKey2() {
      var object = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var key = Object.keys(object).toString();
      switch (key) {
        case _types.TraceDirectionKey.POSITIVE:
          return _types.TraceDirectionKey.POSITIVE;
        case _types.TraceDirectionKey.NEGATIVE:
          return _types.TraceDirectionKey.NEGATIVE;
        default:
          return _types.TraceDirectionKey.NONE;
      }
    };
    exports.getDirectionKey = getDirectionKey;
    var getDirectionValue = function getDirectionValue2() {
      var values = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return values[values.length - 1] || 0;
    };
    exports.getDirectionValue = getDirectionValue;
    var getDifference = function getDifference2() {
      var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return Math.abs(x - y);
    };
    exports.getDifference = getDifference;
    var resolveAxisDirection = function resolveAxisDirection2(axis, key) {
      var negative = _types.Direction.LEFT;
      var positive = _types.Direction.RIGHT;
      var direction = _types.Direction.NONE;
      if (axis === _types.Axis.Y) {
        negative = _types.Direction.BOTTOM;
        positive = _types.Direction.TOP;
      }
      if (key === _types.TraceDirectionKey.NEGATIVE) {
        direction = negative;
      }
      if (key === _types.TraceDirectionKey.POSITIVE) {
        direction = positive;
      }
      return direction;
    };
    exports.resolveAxisDirection = resolveAxisDirection;
  }
});

// node_modules/vanilla-swipe/lib/utils/calculateDirectionDelta.js
var require_calculateDirectionDelta = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/calculateDirectionDelta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.calculateDirectionDelta = calculateDirectionDelta;
    var _types = require_types();
    var _common = require_common();
    function calculateDirectionDelta(traceDirections) {
      var delta = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var length = traceDirections.length;
      var i = length - 1;
      var direction = _types.TraceDirectionKey.NONE;
      for (; i >= 0; i--) {
        var current = traceDirections[i];
        var currentKey = (0, _common.getDirectionKey)(current);
        var currentValue = (0, _common.getDirectionValue)(current[currentKey]);
        var prev = traceDirections[i - 1] || {};
        var prevKey = (0, _common.getDirectionKey)(prev);
        var prevValue = (0, _common.getDirectionValue)(prev[prevKey]);
        var difference = (0, _common.getDifference)(currentValue, prevValue);
        if (difference >= delta) {
          direction = currentKey;
          break;
        } else {
          direction = prevKey;
        }
      }
      return direction;
    }
  }
});

// node_modules/vanilla-swipe/lib/utils/calculateDuration.js
var require_calculateDuration = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/calculateDuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.calculateDuration = calculateDuration;
    function calculateDuration() {
      var prevTime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var nextTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return prevTime ? nextTime - prevTime : 0;
    }
  }
});

// node_modules/vanilla-swipe/lib/utils/calculateMovingPosition.js
var require_calculateMovingPosition = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/calculateMovingPosition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.calculateMovingPosition = calculateMovingPosition;
    function calculateMovingPosition(e) {
      if ("changedTouches" in e) {
        var touches = e.changedTouches && e.changedTouches[0];
        return {
          x: touches && touches.clientX,
          y: touches && touches.clientY
        };
      }
      return {
        x: e.clientX,
        y: e.clientY
      };
    }
  }
});

// node_modules/vanilla-swipe/lib/utils/updateTrace.js
var require_updateTrace = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/updateTrace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.updateTrace = updateTrace;
    function updateTrace(trace, value2) {
      var last = trace[trace.length - 1];
      if (last !== value2) {
        trace.push(value2);
      }
      return trace;
    }
  }
});

// node_modules/vanilla-swipe/lib/utils/calculateTraceDirections.js
var require_calculateTraceDirections = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/calculateTraceDirections.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.calculateTraceDirections = calculateTraceDirections;
    var _types = require_types();
    function _defineProperty(obj, key, value2) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    function calculateTraceDirections() {
      var trace = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var ticks = [];
      var positive = _types.TraceDirectionKey.POSITIVE;
      var negative = _types.TraceDirectionKey.NEGATIVE;
      var i = 0;
      var tick2 = [];
      var direction = _types.TraceDirectionKey.NONE;
      for (; i < trace.length; i++) {
        var current = trace[i];
        var prev = trace[i - 1];
        if (tick2.length) {
          var currentDirection = current > prev ? positive : negative;
          if (direction === _types.TraceDirectionKey.NONE) {
            direction = currentDirection;
          }
          if (currentDirection === direction) {
            tick2.push(current);
          } else {
            ticks.push(_defineProperty({}, direction, tick2.slice()));
            tick2 = [];
            tick2.push(current);
            direction = currentDirection;
          }
        } else {
          if (current !== 0) {
            direction = current > 0 ? positive : negative;
          }
          tick2.push(current);
        }
      }
      if (tick2.length) {
        ticks.push(_defineProperty({}, direction, tick2));
      }
      return ticks;
    }
  }
});

// node_modules/vanilla-swipe/lib/utils/resolveDirection.js
var require_resolveDirection = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/resolveDirection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.resolveDirection = resolveDirection;
    var _calculateDirection = require_calculateDirection();
    var _calculateTraceDirections = require_calculateTraceDirections();
    var _calculateDirectionDelta = require_calculateDirectionDelta();
    var _common = require_common();
    var _types = require_types();
    function resolveDirection(trace) {
      var axis = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _types.Axis.X;
      var directionDelta = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      if (directionDelta) {
        var directions = (0, _calculateTraceDirections.calculateTraceDirections)(trace);
        var _direction = (0, _calculateDirectionDelta.calculateDirectionDelta)(directions, directionDelta);
        return (0, _common.resolveAxisDirection)(axis, _direction);
      }
      var direction = (0, _calculateDirection.calculateDirection)(trace);
      return (0, _common.resolveAxisDirection)(axis, direction);
    }
  }
});

// node_modules/vanilla-swipe/lib/utils/calculateVelocity.js
var require_calculateVelocity = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/calculateVelocity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.calculateVelocity = calculateVelocity;
    function calculateVelocity(x, y, time) {
      var magnitude = Math.sqrt(x * x + y * y);
      return magnitude / (time || 1);
    }
  }
});

// node_modules/vanilla-swipe/lib/utils/calculatePosition.js
var require_calculatePosition = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/calculatePosition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.calculatePosition = calculatePosition;
    var _updateTrace = require_updateTrace();
    var _resolveDirection = require_resolveDirection();
    var _calculateDuration = require_calculateDuration();
    var _calculateVelocity = require_calculateVelocity();
    var _types = require_types();
    function calculatePosition(state, options) {
      var start = state.start, x = state.x, y = state.y, traceX = state.traceX, traceY = state.traceY;
      var rotatePosition = options.rotatePosition, directionDelta = options.directionDelta;
      var deltaX = rotatePosition.x - x;
      var deltaY = y - rotatePosition.y;
      var absX = Math.abs(deltaX);
      var absY = Math.abs(deltaY);
      (0, _updateTrace.updateTrace)(traceX, deltaX);
      (0, _updateTrace.updateTrace)(traceY, deltaY);
      var directionX = (0, _resolveDirection.resolveDirection)(traceX, _types.Axis.X, directionDelta);
      var directionY = (0, _resolveDirection.resolveDirection)(traceY, _types.Axis.Y, directionDelta);
      var duration2 = (0, _calculateDuration.calculateDuration)(start, Date.now());
      var velocity = (0, _calculateVelocity.calculateVelocity)(absX, absY, duration2);
      return {
        absX,
        absY,
        deltaX,
        deltaY,
        directionX,
        directionY,
        duration: duration2,
        positionX: rotatePosition.x,
        positionY: rotatePosition.y,
        velocity
      };
    }
  }
});

// node_modules/vanilla-swipe/lib/utils/checkIsMoreThanSingleTouches.js
var require_checkIsMoreThanSingleTouches = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/checkIsMoreThanSingleTouches.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.checkIsMoreThanSingleTouches = void 0;
    var checkIsMoreThanSingleTouches = function checkIsMoreThanSingleTouches2(e) {
      return Boolean(e.touches && e.touches.length > 1);
    };
    exports.checkIsMoreThanSingleTouches = checkIsMoreThanSingleTouches;
  }
});

// node_modules/vanilla-swipe/lib/utils/createOptions.js
var require_createOptions = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/createOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createOptions = createOptions;
    function createOptions() {
      var proxy = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      Object.defineProperty(proxy, "passive", {
        get: function get() {
          this.isPassiveSupported = true;
          return true;
        },
        enumerable: true
      });
      return proxy;
    }
  }
});

// node_modules/vanilla-swipe/lib/utils/checkIsPassiveSupported.js
var require_checkIsPassiveSupported = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/checkIsPassiveSupported.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.checkIsPassiveSupported = checkIsPassiveSupported;
    exports.noop = void 0;
    var _createOptions = require_createOptions();
    function checkIsPassiveSupported(isPassiveSupported) {
      if (typeof isPassiveSupported === "boolean") {
        return isPassiveSupported;
      }
      var proxy = {
        isPassiveSupported
      };
      try {
        var options = (0, _createOptions.createOptions)(proxy);
        window.addEventListener("checkIsPassiveSupported", noop2, options);
        window.removeEventListener("checkIsPassiveSupported", noop2, options);
      } catch (err) {
      }
      return proxy.isPassiveSupported;
    }
    var noop2 = function noop3() {
    };
    exports.noop = noop2;
  }
});

// node_modules/vanilla-swipe/lib/utils/checkIsTouchEventsSupported.js
var require_checkIsTouchEventsSupported = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/checkIsTouchEventsSupported.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.checkIsTouchEventsSupported = void 0;
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    var checkIsTouchEventsSupported = function checkIsTouchEventsSupported2() {
      return (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && ("ontouchstart" in window || Boolean(window.navigator.maxTouchPoints));
    };
    exports.checkIsTouchEventsSupported = checkIsTouchEventsSupported;
  }
});

// node_modules/vanilla-swipe/lib/utils/getInitialState.js
var require_getInitialState = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/getInitialState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getInitialState = void 0;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value2) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    var getInitialState = function getInitialState2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return _objectSpread({
        x: 0,
        y: 0,
        start: 0,
        isSwiping: false,
        traceX: [],
        traceY: []
      }, options);
    };
    exports.getInitialState = getInitialState;
  }
});

// node_modules/vanilla-swipe/lib/utils/getInitialProps.js
var require_getInitialProps = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/getInitialProps.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getInitialProps = void 0;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value2) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    var getInitialProps = function getInitialProps2() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return _objectSpread({
        element: null,
        target: null,
        delta: 10,
        directionDelta: 0,
        rotationAngle: 0,
        mouseTrackingEnabled: false,
        touchTrackingEnabled: true,
        preventDefaultTouchmoveEvent: false,
        preventTrackingOnMouseleave: false
      }, props);
    };
    exports.getInitialProps = getInitialProps;
  }
});

// node_modules/vanilla-swipe/lib/utils/getOptions.js
var require_getOptions = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/getOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getOptions = getOptions;
    function getOptions() {
      var isPassiveSupported = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (isPassiveSupported) {
        return {
          passive: false
        };
      }
      return {};
    }
  }
});

// node_modules/vanilla-swipe/lib/utils/rotateByAngle.js
var require_rotateByAngle = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/rotateByAngle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.rotateByAngle = rotateByAngle;
    function rotateByAngle(position) {
      var angle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (angle === 0) {
        return position;
      }
      var x = position.x, y = position.y;
      var angleInRadians = Math.PI / 180 * angle;
      var rotatedX = x * Math.cos(angleInRadians) + y * Math.sin(angleInRadians);
      var rotatedY = y * Math.cos(angleInRadians) - x * Math.sin(angleInRadians);
      return {
        x: rotatedX,
        y: rotatedY
      };
    }
  }
});

// node_modules/vanilla-swipe/lib/utils/index.js
var require_utils = __commonJS({
  "node_modules/vanilla-swipe/lib/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _calculateDirection = require_calculateDirection();
    Object.keys(_calculateDirection).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _calculateDirection[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _calculateDirection[key];
        }
      });
    });
    var _calculateDirectionDelta = require_calculateDirectionDelta();
    Object.keys(_calculateDirectionDelta).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _calculateDirectionDelta[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _calculateDirectionDelta[key];
        }
      });
    });
    var _calculateDuration = require_calculateDuration();
    Object.keys(_calculateDuration).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _calculateDuration[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _calculateDuration[key];
        }
      });
    });
    var _calculateMovingPosition = require_calculateMovingPosition();
    Object.keys(_calculateMovingPosition).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _calculateMovingPosition[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _calculateMovingPosition[key];
        }
      });
    });
    var _calculatePosition = require_calculatePosition();
    Object.keys(_calculatePosition).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _calculatePosition[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _calculatePosition[key];
        }
      });
    });
    var _calculateTraceDirections = require_calculateTraceDirections();
    Object.keys(_calculateTraceDirections).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _calculateTraceDirections[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _calculateTraceDirections[key];
        }
      });
    });
    var _calculateVelocity = require_calculateVelocity();
    Object.keys(_calculateVelocity).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _calculateVelocity[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _calculateVelocity[key];
        }
      });
    });
    var _checkIsMoreThanSingleTouches = require_checkIsMoreThanSingleTouches();
    Object.keys(_checkIsMoreThanSingleTouches).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _checkIsMoreThanSingleTouches[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _checkIsMoreThanSingleTouches[key];
        }
      });
    });
    var _checkIsPassiveSupported = require_checkIsPassiveSupported();
    Object.keys(_checkIsPassiveSupported).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _checkIsPassiveSupported[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _checkIsPassiveSupported[key];
        }
      });
    });
    var _checkIsTouchEventsSupported = require_checkIsTouchEventsSupported();
    Object.keys(_checkIsTouchEventsSupported).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _checkIsTouchEventsSupported[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _checkIsTouchEventsSupported[key];
        }
      });
    });
    var _common = require_common();
    Object.keys(_common).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _common[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _common[key];
        }
      });
    });
    var _createOptions = require_createOptions();
    Object.keys(_createOptions).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _createOptions[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _createOptions[key];
        }
      });
    });
    var _getInitialState = require_getInitialState();
    Object.keys(_getInitialState).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _getInitialState[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _getInitialState[key];
        }
      });
    });
    var _getInitialProps = require_getInitialProps();
    Object.keys(_getInitialProps).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _getInitialProps[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _getInitialProps[key];
        }
      });
    });
    var _getOptions = require_getOptions();
    Object.keys(_getOptions).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _getOptions[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _getOptions[key];
        }
      });
    });
    var _resolveDirection = require_resolveDirection();
    Object.keys(_resolveDirection).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _resolveDirection[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _resolveDirection[key];
        }
      });
    });
    var _rotateByAngle = require_rotateByAngle();
    Object.keys(_rotateByAngle).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _rotateByAngle[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _rotateByAngle[key];
        }
      });
    });
    var _updateTrace = require_updateTrace();
    Object.keys(_updateTrace).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _updateTrace[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _updateTrace[key];
        }
      });
    });
  }
});

// node_modules/vanilla-swipe/lib/index.js
var require_lib = __commonJS({
  "node_modules/vanilla-swipe/lib/index.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {};
    exports["default"] = void 0;
    var Utils2 = _interopRequireWildcard(require_utils());
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _types[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _types[key];
        }
      });
    });
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _classCallCheck(instance122, Constructor) {
      if (!(instance122 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _defineProperty(obj, key, value2) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    var VanillaSwipe2 = /* @__PURE__ */ function() {
      function VanillaSwipe3(props) {
        _classCallCheck(this, VanillaSwipe3);
        _defineProperty(this, "state", void 0);
        _defineProperty(this, "props", void 0);
        this.state = Utils2.getInitialState();
        this.props = Utils2.getInitialProps(props);
        this.handleSwipeStart = this.handleSwipeStart.bind(this);
        this.handleSwipeMove = this.handleSwipeMove.bind(this);
        this.handleSwipeEnd = this.handleSwipeEnd.bind(this);
        this.handleMouseDown = this.handleMouseDown.bind(this);
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.handleMouseUp = this.handleMouseUp.bind(this);
        this.handleMouseLeave = this.handleMouseLeave.bind(this);
      }
      _createClass(VanillaSwipe3, [{
        key: "init",
        value: function init3() {
          this.setupTouchListeners();
          this.setupMouseListeners();
        }
      }, {
        key: "update",
        value: function update2(props) {
          var prevProps = this.props;
          var nextProps = Object.assign({}, prevProps, props);
          if (prevProps.element !== nextProps.element || prevProps.target !== nextProps.target) {
            this.destroy();
            this.props = nextProps;
            this.init();
            return;
          }
          this.props = nextProps;
          if (prevProps.mouseTrackingEnabled !== nextProps.mouseTrackingEnabled || prevProps.preventTrackingOnMouseleave !== nextProps.preventTrackingOnMouseleave) {
            this.cleanupMouseListeners();
            nextProps.mouseTrackingEnabled ? this.setupMouseListeners() : this.cleanupMouseListeners();
          }
          if (prevProps.touchTrackingEnabled !== nextProps.touchTrackingEnabled) {
            this.cleanupTouchListeners();
            nextProps.touchTrackingEnabled ? this.setupTouchListeners() : this.cleanupTouchListeners();
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.cleanupMouseListeners();
          this.cleanupTouchListeners();
          this.state = Utils2.getInitialState();
          this.props = Utils2.getInitialProps();
        }
      }, {
        key: "setupTouchListeners",
        value: function setupTouchListeners() {
          var _this$props = this.props, element3 = _this$props.element, target = _this$props.target, touchTrackingEnabled = _this$props.touchTrackingEnabled;
          if (element3 && touchTrackingEnabled) {
            var listener = target || element3;
            var isPassiveSupported = Utils2.checkIsPassiveSupported();
            var options = Utils2.getOptions(isPassiveSupported);
            listener.addEventListener("touchstart", this.handleSwipeStart, options);
            listener.addEventListener("touchmove", this.handleSwipeMove, options);
            listener.addEventListener("touchend", this.handleSwipeEnd, options);
          }
        }
      }, {
        key: "cleanupTouchListeners",
        value: function cleanupTouchListeners() {
          var _this$props2 = this.props, element3 = _this$props2.element, target = _this$props2.target;
          var listener = target || element3;
          if (listener) {
            listener.removeEventListener("touchstart", this.handleSwipeStart);
            listener.removeEventListener("touchmove", this.handleSwipeMove);
            listener.removeEventListener("touchend", this.handleSwipeEnd);
          }
        }
      }, {
        key: "setupMouseListeners",
        value: function setupMouseListeners() {
          var _this$props3 = this.props, element3 = _this$props3.element, mouseTrackingEnabled = _this$props3.mouseTrackingEnabled, preventTrackingOnMouseleave = _this$props3.preventTrackingOnMouseleave;
          if (mouseTrackingEnabled && element3) {
            element3.addEventListener("mousedown", this.handleMouseDown);
            element3.addEventListener("mousemove", this.handleMouseMove);
            element3.addEventListener("mouseup", this.handleMouseUp);
            if (preventTrackingOnMouseleave) {
              element3.addEventListener("mouseleave", this.handleMouseLeave);
            }
          }
        }
      }, {
        key: "cleanupMouseListeners",
        value: function cleanupMouseListeners() {
          var element3 = this.props.element;
          if (element3) {
            element3.removeEventListener("mousedown", this.handleMouseDown);
            element3.removeEventListener("mousemove", this.handleMouseMove);
            element3.removeEventListener("mouseup", this.handleMouseUp);
            element3.removeEventListener("mouseleave", this.handleMouseLeave);
          }
        }
      }, {
        key: "getEventData",
        value: function getEventData(e) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            directionDelta: 0
          };
          var rotationAngle = this.props.rotationAngle;
          var directionDelta = options.directionDelta;
          var movingPosition = Utils2.calculateMovingPosition(e);
          var rotatePosition = Utils2.rotateByAngle(movingPosition, rotationAngle);
          return Utils2.calculatePosition(this.state, {
            rotatePosition,
            directionDelta
          });
        }
      }, {
        key: "handleSwipeStart",
        value: function handleSwipeStart(e) {
          if (Utils2.checkIsMoreThanSingleTouches(e))
            return;
          var rotationAngle = this.props.rotationAngle;
          var movingPosition = Utils2.calculateMovingPosition(e);
          var _Utils$rotateByAngle = Utils2.rotateByAngle(movingPosition, rotationAngle), x = _Utils$rotateByAngle.x, y = _Utils$rotateByAngle.y;
          this.state = Utils2.getInitialState({
            isSwiping: false,
            start: Date.now(),
            x,
            y
          });
        }
      }, {
        key: "handleSwipeMove",
        value: function handleSwipeMove(e) {
          var _this$state = this.state, x = _this$state.x, y = _this$state.y, isSwiping = _this$state.isSwiping;
          if (!x || !y || Utils2.checkIsMoreThanSingleTouches(e))
            return;
          var directionDelta = this.props.directionDelta || 0;
          var _this$getEventData = this.getEventData(e, {
            directionDelta
          }), absX = _this$getEventData.absX, absY = _this$getEventData.absY, deltaX = _this$getEventData.deltaX, deltaY = _this$getEventData.deltaY, directionX = _this$getEventData.directionX, directionY = _this$getEventData.directionY, duration2 = _this$getEventData.duration, velocity = _this$getEventData.velocity;
          var _this$props4 = this.props, delta = _this$props4.delta, preventDefaultTouchmoveEvent = _this$props4.preventDefaultTouchmoveEvent, onSwipeStart = _this$props4.onSwipeStart, onSwiping = _this$props4.onSwiping;
          if (e.cancelable && preventDefaultTouchmoveEvent)
            e.preventDefault();
          if (absX < Number(delta) && absY < Number(delta) && !isSwiping)
            return;
          if (onSwipeStart && !isSwiping) {
            onSwipeStart(e, {
              deltaX,
              deltaY,
              absX,
              absY,
              directionX,
              directionY,
              duration: duration2,
              velocity
            });
          }
          this.state.isSwiping = true;
          if (onSwiping) {
            onSwiping(e, {
              deltaX,
              deltaY,
              absX,
              absY,
              directionX,
              directionY,
              duration: duration2,
              velocity
            });
          }
        }
      }, {
        key: "handleSwipeEnd",
        value: function handleSwipeEnd(e) {
          var _this$props5 = this.props, onSwiped = _this$props5.onSwiped, onTap = _this$props5.onTap;
          if (this.state.isSwiping) {
            var directionDelta = this.props.directionDelta || 0;
            var position = this.getEventData(e, {
              directionDelta
            });
            onSwiped && onSwiped(e, position);
          } else {
            var _position = this.getEventData(e);
            onTap && onTap(e, _position);
          }
          this.state = Utils2.getInitialState();
        }
      }, {
        key: "handleMouseDown",
        value: function handleMouseDown(e) {
          var target = this.props.target;
          if (target) {
            if (target === e.target) {
              this.handleSwipeStart(e);
            }
          } else {
            this.handleSwipeStart(e);
          }
        }
      }, {
        key: "handleMouseMove",
        value: function handleMouseMove(e) {
          this.handleSwipeMove(e);
        }
      }, {
        key: "handleMouseUp",
        value: function handleMouseUp(e) {
          var isSwiping = this.state.isSwiping;
          var target = this.props.target;
          if (target) {
            if (target === e.target || isSwiping) {
              this.handleSwipeEnd(e);
            }
          } else {
            this.handleSwipeEnd(e);
          }
        }
      }, {
        key: "handleMouseLeave",
        value: function handleMouseLeave(e) {
          var isSwiping = this.state.isSwiping;
          if (isSwiping) {
            this.handleSwipeEnd(e);
          }
        }
      }], [{
        key: "isTouchEventsSupported",
        value: function isTouchEventsSupported() {
          return Utils2.checkIsTouchEventsSupported();
        }
      }]);
      return VanillaSwipe3;
    }();
    exports["default"] = VanillaSwipe2;
  }
});

// node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "node_modules/prismjs/prism.js"(exports, module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism2 = function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _ = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: _self2.Prism && _self2.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode2(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode2(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode2);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone;
            var id2;
            switch (_.util.type(o)) {
              case "Object":
                id2 = _.util.objId(o);
                if (visited[id2]) {
                  return visited[id2];
                }
                clone = /** @type {Record<string, any>} */
                {};
                visited[id2] = clone;
                for (var key in o) {
                  if (o.hasOwnProperty(key)) {
                    clone[key] = deepClone(o[key], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone
                );
              case "Array":
                id2 = _.util.objId(o);
                if (visited[id2]) {
                  return visited[id2];
                }
                clone = [];
                visited[id2] = clone;
                /** @type {Array} */
                /** @type {any} */
                o.forEach(function(v, i) {
                  clone[i] = deepClone(v, visited);
                });
                return (
                  /** @type {any} */
                  clone
                );
              default:
                return o;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element3) {
            while (element3) {
              var m = lang.exec(element3.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element3 = element3.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element3, language) {
            element3.className = element3.className.replace(RegExp(lang, "gi"), "");
            element3.classList.add("language-" + language);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return (
                /** @type {any} */
                document.currentScript
              );
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element3, className2, defaultActivation) {
            var no = "no-" + className2;
            while (element3) {
              var classList = element3.classList;
              if (classList.contains(className2)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element3 = element3.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id2, redef) {
            var lang2 = _.util.clone(_.languages[id2]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert2, root) {
            root = root || /** @type {any} */
            _.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert2) {
                    if (insert2.hasOwnProperty(newToken)) {
                      ret[newToken] = insert2[newToken];
                    }
                  }
                }
                if (!insert2.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _.languages.DFS(_.languages, function(key, value2) {
              if (value2 === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o, callback, type, visited) {
            visited = visited || {};
            var objId = _.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type || i);
                var property = o[i];
                var propertyType = _.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prisms API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(async, callback) {
          _.highlightAllUnder(document, async, callback);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element3; element3 = env.elements[i++]; ) {
            _.highlightElement(element3, async === true, env.callback);
          }
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(element3, async, callback) {
          var language = _.util.getLanguage(element3);
          var grammar = _.languages[language];
          _.util.setLanguage(element3, language);
          var parent = element3.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _.util.setLanguage(parent, language);
          }
          var code = element3.textContent;
          var env = {
            element: element3,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _.hooks.run("after-highlight", env);
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
          }
        },
        /**
         * Low-level function, only use if you know what youre doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text2, grammar, language) {
          var env = {
            code: text2,
            grammar,
            language
          };
          _.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _.tokenize(env.code, env.grammar);
          _.hooks.run("after-tokenize", env);
          return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text2, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text2);
          matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name2, callback) {
            var hooks = _.hooks.all;
            hooks[name2] = hooks[name2] || [];
            hooks[name2].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name2, env) {
            var callbacks = _.hooks.all[name2];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _;
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify2(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s = "";
          o.forEach(function(e) {
            s += stringify2(e, language);
          });
          return s;
        }
        var env = {
          type: o.type,
          content: stringify2(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases2 = o.alias;
        if (aliases2) {
          if (Array.isArray(aliases2)) {
            Array.prototype.push.apply(env.classes, aliases2);
          } else {
            env.classes.push(aliases2);
          }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name2 in env.attributes) {
          attributes += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text2, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text2);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text2.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text2, lookbehind);
                if (!match || match.index >= text2.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p = pos;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                  removeCount++;
                  p += k.value.length;
                }
                removeCount--;
                str = text2.slice(pos, p);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j,
                  reach
                };
                matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value2) {
        var next = node.next;
        var newNode = { value: value2, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _;
        }
        if (!_.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_.highlight(code, _.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _;
      }
      var script = _.util.currentScript();
      if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_.manual) {
          _.highlightAll();
        }
      }
      if (!_.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _;
    }(_self);
    if (typeof module !== "undefined" && module.exports) {
      module.exports = Prism2;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism2;
    }
    Prism2.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
    Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
    Prism2.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function addInlined2(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism2.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism2.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism2.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(attrName, lang) {
        Prism2.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism2.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism2.languages.html = Prism2.languages.markup;
    Prism2.languages.mathml = Prism2.languages.markup;
    Prism2.languages.svg = Prism2.languages.markup;
    Prism2.languages.xml = Prism2.languages.extend("markup", {});
    Prism2.languages.ssml = Prism2.languages.xml;
    Prism2.languages.atom = Prism2.languages.xml;
    Prism2.languages.rss = Prism2.languages.xml;
    (function(Prism3) {
      var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism3.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        "url": {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
      var markup = Prism3.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism2);
    Prism2.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism2.languages.javascript = Prism2.languages.extend("clike", {
      "class-name": [
        Prism2.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism2.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism2.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism2.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism2.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism2.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism2.languages.markup) {
      Prism2.languages.markup.tag.addInlined("script", "javascript");
      Prism2.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism2.languages.js = Prism2.languages.javascript;
    (function() {
      if (typeof Prism2 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading\u2026";
      var FAILURE_MESSAGE = function(status, message) {
        return "\u2716 Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error2) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error2(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error2(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range2) {
        var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range2 || "");
        if (m) {
          var start = Number(m[1]);
          var comma = m[2];
          var end = m[3];
          if (!comma) {
            return [start, start];
          }
          if (!end) {
            return [start, void 0];
          }
          return [start, Number(end)];
        }
        return void 0;
      }
      Prism2.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism2.hooks.add("before-sanity-check", function(env) {
        var pre = (
          /** @type {HTMLPreElement} */
          env.element
        );
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          Prism2.util.setLanguage(code, language);
          Prism2.util.setLanguage(pre, language);
          var autoloader = Prism2.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          loadFile(
            src,
            function(text2) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range2 = parseRange(pre.getAttribute("data-range"));
              if (range2) {
                var lines = text2.split(/\r\n?|\n/g);
                var start = range2[0];
                var end = range2[1] == null ? lines.length : range2[1];
                if (start < 0) {
                  start += lines.length;
                }
                start = Math.max(0, Math.min(start - 1, lines.length));
                if (end < 0) {
                  end += lines.length;
                }
                end = Math.max(0, Math.min(end, lines.length));
                text2 = lines.slice(start, end).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start + 1));
                }
              }
              code.textContent = text2;
              Prism2.highlightElement(code);
            },
            function(error2) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code.textContent = error2;
            }
          );
        }
      });
      Prism2.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i = 0, element3; element3 = elements[i++]; ) {
            Prism2.highlightElement(element3);
          }
        }
      };
      var logged = false;
      Prism2.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  }
});

// node_modules/prismjs/plugins/normalize-whitespace/prism-normalize-whitespace.js
var require_prism_normalize_whitespace = __commonJS({
  "node_modules/prismjs/plugins/normalize-whitespace/prism-normalize-whitespace.js"(exports, module) {
    (function() {
      if (typeof Prism === "undefined") {
        return;
      }
      var assign2 = Object.assign || function(obj1, obj2) {
        for (var name2 in obj2) {
          if (obj2.hasOwnProperty(name2)) {
            obj1[name2] = obj2[name2];
          }
        }
        return obj1;
      };
      function NormalizeWhitespace(defaults) {
        this.defaults = assign2({}, defaults);
      }
      function toCamelCase(value2) {
        return value2.replace(/-(\w)/g, function(match, firstChar) {
          return firstChar.toUpperCase();
        });
      }
      function tabLen(str) {
        var res = 0;
        for (var i = 0; i < str.length; ++i) {
          if (str.charCodeAt(i) == "	".charCodeAt(0)) {
            res += 3;
          }
        }
        return str.length + res;
      }
      var settingsConfig = {
        "remove-trailing": "boolean",
        "remove-indent": "boolean",
        "left-trim": "boolean",
        "right-trim": "boolean",
        "break-lines": "number",
        "indent": "number",
        "remove-initial-line-feed": "boolean",
        "tabs-to-spaces": "number",
        "spaces-to-tabs": "number"
      };
      NormalizeWhitespace.prototype = {
        setDefaults: function(defaults) {
          this.defaults = assign2(this.defaults, defaults);
        },
        normalize: function(input, settings) {
          settings = assign2(this.defaults, settings);
          for (var name2 in settings) {
            var methodName = toCamelCase(name2);
            if (name2 !== "normalize" && methodName !== "setDefaults" && settings[name2] && this[methodName]) {
              input = this[methodName].call(this, input, settings[name2]);
            }
          }
          return input;
        },
        /*
         * Normalization methods
         */
        leftTrim: function(input) {
          return input.replace(/^\s+/, "");
        },
        rightTrim: function(input) {
          return input.replace(/\s+$/, "");
        },
        tabsToSpaces: function(input, spaces) {
          spaces = spaces | 0 || 4;
          return input.replace(/\t/g, new Array(++spaces).join(" "));
        },
        spacesToTabs: function(input, spaces) {
          spaces = spaces | 0 || 4;
          return input.replace(RegExp(" {" + spaces + "}", "g"), "	");
        },
        removeTrailing: function(input) {
          return input.replace(/\s*?$/gm, "");
        },
        // Support for deprecated plugin remove-initial-line-feed
        removeInitialLineFeed: function(input) {
          return input.replace(/^(?:\r?\n|\r)/, "");
        },
        removeIndent: function(input) {
          var indents = input.match(/^[^\S\n\r]*(?=\S)/gm);
          if (!indents || !indents[0].length) {
            return input;
          }
          indents.sort(function(a, b) {
            return a.length - b.length;
          });
          if (!indents[0].length) {
            return input;
          }
          return input.replace(RegExp("^" + indents[0], "gm"), "");
        },
        indent: function(input, tabs) {
          return input.replace(/^[^\S\n\r]*(?=\S)/gm, new Array(++tabs).join("	") + "$&");
        },
        breakLines: function(input, characters) {
          characters = characters === true ? 80 : characters | 0 || 80;
          var lines = input.split("\n");
          for (var i = 0; i < lines.length; ++i) {
            if (tabLen(lines[i]) <= characters) {
              continue;
            }
            var line = lines[i].split(/(\s+)/g);
            var len = 0;
            for (var j = 0; j < line.length; ++j) {
              var tl = tabLen(line[j]);
              len += tl;
              if (len > characters) {
                line[j] = "\n" + line[j];
                len = tl;
              }
            }
            lines[i] = line.join("");
          }
          return lines.join("\n");
        }
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = NormalizeWhitespace;
      }
      Prism.plugins.NormalizeWhitespace = new NormalizeWhitespace({
        "remove-trailing": true,
        "remove-indent": true,
        "left-trim": true,
        "right-trim": true
        /*'break-lines': 80,
        'indent': 2,
        'remove-initial-line-feed': false,
        'tabs-to-spaces': 4,
        'spaces-to-tabs': 4*/
      });
      Prism.hooks.add("before-sanity-check", function(env) {
        var Normalizer = Prism.plugins.NormalizeWhitespace;
        if (env.settings && env.settings["whitespace-normalization"] === false) {
          return;
        }
        if (!Prism.util.isActive(env.element, "whitespace-normalization", true)) {
          return;
        }
        if ((!env.element || !env.element.parentNode) && env.code) {
          env.code = Normalizer.normalize(env.code, env.settings);
          return;
        }
        var pre = env.element.parentNode;
        if (!env.code || !pre || pre.nodeName.toLowerCase() !== "pre") {
          return;
        }
        if (env.settings == null) {
          env.settings = {};
        }
        for (var key in settingsConfig) {
          if (Object.hasOwnProperty.call(settingsConfig, key)) {
            var settingType = settingsConfig[key];
            if (pre.hasAttribute("data-" + key)) {
              try {
                var value2 = JSON.parse(pre.getAttribute("data-" + key) || "true");
                if (typeof value2 === settingType) {
                  env.settings[key] = value2;
                }
              } catch (_error) {
              }
            }
          }
        }
        var children2 = pre.childNodes;
        var before = "";
        var after = "";
        var codeFound = false;
        for (var i = 0; i < children2.length; ++i) {
          var node = children2[i];
          if (node == env.element) {
            codeFound = true;
          } else if (node.nodeName === "#text") {
            if (codeFound) {
              after += node.nodeValue;
            } else {
              before += node.nodeValue;
            }
            pre.removeChild(node);
            --i;
          }
        }
        if (!env.element.children.length || !Prism.plugins.KeepMarkup) {
          env.code = before + env.code + after;
          env.code = Normalizer.normalize(env.code, env.settings);
        } else {
          var html = before + env.element.innerHTML + after;
          env.element.innerHTML = Normalizer.normalize(html, env.settings);
          env.code = env.element.textContent;
        }
      });
    })();
  }
});

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
var identity = (x) => x;
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function add_location(element3, file114, line, column, char) {
  element3.__svelte_meta = {
    loc: { file: file114, line, column, char }
  };
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function validate_store(store, name2) {
  if (store != null && typeof store.subscribe !== "function") {
    throw new Error(`'${name2}' is not a store with a 'subscribe' method`);
  }
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value2;
  subscribe(store, (_) => value2 = _)();
  return value2;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope2, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope2, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope2, fn) {
  return definition[1] && fn ? assign($$scope2.ctx.slice(), definition[1](fn(ctx))) : $$scope2.ctx;
}
function get_slot_changes(definition, $$scope2, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope2.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope2.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope2.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope2.dirty | lets;
  }
  return $$scope2.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope2, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope2, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope2) {
  if ($$scope2.ctx.length > 32) {
    const dirty = [];
    const length = $$scope2.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function compute_slots(slots2) {
  const result = {};
  for (const key in slots2) {
    result[key] = true;
  }
  return result;
}
function set_store_value(store, ret, value2) {
  store.set(value2);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
function split_css_unit(value2) {
  const split = typeof value2 === "string" && value2.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return split ? [parseFloat(split[1]), split[2] || "px"] : [
    /** @type {number} */
    value2,
    "px"
  ];
}

// node_modules/svelte/src/runtime/internal/environment.js
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;

// node_modules/svelte/src/runtime/internal/loop.js
var tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /**
   * @private
   * @readonly
   * @type {WeakMap<Element, import('./private.js').Listener>}
   */
  _listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
  /**
   * @private
   * @type {ResizeObserver}
   */
  _observer = void 0;
  /** @type {ResizeObserverOptions} */
  options;
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element3, listener) {
    this._listeners.set(element3, listener);
    this._getObserver().observe(element3, this.options);
    return () => {
      this._listeners.delete(element3);
      this._observer.unobserve(element3);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    return this._observer ?? (this._observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        this._listeners.get(entry.target)?.(entry);
      }
    }));
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element2("style");
  style_element.textContent = "/* empty */";
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element2(name2) {
  return document.createElement(name2);
}
function svg_element(name2) {
  return document.createElementNS("http://www.w3.org/2000/svg", name2);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value2) {
  if (value2 == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value2)
    node.setAttribute(attribute, value2);
}
var always_set_through_set_attribute = ["width", "height"];
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function to_number(value2) {
  return value2 === "" ? null : +value2;
}
function children(element3) {
  return Array.from(element3.childNodes);
}
function set_input_value(input, value2) {
  input.value = value2 == null ? "" : value2;
}
function set_style(node, key, value2, important) {
  if (value2 == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value2, important ? "important" : "");
  }
}
function select_option(select, value2, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value2) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value2 !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element3, name2, toggle) {
  element3.classList.toggle(name2, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
var HtmlTag = class {
  /**
   * @private
   * @default false
   */
  is_svg = false;
  /** parent for creating node */
  e = void 0;
  /** html tag nodes */
  n = void 0;
  /** target */
  t = void 0;
  /** anchor */
  a = void 0;
  constructor(is_svg = false) {
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element2(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
};
function get_custom_elements_slots(element3) {
  const result = {};
  element3.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/style_manager.js
var managed_styles = /* @__PURE__ */ new Map();
var active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info2 = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info2);
  return info2;
}
function create_rule(node, a, b, duration2, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration2;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name2 = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name2]) {
    rules[name2] = true;
    stylesheet.insertRule(`@keyframes ${name2} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name2} ${duration2}ms linear ${delay}ms 1 both`;
  active += 1;
  return name2;
}
function delete_rule(node, name2) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name2 ? (anim) => anim.indexOf(name2) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info2) => {
      const { ownerNode } = info2.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}

// node_modules/svelte/src/runtime/internal/animations.js
function create_animation(node, from, fn, params) {
  if (!from)
    return noop;
  const to = node.getBoundingClientRect();
  if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
    return noop;
  const {
    delay = 0,
    duration: duration2 = 300,
    easing = identity,
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay,
    // @ts-ignore todo:
    end = start_time + duration2,
    tick: tick2 = noop,
    css
  } = fn(node, { from, to }, params);
  let running = true;
  let started = false;
  let name2;
  function start() {
    if (css) {
      name2 = create_rule(node, 0, 1, duration2, delay, easing, css);
    }
    if (!delay) {
      started = true;
    }
  }
  function stop() {
    if (css)
      delete_rule(node, name2);
    running = false;
  }
  loop((now2) => {
    if (!started && now2 >= start_time) {
      started = true;
    }
    if (started && now2 >= end) {
      tick2(1, 0);
      stop();
    }
    if (!running) {
      return false;
    }
    if (started) {
      const p = now2 - start_time;
      const t = 0 + 1 * easing(p / duration2);
      tick2(t, 1 - t);
    }
    return true;
  });
  start();
  tick2(0, 1);
  return stop;
}
function fix_position(node) {
  const style = getComputedStyle(node);
  if (style.position !== "absolute" && style.position !== "fixed") {
    const { width, height } = style;
    const a = node.getBoundingClientRect();
    node.style.position = "absolute";
    node.style.width = width;
    node.style.height = height;
    add_transform(node, a);
  }
}
function add_transform(node, a) {
  const b = node.getBoundingClientRect();
  if (a.left !== b.left || a.top !== b.top) {
    const style = getComputedStyle(node);
    const transform = style.transform === "none" ? "" : style.transform;
    node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
  }
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function beforeUpdate(fn) {
  get_current_component().$$.before_update.push(fn);
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch2(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
  const options = { direction: "in" };
  let config2 = fn(node, params, options);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function go() {
    const {
      delay = 0,
      duration: duration2 = 300,
      easing = identity,
      tick: tick2 = noop,
      css
    } = config2 || null_transition;
    if (css)
      animation_name = create_rule(node, 0, 1, duration2, delay, easing, css, uid++);
    tick2(0, 1);
    const start_time = now() + delay;
    const end_time = start_time + duration2;
    if (task)
      task.abort();
    running = true;
    add_render_callback(() => dispatch2(node, true, "start"));
    task = loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(1, 0);
          dispatch2(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration2);
          tick2(t, 1 - t);
        }
      }
      return running;
    });
  }
  let started = false;
  return {
    start() {
      if (started)
        return;
      started = true;
      delete_rule(node);
      if (is_function(config2)) {
        config2 = config2(options);
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
function create_out_transition(node, fn, params) {
  const options = { direction: "out" };
  let config2 = fn(node, params, options);
  let running = true;
  let animation_name;
  const group = outros;
  group.r += 1;
  let original_inert_value;
  function go() {
    const {
      delay = 0,
      duration: duration2 = 300,
      easing = identity,
      tick: tick2 = noop,
      css
    } = config2 || null_transition;
    if (css)
      animation_name = create_rule(node, 1, 0, duration2, delay, easing, css);
    const start_time = now() + delay;
    const end_time = start_time + duration2;
    add_render_callback(() => dispatch2(node, false, "start"));
    if ("inert" in node) {
      original_inert_value = /** @type {HTMLElement} */
      node.inert;
      node.inert = true;
    }
    loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(0, 1);
          dispatch2(node, false, "end");
          if (!--group.r) {
            run_all(group.c);
          }
          return false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration2);
          tick2(1 - t, t);
        }
      }
      return running;
    });
  }
  if (is_function(config2)) {
    wait().then(() => {
      config2 = config2(options);
      go();
    });
  } else {
    go();
  }
  return {
    end(reset) {
      if (reset && "inert" in node) {
        node.inert = original_inert_value;
      }
      if (reset && config2.tick) {
        config2.tick(1, 0);
      }
      if (running) {
        if (animation_name)
          delete_rule(node, animation_name);
        running = false;
      }
    }
  };
}
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config2 = fn(node, params, options);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  let original_inert_value;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init3(program, duration2) {
    const d = (
      /** @type {Program['d']} */
      program.b - t
    );
    duration2 *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration: duration2,
      start: program.start,
      end: program.start + duration2,
      group: program.group
    };
  }
  function go(b) {
    const {
      delay = 0,
      duration: duration2 = 300,
      easing = identity,
      tick: tick2 = noop,
      css
    } = config2 || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if ("inert" in node) {
      if (b) {
        if (original_inert_value !== void 0) {
          node.inert = original_inert_value;
        }
      } else {
        original_inert_value = /** @type {HTMLElement} */
        node.inert;
        node.inert = true;
      }
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration2, delay, easing, css);
      }
      if (b)
        tick2(0, 1);
      running_program = init3(program, duration2);
      add_render_callback(() => dispatch2(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init3(pending_program, duration2);
          pending_program = null;
          dispatch2(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(
              node,
              t,
              running_program.b,
              running_program.duration,
              0,
              easing,
              config2.css
            );
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick2(t = running_program.b, 1 - t);
            dispatch2(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick2(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config2)) {
        wait().then(() => {
          const opts = { direction: b ? "in" : "out" };
          config2 = config2(opts);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function destroy_block(block, lookup) {
  block.d(1);
  lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function fix_and_outro_and_destroy_block(block, lookup) {
  block.f();
  outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block20, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block20(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}
function validate_each_keys(ctx, list, get_context, get_key) {
  const keys = /* @__PURE__ */ new Map();
  for (let i = 0; i < list.length; i++) {
    const key = get_key(get_context(ctx, list, i));
    if (keys.has(key)) {
      let value2 = "";
      try {
        value2 = `with value '${String(key)}' `;
      } catch (e) {
      }
      throw new Error(
        `Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(
          key
        )} and ${i} ${value2}are duplicates`
      );
    }
    keys.set(key, i);
  }
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind(component, name2, callback) {
  const index = component.$$.props[name2];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance122, create_fragment122, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance122 ? instance122(component, options.props || {}, (i, ret, ...rest) => {
    const value2 = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value2)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value2);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment122 ? create_fragment122($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    /** The Svelte component constructor */
    $$ctor;
    /** Slots */
    $$s;
    /** The Svelte component instance */
    $$c;
    /** Whether or not the custom element is connected */
    $$cn = false;
    /** Component props data */
    $$d = {};
    /** `true` if currently in the process of reflecting component props back to attributes */
    $$r = false;
    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
    $$p_d = {};
    /** @type {Record<string, Function[]>} Event listeners */
    $$l = {};
    /** @type {Map<Function, Function>} Event listener unsubscribe functions */
    $$l_u = /* @__PURE__ */ new Map();
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name2) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element2("slot");
                if (name2 !== "default") {
                  attr(node, "name", name2);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name2 of this.$$s) {
          if (name2 in existing_slots) {
            $$slots[name2] = [create_slot2(name2)];
          }
        }
        for (const attribute of this.attributes) {
          const name2 = this.$$g_p(attribute.name);
          if (!(name2 in this.$$d)) {
            this.$$d[name2] = get_custom_element_value(name2, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      this.$$c?.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value2, props_definition, transform) {
  const type = props_definition[prop]?.type;
  value2 = type === "Boolean" && typeof value2 !== "boolean" ? value2 != null : value2;
  if (!transform || !props_definition[prop]) {
    return value2;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value2 == null ? null : JSON.stringify(value2);
      case "Boolean":
        return value2 ? "" : null;
      case "Number":
        return value2 == null ? null : value2;
      default:
        return value2;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value2 && JSON.parse(value2);
      case "Boolean":
        return value2;
      case "Number":
        return value2 != null ? +value2 : value2;
      default:
        return value2;
    }
  }
}
var SvelteComponent = class {
  /**
   * ### PRIVATE API
   *
   * Do not use, may change at any time
   *
   * @type {any}
   */
  $$ = void 0;
  /**
   * ### PRIVATE API
   *
   * Do not use, may change at any time
   *
   * @type {any}
   */
  $$set = void 0;
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var VERSION = "4.2.17";
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/dev.js
function dispatch_dev(type, detail) {
  document.dispatchEvent(custom_event(type, { version: VERSION, ...detail }, { bubbles: true }));
}
function append_dev(target, node) {
  dispatch_dev("SvelteDOMInsert", { target, node });
  append(target, node);
}
function insert_dev(target, node, anchor) {
  dispatch_dev("SvelteDOMInsert", { target, node, anchor });
  insert(target, node, anchor);
}
function detach_dev(node) {
  dispatch_dev("SvelteDOMRemove", { node });
  detach(node);
}
function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {
  const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
  if (has_prevent_default)
    modifiers.push("preventDefault");
  if (has_stop_propagation)
    modifiers.push("stopPropagation");
  if (has_stop_immediate_propagation)
    modifiers.push("stopImmediatePropagation");
  dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
  const dispose = listen(node, event, handler, options);
  return () => {
    dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
    dispose();
  };
}
function attr_dev(node, attribute, value2) {
  attr(node, attribute, value2);
  if (value2 == null)
    dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
  else
    dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value: value2 });
}
function prop_dev(node, property, value2) {
  node[property] = value2;
  dispatch_dev("SvelteDOMSetProperty", { node, property, value: value2 });
}
function set_data_dev(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  dispatch_dev("SvelteDOMSetData", { node: text2, data });
  text2.data = /** @type {string} */
  data;
}
function ensure_array_like_dev(arg) {
  if (typeof arg !== "string" && !(arg && typeof arg === "object" && "length" in arg) && !(typeof Symbol === "function" && arg && Symbol.iterator in arg)) {
    throw new Error("{#each} only works with iterable values.");
  }
  return ensure_array_like(arg);
}
function validate_slots(name2, slot, keys) {
  for (const slot_key of Object.keys(slot)) {
    if (!~keys.indexOf(slot_key)) {
      console.warn(`<${name2}> received an unexpected slot "${slot_key}".`);
    }
  }
}
function construct_svelte_component_dev(component, props) {
  const error_message = "this={...} of <svelte:component> should specify a Svelte component.";
  try {
    const instance122 = new component(props);
    if (!instance122.$$ || !instance122.$set || !instance122.$on || !instance122.$destroy) {
      throw new Error(error_message);
    }
    return instance122;
  } catch (err) {
    const { message } = err;
    if (typeof message === "string" && message.indexOf("is not a constructor") !== -1) {
      throw new Error(error_message);
    } else {
      throw err;
    }
  }
}
var SvelteComponentDev = class extends SvelteComponent {
  /**
   * For type checking capabilities only.
   * Does not exist at runtime.
   * ### DO NOT USE!
   *
   * @type {Props}
   */
  $$prop_def;
  /**
   * For type checking capabilities only.
   * Does not exist at runtime.
   * ### DO NOT USE!
   *
   * @type {Events}
   */
  $$events_def;
  /**
   * For type checking capabilities only.
   * Does not exist at runtime.
   * ### DO NOT USE!
   *
   * @type {Slots}
   */
  $$slot_def;
  /** @param {import('./public.js').ComponentConstructorOptions<Props>} options */
  constructor(options) {
    if (!options || !options.target && !options.$$inline) {
      throw new Error("'target' is a required option");
    }
    super();
  }
  /** @returns {void} */
  $destroy() {
    super.$destroy();
    this.$destroy = () => {
      console.warn("Component was already destroyed");
    };
  }
  /** @returns {void} */
  $capture_state() {
  }
  /** @returns {void} */
  $inject_state() {
  }
};

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// src/button-group/ButtonGroup.svelte
var file = "src/button-group/ButtonGroup.svelte";
function create_fragment(ctx) {
  let div2;
  let div1;
  let div0;
  let div2_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      div2 = element2("div");
      div1 = element2("div");
      div0 = element2("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div0, "class", "button-group-inner");
      attr_dev(div0, "role", "group");
      add_location(div0, file, 2, 2, 112);
      attr_dev(div1, "class", "button-group-scroller");
      add_location(div1, file, 1, 1, 74);
      attr_dev(div2, "class", div2_class_value = "button-group " + /*className*/
      ctx[1]);
      toggle_class(
        div2,
        "round",
        /*round*/
        ctx[2]
      );
      add_location(div2, file, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div1);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[5](div2);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*className*/
      2 && div2_class_value !== (div2_class_value = "button-group " + /*className*/
      ctx2[1])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*className, round*/
      6) {
        toggle_class(
          div2,
          "round",
          /*round*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[5](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("ButtonGroup", slots2, ["default"]);
  let { class: className2 = "" } = $$props2;
  let { round = void 0 } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  const writable_props = ["class", "round", "element"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ButtonGroup> was created with unknown prop '${key}'`);
  });
  function div2_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("round" in $$props3)
      $$invalidate2(2, round = $$props3.round);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("$$scope" in $$props3)
      $$invalidate2(3, $$scope2 = $$props3.$$scope);
  };
  $$self2.$capture_state = () => ({ className: className2, round, element: element3 });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("round" in $$props3)
      $$invalidate2(2, round = $$props3.round);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [element3, className2, round, $$scope2, slots2, div2_binding2];
}
var ButtonGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { class: 1, round: 2, element: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonGroup",
      options,
      id: create_fragment.name
    });
  }
  get class() {
    throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get round() {
    throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set round(value2) {
    throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ButtonGroup_default = ButtonGroup;

// src/icon/icons.js
var svgs = '<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icon-tabler-';
var svge = "/></svg>";
var icons = {
  adjustments: 'adjustments-horizontal"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="14" cy="6" r="2"/><line x1="4" y1="6" x2="12" y2="6"/><line x1="16" y1="6" x2="20" y2="6"/><circle cx="8" cy="12" r="2"/><line x1="4" y1="12" x2="6" y2="12"/><line x1="10" y1="12" x2="20" y2="12"/><circle cx="17" cy="18" r="2"/><line x1="4" y1="18" x2="15" y2="18"/><line x1="19" y1="18" x2="20" y2="18"',
  alert: 'alert-triangle"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 9v2m0 4v.01"/><path d="M5 19h14a2 2 0 0 0 1.84 -2.75l-7.1 -12.25a2 2 0 0 0 -3.5 0l-7.1 12.25a2 2 0 0 0 1.75 2.75"',
  apps: 'apps"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="4" y="4" width="6" height="6" rx="1"/><rect x="4" y="14" width="6" height="6" rx="1"/><rect x="14" y="14" width="6" height="6" rx="1"/><line x1="14" y1="7" x2="20" y2="7"/><line x1="17" y1="4" x2="17" y2="10"',
  archive: 'archive"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10"/><line x1="10" y1="12" x2="14" y2="12"',
  arrowLeft: 'arrow-left"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><line x1="5" y1="12" x2="19" y2="12"/><line x1="5" y1="12" x2="11" y2="18"/><line x1="5" y1="12" x2="11" y2="6"',
  arrowNarrowDown: 'arrow-narrow-down"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><line x1="12" y1="5" x2="12" y2="19"/><line x1="16" y1="15" x2="12" y2="19"/><line x1="8" y1="15" x2="12" y2="19"',
  arrowNarrowUp: 'arrow-narrow-up"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><line x1="12" y1="5" x2="12" y2="19"/><line x1="16" y1="9" x2="12" y2="5"/><line x1="8" y1="9" x2="12" y2="5"',
  arrowRight: 'arrow-right"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><line x1="5" y1="12" x2="19" y2="12"/><line x1="13" y1="18" x2="19" y2="12"/><line x1="13" y1="6" x2="19" y2="12"',
  bank: 'building-bank"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><line x1="3" y1="21" x2="21" y2="21"/><line x1="3" y1="10" x2="21" y2="10"/><polyline points="5 6 12 3 19 6"/><line x1="4" y1="10" x2="4" y2="21"/><line x1="20" y1="10" x2="20" y2="21"/><line x1="8" y1="14" x2="8" y2="17"/><line x1="12" y1="14" x2="12" y2="17"/><line x1="16" y1="14" x2="16" y2="17"',
  basket: 'basket"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><polyline points="7 10 12 4 17 10" /><path d="M21 10l-2 8a2 2.5 0 0 1 -2 2h-10a2 2.5 0 0 1 -2 -2l-2 -8z" /><circle cx="12" cy="15" r="2" ',
  bell: 'bell"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 5a2 2 0 0 1 4 0a7 7 0 0 1 4 6v3a4 4 0 0 0 2 3h-16a4 4 0 0 0 2 -3v-3a7 7 0 0 1 4 -6"/><path d="M9 17v1a3 3 0 0 0 6 0v-1"',
  book: 'book"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0"/><path d="M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0"/><line x1="3" y1="6" x2="3" y2="19"/><line x1="12" y1="6" x2="12" y2="19"/><line x1="21" y1="6" x2="21" y2="19"',
  bookmark: 'bookmark"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 4h6a2 2 0 0 1 2 2v14l-5 -3l-5 3v-14a2 2 0 0 1 2 -2"',
  calculator: 'calculator"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="4" y="3" width="16" height="18" rx="2"/><rect x="8" y="7" width="8" height="3" rx="1"/><line x1="8" y1="14" x2="8" y2="14.01"/><line x1="12" y1="14" x2="12" y2="14.01"/><line x1="16" y1="14" x2="16" y2="14.01"/><line x1="8" y1="17" x2="8" y2="17.01"/><line x1="12" y1="17" x2="12" y2="17.01"/><line x1="16" y1="17" x2="16" y2="17.01"',
  calendar: 'calendar"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="4" y="5" width="16" height="16" rx="2"/><line x1="16" y1="3" x2="16" y2="7"/><line x1="8" y1="3" x2="8" y2="7"/><line x1="4" y1="11" x2="20" y2="11"/><line x1="11" y1="15" x2="12" y2="15"/><line x1="12" y1="15" x2="12" y2="18"',
  cart: 'shopping-cart"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="6" cy="19" r="2" /><circle cx="17" cy="19" r="2" /><path d="M17 17h-11v-14h-2" /><path d="M6 5l14 1l-1 7h-13" ',
  cash: 'cash"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="7" y="9" width="14" height="10" rx="2"/><circle cx="14" cy="14" r="2"/><path d="M17 9v-2a2 2 0 0 0 -2 -2h-10a2 2 0 0 0 -2 2v6a2 2 0 0 0 2 2h2"',
  chartLine: 'line-chart"><path d="M1.66162313,21 L22,21 M1.66162313,21 L1.66162313,1 M4.38166815,17.7623829 L7.91691553,8.62488914 L12.6112769,11.5868912 L17.3056383,4.18188618 L20.9636681,7.82869207"',
  chartPie: 'chart-pie"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 3.2a9 9 0 1 0 10.8 10.8a1 1 0 0 0 -1 -1h-6.8a2 2 0 0 1 -2 -2v-7a0.9 .9 0 0 0 -1 -.8"/><path d="M15 3.5a9 9 0 0 1 5.5 5.5h-4.5a1 1 0 0 1 -1 -1v-4.5"',
  check: 'check"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 12l5 5l10 -10"',
  checkbox: 'square"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="4" y="4" width="16" height="16" rx="2"',
  checkboxChecked: 'square-check"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="4" y="4" width="16" height="16" rx="2"/><path d="M9 12l2 2l4 -4"',
  checkCircle: 'circle-check"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" /><path d="M9 12l2 2l4 -4" ',
  checklist: 'list-check"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3.5 5.5l1.5 1.5l2.5 -2.5"/><path d="M3.5 11.5l1.5 1.5l2.5 -2.5"/><path d="M3.5 17.5l1.5 1.5l2.5 -2.5"/><line x1="11" y1="6" x2="20" y2="6"/><line x1="11" y1="12" x2="20" y2="12"/><line x1="11" y1="18" x2="20" y2="18"',
  chevronLeft: 'chevron-left"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><polyline points="15 6 9 12 15 18"',
  chevronRight: 'chevron-right"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><polyline points="9 6 15 12 9 18"',
  circle: 'circle"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" ',
  clock: 'clock-hour-3"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"/><path d="M12 12h3.5"/><path d="M12 7v5"',
  close: 'x"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"',
  cog: 'settings"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z"/><circle cx="12" cy="12" r="3"',
  coin: 'coin"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9" /><path d="M14.8 9a2 2 0 0 0 -1.8 -1h-2a2 2 0 0 0 0 4h2a2 2 0 0 1 0 4h-2a2 2 0 0 1 -1.8 -1" /><path d="M12 6v2m0 8v2" ',
  copy: 'copy"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="8" y="8" width="12" height="12" rx="2" /><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2" ',
  dots: 'dots"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="5" cy="12" r="1"/><circle cx="12" cy="12" r="1"/><circle cx="19" cy="12" r="1"',
  edit: 'edit"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 7h-3a2 2 0 0 0 -2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2 -2v-3"/><path d="M9 15h3l8.5 -8.5a1.5 1.5 0 0 0 -3 -3l-8.5 8.5v3"/><line x1="16" y1="5" x2="19" y2="8"',
  envelope: 'mail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="3" y="5" width="18" height="14" rx="2" /><polyline points="3 7 12 13 21 7" ',
  error: 'alert-circle"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"',
  eye: 'eye"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="2"/><path d="M22 12c-2.667 4.667 -6 7 -10 7s-7.333 -2.333 -10 -7c2.667 -4.667 6 -7 10 -7s7.333 2.333 10 7"',
  eyeOff: 'eye-off"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><line x1="3" y1="3" x2="21" y2="21"/><path d="M10.584 10.587a2 2 0 0 0 2.828 2.83"/><path d="M9.363 5.365a9.466 9.466 0 0 1 2.637 -.365c4 0 7.333 2.333 10 7c-.778 1.361 -1.612 2.524 -2.503 3.488m-2.14 1.861c-1.631 1.1 -3.415 1.651 -5.357 1.651c-4 0 -7.333 -2.333 -10 -7c1.369 -2.395 2.913 -4.175 4.632 -5.341"',
  filter: 'filter"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5.5 5h13a1 1 0 0 1 .5 1.5l-5 5.5l0 7l-4 -3l0 -4l-5 -5.5a1 1 0 0 1 .5 -1.5"',
  folder: 'folder"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2"',
  help: 'help"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><line x1="12" y1="17" x2="12" y2="17.01"/><path d="M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4"',
  home: 'home"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"/><path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"',
  info: 'info-circle"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><line x1="12" y1="8" x2="12.01" y2="8"/><polyline points="11 12 12 12 12 16 13 16"',
  link: 'link"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5"/><path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5"',
  list: 'list"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><line x1="9" y1="6" x2="20" y2="6"/><line x1="9" y1="12" x2="20" y2="12"/><line x1="9" y1="18" x2="20" y2="18"/><line x1="5" y1="6" x2="5" y2="6.01"/><line x1="5" y1="12" x2="5" y2="12.01"/><line x1="5" y1="18" x2="5" y2="18.01"',
  logout: 'logout"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M14 8v-2a2 2 0 0 0 -2 -2h-7a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h7a2 2 0 0 0 2 -2v-2"/><path d="M7 12h14l-3 -3m0 6l3 -3"',
  math: 'math-symbols"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="12" y1="3" x2="12" y2="21"/><line x1="16.5" y1="4.5" x2="19.5" y2="7.5"/><line x1="19.5" y1="4.5" x2="16.5" y2="7.5"/><line x1="6" y1="4" x2="6" y2="8"/><line x1="4" y1="6" x2="8" y2="6"/><line x1="18" y1="16" x2="18.01" y2="16"/><line x1="18" y1="20" x2="18.01" y2="20"/><line x1="4" y1="18" x2="8" y2="18"',
  meatballs: 'dots-vertical"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="1"/><circle cx="12" cy="19" r="1"/><circle cx="12" cy="5" r="1"',
  minusCircle: 'circle-minus"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><line x1="9" y1="12" x2="15" y2="12"',
  moon: 'moon"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" ',
  plus: 'plus"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"',
  plusCircle: 'circle-plus"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><line x1="9" y1="12" x2="15" y2="12"/><line x1="12" y1="9" x2="12" y2="15"',
  print: 'printer"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M17 17h2a2 2 0 0 0 2 -2v-4a2 2 0 0 0 -2 -2h-14a2 2 0 0 0 -2 2v4a2 2 0 0 0 2 2h2" /><path d="M17 9v-4a2 2 0 0 0 -2 -2h-6a2 2 0 0 0 -2 2v4" /><path d="M7 13m0 2a2 2 0 0 1 2 -2h6a2 2 0 0 1 2 2v4a2 2 0 0 1 -2 2h-6a2 2 0 0 1 -2 -2z" ',
  receipt: 'receipt"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 21v-16a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v16l-3 -2l-2 2l-2 -2l-2 2l-2 -2l-3 2m4 -14h6m-6 4h6m-2 4h2"',
  redo: 'corner-up-right"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 18v-6a3 3 0 0 1 3 -3h10l-4 -4m0 8l4 -4" ',
  refresh: 'refresh"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M20 11a8.1 8.1 0 0 0 -15.5 -2m-.5 -4v4h4"/><path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"',
  repeat: 'repeat"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 12v-3a3 3 0 0 1 3 -3h13m-3 -3l3 3l-3 3"/><path d="M20 12v3a3 3 0 0 1 -3 3h-13m3 3l-3 -3l3 -3"',
  reportAnalytics: 'file-analytics"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M14 3v4a1 1 0 0 0 1 1h4"/><path d="M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z"/><line x1="9" y1="17" x2="9" y2="12"/><line x1="12" y1="17" x2="12" y2="16"/><line x1="15" y1="17" x2="15" y2="14"',
  reportMoney: 'report-money"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2"/><rect x="9" y="3" width="6" height="4" rx="2"/><path d="M14 11h-2.5a1.5 1.5 0 0 0 0 3h1a1.5 1.5 0 0 1 0 3h-2.5"/><path d="M12 17v1m0 -8v1"',
  search: 'search"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"',
  shared: 'share"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="6" r="3"/><circle cx="18" cy="18" r="3"/><line x1="8.7" y1="10.7" x2="15.3" y2="7.3"/><line x1="8.7" y1="13.3" x2="15.3" y2="16.7"',
  sidebarLeft: 'layout-sidebar"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="4" y="4" width="16" height="16" rx="2"/><line x1="9" y1="4" x2="9" y2="20"',
  sidebarRight: 'layout-sidebar-right"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="4" y="4" width="16" height="16" rx="2"/><line x1="15" y1="4" x2="15" y2="20"',
  sortAsc: 'sort-ascending"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><line x1="4" y1="6" x2="11" y2="6"/><line x1="4" y1="12" x2="11" y2="12"/><line x1="4" y1="18" x2="13" y2="18"/><polyline points="15 9 18 6 21 9"/><line x1="18" y1="6" x2="18" y2="18"',
  sortDesc: 'sort-descending"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><line x1="4" y1="6" x2="13" y2="6"/><line x1="4" y1="12" x2="11" y2="12"/><line x1="4" y1="18" x2="11" y2="18"/><polyline points="15 15 18 18 21 15"/><line x1="18" y1="6" x2="18" y2="18"',
  split: 'arrows-split-2"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M21 17h-5.397a5 5 0 0 1 -4.096 -2.133l-.514 -.734a5 5 0 0 0 -4.096 -2.133h-3.897"/><path d="M21 7h-5.395a5 5 0 0 0 -4.098 2.135l-.51 .73a5 5 0 0 1 -4.097 2.135h-3.9"/><path d="M18 10l3 -3l-3 -3"/><path d="M18 20l3 -3l-3 -3"',
  star: 'star"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 17.75l-6.172 3.245l1.179 -6.873l-5 -4.867l6.9 -1l3.086 -6.253l3.086 6.253l6.9 1l-5 4.867l1.179 6.873z" ',
  sun: ' brightness-up"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" /><path d="M12 5l0 -2" /><path d="M17 7l1.4 -1.4" /><path d="M19 12l2 0" /><path d="M17 17l1.4 1.4" /><path d="M12 19l0 2" /><path d="M7 17l-1.4 1.4" /><path d="M6 12l-2 0" /><path d="M7 7l-1.4 -1.4" ',
  tag: 'tag"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 3l9 9a1.5 1.5 0 0 1 0 2l-6 6a1.5 1.5 0 0 1 -2 0l-9 -9v-4a4 4 0 0 1 4 -4h4"/><circle cx="9" cy="9" r="2"',
  trash: 'trash"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><line x1="4" y1="7" x2="20" y2="7"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12"/><path d="M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3"',
  undo: 'corner-up-left"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M18 18v-6a3 3 0 0 0 -3 -3h-10l4 -4m0 8l-4 -4" ',
  user: 'user"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"',
  users: 'users"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="9" cy="7" r="4"/><path d="M3 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/><path d="M21 21v-2a4 4 0 0 0 -3 -3.85"'
};
var aliases = {
  add: "plus",
  report: "reportAnalytics",
  success: "checkCircle",
  warning: "alert"
};
var customIcons = {};
function getIcon(name2) {
  if (name2 in aliases)
    name2 = aliases[name2];
  if (name2 in customIcons)
    return customIcons[name2];
  if (name2 in icons)
    return svgs + icons[name2] + svge;
  return `<svg width="20" height="20" title="${name2}"></svg>`;
}
function addIcon(name2, svg) {
  if (!customIcons[name2])
    customIcons[name2] = svg;
}

// src/icon/Icon.svelte
function create_fragment2(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*svg*/
        ctx[0],
        target,
        anchor
      );
      insert_dev(target, html_anchor, anchor);
    },
    p: function update2(ctx2, [dirty]) {
      if (dirty & /*svg*/
      1)
        html_tag.p(
          /*svg*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self2, $$props2, $$invalidate2) {
  let svg;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Icon", slots2, []);
  let { name: name2 = "" } = $$props2;
  const writable_props = ["name"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Icon> was created with unknown prop '${key}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("name" in $$props3)
      $$invalidate2(1, name2 = $$props3.name);
  };
  $$self2.$capture_state = () => ({ getIcon, name: name2, svg });
  $$self2.$inject_state = ($$props3) => {
    if ("name" in $$props3)
      $$invalidate2(1, name2 = $$props3.name);
    if ("svg" in $$props3)
      $$invalidate2(0, svg = $$props3.svg);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*name*/
    2) {
      $:
        $$invalidate2(0, svg = getIcon(name2));
    }
  };
  return [svg, name2];
}
var Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icon",
      options,
      id: create_fragment2.name
    });
  }
  get name() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value2) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Icon_default = Icon;

// src/button/Button.svelte
var file2 = "src/button/Button.svelte";
function create_if_block(ctx) {
  let icon_1;
  let current;
  icon_1 = new Icon_default({
    props: { name: (
      /*icon*/
      ctx[10]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(icon_1, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const icon_1_changes = {};
      if (dirty & /*icon*/
      1024)
        icon_1_changes.name = /*icon*/
        ctx2[10];
      icon_1.$set(icon_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(32:1) {#if icon}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let button;
  let t;
  let button_type_value;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*icon*/
    ctx[10] && create_if_block(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let button_levels = [
    {
      type: button_type_value = /*submit*/
      ctx[6] ? "submit" : "button"
    },
    {
      class: button_class_value = "button " + /*className*/
      ctx[12]
    },
    /*$$restProps*/
    ctx[15]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element2("button");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      set_attributes(button, button_data);
      toggle_class(button, "button-normal", !/*link*/
      ctx[8] && !/*text*/
      ctx[9] && !/*outline*/
      ctx[7]);
      toggle_class(
        button,
        "button-outline",
        /*outline*/
        ctx[7]
      );
      toggle_class(
        button,
        "button-link",
        /*link*/
        ctx[8]
      );
      toggle_class(
        button,
        "button-text",
        /*text*/
        ctx[9]
      );
      toggle_class(
        button,
        "button-has-text",
        /*$$slots*/
        ctx[14].default
      );
      toggle_class(
        button,
        "round",
        /*round*/
        ctx[11]
      );
      toggle_class(
        button,
        "info",
        /*info*/
        ctx[1]
      );
      toggle_class(
        button,
        "success",
        /*success*/
        ctx[2]
      );
      toggle_class(
        button,
        "warning",
        /*warning*/
        ctx[3]
      );
      toggle_class(
        button,
        "danger",
        /*danger*/
        ctx[4]
      );
      toggle_class(
        button,
        "error",
        /*error*/
        ctx[5]
      );
      toggle_class(
        button,
        "touching",
        /*touching*/
        ctx[13]
      );
      add_location(button, file2, 1, 0, 57);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (if_block)
        if_block.m(button, null);
      append_dev(button, t);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[26](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "focus",
            /*focus_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mousedown",
            /*mousedown_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseup",
            /*mouseup_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseover",
            /*mouseover_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseout",
            /*mouseout_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mousemove",
            /*mousemove_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "touchstart",
            /*touchstart_handler*/
            ctx[27],
            { passive: true },
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "touchend",
            /*touchend_handler*/
            ctx[28],
            { passive: true },
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      if (
        /*icon*/
        ctx2[10]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*icon*/
          1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(button, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        (!current || dirty & /*submit*/
        64 && button_type_value !== (button_type_value = /*submit*/
        ctx2[6] ? "submit" : "button")) && { type: button_type_value },
        (!current || dirty & /*className*/
        4096 && button_class_value !== (button_class_value = "button " + /*className*/
        ctx2[12])) && { class: button_class_value },
        dirty & /*$$restProps*/
        32768 && /*$$restProps*/
        ctx2[15]
      ]));
      toggle_class(button, "button-normal", !/*link*/
      ctx2[8] && !/*text*/
      ctx2[9] && !/*outline*/
      ctx2[7]);
      toggle_class(
        button,
        "button-outline",
        /*outline*/
        ctx2[7]
      );
      toggle_class(
        button,
        "button-link",
        /*link*/
        ctx2[8]
      );
      toggle_class(
        button,
        "button-text",
        /*text*/
        ctx2[9]
      );
      toggle_class(
        button,
        "button-has-text",
        /*$$slots*/
        ctx2[14].default
      );
      toggle_class(
        button,
        "round",
        /*round*/
        ctx2[11]
      );
      toggle_class(
        button,
        "info",
        /*info*/
        ctx2[1]
      );
      toggle_class(
        button,
        "success",
        /*success*/
        ctx2[2]
      );
      toggle_class(
        button,
        "warning",
        /*warning*/
        ctx2[3]
      );
      toggle_class(
        button,
        "danger",
        /*danger*/
        ctx2[4]
      );
      toggle_class(
        button,
        "error",
        /*error*/
        ctx2[5]
      );
      toggle_class(
        button,
        "touching",
        /*touching*/
        ctx2[13]
      );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[26](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self2, $$props2, $$invalidate2) {
  const omit_props_names2 = [
    "element",
    "info",
    "success",
    "warning",
    "danger",
    "error",
    "submit",
    "outline",
    "link",
    "text",
    "icon",
    "round",
    "class"
  ];
  let $$restProps2 = compute_rest_props($$props2, omit_props_names2);
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Button", slots2, ["default"]);
  const $$slots = compute_slots(slots2);
  let { element: element3 = void 0 } = $$props2;
  let { info: info2 = false } = $$props2;
  let { success = false } = $$props2;
  let { warning = false } = $$props2;
  let { danger = false } = $$props2;
  let { error: error2 = false } = $$props2;
  let { submit = false } = $$props2;
  let { outline = false } = $$props2;
  let { link = false } = $$props2;
  let { text: text2 = false } = $$props2;
  let { icon = void 0 } = $$props2;
  let { round = void 0 } = $$props2;
  let { class: className2 = "" } = $$props2;
  let touching = false;
  function focus_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function mousemove_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  const touchstart_handler = () => $$invalidate2(13, touching = true);
  const touchend_handler = () => $$invalidate2(13, touching = false);
  $$self2.$$set = ($$new_props) => {
    $$props2 = assign(assign({}, $$props2), exclude_internal_props($$new_props));
    $$invalidate2(15, $$restProps2 = compute_rest_props($$props2, omit_props_names2));
    if ("element" in $$new_props)
      $$invalidate2(0, element3 = $$new_props.element);
    if ("info" in $$new_props)
      $$invalidate2(1, info2 = $$new_props.info);
    if ("success" in $$new_props)
      $$invalidate2(2, success = $$new_props.success);
    if ("warning" in $$new_props)
      $$invalidate2(3, warning = $$new_props.warning);
    if ("danger" in $$new_props)
      $$invalidate2(4, danger = $$new_props.danger);
    if ("error" in $$new_props)
      $$invalidate2(5, error2 = $$new_props.error);
    if ("submit" in $$new_props)
      $$invalidate2(6, submit = $$new_props.submit);
    if ("outline" in $$new_props)
      $$invalidate2(7, outline = $$new_props.outline);
    if ("link" in $$new_props)
      $$invalidate2(8, link = $$new_props.link);
    if ("text" in $$new_props)
      $$invalidate2(9, text2 = $$new_props.text);
    if ("icon" in $$new_props)
      $$invalidate2(10, icon = $$new_props.icon);
    if ("round" in $$new_props)
      $$invalidate2(11, round = $$new_props.round);
    if ("class" in $$new_props)
      $$invalidate2(12, className2 = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate2(16, $$scope2 = $$new_props.$$scope);
  };
  $$self2.$capture_state = () => ({
    Icon: Icon_default,
    element: element3,
    info: info2,
    success,
    warning,
    danger,
    error: error2,
    submit,
    outline,
    link,
    text: text2,
    icon,
    round,
    className: className2,
    touching
  });
  $$self2.$inject_state = ($$new_props) => {
    if ("element" in $$props2)
      $$invalidate2(0, element3 = $$new_props.element);
    if ("info" in $$props2)
      $$invalidate2(1, info2 = $$new_props.info);
    if ("success" in $$props2)
      $$invalidate2(2, success = $$new_props.success);
    if ("warning" in $$props2)
      $$invalidate2(3, warning = $$new_props.warning);
    if ("danger" in $$props2)
      $$invalidate2(4, danger = $$new_props.danger);
    if ("error" in $$props2)
      $$invalidate2(5, error2 = $$new_props.error);
    if ("submit" in $$props2)
      $$invalidate2(6, submit = $$new_props.submit);
    if ("outline" in $$props2)
      $$invalidate2(7, outline = $$new_props.outline);
    if ("link" in $$props2)
      $$invalidate2(8, link = $$new_props.link);
    if ("text" in $$props2)
      $$invalidate2(9, text2 = $$new_props.text);
    if ("icon" in $$props2)
      $$invalidate2(10, icon = $$new_props.icon);
    if ("round" in $$props2)
      $$invalidate2(11, round = $$new_props.round);
    if ("className" in $$props2)
      $$invalidate2(12, className2 = $$new_props.className);
    if ("touching" in $$props2)
      $$invalidate2(13, touching = $$new_props.touching);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    element3,
    info2,
    success,
    warning,
    danger,
    error2,
    submit,
    outline,
    link,
    text2,
    icon,
    round,
    className2,
    touching,
    $$slots,
    $$restProps2,
    $$scope2,
    slots2,
    focus_handler2,
    keydown_handler,
    mousedown_handler,
    mouseup_handler,
    mouseover_handler,
    mouseout_handler,
    mousemove_handler,
    click_handler,
    button_binding,
    touchstart_handler,
    touchend_handler
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      element: 0,
      info: 1,
      success: 2,
      warning: 3,
      danger: 4,
      error: 5,
      submit: 6,
      outline: 7,
      link: 8,
      text: 9,
      icon: 10,
      round: 11,
      class: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment3.name
    });
  }
  get element() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get success() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set success(value2) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warning() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warning(value2) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get danger() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set danger(value2) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get submit() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set submit(value2) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value2) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get link() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set link(value2) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value2) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value2) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get round() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set round(value2) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function writable(value2, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value2, new_value)) {
      value2 = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value2);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value2));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value2);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/utils.js
var FOCUSABLE_SELECTOR = [
  "a[href]:not([disabled])",
  "button:not([disabled])",
  "iframe:not([disabled])",
  "input:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "[contentEditable]",
  "[tabindex]:not(.focus-trap)"
  // warning: this will try to focus tabindex="-1" elements
].join(",");
var ANIMATION_SPEED = writable(300);
var PREFERS_DARK = writable(false);
var setReducedMotion = (query) => ANIMATION_SPEED.set(!query || query.matches ? 0 : 200);
var setPrefersDark = (query) => PREFERS_DARK.set(query && query.matches);
if (window.matchMedia) {
  const reducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)");
  setReducedMotion(reducedMotion);
  reducedMotion.addEventListener("change", setReducedMotion);
  const prefersDark = window.matchMedia("(prefers-color-scheme: dark)");
  setPrefersDark(prefersDark);
  prefersDark.addEventListener("change", setPrefersDark);
}
function animate(el, from, to, _options = {}) {
  const dflt = { duration: get_store_value(ANIMATION_SPEED), easing: "ease-out", fill: "forwards" };
  const opts = Object.assign({}, dflt, _options);
  return new Promise((resolve) => {
    requestAnimationFrame(() => {
      const anim = el.animate([from, to], opts);
      anim.oncancel = resolve;
      anim.onfinish = resolve;
    });
  });
}
function blink(el, duration2 = 160) {
  return animate(
    el,
    { opacity: 1 },
    { opacity: 0.5 },
    { duration: duration2 / 2, fill: "backwards" }
  );
}
function debounce(func, timeout = 300) {
  let timer2;
  return (...args) => {
    if (timer2)
      clearTimeout(timer2);
    timer2 = setTimeout(() => func.apply(this, args), timeout);
  };
}
function throttle(fn, delay = 300) {
  let lastCalled = 0;
  return (...args) => {
    const now2 = (/* @__PURE__ */ new Date()).getTime();
    if (now2 - lastCalled < delay)
      return;
    lastCalled = now2;
    return fn(...args);
  };
}
function isset(v) {
  return typeof v !== "undefined" && v !== null;
}
function fuzzy(hay = "", s = "") {
  if (s.length === 0)
    return true;
  if (hay.length === 0)
    return false;
  if (s.length > hay.length)
    return false;
  if (s === hay)
    return true;
  hay = hay.toLowerCase();
  s = s.toLowerCase();
  let n = -1;
  for (const l of s)
    if (!~(n = hay.indexOf(l, n + 1)))
      return false;
  return true;
}
function guid() {
  if (window.crypto?.randomUUID)
    return window.crypto.randomUUID();
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function getMouseX(e) {
  return e.type.includes("touch") ? e.changedTouches[0].clientX : e.clientX;
}
function getMouseY(e) {
  return e.type.includes("touch") ? e.changedTouches[0].clientY : e.clientY;
}
function isMobile() {
  const ua = navigator.userAgent;
  let regex = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i;
  if (regex.test(ua))
    return true;
  regex = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i;
  return regex.test(ua.slice(0, 4));
}
function pluckOne(obj, key) {
  if (key in obj)
    return obj[key];
}
function pluckMany(obj, keys) {
  const newObj = {};
  keys.forEach((key) => {
    if (key in obj)
      newObj[key] = obj[key];
  });
  return newObj;
}
function pluck(obj, keys) {
  if (!obj)
    return {};
  if (!Array.isArray(keys))
    return pluckOne(obj, keys);
  return pluckMany(obj, keys);
}
function roundAmount(val, precision = 2) {
  const multiplier = Math.pow(10, precision);
  return Math.round(val * multiplier) / multiplier;
}
function formatDate(date) {
  const year = date.getFullYear();
  const month = ("0" + (date.getMonth() + 1)).slice(-2);
  const day = ("0" + date.getDate()).slice(-2);
  const hours = ("0" + date.getHours()).slice(-2);
  const minutes = ("0" + date.getMinutes()).slice(-2);
  return `${year}-${month}-${day} ${hours}:${minutes}`;
}
function timeAgo(date, now2) {
  if (!date)
    return "";
  now2 = now2 || (/* @__PURE__ */ new Date()).getTime();
  let seconds = (now2 - +date) / 1e3;
  const intervals = [
    { label: "year", seconds: 31536e3 },
    { label: "month", seconds: 2592e3 },
    { label: "day", seconds: 86400 },
    { label: "hour", seconds: 3600 },
    { label: "minute", seconds: 60 }
  ];
  const chunks = [];
  while (seconds > 60) {
    const interval = intervals.find((i) => i.seconds < seconds) || { seconds: 0, label: "" };
    const count = Math.floor(seconds / (interval.seconds || seconds));
    chunks.push(`${count} ${interval.label}${count !== 1 ? "s" : ""}`);
    seconds -= count * (interval.seconds || seconds);
  }
  if (!chunks.length)
    return "just now";
  if (chunks.length === 1)
    return chunks[0] + " ago";
  return formatDate(date);
}
function alignItem({
  element: element3,
  target,
  alignH = "left",
  offsetH = 0,
  alignV = "bottom",
  offsetV = 2,
  viewportPadding = 10,
  setMinWidthToTarget = false
}) {
  if (!element3 || !target)
    return;
  const winH = window.visualViewport.height || window.innerHeight;
  const winW = window.visualViewport.width || window.innerWidth;
  let targetBox = {};
  let top, left;
  if (target instanceof Event && (target.type === "contextmenu" || target.type === "longpress")) {
    if (target.type === "contextmenu") {
      targetBox = { top: target.y, left: target.x };
    } else if (target.type === "longpress") {
      targetBox = { top: target.detail.y, left: target.detail.x };
    }
    targetBox.height = 0;
    targetBox.width = 0;
  } else if (target.type === "click")
    targetBox = target.target.getBoundingClientRect();
  else
    targetBox = target.getBoundingClientRect();
  top = targetBox.top + targetBox.height + offsetV;
  left = targetBox.left + offsetH;
  if (alignH === "right")
    left += targetBox.width - element3.offsetWidth;
  else if (alignH === "center") {
    left = (targetBox.width - element3.offsetWidth) / 2 + targetBox.left;
  }
  element3.style.top = top + window.scrollY + "px";
  element3.style.left = left + window.scrollX + "px";
  if (setMinWidthToTarget)
    element3.style.minWidth = targetBox.width + "px";
  const spaceAbove = targetBox.top - viewportPadding;
  const spaceBelow = winH - targetBox.top - targetBox.height - viewportPadding;
  element3.style.maxHeight = Math.max(spaceAbove, spaceBelow) + "px";
  const elementBox = element3.getBoundingClientRect();
  if (alignV === "top" && spaceAbove > elementBox.height || spaceBelow < elementBox.height) {
    top = winH - elementBox.height - viewportPadding;
    if (alignV === "top" || top < elementBox.y) {
      top = targetBox.top - elementBox.height - offsetV;
    }
    element3.style.top = top + window.scrollY + "px";
  }
  const padding = alignH === "center" ? viewportPadding * 2 : viewportPadding;
  if (winW < elementBox.x + elementBox.width + padding) {
    left = winW - elementBox.width - padding;
    if (left < 0)
      left = viewportPadding;
    left = left + window.scrollX;
  }
  if (elementBox.x < viewportPadding) {
    left = viewportPadding + window.scrollX;
  }
  element3.style.left = left + "px";
  element3.style.maxWidth = `calc(100% - ${left + viewportPadding}px)`;
  element3.style.setProperty("--tip-offset", findTipOffset(targetBox, element3));
  return top > targetBox.top ? "bottom" : "top";
}
function findTipOffset(targetBox, element3) {
  const elementBox = element3.getBoundingClientRect();
  const targetCenter = targetBox.left + targetBox.width / 2;
  const elementCenter = elementBox.left + elementBox.width / 2;
  const elemWidth = elementBox.width ? elementBox.width / 100 : 1;
  const tOffset = 50 + (targetCenter - elementCenter) / elemWidth;
  const tooltipOffsetPercent = Math.max(8, Math.min(93, tOffset));
  const tooltipOffset = Math.round(tooltipOffsetPercent * elemWidth - 1);
  return `${tooltipOffset}px`;
}
function isScrollable(node) {
  const css = getComputedStyle(node, null);
  const overflow = css.overflowX || css.overflow;
  if (!/(auto|scroll)/.test(overflow))
    return false;
  return node.scrollWidth > node.clientWidth;
}
function isInScrollable(node) {
  if (!(node instanceof HTMLElement || node instanceof SVGElement))
    return false;
  if (isScrollable(node))
    return true;
  let parent = node.parentElement;
  while (parent) {
    if (isScrollable(parent))
      return true;
    parent = parent.parentElement;
  }
  return false;
}
function isColorDark(hex) {
  hex = hex[0] === "#" ? hex.slice(1) : hex;
  if (hex.length === 3)
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  if (hex.length !== 6)
    return false;
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);
  if (isNaN(r) || isNaN(g) || isNaN(b))
    return false;
  const brightness = (r * 299 + g * 587 + b * 114) / 1e3;
  return isNaN(brightness) ? false : brightness < 140;
}

// src/dialog/Dialog.svelte
var file3 = "src/dialog/Dialog.svelte";
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx) => ({});
function create_fragment4(ctx) {
  let div5;
  let div4;
  let div0;
  let t0;
  let h1;
  let t1;
  let t2;
  let div1;
  let t3;
  let div2;
  let t4;
  let div3;
  let div5_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  const footer_slot_template = (
    /*#slots*/
    ctx[16].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_footer_slot_context
  );
  const block = {
    c: function create() {
      div5 = element2("div");
      div4 = element2("div");
      div0 = element2("div");
      t0 = space();
      h1 = element2("h1");
      t1 = text(
        /*title*/
        ctx[3]
      );
      t2 = space();
      div1 = element2("div");
      if (default_slot)
        default_slot.c();
      t3 = space();
      div2 = element2("div");
      if (footer_slot)
        footer_slot.c();
      t4 = space();
      div3 = element2("div");
      attr_dev(div0, "tabindex", "0");
      attr_dev(div0, "class", "focus-trap focus-trap-top");
      add_location(div0, file3, 14, 2, 457);
      attr_dev(h1, "class", "dialog-header");
      add_location(h1, file3, 15, 2, 541);
      attr_dev(div1, "class", "dialog-content");
      add_location(div1, file3, 16, 2, 582);
      attr_dev(div2, "class", "dialog-footer");
      add_location(div2, file3, 17, 2, 650);
      attr_dev(div3, "tabindex", "0");
      attr_dev(div3, "class", "focus-trap focus-trap-bottom");
      add_location(div3, file3, 18, 2, 730);
      attr_dev(div4, "class", "dialog");
      toggle_class(div4, "no-title", !/*title*/
      ctx[3]);
      add_location(div4, file3, 13, 1, 385);
      attr_dev(div5, "role", "dialog");
      attr_dev(div5, "aria-modal", "true");
      attr_dev(
        div5,
        "aria-label",
        /*title*/
        ctx[3]
      );
      attr_dev(div5, "class", div5_class_value = "dialog-backdrop " + /*className*/
      ctx[2]);
      toggle_class(
        div5,
        "opened",
        /*opened*/
        ctx[0]
      );
      add_location(div5, file3, 4, 0, 180);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div5, anchor);
      append_dev(div5, div4);
      append_dev(div4, div0);
      append_dev(div4, t0);
      append_dev(div4, h1);
      append_dev(h1, t1);
      append_dev(div4, t2);
      append_dev(div4, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      ctx[17](div1);
      append_dev(div4, t3);
      append_dev(div4, div2);
      if (footer_slot) {
        footer_slot.m(div2, null);
      }
      ctx[18](div2);
      append_dev(div4, t4);
      append_dev(div4, div3);
      ctx[19](div4);
      ctx[20](div5);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div0,
            "focus",
            /*focusLast*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "focus",
            /*focusFirst*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div5,
            "mousedown",
            /*onBackdropMousedown*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div5,
            "click",
            /*onBackdropClick*/
            ctx[10],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      if (!current || dirty & /*title*/
      8)
        set_data_dev(
          t1,
          /*title*/
          ctx2[3]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
      if (!current || dirty & /*title*/
      8) {
        toggle_class(div4, "no-title", !/*title*/
        ctx2[3]);
      }
      if (!current || dirty & /*title*/
      8) {
        attr_dev(
          div5,
          "aria-label",
          /*title*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*className*/
      4 && div5_class_value !== (div5_class_value = "dialog-backdrop " + /*className*/
      ctx2[2])) {
        attr_dev(div5, "class", div5_class_value);
      }
      if (!current || dirty & /*className, opened*/
      5) {
        toggle_class(
          div5,
          "opened",
          /*opened*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div5);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[17](null);
      if (footer_slot)
        footer_slot.d(detaching);
      ctx[18](null);
      ctx[19](null);
      ctx[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function focusOtherButton(target, key) {
  const btnMap = {
    ArrowLeft: "nextElementSibling",
    ArrowRight: "previousElementSibling"
  };
  const direction = btnMap[key];
  let otherBtn = target[direction];
  while (otherBtn && otherBtn.tagName !== "BUTTON") {
    otherBtn = otherBtn[direction];
  }
  if (otherBtn)
    otherBtn.focus();
}
function instance4($$self2, $$props2, $$invalidate2) {
  let $ANIMATION_SPEED;
  validate_store(ANIMATION_SPEED, "ANIMATION_SPEED");
  component_subscribe($$self2, ANIMATION_SPEED, ($$value) => $$invalidate2(25, $ANIMATION_SPEED = $$value));
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Dialog", slots2, ["default", "footer"]);
  let { class: className2 = "" } = $$props2;
  let { title = "" } = $$props2;
  let { opened = false } = $$props2;
  let { skipFirstFocus = false } = $$props2;
  let { modal = false } = $$props2;
  let { element: element3 } = $$props2;
  const dispatch3 = createEventDispatcher();
  let dialogEl, contentEl, footerEl, triggerEl, openTimer, closeTimer, scrollPos;
  onMount(() => {
    document.body.appendChild(element3);
  });
  function focusFirst() {
    let first = getFocusableElements().shift();
    const last = getFocusableElements().pop();
    if (!first && !last) {
      contentEl.setAttribute("tabindex", 0);
      first = contentEl;
    }
    if (last)
      last.scrollIntoView({ block: "end" });
    if (first)
      first.focus();
  }
  function focusLast() {
    const first = getFocusableElements().shift();
    let last = getFocusableElements().pop();
    if (!first && !last) {
      contentEl.setAttribute("tabindex", 0);
      last = contentEl;
    }
    if (first)
      first.scrollIntoView({ block: "end" });
    if (last)
      last.focus();
  }
  function getFocusableElements() {
    const contentElements = Array.from(contentEl.querySelectorAll(FOCUSABLE_SELECTOR));
    const footerElements = Array.from(footerEl.querySelectorAll(FOCUSABLE_SELECTOR));
    return [...contentElements, ...footerElements];
  }
  function onBackdropMousedown(e) {
    if (modal) {
      e.stopPropagation();
      e.preventDefault();
    }
  }
  function onBackdropClick(e) {
    if (!dialogEl.contains(e.target) && !modal) {
      e.stopPropagation();
      close();
    }
  }
  function onDocKeydown(e) {
    if (!opened)
      return;
    const hasFocus = element3.contains(document.activeElement);
    if (e.key === "Tab" && !hasFocus)
      return focusFirst();
    if (e.key === "Escape" && !modal) {
      e.stopPropagation();
      return close();
    }
    const target = e.target?.closest("button");
    if (target && (e.key === "ArrowLeft" || e.key === "ArrowRight")) {
      focusOtherButton(target, e.key);
    }
  }
  function freezeBody(freeze) {
    if (freeze) {
      scrollPos = window.scrollY;
      document.body.classList.add("has-dialog");
      document.body.style.top = `-${scrollPos}px`;
    } else {
      document.body.classList.remove("has-dialog");
      document.scrollingElement.scrollTop = scrollPos;
      document.body.style.top = "";
    }
  }
  function open(openedBy) {
    if (opened)
      return;
    if (openedBy instanceof Event)
      openedBy = openedBy.target;
    triggerEl = openedBy || document.activeElement;
    if (triggerEl && triggerEl !== document.body) {
      triggerEl.setAttribute("aria-haspopup", "true");
      triggerEl.setAttribute("aria-expanded", "true");
    }
    $$invalidate2(1, element3.style.display = "flex", element3);
    if (openTimer)
      clearTimeout(openTimer);
    openTimer = setTimeout(
      () => {
        $$invalidate2(0, opened = true);
        $$invalidate2(1, element3.style.display = "flex", element3);
        if (skipFirstFocus !== true && skipFirstFocus !== "true")
          focusFirst();
        document.addEventListener("keydown", onDocKeydown);
        freezeBody(true);
        dispatch3("open");
      },
      100
    );
  }
  function close() {
    if (!opened)
      return;
    $$invalidate2(0, opened = false);
    if (triggerEl && triggerEl.focus)
      triggerEl.focus();
    if (closeTimer)
      clearTimeout(closeTimer);
    closeTimer = setTimeout(
      () => {
        $$invalidate2(0, opened = false);
        $$invalidate2(1, element3.style.display = "none", element3);
        document.removeEventListener("keydown", onDocKeydown);
        if (triggerEl && triggerEl !== document.body) {
          triggerEl.removeAttribute("aria-expanded");
        }
        freezeBody(false);
        dispatch3("close");
      },
      $ANIMATION_SPEED
    );
  }
  $$self2.$$.on_mount.push(function() {
    if (element3 === void 0 && !("element" in $$props2 || $$self2.$$.bound[$$self2.$$.props["element"]])) {
      console.warn("<Dialog> was created without expected prop 'element'");
    }
  });
  const writable_props = ["class", "title", "opened", "skipFirstFocus", "modal", "element"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Dialog> was created with unknown prop '${key}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentEl = $$value;
      $$invalidate2(5, contentEl);
    });
  }
  function div2_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      footerEl = $$value;
      $$invalidate2(6, footerEl);
    });
  }
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dialogEl = $$value;
      $$invalidate2(4, dialogEl);
    });
  }
  function div5_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(2, className2 = $$props3.class);
    if ("title" in $$props3)
      $$invalidate2(3, title = $$props3.title);
    if ("opened" in $$props3)
      $$invalidate2(0, opened = $$props3.opened);
    if ("skipFirstFocus" in $$props3)
      $$invalidate2(11, skipFirstFocus = $$props3.skipFirstFocus);
    if ("modal" in $$props3)
      $$invalidate2(12, modal = $$props3.modal);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("$$scope" in $$props3)
      $$invalidate2(15, $$scope2 = $$props3.$$scope);
  };
  $$self2.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    ANIMATION_SPEED,
    FOCUSABLE_SELECTOR,
    className: className2,
    title,
    opened,
    skipFirstFocus,
    modal,
    element: element3,
    dispatch: dispatch3,
    dialogEl,
    contentEl,
    footerEl,
    triggerEl,
    openTimer,
    closeTimer,
    scrollPos,
    focusFirst,
    focusLast,
    getFocusableElements,
    onBackdropMousedown,
    onBackdropClick,
    focusOtherButton,
    onDocKeydown,
    freezeBody,
    open,
    close,
    $ANIMATION_SPEED
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(2, className2 = $$props3.className);
    if ("title" in $$props3)
      $$invalidate2(3, title = $$props3.title);
    if ("opened" in $$props3)
      $$invalidate2(0, opened = $$props3.opened);
    if ("skipFirstFocus" in $$props3)
      $$invalidate2(11, skipFirstFocus = $$props3.skipFirstFocus);
    if ("modal" in $$props3)
      $$invalidate2(12, modal = $$props3.modal);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("dialogEl" in $$props3)
      $$invalidate2(4, dialogEl = $$props3.dialogEl);
    if ("contentEl" in $$props3)
      $$invalidate2(5, contentEl = $$props3.contentEl);
    if ("footerEl" in $$props3)
      $$invalidate2(6, footerEl = $$props3.footerEl);
    if ("triggerEl" in $$props3)
      triggerEl = $$props3.triggerEl;
    if ("openTimer" in $$props3)
      openTimer = $$props3.openTimer;
    if ("closeTimer" in $$props3)
      closeTimer = $$props3.closeTimer;
    if ("scrollPos" in $$props3)
      scrollPos = $$props3.scrollPos;
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    opened,
    element3,
    className2,
    title,
    dialogEl,
    contentEl,
    footerEl,
    focusFirst,
    focusLast,
    onBackdropMousedown,
    onBackdropClick,
    skipFirstFocus,
    modal,
    open,
    close,
    $$scope2,
    slots2,
    div1_binding,
    div2_binding2,
    div4_binding,
    div5_binding
  ];
}
var Dialog = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      class: 2,
      title: 3,
      opened: 0,
      skipFirstFocus: 11,
      modal: 12,
      element: 1,
      open: 13,
      close: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dialog",
      options,
      id: create_fragment4.name
    });
  }
  get class() {
    return this.$$.ctx[2];
  }
  set class(className2) {
    this.$$set({ class: className2 });
    flush();
  }
  get title() {
    return this.$$.ctx[3];
  }
  set title(title) {
    this.$$set({ title });
    flush();
  }
  get opened() {
    return this.$$.ctx[0];
  }
  set opened(opened) {
    this.$$set({ opened });
    flush();
  }
  get skipFirstFocus() {
    return this.$$.ctx[11];
  }
  set skipFirstFocus(skipFirstFocus) {
    this.$$set({ skipFirstFocus });
    flush();
  }
  get modal() {
    return this.$$.ctx[12];
  }
  set modal(modal) {
    this.$$set({ modal });
    flush();
  }
  get element() {
    return this.$$.ctx[1];
  }
  set element(element3) {
    this.$$set({ element: element3 });
    flush();
  }
  get open() {
    return this.$$.ctx[13];
  }
  set open(value2) {
    throw new Error("<Dialog>: Cannot set read-only property 'open'");
  }
  get close() {
    return this.$$.ctx[14];
  }
  set close(value2) {
    throw new Error("<Dialog>: Cannot set read-only property 'close'");
  }
};
var Dialog_default = Dialog;

// node_modules/svelte/src/runtime/easing/index.js
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}

// node_modules/svelte/src/runtime/transition/index.js
function fly(node, { delay = 0, duration: duration2 = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === "none" ? "" : style.transform;
  const od = target_opacity * (1 - opacity);
  const [xValue, xUnit] = split_css_unit(x);
  const [yValue, yUnit] = split_css_unit(y);
  return {
    delay,
    duration: duration2,
    easing,
    css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * xValue}${xUnit}, ${(1 - t) * yValue}${yUnit});
			opacity: ${target_opacity - od * u}`
  };
}
function crossfade({ fallback, ...defaults }) {
  const to_receive = /* @__PURE__ */ new Map();
  const to_send = /* @__PURE__ */ new Map();
  function crossfade2(from_node, node, params) {
    const {
      delay = 0,
      duration: duration2 = (d2) => Math.sqrt(d2) * 30,
      easing = cubicOut
    } = assign(assign({}, defaults), params);
    const from = from_node.getBoundingClientRect();
    const to = node.getBoundingClientRect();
    const dx = from.left - to.left;
    const dy = from.top - to.top;
    const dw = from.width / to.width;
    const dh = from.height / to.height;
    const d = Math.sqrt(dx * dx + dy * dy);
    const style = getComputedStyle(node);
    const transform = style.transform === "none" ? "" : style.transform;
    const opacity = +style.opacity;
    return {
      delay,
      duration: is_function(duration2) ? duration2(d) : duration2,
      easing,
      css: (t, u) => `
				opacity: ${t * opacity};
				transform-origin: top left;
				transform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${t + (1 - t) * dh});
			`
    };
  }
  function transition(items, counterparts, intro) {
    return (node, params) => {
      items.set(params.key, node);
      return () => {
        if (counterparts.has(params.key)) {
          const other_node = counterparts.get(params.key);
          counterparts.delete(params.key);
          return crossfade2(other_node, node, params);
        }
        items.delete(params.key);
        return fallback && fallback(node, params, intro);
      };
    };
  }
  return [transition(to_send, to_receive, false), transition(to_receive, to_send, true)];
}

// src/drawer/Drawer.svelte
var file4 = "src/drawer/Drawer.svelte";
function create_if_block2(ctx) {
  let div3;
  let div0;
  let t0;
  let header;
  let h2;
  let t1;
  let t2;
  let button;
  let t3;
  let div1;
  let t4;
  let div2;
  let div3_class_value;
  let docclick_action;
  let div3_intro;
  let div3_outro;
  let current;
  let mounted;
  let dispose;
  button = new Button_default({
    props: {
      round: true,
      text: true,
      icon: "close",
      class: "btn-close",
      title: "Close"
    },
    $$inline: true
  });
  button.$on(
    "click",
    /*close*/
    ctx[3]
  );
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      div3 = element2("div");
      div0 = element2("div");
      t0 = space();
      header = element2("header");
      h2 = element2("h2");
      t1 = text(
        /*title*/
        ctx[2]
      );
      t2 = space();
      create_component(button.$$.fragment);
      t3 = space();
      div1 = element2("div");
      if (default_slot)
        default_slot.c();
      t4 = space();
      div2 = element2("div");
      attr_dev(div0, "tabindex", "0");
      attr_dev(div0, "class", "focus-trap focus-trap-top");
      add_location(div0, file4, 10, 2, 301);
      add_location(h2, file4, 12, 3, 443);
      attr_dev(header, "class", "drawer-header");
      add_location(header, file4, 11, 2, 385);
      attr_dev(div1, "class", "drawer-content");
      add_location(div1, file4, 15, 2, 562);
      attr_dev(div2, "tabindex", "0");
      attr_dev(div2, "class", "focus-trap focus-trap-bottom");
      add_location(div2, file4, 16, 2, 612);
      attr_dev(div3, "class", div3_class_value = "drawer " + /*className*/
      ctx[1]);
      attr_dev(div3, "tabindex", "-1");
      add_location(div3, file4, 2, 1, 73);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      append_dev(div3, div0);
      append_dev(div3, t0);
      append_dev(div3, header);
      append_dev(header, h2);
      append_dev(h2, t1);
      append_dev(header, t2);
      mount_component(button, header, null);
      ctx[14](header);
      append_dev(div3, t3);
      append_dev(div3, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_dev(div3, t4);
      append_dev(div3, div2);
      ctx[15](div3);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div0,
            "focus",
            /*focusLast*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "focus",
            /*focusFirst*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          action_destroyer(docclick_action = /*docclick*/
          ctx[7].call(null, div3))
        ];
        mounted = true;
      }
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*title*/
      4)
        set_data_dev(
          t1,
          /*title*/
          ctx[2]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*className*/
      2 && div3_class_value !== (div3_class_value = "drawer " + /*className*/
      ctx[1])) {
        attr_dev(div3, "class", div3_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div3_outro)
            div3_outro.end(1);
          div3_intro = create_in_transition(div3, fly, {
            x: 300,
            duration: (
              /*$ANIMATION_SPEED*/
              ctx[6]
            )
          });
          div3_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      transition_out(default_slot, local);
      if (div3_intro)
        div3_intro.invalidate();
      if (local) {
        div3_outro = create_out_transition(div3, fly, {
          x: 300,
          duration: (
            /*$ANIMATION_SPEED*/
            ctx[6] ? (
              /*$ANIMATION_SPEED*/
              ctx[6] + 100
            ) : 0
          )
        });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      destroy_component(button);
      ctx[14](null);
      if (default_slot)
        default_slot.d(detaching);
      ctx[15](null);
      if (detaching && div3_outro)
        div3_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(1:0) {#if isVisible}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isVisible*/
    ctx[4] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      if (
        /*isVisible*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isVisible*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self2, $$props2, $$invalidate2) {
  let $ANIMATION_SPEED;
  validate_store(ANIMATION_SPEED, "ANIMATION_SPEED");
  component_subscribe($$self2, ANIMATION_SPEED, ($$value) => $$invalidate2(6, $ANIMATION_SPEED = $$value));
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Drawer", slots2, ["default"]);
  let { class: className2 = "" } = $$props2;
  let { title = "Drawer" } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  const dispatch3 = createEventDispatcher();
  let isVisible = false;
  let headerEl, targetBtn;
  function docclick() {
    requestAnimationFrame(() => document.addEventListener("click", onDocClick));
    return {
      destroy: () => document.removeEventListener("click", onDocClick)
    };
  }
  function onDocClick(e) {
    if (element3.contains(e.target))
      return;
    if (!isVisible)
      return;
    e.preventDefault();
    e.stopPropagation();
    close();
  }
  function toggle(target) {
    if (target)
      targetBtn = target;
    isVisible ? close() : open(target);
  }
  function open(target) {
    targetBtn = target || document.activeElement;
    $$invalidate2(4, isVisible = true);
    requestAnimationFrame(() => headerEl.querySelector(".btn-close").focus());
    dispatch3("open");
  }
  function close() {
    $$invalidate2(4, isVisible = false);
    if (targetBtn)
      targetBtn.focus();
    dispatch3("close");
  }
  function focusFirst() {
    const first = getFocusableElements().shift();
    const last = getFocusableElements().pop();
    if (last && last.scrollIntoView)
      last.scrollIntoView({ block: "end" });
    if (first && first.focus)
      first.focus();
  }
  function focusLast() {
    const first = getFocusableElements().shift();
    const last = getFocusableElements().pop();
    if (first && first.scrollIntoView)
      first.scrollIntoView({ block: "end" });
    if (last && last.focus)
      last.focus();
  }
  function getFocusableElements() {
    return Array.from(element3.querySelectorAll(FOCUSABLE_SELECTOR));
  }
  const writable_props = ["class", "title", "element"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Drawer> was created with unknown prop '${key}'`);
  });
  function header_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      headerEl = $$value;
      $$invalidate2(5, headerEl);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("title" in $$props3)
      $$invalidate2(2, title = $$props3.title);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("$$scope" in $$props3)
      $$invalidate2(12, $$scope2 = $$props3.$$scope);
  };
  $$self2.$capture_state = () => ({
    createEventDispatcher,
    fly,
    ANIMATION_SPEED,
    FOCUSABLE_SELECTOR,
    Button: Button_default,
    className: className2,
    title,
    element: element3,
    dispatch: dispatch3,
    isVisible,
    headerEl,
    targetBtn,
    docclick,
    onDocClick,
    toggle,
    open,
    close,
    focusFirst,
    focusLast,
    getFocusableElements,
    $ANIMATION_SPEED
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("title" in $$props3)
      $$invalidate2(2, title = $$props3.title);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("isVisible" in $$props3)
      $$invalidate2(4, isVisible = $$props3.isVisible);
    if ("headerEl" in $$props3)
      $$invalidate2(5, headerEl = $$props3.headerEl);
    if ("targetBtn" in $$props3)
      targetBtn = $$props3.targetBtn;
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    element3,
    className2,
    title,
    close,
    isVisible,
    headerEl,
    $ANIMATION_SPEED,
    docclick,
    focusFirst,
    focusLast,
    toggle,
    open,
    $$scope2,
    slots2,
    header_binding,
    div3_binding
  ];
}
var Drawer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      class: 1,
      title: 2,
      element: 0,
      toggle: 10,
      open: 11,
      close: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Drawer",
      options,
      id: create_fragment5.name
    });
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(className2) {
    this.$$set({ class: className2 });
    flush();
  }
  get title() {
    return this.$$.ctx[2];
  }
  set title(title) {
    this.$$set({ title });
    flush();
  }
  get element() {
    return this.$$.ctx[0];
  }
  set element(element3) {
    this.$$set({ element: element3 });
    flush();
  }
  get toggle() {
    return this.$$.ctx[10];
  }
  set toggle(value2) {
    throw new Error("<Drawer>: Cannot set read-only property 'toggle'");
  }
  get open() {
    return this.$$.ctx[11];
  }
  set open(value2) {
    throw new Error("<Drawer>: Cannot set read-only property 'open'");
  }
  get close() {
    return this.$$.ctx[3];
  }
  set close(value2) {
    throw new Error("<Drawer>: Cannot set read-only property 'close'");
  }
};
var Drawer_default = Drawer;

// src/grid/utils.js
function isActiveElement(element3) {
  const skipEventFor = ["INPUT", "TEXTAREA", "SELECT", "BUTTON"];
  if (skipEventFor.includes(element3.tagName))
    return true;
}
function isInsidePopup(element3) {
  const skipEventIfInside = ".dialog,.drawer,.popover,.menu";
  return element3.closest(skipEventIfInside);
}
function shouldSkipNav(e, element3) {
  const target = e && e.target;
  if (!target || target === document)
    return false;
  const notInElem = !element3 || !element3.contains(target);
  return notInElem || isActiveElement(target) || isInsidePopup(target);
}
function getSelectableItems(element3) {
  const rootEl = element3.parentElement || document;
  const rows = rootEl.querySelectorAll(".table tbody");
  if (rows && rows.length)
    return Array.from(rows);
  return [];
}
function getScrollContainer(element3, scrollContainer) {
  let scrollEl = element3;
  if (scrollContainer) {
    if (typeof scrollContainer === "string")
      scrollEl = element3.closest(scrollContainer);
    else
      scrollEl = scrollContainer;
  }
  return scrollEl.scrollTo ? scrollEl : null;
}
function getHeaderHeight(element3) {
  if (!element3)
    return 0;
  const _title = element3.querySelector(".grid-title");
  const titleHeight = _title ? _title.offsetHeight : 0;
  const head = element3.querySelector("thead");
  const headHeight = head ? head.offsetHeight : 0;
  return headHeight + titleHeight;
}

// src/grid/DataStore.js
function DataStore() {
  const _this = writable([]);
  const { subscribe: subscribe2, set } = _this;
  const columns = writable([]);
  const allSelected = writable(false);
  const someSelected = writable(false);
  const sortField = writable("");
  const sortOrder = writable("ASC");
  let lastSelectedItemId = null;
  function getById(id2) {
    return get_store_value(_this).find((i) => i.id === id2);
  }
  function toggleSelection(item, event, forceState) {
    if (event.shiftKey && lastSelectedItemId)
      return selectRange(event);
    const $Data = get_store_value(_this);
    const _item = getById(item.id);
    if (!isset(forceState))
      _item.selected = !_item.selected;
    else
      _item.selected = forceState;
    if (_item.selected)
      lastSelectedItemId = _item.id;
    set($Data);
    updateSelectedCounters();
  }
  function toggleSelectAll(forceState = null) {
    let isAll = get_store_value(allSelected);
    if (typeof forceState === "boolean")
      isAll = forceState;
    else
      isAll = get_store_value(someSelected) ? false : !isAll;
    allSelected.set(isAll);
    someSelected.set(false);
    const $Data = get_store_value(_this);
    $Data.forEach((_item) => _item.selected = isAll);
    set($Data);
  }
  function selectRange(event) {
    const rowEl = event.target.closest(".item");
    const gridEl = rowEl.closest(".grid");
    const lastSelectedRowEl = gridEl.querySelector(`.item[data-id="${lastSelectedItemId}"]`);
    if (!rowEl || !lastSelectedRowEl)
      return;
    const $Data = get_store_value(_this);
    const rows = gridEl.querySelectorAll(".item");
    const rowsToSelect = [rowEl, lastSelectedRowEl];
    let start = false;
    for (let i = 0; i < rows.length; i++) {
      if (rows[i] === rowEl || rows[i] === lastSelectedRowEl) {
        if (start)
          break;
        start = true;
      }
      if (start)
        rowsToSelect.push(rows[i]);
    }
    rowsToSelect.forEach((id2) => {
      getById(+id2.dataset.id).selected = true;
    });
    set($Data);
    updateSelectedCounters();
  }
  function updateSelectedCounters() {
    const $Data = get_store_value(_this);
    const countSelected = $Data.filter((t) => t.selected).length;
    const isAll = $Data.length === countSelected;
    allSelected.set(isAll);
    someSelected.set(countSelected > 0 && !isAll);
  }
  sortField.subscribe((field) => {
    if (field)
      set(sortData(get_store_value(_this), field, get_store_value(sortOrder)));
  });
  sortOrder.subscribe((order) => {
    if (order)
      set(sortData(get_store_value(_this), get_store_value(sortField), order));
  });
  return {
    subscribe: subscribe2,
    set,
    get: () => _this,
    columns,
    allSelected,
    someSelected,
    sortField,
    sortOrder,
    toggleSelection,
    toggleSelectAll,
    reset: () => set([])
  };
}
function sortData(items, field, order) {
  if (!items || !items.length)
    return [];
  if (field === "")
    return items.sort(numberSort("id", order));
  if (typeof items[0][field] === "number") {
    return items.sort(numberSort(field, order));
  }
  return items.sort(stringSort(field, order));
}
function numberSort(field, order = "ASC") {
  if (order === "ASC")
    return (a, b) => Math.abs(a[field]) - Math.abs(b[field]);
  return (a, b) => Math.abs(b[field]) - Math.abs(a[field]);
}
function stringSort(field, order = "ASC") {
  if (order === "ASC")
    return (a, b) => ("" + a[field]).localeCompare("" + b[field]);
  return (a, b) => ("" + b[field]).localeCompare("" + a[field]);
}

// src/input/combobox/utils.js
function groupData(items) {
  const nogroup = [];
  const _groups = {};
  items.forEach((item) => {
    if (!item.group)
      return nogroup.push(item);
    _groups[item.group] = _groups[item.group] || { name: item.group, items: [] };
    _groups[item.group].items.push(item);
  });
  const groups = Object.values(_groups).filter((g) => !!g.items.length);
  if (nogroup.length)
    groups.unshift({ items: nogroup });
  return groups;
}
function scrollToSelectedItem(listEl) {
  if (!listEl)
    return;
  requestAnimationFrame(() => {
    const selectedEl = listEl.querySelector(".selected");
    if (!selectedEl || !listEl.scrollTo)
      return;
    const paddingTop = 3;
    let top = selectedEl.offsetTop - paddingTop;
    if (listEl.scrollTop > top)
      listEl.scrollTo({ top });
    else {
      const paddingBottom = 6;
      top = selectedEl.offsetTop + selectedEl.offsetHeight - listEl.offsetHeight + paddingBottom;
      if (listEl.scrollTop < top)
        listEl.scrollTo({ top });
    }
  });
}
function emphasize(str, q) {
  if (!q)
    return str;
  str = "" + str;
  let idx = 0;
  const low = str.toLowerCase();
  if (low.includes(q))
    return str.replace(new RegExp(`(${q})`, "ig"), "<b>$1</b>");
  const stra = str.split("");
  q = q.toLowerCase();
  for (const l of q) {
    idx = low.indexOf(l, idx);
    const letter = stra[idx];
    if (letter) {
      stra.splice(idx, 1, `<b>${letter}</b>`);
      idx += 1;
    }
  }
  return stra.join("");
}
function findSourceItem(v, items) {
  v = v.id || v.name || v;
  const idx = items.findIndex((i) => (i.id || i.name || i) === v);
  return items[idx];
}
function findValueInSource(val, items) {
  if (!val)
    return val;
  if (!Array.isArray(val))
    return findSourceItem(val, items);
  return val.map((v) => findSourceItem(v, items));
}
function getInputValue(_val, isMultiselect = false) {
  if (!isMultiselect)
    return _val?.name || _val || "";
  if (!Array.isArray(_val))
    _val = [_val];
  return _val.map((i) => i.name || i).join(", ");
}
function alignDropdown(listElement, inputElement2, e) {
  requestAnimationFrame(() => {
    alignItem({
      element: listElement,
      target: inputElement2,
      setMinWidthToTarget: true,
      offsetH: -1
    });
    if (e && e.type === "focus")
      inputElement2.select();
  });
}
function hasSingleValueChanged(oldV, newV) {
  return (oldV?.id || oldV?.name || oldV) !== (newV?.id || newV?.name || newV);
}
function hasValueChanged(oldV, newV, multiselect = false) {
  if (!multiselect)
    return hasSingleValueChanged(oldV, newV);
  if (!Array.isArray(oldV))
    oldV = [oldV];
  if (!Array.isArray(newV))
    newV = [newV];
  if (oldV.length !== newV.length)
    return true;
  for (let i = 0; i < newV.length; i++) {
    if (hasSingleValueChanged(oldV[i], newV[i]))
      return true;
  }
  return false;
}

// src/info-bar/InfoBar.svelte
var file5 = "src/info-bar/InfoBar.svelte";
function create_if_block3(ctx) {
  let div;
  let icon;
  let t;
  let p;
  let div_class_value;
  let current;
  icon = new Icon_default({
    props: { name: (
      /*type*/
      ctx[4]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element2("div");
      create_component(icon.$$.fragment);
      t = space();
      p = element2("p");
      attr_dev(
        p,
        "id",
        /*id*/
        ctx[2]
      );
      add_location(p, file5, 3, 2, 110);
      attr_dev(div, "class", div_class_value = "info-bar info-bar-" + /*type*/
      ctx[4] + " " + /*className*/
      ctx[1]);
      add_location(div, file5, 1, 1, 11);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(icon, div, null);
      append_dev(div, t);
      append_dev(div, p);
      p.innerHTML = /*msg*/
      ctx[3];
      ctx[5](div);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & /*type*/
      16)
        icon_changes.name = /*type*/
        ctx2[4];
      icon.$set(icon_changes);
      if (!current || dirty & /*msg*/
      8)
        p.innerHTML = /*msg*/
        ctx2[3];
      ;
      if (!current || dirty & /*id*/
      4) {
        attr_dev(
          p,
          "id",
          /*id*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*type, className*/
      18 && div_class_value !== (div_class_value = "info-bar info-bar-" + /*type*/
      ctx2[4] + " " + /*className*/
      ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(icon);
      ctx[5](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(1:0) {#if msg}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*msg*/
    ctx[3] && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      if (
        /*msg*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*msg*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InfoBar", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { id: id2 = void 0 } = $$props2;
  let { msg = "" } = $$props2;
  let { type = "info" } = $$props2;
  const writable_props = ["class", "element", "id", "msg", "type"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InfoBar> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("id" in $$props3)
      $$invalidate2(2, id2 = $$props3.id);
    if ("msg" in $$props3)
      $$invalidate2(3, msg = $$props3.msg);
    if ("type" in $$props3)
      $$invalidate2(4, type = $$props3.type);
  };
  $$self2.$capture_state = () => ({ Icon: Icon_default, className: className2, element: element3, id: id2, msg, type });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("id" in $$props3)
      $$invalidate2(2, id2 = $$props3.id);
    if ("msg" in $$props3)
      $$invalidate2(3, msg = $$props3.msg);
    if ("type" in $$props3)
      $$invalidate2(4, type = $$props3.type);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [element3, className2, id2, msg, type, div_binding];
}
var InfoBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      class: 1,
      element: 0,
      id: 2,
      msg: 3,
      type: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InfoBar",
      options,
      id: create_fragment6.name
    });
  }
  get class() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get msg() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set msg(value2) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value2) {
    throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InfoBar_default = InfoBar;

// src/info-bar/Error.svelte
var { Error: Error_1 } = globals;
function create_fragment7(ctx) {
  let infobar;
  let updating_element;
  let current;
  function infobar_element_binding(value2) {
    ctx[4](value2);
  }
  let infobar_props = {
    class: (
      /*className*/
      ctx[1]
    ),
    id: (
      /*id*/
      ctx[2]
    ),
    msg: (
      /*msg*/
      ctx[3]
    ),
    type: "error"
  };
  if (
    /*element*/
    ctx[0] !== void 0
  ) {
    infobar_props.element = /*element*/
    ctx[0];
  }
  infobar = new InfoBar_default({ props: infobar_props, $$inline: true });
  binding_callbacks.push(() => bind(infobar, "element", infobar_element_binding));
  const block = {
    c: function create() {
      create_component(infobar.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(infobar, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const infobar_changes = {};
      if (dirty & /*className*/
      2)
        infobar_changes.class = /*className*/
        ctx2[1];
      if (dirty & /*id*/
      4)
        infobar_changes.id = /*id*/
        ctx2[2];
      if (dirty & /*msg*/
      8)
        infobar_changes.msg = /*msg*/
        ctx2[3];
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        infobar_changes.element = /*element*/
        ctx2[0];
        add_flush_callback(() => updating_element = false);
      }
      infobar.$set(infobar_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(infobar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(infobar.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(infobar, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Error", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { id: id2 = void 0 } = $$props2;
  let { msg = "" } = $$props2;
  const writable_props = ["class", "element", "id", "msg"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Error> was created with unknown prop '${key}'`);
  });
  function infobar_element_binding(value2) {
    element3 = value2;
    $$invalidate2(0, element3);
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("id" in $$props3)
      $$invalidate2(2, id2 = $$props3.id);
    if ("msg" in $$props3)
      $$invalidate2(3, msg = $$props3.msg);
  };
  $$self2.$capture_state = () => ({ InfoBar: InfoBar_default, className: className2, element: element3, id: id2, msg });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("id" in $$props3)
      $$invalidate2(2, id2 = $$props3.id);
    if ("msg" in $$props3)
      $$invalidate2(3, msg = $$props3.msg);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [element3, className2, id2, msg, infobar_element_binding];
}
var Error2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { class: 1, element: 0, id: 2, msg: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Error",
      options,
      id: create_fragment7.name
    });
  }
  get class() {
    throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get msg() {
    throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set msg(value2) {
    throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Error_default = Error2;

// src/info-bar/Info.svelte
function create_fragment8(ctx) {
  let infobar;
  let updating_element;
  let current;
  function infobar_element_binding(value2) {
    ctx[4](value2);
  }
  let infobar_props = {
    class: (
      /*className*/
      ctx[1]
    ),
    id: (
      /*id*/
      ctx[2]
    ),
    msg: (
      /*msg*/
      ctx[3]
    ),
    type: "info"
  };
  if (
    /*element*/
    ctx[0] !== void 0
  ) {
    infobar_props.element = /*element*/
    ctx[0];
  }
  infobar = new InfoBar_default({ props: infobar_props, $$inline: true });
  binding_callbacks.push(() => bind(infobar, "element", infobar_element_binding));
  const block = {
    c: function create() {
      create_component(infobar.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(infobar, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const infobar_changes = {};
      if (dirty & /*className*/
      2)
        infobar_changes.class = /*className*/
        ctx2[1];
      if (dirty & /*id*/
      4)
        infobar_changes.id = /*id*/
        ctx2[2];
      if (dirty & /*msg*/
      8)
        infobar_changes.msg = /*msg*/
        ctx2[3];
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        infobar_changes.element = /*element*/
        ctx2[0];
        add_flush_callback(() => updating_element = false);
      }
      infobar.$set(infobar_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(infobar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(infobar.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(infobar, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Info", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { id: id2 = void 0 } = $$props2;
  let { msg = "" } = $$props2;
  const writable_props = ["class", "element", "id", "msg"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Info> was created with unknown prop '${key}'`);
  });
  function infobar_element_binding(value2) {
    element3 = value2;
    $$invalidate2(0, element3);
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("id" in $$props3)
      $$invalidate2(2, id2 = $$props3.id);
    if ("msg" in $$props3)
      $$invalidate2(3, msg = $$props3.msg);
  };
  $$self2.$capture_state = () => ({ InfoBar: InfoBar_default, className: className2, element: element3, id: id2, msg });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("id" in $$props3)
      $$invalidate2(2, id2 = $$props3.id);
    if ("msg" in $$props3)
      $$invalidate2(3, msg = $$props3.msg);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [element3, className2, id2, msg, infobar_element_binding];
}
var Info = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { class: 1, element: 0, id: 2, msg: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Info",
      options,
      id: create_fragment8.name
    });
  }
  get class() {
    throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get msg() {
    throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set msg(value2) {
    throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Info_default = Info;

// src/info-bar/Success.svelte
function create_fragment9(ctx) {
  let infobar;
  let updating_element;
  let current;
  function infobar_element_binding(value2) {
    ctx[4](value2);
  }
  let infobar_props = {
    class: (
      /*className*/
      ctx[1]
    ),
    id: (
      /*id*/
      ctx[2]
    ),
    msg: (
      /*msg*/
      ctx[3]
    ),
    type: "success"
  };
  if (
    /*element*/
    ctx[0] !== void 0
  ) {
    infobar_props.element = /*element*/
    ctx[0];
  }
  infobar = new InfoBar_default({ props: infobar_props, $$inline: true });
  binding_callbacks.push(() => bind(infobar, "element", infobar_element_binding));
  const block = {
    c: function create() {
      create_component(infobar.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(infobar, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const infobar_changes = {};
      if (dirty & /*className*/
      2)
        infobar_changes.class = /*className*/
        ctx2[1];
      if (dirty & /*id*/
      4)
        infobar_changes.id = /*id*/
        ctx2[2];
      if (dirty & /*msg*/
      8)
        infobar_changes.msg = /*msg*/
        ctx2[3];
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        infobar_changes.element = /*element*/
        ctx2[0];
        add_flush_callback(() => updating_element = false);
      }
      infobar.$set(infobar_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(infobar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(infobar.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(infobar, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Success", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { id: id2 = void 0 } = $$props2;
  let { msg = "" } = $$props2;
  const writable_props = ["class", "element", "id", "msg"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Success> was created with unknown prop '${key}'`);
  });
  function infobar_element_binding(value2) {
    element3 = value2;
    $$invalidate2(0, element3);
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("id" in $$props3)
      $$invalidate2(2, id2 = $$props3.id);
    if ("msg" in $$props3)
      $$invalidate2(3, msg = $$props3.msg);
  };
  $$self2.$capture_state = () => ({ InfoBar: InfoBar_default, className: className2, element: element3, id: id2, msg });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("id" in $$props3)
      $$invalidate2(2, id2 = $$props3.id);
    if ("msg" in $$props3)
      $$invalidate2(3, msg = $$props3.msg);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [element3, className2, id2, msg, infobar_element_binding];
}
var Success = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { class: 1, element: 0, id: 2, msg: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Success",
      options,
      id: create_fragment9.name
    });
  }
  get class() {
    throw new Error("<Success>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Success>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Success>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Success>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Success>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<Success>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get msg() {
    throw new Error("<Success>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set msg(value2) {
    throw new Error("<Success>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Success_default = Success;

// src/info-bar/Warning.svelte
function create_fragment10(ctx) {
  let infobar;
  let updating_element;
  let current;
  function infobar_element_binding(value2) {
    ctx[4](value2);
  }
  let infobar_props = {
    class: (
      /*className*/
      ctx[1]
    ),
    id: (
      /*id*/
      ctx[2]
    ),
    msg: (
      /*msg*/
      ctx[3]
    ),
    type: "warning"
  };
  if (
    /*element*/
    ctx[0] !== void 0
  ) {
    infobar_props.element = /*element*/
    ctx[0];
  }
  infobar = new InfoBar_default({ props: infobar_props, $$inline: true });
  binding_callbacks.push(() => bind(infobar, "element", infobar_element_binding));
  const block = {
    c: function create() {
      create_component(infobar.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(infobar, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const infobar_changes = {};
      if (dirty & /*className*/
      2)
        infobar_changes.class = /*className*/
        ctx2[1];
      if (dirty & /*id*/
      4)
        infobar_changes.id = /*id*/
        ctx2[2];
      if (dirty & /*msg*/
      8)
        infobar_changes.msg = /*msg*/
        ctx2[3];
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        infobar_changes.element = /*element*/
        ctx2[0];
        add_flush_callback(() => updating_element = false);
      }
      infobar.$set(infobar_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(infobar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(infobar.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(infobar, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Warning", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { id: id2 = void 0 } = $$props2;
  let { msg = "" } = $$props2;
  const writable_props = ["class", "element", "id", "msg"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Warning> was created with unknown prop '${key}'`);
  });
  function infobar_element_binding(value2) {
    element3 = value2;
    $$invalidate2(0, element3);
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("id" in $$props3)
      $$invalidate2(2, id2 = $$props3.id);
    if ("msg" in $$props3)
      $$invalidate2(3, msg = $$props3.msg);
  };
  $$self2.$capture_state = () => ({ InfoBar: InfoBar_default, className: className2, element: element3, id: id2, msg });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("id" in $$props3)
      $$invalidate2(2, id2 = $$props3.id);
    if ("msg" in $$props3)
      $$invalidate2(3, msg = $$props3.msg);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [element3, className2, id2, msg, infobar_element_binding];
}
var Warning = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { class: 1, element: 0, id: 2, msg: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Warning",
      options,
      id: create_fragment10.name
    });
  }
  get class() {
    throw new Error("<Warning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Warning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Warning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Warning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Warning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<Warning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get msg() {
    throw new Error("<Warning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set msg(value2) {
    throw new Error("<Warning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Warning_default = Warning;

// src/input/input-error/InputError.svelte
var { Error: Error_12 } = globals;
var file6 = "src/input/input-error/InputError.svelte";
function create_if_block4(ctx) {
  let div;
  let error2;
  let div_transition;
  let current;
  error2 = new Error_default({
    props: { id: (
      /*id*/
      ctx[1]
    ), msg: (
      /*msg*/
      ctx[2]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element2("div");
      create_component(error2.$$.fragment);
      attr_dev(div, "class", "error-wrap");
      add_location(div, file6, 1, 1, 11);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(error2, div, null);
      ctx[8](div);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const error_changes = {};
      if (dirty & /*id*/
      2)
        error_changes.id = /*id*/
        ctx2[1];
      if (dirty & /*msg*/
      4)
        error_changes.msg = /*msg*/
        ctx2[2];
      error2.$set(error_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error2.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(
              div,
              /*slideError*/
              ctx[3],
              {},
              true
            );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(error2.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            /*slideError*/
            ctx[3],
            {},
            false
          );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(error2);
      ctx[8](null);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(1:0) {#if msg}",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*msg*/
    ctx[2] && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error_12("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      if (
        /*msg*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*msg*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self2, $$props2, $$invalidate2) {
  let _animOffset;
  let _hasOffset;
  let _animOpacity;
  let $ANIMATION_SPEED;
  validate_store(ANIMATION_SPEED, "ANIMATION_SPEED");
  component_subscribe($$self2, ANIMATION_SPEED, ($$value) => $$invalidate2(10, $ANIMATION_SPEED = $$value));
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputError", slots2, []);
  let { id: id2 = void 0 } = $$props2;
  let { msg = "" } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { animOffset = 0 } = $$props2;
  let { animOpacity = false } = $$props2;
  function slideError(node) {
    const o = node.getBoundingClientRect().height;
    return {
      duration: $ANIMATION_SPEED,
      css: (t) => {
        return `height: ${t * o}px;` + (_animOpacity ? `opacity: ${t};` : "") + (_hasOffset ? `margin-bottom: ${t * _animOffset - _animOffset}px;` : "");
      }
    };
  }
  const writable_props = ["id", "msg", "element", "animOffset", "animOpacity"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InputError> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("id" in $$props3)
      $$invalidate2(1, id2 = $$props3.id);
    if ("msg" in $$props3)
      $$invalidate2(2, msg = $$props3.msg);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("animOffset" in $$props3)
      $$invalidate2(4, animOffset = $$props3.animOffset);
    if ("animOpacity" in $$props3)
      $$invalidate2(5, animOpacity = $$props3.animOpacity);
  };
  $$self2.$capture_state = () => ({
    ANIMATION_SPEED,
    Error: Error_default,
    id: id2,
    msg,
    element: element3,
    animOffset,
    animOpacity,
    slideError,
    _animOffset,
    _hasOffset,
    _animOpacity,
    $ANIMATION_SPEED
  });
  $$self2.$inject_state = ($$props3) => {
    if ("id" in $$props3)
      $$invalidate2(1, id2 = $$props3.id);
    if ("msg" in $$props3)
      $$invalidate2(2, msg = $$props3.msg);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("animOffset" in $$props3)
      $$invalidate2(4, animOffset = $$props3.animOffset);
    if ("animOpacity" in $$props3)
      $$invalidate2(5, animOpacity = $$props3.animOpacity);
    if ("_animOffset" in $$props3)
      $$invalidate2(6, _animOffset = $$props3._animOffset);
    if ("_hasOffset" in $$props3)
      $$invalidate2(7, _hasOffset = $$props3._hasOffset);
    if ("_animOpacity" in $$props3)
      _animOpacity = $$props3._animOpacity;
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*animOffset*/
    16) {
      $:
        $$invalidate2(6, _animOffset = parseInt(animOffset, 10) || 0);
    }
    if ($$self2.$$.dirty & /*_animOffset*/
    64) {
      $:
        $$invalidate2(7, _hasOffset = _animOffset > 0);
    }
    if ($$self2.$$.dirty & /*animOpacity, _hasOffset*/
    160) {
      $:
        _animOpacity = animOpacity === "true" || animOpacity === true || _hasOffset;
    }
  };
  return [
    element3,
    id2,
    msg,
    slideError,
    animOffset,
    animOpacity,
    _animOffset,
    _hasOffset,
    div_binding
  ];
}
var InputError = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {
      id: 1,
      msg: 2,
      element: 0,
      animOffset: 4,
      animOpacity: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputError",
      options,
      id: create_fragment11.name
    });
  }
  get id() {
    throw new Error_12("<InputError>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error_12("<InputError>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get msg() {
    throw new Error_12("<InputError>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set msg(value2) {
    throw new Error_12("<InputError>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error_12("<InputError>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error_12("<InputError>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animOffset() {
    throw new Error_12("<InputError>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animOffset(value2) {
    throw new Error_12("<InputError>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animOpacity() {
    throw new Error_12("<InputError>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animOpacity(value2) {
    throw new Error_12("<InputError>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputError_default = InputError;

// src/input/label/Label.svelte
var file7 = "src/input/label/Label.svelte";
function create_if_block5(ctx) {
  let label_1;
  let t;
  let label_1_class_value;
  const block = {
    c: function create() {
      label_1 = element2("label");
      t = text(
        /*label*/
        ctx[3]
      );
      attr_dev(label_1, "class", label_1_class_value = "label " + /*className*/
      ctx[1]);
      attr_dev(
        label_1,
        "for",
        /*_for*/
        ctx[2]
      );
      toggle_class(
        label_1,
        "disabled",
        /*disabled*/
        ctx[4]
      );
      add_location(label_1, file7, 1, 1, 13);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label_1, anchor);
      append_dev(label_1, t);
      ctx[5](label_1);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*label*/
      8)
        set_data_dev(
          t,
          /*label*/
          ctx2[3]
        );
      if (dirty & /*className*/
      2 && label_1_class_value !== (label_1_class_value = "label " + /*className*/
      ctx2[1])) {
        attr_dev(label_1, "class", label_1_class_value);
      }
      if (dirty & /*_for*/
      4) {
        attr_dev(
          label_1,
          "for",
          /*_for*/
          ctx2[2]
        );
      }
      if (dirty & /*className, disabled*/
      18) {
        toggle_class(
          label_1,
          "disabled",
          /*disabled*/
          ctx2[4]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label_1);
      }
      ctx[5](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(1:0) {#if label}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let if_block_anchor;
  let if_block = (
    /*label*/
    ctx[3] && create_if_block5(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update2(ctx2, [dirty]) {
      if (
        /*label*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Label", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { for: _for = "" } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  const writable_props = ["class", "for", "label", "disabled", "element"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Label> was created with unknown prop '${key}'`);
  });
  function label_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("for" in $$props3)
      $$invalidate2(2, _for = $$props3.for);
    if ("label" in $$props3)
      $$invalidate2(3, label2 = $$props3.label);
    if ("disabled" in $$props3)
      $$invalidate2(4, disabled2 = $$props3.disabled);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
  };
  $$self2.$capture_state = () => ({
    className: className2,
    _for,
    label: label2,
    disabled: disabled2,
    element: element3
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("_for" in $$props3)
      $$invalidate2(2, _for = $$props3._for);
    if ("label" in $$props3)
      $$invalidate2(3, label2 = $$props3.label);
    if ("disabled" in $$props3)
      $$invalidate2(4, disabled2 = $$props3.disabled);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [element3, className2, _for, label2, disabled2, label_1_binding];
}
var Label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      class: 1,
      for: 2,
      label: 3,
      disabled: 4,
      element: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options,
      id: create_fragment12.name
    });
  }
  get class() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get for() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set for(value2) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Label_default = Label;

// src/input/combobox/Combobox.svelte
var file8 = "src/input/combobox/Combobox.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[74] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[77] = list[i];
  const constants_0 = (
    /*multiselect*/
    child_ctx[13] && /*selectedItems*/
    child_ctx[1].find(function func(...args) {
      return (
        /*func*/
        ctx[47](
          /*item*/
          child_ctx[77],
          ...args
        )
      );
    })
  );
  child_ctx[78] = constants_0;
  return child_ctx;
}
function create_if_block6(ctx) {
  let div;
  let t;
  let div_id_value;
  let div_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*filteredData*/
      ctx2[14].length
    )
      return create_if_block_2;
    if (
      /*allowNew*/
      ctx2[7]
    )
      return create_if_block_6;
  }
  let current_block_type = select_block_type(ctx, [-1, -1, -1]);
  let if_block0 = current_block_type && current_block_type(ctx);
  let if_block1 = (
    /*shouldShowNewItem*/
    ctx[20] && create_if_block_1(ctx)
  );
  const block = {
    c: function create() {
      div = element2("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr_dev(div, "id", div_id_value = "combobox-list-" + /*gui*/
      ctx[22]);
      attr_dev(div, "class", div_class_value = "combobox-list " + /*opened*/
      (ctx[16] ? "" : "hidden"));
      attr_dev(div, "role", "listbox");
      toggle_class(
        div,
        "multiselect",
        /*multiselect*/
        ctx[13]
      );
      toggle_class(div, "empty", !/*filteredData*/
      ctx[14].length && !/*shouldShowNewItem*/
      ctx[20]);
      add_location(div, file8, 55, 1, 1340);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      ctx[49](div);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "mousedown",
          /*onListMouseDown*/
          ctx[28],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update2(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if (if_block0)
          if_block0.d(1);
        if_block0 = current_block_type && current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div, t);
        }
      }
      if (
        /*shouldShowNewItem*/
        ctx2[20]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*opened*/
      65536 && div_class_value !== (div_class_value = "combobox-list " + /*opened*/
      (ctx2[16] ? "" : "hidden"))) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty[0] & /*opened, multiselect*/
      73728) {
        toggle_class(
          div,
          "multiselect",
          /*multiselect*/
          ctx2[13]
        );
      }
      if (dirty[0] & /*opened, filteredData, shouldShowNewItem*/
      1130496) {
        toggle_class(div, "empty", !/*filteredData*/
        ctx2[14].length && !/*shouldShowNewItem*/
        ctx2[20]);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0) {
        if_block0.d();
      }
      if (if_block1)
        if_block1.d();
      ctx[49](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(55:0) {#if opened}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element2("div");
      div.textContent = "No items found";
      attr_dev(div, "class", "combobox-list-empty");
      add_location(div, file8, 103, 3, 2995);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(103:21) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like_dev(
    /*groupedData*/
    ctx[18]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (dirty[0] & /*groupedData, highlightIndex, multiselect, selectedItems, onclick*/
      537272322) {
        each_value = ensure_array_like_dev(
          /*groupedData*/
          ctx2[18]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(64:2) {#if filteredData.length}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let div;
  let t_value = (
    /*group*/
    ctx[74].name + ""
  );
  let t;
  const block = {
    c: function create() {
      div = element2("div");
      t = text(t_value);
      attr_dev(div, "class", "combobox-list-header");
      add_location(div, file8, 66, 5, 1667);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update2(ctx2, dirty) {
      if (dirty[0] & /*groupedData*/
      262144 && t_value !== (t_value = /*group*/
      ctx2[74].name + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(66:4) {#if group.name}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let each_1_anchor;
  let each_value_1 = ensure_array_like_dev(
    /*group*/
    ctx[74].items
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (dirty[0] & /*groupedData, highlightIndex, multiselect, selectedItems, onclick*/
      537272322) {
        each_value_1 = ensure_array_like_dev(
          /*group*/
          ctx2[74].items
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(69:4) {#if group.items}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let svg;
  let rect;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      attr_dev(rect, "x", "4");
      attr_dev(rect, "y", "4");
      attr_dev(rect, "width", "16");
      attr_dev(rect, "height", "16");
      attr_dev(rect, "rx", "3");
      add_location(rect, file8, 93, 9, 2718);
      attr_dev(path, "class", "tick");
      attr_dev(path, "d", "M8 12l3 3l5.5 -5.5");
      add_location(path, file8, 94, 9, 2783);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke-width", "1.5");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", "icon icon-tabler icon-tabler-square-check");
      add_location(svg, file8, 92, 8, 2498);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, rect);
      append_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(92:7) {#if multiselect}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let div;
  let t0;
  let span;
  let raw_value = (
    /*item*/
    (ctx[77].highlightedName || /*item*/
    ctx[77].name) + ""
  );
  let t1;
  let div_aria_selected_value;
  let div_aria_checked_value;
  let mounted;
  let dispose;
  let if_block = (
    /*multiselect*/
    ctx[13] && create_if_block_4(ctx)
  );
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[44](
        /*item*/
        ctx[77],
        ...args
      )
    );
  }
  function mouseenter_handler() {
    return (
      /*mouseenter_handler*/
      ctx[45](
        /*item*/
        ctx[77]
      )
    );
  }
  function mouseup_handler(...args) {
    return (
      /*mouseup_handler*/
      ctx[46](
        /*item*/
        ctx[77],
        ...args
      )
    );
  }
  const block = {
    c: function create() {
      div = element2("div");
      if (if_block)
        if_block.c();
      t0 = space();
      span = element2("span");
      t1 = space();
      add_location(span, file8, 97, 7, 2868);
      attr_dev(div, "role", "option");
      attr_dev(div, "class", "combobox-list-item");
      attr_dev(div, "aria-selected", div_aria_selected_value = /*item*/
      ctx[77].idx === /*highlightIndex*/
      ctx[17]);
      attr_dev(div, "aria-checked", div_aria_checked_value = !!/*isChecked*/
      ctx[78]);
      toggle_class(div, "in-group", !!/*item*/
      ctx[77].group);
      toggle_class(
        div,
        "selected",
        /*item*/
        ctx[77].idx === /*highlightIndex*/
        ctx[17]
      );
      toggle_class(
        div,
        "checked",
        /*isChecked*/
        ctx[78]
      );
      add_location(div, file8, 73, 6, 1930);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t0);
      append_dev(div, span);
      span.innerHTML = raw_value;
      append_dev(div, t1);
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", click_handler, false, false, false, false),
          listen_dev(div, "mouseenter", mouseenter_handler, false, false, false, false),
          listen_dev(div, "mousedown", prevent_default(
            /*mousedown_handler*/
            ctx[41]
          ), false, true, false, false),
          listen_dev(div, "mouseup", mouseup_handler, false, false, false, false),
          listen_dev(div, "touchstart", touchStart, false, false, false, false),
          listen_dev(div, "touchend", touchEnd, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*multiselect*/
        ctx[13]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_4(ctx);
          if_block.c();
          if_block.m(div, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*groupedData*/
      262144 && raw_value !== (raw_value = /*item*/
      (ctx[77].highlightedName || /*item*/
      ctx[77].name) + ""))
        span.innerHTML = raw_value;
      ;
      if (dirty[0] & /*groupedData, highlightIndex*/
      393216 && div_aria_selected_value !== (div_aria_selected_value = /*item*/
      ctx[77].idx === /*highlightIndex*/
      ctx[17])) {
        attr_dev(div, "aria-selected", div_aria_selected_value);
      }
      if (dirty[0] & /*multiselect, selectedItems, groupedData*/
      270338 && div_aria_checked_value !== (div_aria_checked_value = !!/*isChecked*/
      ctx[78])) {
        attr_dev(div, "aria-checked", div_aria_checked_value);
      }
      if (dirty[0] & /*groupedData*/
      262144) {
        toggle_class(div, "in-group", !!/*item*/
        ctx[77].group);
      }
      if (dirty[0] & /*groupedData, highlightIndex*/
      393216) {
        toggle_class(
          div,
          "selected",
          /*item*/
          ctx[77].idx === /*highlightIndex*/
          ctx[17]
        );
      }
      if (dirty[0] & /*multiselect, selectedItems, groupedData*/
      270338) {
        toggle_class(
          div,
          "checked",
          /*isChecked*/
          ctx[78]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(70:5) {#each group.items as item}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let t;
  let if_block1_anchor;
  let if_block0 = (
    /*group*/
    ctx[74].name && create_if_block_5(ctx)
  );
  let if_block1 = (
    /*group*/
    ctx[74].items && create_if_block_3(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (
        /*group*/
        ctx2[74].name
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*group*/
        ctx2[74].items
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_3(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(65:3) {#each groupedData as group}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div0;
  let t1;
  let div1;
  let t2;
  let div1_aria_selected_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div0 = element2("div");
      div0.textContent = "Create new item";
      t1 = space();
      div1 = element2("div");
      t2 = text(
        /*newItemName*/
        ctx[19]
      );
      attr_dev(div0, "class", "combobox-list-header");
      add_location(div0, file8, 107, 2, 3086);
      attr_dev(div1, "role", "option");
      attr_dev(div1, "class", "combobox-list-item");
      attr_dev(div1, "aria-selected", div1_aria_selected_value = /*highlightIndex*/
      ctx[17] === /*filteredData*/
      ctx[14].length);
      toggle_class(
        div1,
        "selected",
        /*highlightIndex*/
        ctx[17] === /*filteredData*/
        ctx[14].length
      );
      add_location(div1, file8, 108, 3, 3145);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div0, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, div1, anchor);
      append_dev(div1, t2);
      if (!mounted) {
        dispose = listen_dev(
          div1,
          "click",
          /*click_handler_1*/
          ctx[48],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update2(ctx2, dirty) {
      if (dirty[0] & /*newItemName*/
      524288)
        set_data_dev(
          t2,
          /*newItemName*/
          ctx2[19]
        );
      if (dirty[0] & /*highlightIndex, filteredData*/
      147456 && div1_aria_selected_value !== (div1_aria_selected_value = /*highlightIndex*/
      ctx2[17] === /*filteredData*/
      ctx2[14].length)) {
        attr_dev(div1, "aria-selected", div1_aria_selected_value);
      }
      if (dirty[0] & /*highlightIndex, filteredData*/
      147456) {
        toggle_class(
          div1,
          "selected",
          /*highlightIndex*/
          ctx2[17] === /*filteredData*/
          ctx2[14].length
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div0);
        detach_dev(t1);
        detach_dev(div1);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(107:2) {#if shouldShowNewItem}",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let div2;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div1;
  let inputerror;
  let t2;
  let div0;
  let button;
  let t3;
  let input;
  let input_aria_controls_value;
  let input_aria_errormessage_value;
  let input_placeholder_value;
  let div2_class_value;
  let t4;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[8]
      ),
      disabled: (
        /*disabled*/
        ctx[5]
      ),
      for: (
        /*_id*/
        ctx[21]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[10]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[23]
      ),
      msg: (
        /*error*/
        ctx[9]
      )
    },
    $$inline: true
  });
  button = new Button_default({
    props: {
      link: true,
      icon: "dots",
      class: "combobox-button",
      tabindex: "-1"
    },
    $$inline: true
  });
  button.$on(
    "mousedown",
    /*onIconMouseDown*/
    ctx[31]
  );
  button.$on(
    "click",
    /*onIconClick*/
    ctx[32]
  );
  let input_levels = [
    { type: "text" },
    { role: "combobox" },
    { class: "prevent-scrolling-on-focus" },
    { "aria-autocomplete": "list" },
    {
      "aria-controls": input_aria_controls_value = "combobox-list-" + /*gui*/
      ctx[22]
    },
    { "aria-expanded": (
      /*opened*/
      ctx[16]
    ) },
    { "aria-invalid": (
      /*error*/
      ctx[9]
    ) },
    {
      "aria-errormessage": input_aria_errormessage_value = /*error*/
      ctx[9] ? (
        /*errorMessageId*/
        ctx[23]
      ) : void 0
    },
    { "aria-required": (
      /*required*/
      ctx[6]
    ) },
    { autocomplete: "off" },
    { value: (
      /*inputValue*/
      ctx[15]
    ) },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    {
      placeholder: input_placeholder_value = /*multiselect*/
      ctx[13] && /*opened*/
      ctx[16] ? "Type to filter..." : (
        /*placeholder*/
        ctx[12]
      )
    },
    { id: (
      /*_id*/
      ctx[21]
    ) },
    /*$$restProps*/
    ctx[33]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block = (
    /*opened*/
    ctx[16] && create_if_block6(ctx)
  );
  const block = {
    c: function create() {
      div2 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div1 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      div0 = element2("div");
      create_component(button.$$.fragment);
      t3 = space();
      input = element2("input");
      t4 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      set_attributes(input, input_data);
      add_location(input, file8, 23, 3, 543);
      attr_dev(div0, "class", "input-row");
      attr_dev(
        div0,
        "title",
        /*inputValue*/
        ctx[15]
      );
      add_location(div0, file8, 14, 2, 344);
      attr_dev(div1, "class", "input-inner");
      toggle_class(
        div1,
        "disabled",
        /*disabled*/
        ctx[5]
      );
      add_location(div1, file8, 11, 1, 247);
      attr_dev(div2, "class", div2_class_value = "input combobox " + /*className*/
      ctx[4]);
      toggle_class(
        div2,
        "open",
        /*opened*/
        ctx[16]
      );
      toggle_class(
        div2,
        "has-error",
        /*error*/
        ctx[9]
      );
      toggle_class(div2, "label-on-the-left", !!/*labelOnTheLeft*/
      ctx[11]);
      toggle_class(
        div2,
        "multiselect",
        /*multiselect*/
        ctx[13]
      );
      add_location(div2, file8, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      mount_component(label_1, div2, null);
      append_dev(div2, t0);
      mount_component(info_1, div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      mount_component(inputerror, div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      mount_component(button, div0, null);
      append_dev(div0, t3);
      append_dev(div0, input);
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      if (input.autofocus)
        input.focus();
      ctx[42](input);
      ctx[43](div2);
      insert_dev(target, t4, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*oninput*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*onfocus*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mousedown",
            /*open*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "click",
            /*open*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*onblur*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*onkeydown*/
            ctx[30],
            true,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, dirty) {
      const label_1_changes = {};
      if (dirty[0] & /*label*/
      256)
        label_1_changes.label = /*label*/
        ctx2[8];
      if (dirty[0] & /*disabled*/
      32)
        label_1_changes.disabled = /*disabled*/
        ctx2[5];
      if (dirty[0] & /*_id*/
      2097152)
        label_1_changes.for = /*_id*/
        ctx2[21];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty[0] & /*info*/
      1024)
        info_1_changes.msg = /*info*/
        ctx2[10];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty[0] & /*error*/
      512)
        inputerror_changes.msg = /*error*/
        ctx2[9];
      inputerror.$set(inputerror_changes);
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        { role: "combobox" },
        { class: "prevent-scrolling-on-focus" },
        { "aria-autocomplete": "list" },
        {
          "aria-controls": input_aria_controls_value
        },
        (!current || dirty[0] & /*opened*/
        65536) && { "aria-expanded": (
          /*opened*/
          ctx2[16]
        ) },
        (!current || dirty[0] & /*error*/
        512) && { "aria-invalid": (
          /*error*/
          ctx2[9]
        ) },
        (!current || dirty[0] & /*error*/
        512 && input_aria_errormessage_value !== (input_aria_errormessage_value = /*error*/
        ctx2[9] ? (
          /*errorMessageId*/
          ctx2[23]
        ) : void 0)) && {
          "aria-errormessage": input_aria_errormessage_value
        },
        (!current || dirty[0] & /*required*/
        64) && { "aria-required": (
          /*required*/
          ctx2[6]
        ) },
        { autocomplete: "off" },
        (!current || dirty[0] & /*inputValue*/
        32768 && input.value !== /*inputValue*/
        ctx2[15]) && { value: (
          /*inputValue*/
          ctx2[15]
        ) },
        (!current || dirty[0] & /*disabled*/
        32) && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        (!current || dirty[0] & /*multiselect, opened, placeholder*/
        77824 && input_placeholder_value !== (input_placeholder_value = /*multiselect*/
        ctx2[13] && /*opened*/
        ctx2[16] ? "Type to filter..." : (
          /*placeholder*/
          ctx2[12]
        ))) && { placeholder: input_placeholder_value },
        (!current || dirty[0] & /*_id*/
        2097152) && { id: (
          /*_id*/
          ctx2[21]
        ) },
        dirty[1] & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[33]
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      if (!current || dirty[0] & /*inputValue*/
      32768) {
        attr_dev(
          div0,
          "title",
          /*inputValue*/
          ctx2[15]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      32) {
        toggle_class(
          div1,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*className*/
      16 && div2_class_value !== (div2_class_value = "input combobox " + /*className*/
      ctx2[4])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*className, opened*/
      65552) {
        toggle_class(
          div2,
          "open",
          /*opened*/
          ctx2[16]
        );
      }
      if (!current || dirty[0] & /*className, error*/
      528) {
        toggle_class(
          div2,
          "has-error",
          /*error*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*className, labelOnTheLeft*/
      2064) {
        toggle_class(div2, "label-on-the-left", !!/*labelOnTheLeft*/
        ctx2[11]);
      }
      if (!current || dirty[0] & /*className, multiselect*/
      8208) {
        toggle_class(
          div2,
          "multiselect",
          /*multiselect*/
          ctx2[13]
        );
      }
      if (
        /*opened*/
        ctx2[16]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
        detach_dev(t4);
        detach_dev(if_block_anchor);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      destroy_component(button);
      ctx[42](null);
      ctx[43](null);
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function touchStart(e) {
  const el = e.target.closest(".combobox-list-item");
  el.classList.add("blinking");
}
function touchEnd(e) {
  const el = e.target.closest(".combobox-list-item");
  requestAnimationFrame(() => el.classList.remove("blinking"));
}
function instance13($$self2, $$props2, $$invalidate2) {
  let _id2;
  let valueMatchesItem;
  let shouldShowNewItem;
  const omit_props_names2 = [
    "class",
    "disabled",
    "required",
    "id",
    "items",
    "value",
    "allowNew",
    "clearOnEsc",
    "showOnFocus",
    "hideOnResize",
    "label",
    "error",
    "info",
    "labelOnTheLeft",
    "placeholder",
    "multiselect",
    "selectedItems",
    "element",
    "inputElement",
    "listElement"
  ];
  let $$restProps2 = compute_rest_props($$props2, omit_props_names2);
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Combobox", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { required: required2 = void 0 } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { items = [] } = $$props2;
  let { value: value2 = null } = $$props2;
  let { allowNew = void 0 } = $$props2;
  let { clearOnEsc = void 0 } = $$props2;
  let { showOnFocus = void 0 } = $$props2;
  let { hideOnResize = void 0 } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = void 0 } = $$props2;
  let { placeholder = void 0 } = $$props2;
  let { multiselect = void 0 } = $$props2;
  let { selectedItems = [] } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { inputElement: inputElement2 = void 0 } = $$props2;
  let { listElement = void 0 } = $$props2;
  const dispatch3 = createEventDispatcher();
  const gui = guid();
  const errorMessageId2 = guid();
  let inputValue = getInputValue(value2, multiselect);
  let originalItems = null;
  let opened = false;
  let hasEdited = false;
  let highlightIndex = 0;
  let filteredData = [], groupedData = [];
  let originalText = "";
  let hasSetValue = true;
  let isSelecting = false;
  let isHiding = false;
  let newItemName = "";
  onDestroy(() => {
    if (listElement)
      listElement.remove();
  });
  afterUpdate(() => {
    if (!opened && items.length) {
      originalItems = structuredClone(items);
      if (items.length && typeof items[0] === "string") {
        $$invalidate2(34, items = items.map((item) => ({ name: item })));
      }
      filter();
      setInitialValue();
    }
  });
  function filter() {
    let filtered = structuredClone(items);
    if (hasEdited && inputElement2.value) {
      const q = inputElement2.value.toLowerCase().trim();
      filtered = filtered.filter((item) => fuzzy(item.name, q)).map((item) => {
        item.highlightedName = emphasize(item.name, q);
        item.score = 1;
        if (item.name.toLowerCase().includes(q))
          item.score = 2;
        if (item.name.includes(q))
          item.score = 3;
        if (item.name.toLowerCase() === q)
          item.score = 4;
        if (item.name === q)
          item.score = 5;
        return item;
      }).sort((a, b) => b.score - a.score);
    }
    $$invalidate2(18, groupedData = groupData(filtered));
    const filteredAndSorted = [];
    let idx = 0;
    groupedData.forEach((g) => {
      g.items.forEach((i) => {
        i.idx = idx++;
        filteredAndSorted.push(i);
      });
    });
    $$invalidate2(14, filteredData = filteredAndSorted);
    $$invalidate2(17, highlightIndex = 0);
    scrollToSelectedItem(listElement);
    alignDropdown(listElement, inputElement2);
  }
  function open(e) {
    const type = e?.type;
    const clickOnMobile = isMobile() && type === "click";
    const mousedownOnDesktop = !isMobile() && type === "mousedown";
    const typing = type === "typing";
    const navigating = type === "navigating";
    if (!clickOnMobile && !mousedownOnDesktop && !typing && !navigating)
      return;
    if (mousedownOnDesktop && opened)
      return close();
    if (opened)
      return;
    $$invalidate2(16, opened = true);
    hasEdited = false;
    if (multiselect) {
      if (!typing) {
        $$invalidate2(0, inputElement2.value = "", inputElement2);
        $$invalidate2(15, inputValue = "");
      }
      filter();
    }
    requestAnimationFrame(() => {
      if (listElement && listElement.parentElement !== document.body) {
        document.body.appendChild(listElement);
      }
      addEventListeners();
      alignDropdown(listElement, inputElement2, e);
    });
  }
  function close() {
    if (!opened)
      return;
    removeEventListeners();
    $$invalidate2(16, opened = false);
    isSelecting = false;
    const empty2 = !inputElement2.value;
    const notInList = !multiselect && !allowNew && inputElement2.value !== inputValue;
    const notInSelected = multiselect && inputElement2.value !== inputValue;
    if (empty2 || notInList || notInSelected)
      revert();
  }
  function selectSingle(item) {
    if (multiselect || hasSetValue)
      return;
    const oldValue = structuredClone(value2);
    if (!item) {
      if (filteredData[highlightIndex])
        item = filteredData[highlightIndex];
      else if (allowNew)
        item = { name: inputElement2.value };
      else if (value2 && value2.name && inputElement2.value !== value2.name)
        $$invalidate2(15, inputValue = value2.name);
    }
    if (item) {
      $$invalidate2(35, value2 = findValueInSource(item, originalItems) || item);
      if (value2 && value2.name && inputElement2.value !== value2.name)
        $$invalidate2(15, inputValue = item.name);
    }
    hasSetValue = true;
    if (hasValueChanged(oldValue, value2))
      dispatch3("change", { value: value2, oldValue });
    requestAnimationFrame(() => {
      inputElement2.select();
      close();
    });
  }
  function selectMultiselect(item) {
    const oldValue = structuredClone(value2);
    $$invalidate2(1, selectedItems = selectedItems || []);
    const itemId = item.id || item.name || item;
    const itemIndex = selectedItems.findIndex((i) => (i?.id || i?.name || i) === itemId);
    if (itemIndex === -1)
      selectedItems.push(item);
    else
      selectedItems.splice(itemIndex, 1);
    $$invalidate2(35, value2 = findValueInSource(selectedItems, originalItems) || []);
    if (hasValueChanged(oldValue, value2, true))
      dispatch3("change", { value: value2, oldValue });
    requestAnimationFrame(() => inputElement2.select());
  }
  function setInitialValue() {
    if (!filteredData || !filteredData.length)
      return;
    if (multiselect) {
      if (value2 === null || value2 === void 0)
        $$invalidate2(35, value2 = []);
      if (!Array.isArray(value2))
        $$invalidate2(35, value2 = [value2]);
      const selectedIds = value2.map((i) => i?.id || i?.name || i);
      $$invalidate2(1, selectedItems = originalItems.filter((i) => selectedIds.includes(i.id || i.name || i)));
      if (opened)
        $$invalidate2(15, inputValue = "");
      else
        $$invalidate2(15, inputValue = getInputValue(selectedItems, multiselect));
    } else {
      const itemId = value2?.id || value2?.name || value2;
      if (itemId) {
        const item = filteredData.find((i) => (i.id || i.name || i) === itemId);
        if (item) {
          $$invalidate2(17, highlightIndex = item.idx);
          $$invalidate2(0, inputElement2.value = filteredData[highlightIndex].name, inputElement2);
        }
        scrollToSelectedItem(listElement);
      } else
        $$invalidate2(0, inputElement2.value = "", inputElement2);
    }
  }
  function up() {
    if (!opened)
      return open({ type: "navigating" });
    let idx = highlightIndex - 1;
    while (idx > 0 && !filteredData[idx])
      idx -= 1;
    if (idx !== highlightIndex && filteredData[idx]) {
      $$invalidate2(17, highlightIndex = filteredData[idx].idx);
      scrollToSelectedItem(listElement);
    }
  }
  function down() {
    if (!opened)
      return open({ type: "navigating" });
    let idx = highlightIndex + 1;
    while (idx < filteredData.length - 1 && !filteredData[idx])
      idx += 1;
    let item = filteredData[idx];
    if (shouldShowNewItem && idx === filteredData.length) {
      item = { idx: filteredData.length };
    }
    if (idx !== highlightIndex && item) {
      $$invalidate2(17, highlightIndex = item.idx);
      scrollToSelectedItem(listElement);
    }
  }
  function revert() {
    if (multiselect) {
      $$invalidate2(0, inputElement2.value = $$invalidate2(15, inputValue = getInputValue(selectedItems, multiselect)), inputElement2);
    } else if (originalText && originalText !== inputElement2.value)
      $$invalidate2(0, inputElement2.value = originalText, inputElement2);
    else if (value2 && value2.name)
      $$invalidate2(0, inputElement2.value = value2.name, inputElement2);
    else
      $$invalidate2(0, inputElement2.value = "", inputElement2);
  }
  function clear() {
    $$invalidate2(0, inputElement2.value = "", inputElement2);
    filter();
    requestAnimationFrame(() => inputElement2.select());
  }
  function onfocus() {
    originalText = inputElement2.value;
    if (showOnFocus)
      open({ type: "navigating" });
  }
  function oninput() {
    open({ type: "typing" });
    requestAnimationFrame(filter);
    hasEdited = true;
    hasSetValue = false;
    $$invalidate2(19, newItemName = inputElement2.value);
  }
  function onblur() {
    if (!isSelecting)
      close();
  }
  function onListMouseDown() {
    isSelecting = true;
  }
  function onclick4(item, e) {
    if (isMobile() && e?.type !== "click")
      return e.preventDefault();
    if (!isMobile() && e?.type === "click")
      return;
    if (multiselect)
      selectMultiselect(item);
    else {
      hasSetValue = false;
      selectSingle(item);
    }
  }
  function onkeydown2(e) {
    if (e.key === "Tab")
      return close();
    const fnmap = {
      ArrowDown: down,
      ArrowUp: up,
      Escape: onEsc,
      " ": onSpace,
      Enter: onEnter
    };
    if (typeof fnmap[e.key] === "function") {
      e.preventDefault();
      fnmap[e.key](e);
    }
  }
  function onEnter() {
    if (!opened)
      return open({ type: "navigating" });
    if (multiselect) {
      close();
      inputElement2.select();
    } else {
      hasSetValue = false;
      selectSingle();
    }
  }
  function onSpace(e) {
    if (!multiselect || !opened)
      return;
    const item = filteredData[highlightIndex];
    onclick4(item, e);
  }
  function onEsc(e) {
    if (clearOnEsc && inputElement2.value) {
      e.stopPropagation();
      return clear();
    }
    if (opened) {
      e.stopPropagation();
      revert();
      inputElement2.select();
      return close();
    }
    dispatch3("keydown", e);
  }
  function onIconMouseDown() {
    isHiding = opened;
  }
  function onIconClick() {
    if (isHiding)
      close();
    else
      open({ type: "navigating" });
    isHiding = false;
    if (inputElement2)
      inputElement2.select();
  }
  function onResize() {
    if (!opened)
      return;
    if (hideOnResize)
      return;
    inputElement2.blur();
    return close();
  }
  function onViewportResize() {
    if (!opened)
      return;
    alignDropdown(listElement, inputElement2);
  }
  function onDocumentClick(e) {
    const notEl = element3 && !element3.contains(e.target);
    const notList = listElement && !listElement.contains(e.target);
    if (open && notEl && notList)
      close();
  }
  function addEventListeners() {
    window.addEventListener("resize", onResize);
    document.addEventListener("click", onDocumentClick, true);
    window.visualViewport.addEventListener("resize", onViewportResize);
  }
  function removeEventListeners() {
    window.removeEventListener("resize", onResize);
    document.removeEventListener("click", onDocumentClick, true);
    window.visualViewport.removeEventListener("resize", onViewportResize);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function input_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(0, inputElement2);
    });
  }
  function div2_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(2, element3);
    });
  }
  const click_handler = (item, e) => onclick4(item, e);
  const mouseenter_handler = (item) => $$invalidate2(17, highlightIndex = item.idx);
  const mouseup_handler = (item, e) => onclick4(item, e);
  const func = (item, i) => (i.id || i.name || i) === (item.id || item.name || item);
  const click_handler_1 = () => onclick4({
    name: newItemName,
    idx: filteredData.length
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      listElement = $$value;
      $$invalidate2(3, listElement);
    });
  }
  $$self2.$$set = ($$new_props) => {
    $$props2 = assign(assign({}, $$props2), exclude_internal_props($$new_props));
    $$invalidate2(33, $$restProps2 = compute_rest_props($$props2, omit_props_names2));
    if ("class" in $$new_props)
      $$invalidate2(4, className2 = $$new_props.class);
    if ("disabled" in $$new_props)
      $$invalidate2(5, disabled2 = $$new_props.disabled);
    if ("required" in $$new_props)
      $$invalidate2(6, required2 = $$new_props.required);
    if ("id" in $$new_props)
      $$invalidate2(36, id2 = $$new_props.id);
    if ("items" in $$new_props)
      $$invalidate2(34, items = $$new_props.items);
    if ("value" in $$new_props)
      $$invalidate2(35, value2 = $$new_props.value);
    if ("allowNew" in $$new_props)
      $$invalidate2(7, allowNew = $$new_props.allowNew);
    if ("clearOnEsc" in $$new_props)
      $$invalidate2(37, clearOnEsc = $$new_props.clearOnEsc);
    if ("showOnFocus" in $$new_props)
      $$invalidate2(38, showOnFocus = $$new_props.showOnFocus);
    if ("hideOnResize" in $$new_props)
      $$invalidate2(39, hideOnResize = $$new_props.hideOnResize);
    if ("label" in $$new_props)
      $$invalidate2(8, label2 = $$new_props.label);
    if ("error" in $$new_props)
      $$invalidate2(9, error2 = $$new_props.error);
    if ("info" in $$new_props)
      $$invalidate2(10, info2 = $$new_props.info);
    if ("labelOnTheLeft" in $$new_props)
      $$invalidate2(11, labelOnTheLeft2 = $$new_props.labelOnTheLeft);
    if ("placeholder" in $$new_props)
      $$invalidate2(12, placeholder = $$new_props.placeholder);
    if ("multiselect" in $$new_props)
      $$invalidate2(13, multiselect = $$new_props.multiselect);
    if ("selectedItems" in $$new_props)
      $$invalidate2(1, selectedItems = $$new_props.selectedItems);
    if ("element" in $$new_props)
      $$invalidate2(2, element3 = $$new_props.element);
    if ("inputElement" in $$new_props)
      $$invalidate2(0, inputElement2 = $$new_props.inputElement);
    if ("listElement" in $$new_props)
      $$invalidate2(3, listElement = $$new_props.listElement);
  };
  $$self2.$capture_state = () => ({
    afterUpdate,
    createEventDispatcher,
    onDestroy,
    emphasize,
    scrollToSelectedItem,
    groupData,
    findValueInSource,
    getInputValue,
    alignDropdown,
    hasValueChanged,
    fuzzy,
    guid,
    isMobile,
    Button: Button_default,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    disabled: disabled2,
    required: required2,
    id: id2,
    items,
    value: value2,
    allowNew,
    clearOnEsc,
    showOnFocus,
    hideOnResize,
    label: label2,
    error: error2,
    info: info2,
    labelOnTheLeft: labelOnTheLeft2,
    placeholder,
    multiselect,
    selectedItems,
    element: element3,
    inputElement: inputElement2,
    listElement,
    dispatch: dispatch3,
    gui,
    errorMessageId: errorMessageId2,
    inputValue,
    originalItems,
    opened,
    hasEdited,
    highlightIndex,
    filteredData,
    groupedData,
    originalText,
    hasSetValue,
    isSelecting,
    isHiding,
    newItemName,
    filter,
    open,
    close,
    selectSingle,
    selectMultiselect,
    setInitialValue,
    up,
    down,
    revert,
    clear,
    onfocus,
    oninput,
    onblur,
    onListMouseDown,
    touchStart,
    touchEnd,
    onclick: onclick4,
    onkeydown: onkeydown2,
    onEnter,
    onSpace,
    onEsc,
    onIconMouseDown,
    onIconClick,
    onResize,
    onViewportResize,
    onDocumentClick,
    addEventListeners,
    removeEventListeners,
    shouldShowNewItem,
    valueMatchesItem,
    _id: _id2
  });
  $$self2.$inject_state = ($$new_props) => {
    if ("className" in $$props2)
      $$invalidate2(4, className2 = $$new_props.className);
    if ("disabled" in $$props2)
      $$invalidate2(5, disabled2 = $$new_props.disabled);
    if ("required" in $$props2)
      $$invalidate2(6, required2 = $$new_props.required);
    if ("id" in $$props2)
      $$invalidate2(36, id2 = $$new_props.id);
    if ("items" in $$props2)
      $$invalidate2(34, items = $$new_props.items);
    if ("value" in $$props2)
      $$invalidate2(35, value2 = $$new_props.value);
    if ("allowNew" in $$props2)
      $$invalidate2(7, allowNew = $$new_props.allowNew);
    if ("clearOnEsc" in $$props2)
      $$invalidate2(37, clearOnEsc = $$new_props.clearOnEsc);
    if ("showOnFocus" in $$props2)
      $$invalidate2(38, showOnFocus = $$new_props.showOnFocus);
    if ("hideOnResize" in $$props2)
      $$invalidate2(39, hideOnResize = $$new_props.hideOnResize);
    if ("label" in $$props2)
      $$invalidate2(8, label2 = $$new_props.label);
    if ("error" in $$props2)
      $$invalidate2(9, error2 = $$new_props.error);
    if ("info" in $$props2)
      $$invalidate2(10, info2 = $$new_props.info);
    if ("labelOnTheLeft" in $$props2)
      $$invalidate2(11, labelOnTheLeft2 = $$new_props.labelOnTheLeft);
    if ("placeholder" in $$props2)
      $$invalidate2(12, placeholder = $$new_props.placeholder);
    if ("multiselect" in $$props2)
      $$invalidate2(13, multiselect = $$new_props.multiselect);
    if ("selectedItems" in $$props2)
      $$invalidate2(1, selectedItems = $$new_props.selectedItems);
    if ("element" in $$props2)
      $$invalidate2(2, element3 = $$new_props.element);
    if ("inputElement" in $$props2)
      $$invalidate2(0, inputElement2 = $$new_props.inputElement);
    if ("listElement" in $$props2)
      $$invalidate2(3, listElement = $$new_props.listElement);
    if ("inputValue" in $$props2)
      $$invalidate2(15, inputValue = $$new_props.inputValue);
    if ("originalItems" in $$props2)
      originalItems = $$new_props.originalItems;
    if ("opened" in $$props2)
      $$invalidate2(16, opened = $$new_props.opened);
    if ("hasEdited" in $$props2)
      hasEdited = $$new_props.hasEdited;
    if ("highlightIndex" in $$props2)
      $$invalidate2(17, highlightIndex = $$new_props.highlightIndex);
    if ("filteredData" in $$props2)
      $$invalidate2(14, filteredData = $$new_props.filteredData);
    if ("groupedData" in $$props2)
      $$invalidate2(18, groupedData = $$new_props.groupedData);
    if ("originalText" in $$props2)
      originalText = $$new_props.originalText;
    if ("hasSetValue" in $$props2)
      hasSetValue = $$new_props.hasSetValue;
    if ("isSelecting" in $$props2)
      isSelecting = $$new_props.isSelecting;
    if ("isHiding" in $$props2)
      isHiding = $$new_props.isHiding;
    if ("newItemName" in $$props2)
      $$invalidate2(19, newItemName = $$new_props.newItemName);
    if ("shouldShowNewItem" in $$props2)
      $$invalidate2(20, shouldShowNewItem = $$new_props.shouldShowNewItem);
    if ("valueMatchesItem" in $$props2)
      $$invalidate2(40, valueMatchesItem = $$new_props.valueMatchesItem);
    if ("_id" in $$props2)
      $$invalidate2(21, _id2 = $$new_props._id);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty[1] & /*id*/
    32) {
      $:
        $$invalidate2(21, _id2 = id2 || name || guid());
    }
    if ($$self2.$$.dirty[0] & /*filteredData, inputElement*/
    16385) {
      $:
        $$invalidate2(40, valueMatchesItem = filteredData?.length && filteredData.find((i) => i.name === inputElement2.value));
    }
    if ($$self2.$$.dirty[0] & /*allowNew, inputElement*/
    129 | $$self2.$$.dirty[1] & /*valueMatchesItem*/
    512) {
      $:
        $$invalidate2(20, shouldShowNewItem = allowNew && inputElement2?.value && !valueMatchesItem);
    }
  };
  return [
    inputElement2,
    selectedItems,
    element3,
    listElement,
    className2,
    disabled2,
    required2,
    allowNew,
    label2,
    error2,
    info2,
    labelOnTheLeft2,
    placeholder,
    multiselect,
    filteredData,
    inputValue,
    opened,
    highlightIndex,
    groupedData,
    newItemName,
    shouldShowNewItem,
    _id2,
    gui,
    errorMessageId2,
    open,
    onfocus,
    oninput,
    onblur,
    onListMouseDown,
    onclick4,
    onkeydown2,
    onIconMouseDown,
    onIconClick,
    $$restProps2,
    items,
    value2,
    id2,
    clearOnEsc,
    showOnFocus,
    hideOnResize,
    valueMatchesItem,
    mousedown_handler,
    input_binding2,
    div2_binding2,
    click_handler,
    mouseenter_handler,
    mouseup_handler,
    func,
    click_handler_1,
    div_binding
  ];
}
var Combobox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance13,
      create_fragment13,
      safe_not_equal,
      {
        class: 4,
        disabled: 5,
        required: 6,
        id: 36,
        items: 34,
        value: 35,
        allowNew: 7,
        clearOnEsc: 37,
        showOnFocus: 38,
        hideOnResize: 39,
        label: 8,
        error: 9,
        info: 10,
        labelOnTheLeft: 11,
        placeholder: 12,
        multiselect: 13,
        selectedItems: 1,
        element: 2,
        inputElement: 0,
        listElement: 3
      },
      null,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Combobox",
      options,
      id: create_fragment13.name
    });
  }
  get class() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowNew() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowNew(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearOnEsc() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearOnEsc(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showOnFocus() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showOnFocus(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideOnResize() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideOnResize(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiselect() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiselect(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedItems() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedItems(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listElement() {
    throw new Error("<Combobox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listElement(value2) {
    throw new Error("<Combobox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Combobox_default = Combobox;

// src/input/button-toggle/ButtonToggle.svelte
var file9 = "src/input/button-toggle/ButtonToggle.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function create_if_block7(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: { name: (
      /*item*/
      ctx[20].icon
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & /*_items*/
      2048)
        icon_changes.name = /*item*/
        ctx2[20].icon;
      icon.$set(icon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(29:7) {#if item.icon}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let label_1;
  let t0;
  let t1_value = (
    /*item*/
    (ctx[20].name || "") + ""
  );
  let t1;
  let t2;
  let input;
  let input_checked_value;
  let input_value_value;
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*item*/
    ctx[20].icon && create_if_block7(ctx)
  );
  function change_handler(...args) {
    return (
      /*change_handler*/
      ctx[17](
        /*item*/
        ctx[20],
        ...args
      )
    );
  }
  const block = {
    c: function create() {
      label_1 = element2("label");
      if (if_block)
        if_block.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      input = element2("input");
      t3 = space();
      input.disabled = /*disabled*/
      ctx[3];
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[5]
      );
      attr_dev(input, "type", "radio");
      input.checked = input_checked_value = /*item*/
      ctx[20].value === /*value*/
      ctx[0];
      input.value = input_value_value = /*item*/
      ctx[20].value;
      add_location(input, file9, 32, 7, 915);
      attr_dev(
        label_1,
        "disabled",
        /*disabled*/
        ctx[3]
      );
      attr_dev(label_1, "class", "button button-normal");
      toggle_class(
        label_1,
        "button-has-text",
        /*item*/
        ctx[20].name
      );
      add_location(label_1, file9, 23, 5, 683);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label_1, anchor);
      if (if_block)
        if_block.m(label_1, null);
      append_dev(label_1, t0);
      append_dev(label_1, t1);
      append_dev(label_1, t2);
      append_dev(label_1, input);
      append_dev(label_1, t3);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", change_handler, false, false, false, false),
          listen_dev(label_1, "click", onclick, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*item*/
        ctx[20].icon
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*_items*/
          2048) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(label_1, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if ((!current || dirty & /*_items*/
      2048) && t1_value !== (t1_value = /*item*/
      (ctx[20].name || "") + ""))
        set_data_dev(t1, t1_value);
      if (!current || dirty & /*disabled*/
      8) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx[3]
        );
      }
      if (!current || dirty & /*name*/
      32) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx[5]
        );
      }
      if (!current || dirty & /*_items, value*/
      2049 && input_checked_value !== (input_checked_value = /*item*/
      ctx[20].value === /*value*/
      ctx[0])) {
        prop_dev(input, "checked", input_checked_value);
      }
      if (!current || dirty & /*_items*/
      2048 && input_value_value !== (input_value_value = /*item*/
      ctx[20].value)) {
        prop_dev(input, "value", input_value_value);
      }
      if (!current || dirty & /*disabled*/
      8) {
        attr_dev(
          label_1,
          "disabled",
          /*disabled*/
          ctx[3]
        );
      }
      if (!current || dirty & /*_items*/
      2048) {
        toggle_class(
          label_1,
          "button-has-text",
          /*item*/
          ctx[20].name
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label_1);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(20:4) {#each _items as item}",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let div3;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div2;
  let inputerror;
  let t2;
  let div1;
  let div0;
  let div3_class_value;
  let div3_aria_errormessage_value;
  let current;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[7]
      ),
      disabled: (
        /*disabled*/
        ctx[3]
      ),
      for: (
        /*_id*/
        ctx[12]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[9]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[13]
      ),
      msg: (
        /*error*/
        ctx[8]
      )
    },
    $$inline: true
  });
  let each_value = ensure_array_like_dev(
    /*_items*/
    ctx[11]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div3 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div2 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      div1 = element2("div");
      div0 = element2("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div0, "class", "input-row");
      attr_dev(
        div0,
        "id",
        /*_id*/
        ctx[12]
      );
      add_location(div0, file9, 18, 3, 498);
      attr_dev(div1, "class", "input-scroller");
      add_location(div1, file9, 17, 2, 466);
      attr_dev(div2, "class", "input-inner");
      toggle_class(
        div2,
        "disabled",
        /*disabled*/
        ctx[3]
      );
      add_location(div2, file9, 14, 1, 369);
      attr_dev(div3, "class", div3_class_value = "input button-toggle " + /*className*/
      ctx[2]);
      attr_dev(div3, "role", "radiogroup");
      attr_dev(
        div3,
        "aria-invalid",
        /*error*/
        ctx[8]
      );
      attr_dev(div3, "aria-errormessage", div3_aria_errormessage_value = /*error*/
      ctx[8] ? (
        /*errorMessageId*/
        ctx[13]
      ) : void 0);
      attr_dev(
        div3,
        "title",
        /*title*/
        ctx[6]
      );
      toggle_class(
        div3,
        "round",
        /*round*/
        ctx[4]
      );
      toggle_class(
        div3,
        "has-error",
        /*error*/
        ctx[8]
      );
      toggle_class(
        div3,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[10] === true || /*labelOnTheLeft*/
        ctx[10] === "true"
      );
      add_location(div3, file9, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      mount_component(label_1, div3, null);
      append_dev(div3, t0);
      mount_component(info_1, div3, null);
      append_dev(div3, t1);
      append_dev(div3, div2);
      mount_component(inputerror, div2, null);
      append_dev(div2, t2);
      append_dev(div2, div1);
      append_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      ctx[18](div3);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const label_1_changes = {};
      if (dirty & /*label*/
      128)
        label_1_changes.label = /*label*/
        ctx2[7];
      if (dirty & /*disabled*/
      8)
        label_1_changes.disabled = /*disabled*/
        ctx2[3];
      if (dirty & /*_id*/
      4096)
        label_1_changes.for = /*_id*/
        ctx2[12];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty & /*info*/
      512)
        info_1_changes.msg = /*info*/
        ctx2[9];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty & /*error*/
      256)
        inputerror_changes.msg = /*error*/
        ctx2[8];
      inputerror.$set(inputerror_changes);
      if (dirty & /*disabled, _items, onclick, name, value, onchange*/
      18473) {
        each_value = ensure_array_like_dev(
          /*_items*/
          ctx2[11]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*_id*/
      4096) {
        attr_dev(
          div0,
          "id",
          /*_id*/
          ctx2[12]
        );
      }
      if (!current || dirty & /*disabled*/
      8) {
        toggle_class(
          div2,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*className*/
      4 && div3_class_value !== (div3_class_value = "input button-toggle " + /*className*/
      ctx2[2])) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (!current || dirty & /*error*/
      256) {
        attr_dev(
          div3,
          "aria-invalid",
          /*error*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*error*/
      256 && div3_aria_errormessage_value !== (div3_aria_errormessage_value = /*error*/
      ctx2[8] ? (
        /*errorMessageId*/
        ctx2[13]
      ) : void 0)) {
        attr_dev(div3, "aria-errormessage", div3_aria_errormessage_value);
      }
      if (!current || dirty & /*title*/
      64) {
        attr_dev(
          div3,
          "title",
          /*title*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*className, round*/
      20) {
        toggle_class(
          div3,
          "round",
          /*round*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*className, error*/
      260) {
        toggle_class(
          div3,
          "has-error",
          /*error*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*className, labelOnTheLeft*/
      1028) {
        toggle_class(
          div3,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[10] === true || /*labelOnTheLeft*/
          ctx2[10] === "true"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      destroy_each(each_blocks, detaching);
      ctx[18](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function onclick(e) {
  const inputElement2 = e.target && e.target.querySelector("input");
  if (!inputElement2)
    return;
  inputElement2.click();
  inputElement2.focus();
}
function instance14($$self2, $$props2, $$invalidate2) {
  let _id2;
  let _items;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("ButtonToggle", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { disabled: disabled2 = void 0 } = $$props2;
  let { round = void 0 } = $$props2;
  let { items = "" } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { name: name2 = guid() } = $$props2;
  let { value: value2 = "" } = $$props2;
  let { title = void 0 } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  const errorMessageId2 = guid();
  const dispatch3 = createEventDispatcher();
  function onchange5(e, button) {
    if (button.value === value2)
      return;
    const btnEl = e.target && e.target.closest("label");
    if (btnEl)
      btnEl.scrollIntoView({ block: "nearest", inline: "nearest" });
    $$invalidate2(0, value2 = button.value);
    dispatch3("change", value2);
  }
  const writable_props = [
    "class",
    "disabled",
    "round",
    "items",
    "id",
    "name",
    "value",
    "title",
    "label",
    "error",
    "info",
    "labelOnTheLeft",
    "element"
  ];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ButtonToggle> was created with unknown prop '${key}'`);
  });
  const change_handler = (item, e) => onchange5(e, item);
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(2, className2 = $$props3.class);
    if ("disabled" in $$props3)
      $$invalidate2(3, disabled2 = $$props3.disabled);
    if ("round" in $$props3)
      $$invalidate2(4, round = $$props3.round);
    if ("items" in $$props3)
      $$invalidate2(15, items = $$props3.items);
    if ("id" in $$props3)
      $$invalidate2(16, id2 = $$props3.id);
    if ("name" in $$props3)
      $$invalidate2(5, name2 = $$props3.name);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("title" in $$props3)
      $$invalidate2(6, title = $$props3.title);
    if ("label" in $$props3)
      $$invalidate2(7, label2 = $$props3.label);
    if ("error" in $$props3)
      $$invalidate2(8, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(9, info2 = $$props3.info);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(10, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
  };
  $$self2.$capture_state = () => ({
    createEventDispatcher,
    guid,
    Icon: Icon_default,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    disabled: disabled2,
    round,
    items,
    id: id2,
    name: name2,
    value: value2,
    title,
    label: label2,
    error: error2,
    info: info2,
    labelOnTheLeft: labelOnTheLeft2,
    element: element3,
    errorMessageId: errorMessageId2,
    dispatch: dispatch3,
    onclick,
    onchange: onchange5,
    _items,
    _id: _id2
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(2, className2 = $$props3.className);
    if ("disabled" in $$props3)
      $$invalidate2(3, disabled2 = $$props3.disabled);
    if ("round" in $$props3)
      $$invalidate2(4, round = $$props3.round);
    if ("items" in $$props3)
      $$invalidate2(15, items = $$props3.items);
    if ("id" in $$props3)
      $$invalidate2(16, id2 = $$props3.id);
    if ("name" in $$props3)
      $$invalidate2(5, name2 = $$props3.name);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("title" in $$props3)
      $$invalidate2(6, title = $$props3.title);
    if ("label" in $$props3)
      $$invalidate2(7, label2 = $$props3.label);
    if ("error" in $$props3)
      $$invalidate2(8, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(9, info2 = $$props3.info);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(10, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("_items" in $$props3)
      $$invalidate2(11, _items = $$props3._items);
    if ("_id" in $$props3)
      $$invalidate2(12, _id2 = $$props3._id);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*id, name*/
    65568) {
      $:
        $$invalidate2(12, _id2 = id2 || name2 || guid());
    }
    if ($$self2.$$.dirty & /*items*/
    32768) {
      $:
        $$invalidate2(11, _items = items.map((item) => {
          if (typeof item === "string") {
            return { name: item, value: item };
          }
          return item;
        }));
    }
  };
  return [
    value2,
    element3,
    className2,
    disabled2,
    round,
    name2,
    title,
    label2,
    error2,
    info2,
    labelOnTheLeft2,
    _items,
    _id2,
    errorMessageId2,
    onchange5,
    items,
    id2,
    change_handler,
    div3_binding
  ];
}
var ButtonToggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      class: 2,
      disabled: 3,
      round: 4,
      items: 15,
      id: 16,
      name: 5,
      value: 0,
      title: 6,
      label: 7,
      error: 8,
      info: 9,
      labelOnTheLeft: 10,
      element: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonToggle",
      options,
      id: create_fragment14.name
    });
  }
  get class() {
    throw new Error("<ButtonToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<ButtonToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ButtonToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<ButtonToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get round() {
    throw new Error("<ButtonToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set round(value2) {
    throw new Error("<ButtonToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<ButtonToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value2) {
    throw new Error("<ButtonToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ButtonToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<ButtonToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<ButtonToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value2) {
    throw new Error("<ButtonToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ButtonToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<ButtonToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ButtonToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value2) {
    throw new Error("<ButtonToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ButtonToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<ButtonToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<ButtonToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<ButtonToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<ButtonToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<ButtonToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<ButtonToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<ButtonToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<ButtonToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<ButtonToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ButtonToggle_default = ButtonToggle;

// src/input/checkbox/Checkbox.svelte
var file10 = "src/input/checkbox/Checkbox.svelte";
function create_fragment15(ctx) {
  let div1;
  let info_1;
  let t0;
  let inputerror;
  let t1;
  let div0;
  let input;
  let input_aria_errormessage_value;
  let t2;
  let label_1;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[8]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[15]
      ),
      msg: (
        /*error*/
        ctx[7]
      ),
      animOffset: "8"
    },
    $$inline: true
  });
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[6]
      ),
      for: (
        /*_id*/
        ctx[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div1 = element2("div");
      create_component(info_1.$$.fragment);
      t0 = space();
      create_component(inputerror.$$.fragment);
      t1 = space();
      div0 = element2("div");
      input = element2("input");
      t2 = space();
      create_component(label_1.$$.fragment);
      attr_dev(input, "type", "checkbox");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[11]
      );
      attr_dev(
        input,
        "id",
        /*_id*/
        ctx[14]
      );
      input.disabled = /*disabled*/
      ctx[5];
      attr_dev(
        input,
        "tabindex",
        /*tabindex*/
        ctx[10]
      );
      attr_dev(
        input,
        "aria-invalid",
        /*error*/
        ctx[7]
      );
      attr_dev(input, "aria-errormessage", input_aria_errormessage_value = /*error*/
      ctx[7] ? (
        /*errorMessageId*/
        ctx[15]
      ) : void 0);
      attr_dev(
        input,
        "aria-required",
        /*required*/
        ctx[12]
      );
      if (
        /*checked*/
        ctx[1] === void 0 || /*indeterminate*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*input_change_handler*/
          ctx[19].call(input)
        ));
      add_location(input, file10, 14, 2, 353);
      attr_dev(div0, "class", "checkbox-row");
      add_location(div0, file10, 13, 1, 324);
      attr_dev(
        div1,
        "title",
        /*title*/
        ctx[9]
      );
      attr_dev(div1, "class", div1_class_value = "check-and-radio checkbox " + /*className*/
      ctx[4]);
      toggle_class(
        div1,
        "indeterminate",
        /*indeterminate*/
        ctx[0]
      );
      toggle_class(
        div1,
        "disabled",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        div1,
        "has-error",
        /*error*/
        ctx[7]
      );
      toggle_class(
        div1,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[13] === true || /*labelOnTheLeft*/
        ctx[13] === "true"
      );
      add_location(div1, file10, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      mount_component(info_1, div1, null);
      append_dev(div1, t0);
      mount_component(inputerror, div1, null);
      append_dev(div1, t1);
      append_dev(div1, div0);
      append_dev(div0, input);
      ctx[18](input);
      input.checked = /*checked*/
      ctx[1];
      input.indeterminate = /*indeterminate*/
      ctx[0];
      append_dev(div0, t2);
      mount_component(label_1, div0, null);
      ctx[20](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[19]
          ),
          listen_dev(
            input,
            "change",
            /*onchange*/
            ctx[16],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      const info_1_changes = {};
      if (dirty & /*info*/
      256)
        info_1_changes.msg = /*info*/
        ctx2[8];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty & /*error*/
      128)
        inputerror_changes.msg = /*error*/
        ctx2[7];
      inputerror.$set(inputerror_changes);
      if (!current || dirty & /*name*/
      2048) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[11]
        );
      }
      if (!current || dirty & /*_id*/
      16384) {
        attr_dev(
          input,
          "id",
          /*_id*/
          ctx2[14]
        );
      }
      if (!current || dirty & /*disabled*/
      32) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*tabindex*/
      1024) {
        attr_dev(
          input,
          "tabindex",
          /*tabindex*/
          ctx2[10]
        );
      }
      if (!current || dirty & /*error*/
      128) {
        attr_dev(
          input,
          "aria-invalid",
          /*error*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*error*/
      128 && input_aria_errormessage_value !== (input_aria_errormessage_value = /*error*/
      ctx2[7] ? (
        /*errorMessageId*/
        ctx2[15]
      ) : void 0)) {
        attr_dev(input, "aria-errormessage", input_aria_errormessage_value);
      }
      if (!current || dirty & /*required*/
      4096) {
        attr_dev(
          input,
          "aria-required",
          /*required*/
          ctx2[12]
        );
      }
      if (dirty & /*checked*/
      2) {
        input.checked = /*checked*/
        ctx2[1];
      }
      if (dirty & /*indeterminate*/
      1) {
        input.indeterminate = /*indeterminate*/
        ctx2[0];
      }
      const label_1_changes = {};
      if (dirty & /*label*/
      64)
        label_1_changes.label = /*label*/
        ctx2[6];
      if (dirty & /*_id*/
      16384)
        label_1_changes.for = /*_id*/
        ctx2[14];
      label_1.$set(label_1_changes);
      if (!current || dirty & /*title*/
      512) {
        attr_dev(
          div1,
          "title",
          /*title*/
          ctx2[9]
        );
      }
      if (!current || dirty & /*className*/
      16 && div1_class_value !== (div1_class_value = "check-and-radio checkbox " + /*className*/
      ctx2[4])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*className, indeterminate*/
      17) {
        toggle_class(
          div1,
          "indeterminate",
          /*indeterminate*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*className, disabled*/
      48) {
        toggle_class(
          div1,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*className, error*/
      144) {
        toggle_class(
          div1,
          "has-error",
          /*error*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*className, labelOnTheLeft*/
      8208) {
        toggle_class(
          div1,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[13] === true || /*labelOnTheLeft*/
          ctx2[13] === "true"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      transition_in(label_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      transition_out(label_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_component(info_1);
      destroy_component(inputerror);
      ctx[18](null);
      destroy_component(label_1);
      ctx[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self2, $$props2, $$invalidate2) {
  let _id2;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Checkbox", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { indeterminate = false } = $$props2;
  let { checked = false } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { title = void 0 } = $$props2;
  let { tabindex = void 0 } = $$props2;
  let { name: name2 = "" } = $$props2;
  let { required: required2 = void 0 } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { inputElement: inputElement2 = void 0 } = $$props2;
  const errorMessageId2 = guid();
  const dispatch3 = createEventDispatcher();
  function onchange5(event) {
    $$invalidate2(1, checked = event.target.checked);
    $$invalidate2(0, indeterminate = event.target.indeterminate);
    dispatch3("change", { event, checked, indeterminate });
  }
  const writable_props = [
    "class",
    "indeterminate",
    "checked",
    "disabled",
    "id",
    "label",
    "error",
    "info",
    "title",
    "tabindex",
    "name",
    "required",
    "labelOnTheLeft",
    "element",
    "inputElement"
  ];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Checkbox> was created with unknown prop '${key}'`);
  });
  function input_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(3, inputElement2);
    });
  }
  function input_change_handler() {
    checked = this.checked;
    indeterminate = this.indeterminate;
    $$invalidate2(1, checked);
    $$invalidate2(0, indeterminate);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(2, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(4, className2 = $$props3.class);
    if ("indeterminate" in $$props3)
      $$invalidate2(0, indeterminate = $$props3.indeterminate);
    if ("checked" in $$props3)
      $$invalidate2(1, checked = $$props3.checked);
    if ("disabled" in $$props3)
      $$invalidate2(5, disabled2 = $$props3.disabled);
    if ("id" in $$props3)
      $$invalidate2(17, id2 = $$props3.id);
    if ("label" in $$props3)
      $$invalidate2(6, label2 = $$props3.label);
    if ("error" in $$props3)
      $$invalidate2(7, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(8, info2 = $$props3.info);
    if ("title" in $$props3)
      $$invalidate2(9, title = $$props3.title);
    if ("tabindex" in $$props3)
      $$invalidate2(10, tabindex = $$props3.tabindex);
    if ("name" in $$props3)
      $$invalidate2(11, name2 = $$props3.name);
    if ("required" in $$props3)
      $$invalidate2(12, required2 = $$props3.required);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(13, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("element" in $$props3)
      $$invalidate2(2, element3 = $$props3.element);
    if ("inputElement" in $$props3)
      $$invalidate2(3, inputElement2 = $$props3.inputElement);
  };
  $$self2.$capture_state = () => ({
    createEventDispatcher,
    guid,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    indeterminate,
    checked,
    disabled: disabled2,
    id: id2,
    label: label2,
    error: error2,
    info: info2,
    title,
    tabindex,
    name: name2,
    required: required2,
    labelOnTheLeft: labelOnTheLeft2,
    element: element3,
    inputElement: inputElement2,
    errorMessageId: errorMessageId2,
    dispatch: dispatch3,
    onchange: onchange5,
    _id: _id2
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(4, className2 = $$props3.className);
    if ("indeterminate" in $$props3)
      $$invalidate2(0, indeterminate = $$props3.indeterminate);
    if ("checked" in $$props3)
      $$invalidate2(1, checked = $$props3.checked);
    if ("disabled" in $$props3)
      $$invalidate2(5, disabled2 = $$props3.disabled);
    if ("id" in $$props3)
      $$invalidate2(17, id2 = $$props3.id);
    if ("label" in $$props3)
      $$invalidate2(6, label2 = $$props3.label);
    if ("error" in $$props3)
      $$invalidate2(7, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(8, info2 = $$props3.info);
    if ("title" in $$props3)
      $$invalidate2(9, title = $$props3.title);
    if ("tabindex" in $$props3)
      $$invalidate2(10, tabindex = $$props3.tabindex);
    if ("name" in $$props3)
      $$invalidate2(11, name2 = $$props3.name);
    if ("required" in $$props3)
      $$invalidate2(12, required2 = $$props3.required);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(13, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("element" in $$props3)
      $$invalidate2(2, element3 = $$props3.element);
    if ("inputElement" in $$props3)
      $$invalidate2(3, inputElement2 = $$props3.inputElement);
    if ("_id" in $$props3)
      $$invalidate2(14, _id2 = $$props3._id);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*id, name*/
    133120) {
      $:
        $$invalidate2(14, _id2 = id2 || name2 || guid());
    }
  };
  return [
    indeterminate,
    checked,
    element3,
    inputElement2,
    className2,
    disabled2,
    label2,
    error2,
    info2,
    title,
    tabindex,
    name2,
    required2,
    labelOnTheLeft2,
    _id2,
    errorMessageId2,
    onchange5,
    id2,
    input_binding2,
    input_change_handler,
    div1_binding
  ];
}
var Checkbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, {
      class: 4,
      indeterminate: 0,
      checked: 1,
      disabled: 5,
      id: 17,
      label: 6,
      error: 7,
      info: 8,
      title: 9,
      tabindex: 10,
      name: 11,
      required: 12,
      labelOnTheLeft: 13,
      element: 2,
      inputElement: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkbox",
      options,
      id: create_fragment15.name
    });
  }
  get class() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminate() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminate(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Checkbox_default = Checkbox;

// node_modules/vanillajs-datepicker/js/lib/utils.js
function lastItemOf(arr) {
  return arr[arr.length - 1];
}
function pushUnique(arr, ...items) {
  items.forEach((item) => {
    if (arr.includes(item)) {
      return;
    }
    arr.push(item);
  });
  return arr;
}
function stringToArray(str, separator) {
  return str ? str.split(separator) : [];
}
function isInRange(testVal, min, max) {
  const minOK = min === void 0 || testVal >= min;
  const maxOK = max === void 0 || testVal <= max;
  return minOK && maxOK;
}
function limitToRange(val, min, max) {
  if (val < min) {
    return min;
  }
  if (val > max) {
    return max;
  }
  return val;
}
function createTagRepeat(tagName, repeat, attributes = {}, index = 0, html = "") {
  const openTagSrc = Object.keys(attributes).reduce((src, attr2) => {
    let val = attributes[attr2];
    if (typeof val === "function") {
      val = val(index);
    }
    return `${src} ${attr2}="${val}"`;
  }, tagName);
  html += `<${openTagSrc}></${tagName}>`;
  const next = index + 1;
  return next < repeat ? createTagRepeat(tagName, repeat, attributes, next, html) : html;
}
function optimizeTemplateHTML(html) {
  return html.replace(/>\s+/g, ">").replace(/\s+</, "<");
}

// node_modules/vanillajs-datepicker/js/lib/date.js
function stripTime(timeValue) {
  return new Date(timeValue).setHours(0, 0, 0, 0);
}
function today() {
  return (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
}
function dateValue(...args) {
  switch (args.length) {
    case 0:
      return today();
    case 1:
      return stripTime(args[0]);
  }
  const newDate = /* @__PURE__ */ new Date(0);
  newDate.setFullYear(...args);
  return newDate.setHours(0, 0, 0, 0);
}
function addDays(date, amount2) {
  const newDate = new Date(date);
  return newDate.setDate(newDate.getDate() + amount2);
}
function addWeeks(date, amount2) {
  return addDays(date, amount2 * 7);
}
function addMonths(date, amount2) {
  const newDate = new Date(date);
  const monthsToSet = newDate.getMonth() + amount2;
  let expectedMonth = monthsToSet % 12;
  if (expectedMonth < 0) {
    expectedMonth += 12;
  }
  const time = newDate.setMonth(monthsToSet);
  return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;
}
function addYears(date, amount2) {
  const newDate = new Date(date);
  const expectedMonth = newDate.getMonth();
  const time = newDate.setFullYear(newDate.getFullYear() + amount2);
  return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;
}
function dayDiff(day, from) {
  return (day - from + 7) % 7;
}
function dayOfTheWeekOf(baseDate, dayOfWeek, weekStart = 0) {
  const baseDay = new Date(baseDate).getDay();
  return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));
}
function calcWeekNum(dayOfTheWeek, sameDayOfFirstWeek) {
  return Math.round((dayOfTheWeek - sameDayOfFirstWeek) / 6048e5) + 1;
}
function getIsoWeek(date) {
  const thuOfTheWeek = dayOfTheWeekOf(date, 4, 1);
  const firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);
  return calcWeekNum(thuOfTheWeek, firstThu);
}
function calcTraditionalWeekNumber(date, weekStart) {
  const startOfFirstWeek = dayOfTheWeekOf(new Date(date).setMonth(0, 1), weekStart, weekStart);
  const startOfTheWeek = dayOfTheWeekOf(date, weekStart, weekStart);
  const weekNum = calcWeekNum(startOfTheWeek, startOfFirstWeek);
  if (weekNum < 53) {
    return weekNum;
  }
  const weekOneOfNextYear = dayOfTheWeekOf(new Date(date).setDate(32), weekStart, weekStart);
  return startOfTheWeek === weekOneOfNextYear ? 1 : weekNum;
}
function getWesternTradWeek(date) {
  return calcTraditionalWeekNumber(date, 0);
}
function getMidEasternWeek(date) {
  return calcTraditionalWeekNumber(date, 6);
}
function startOfYearPeriod(date, years) {
  const year = new Date(date).getFullYear();
  return Math.floor(year / years) * years;
}
function regularizeDate(date, timeSpan, useLastDate) {
  if (timeSpan !== 1 && timeSpan !== 2) {
    return date;
  }
  const newDate = new Date(date);
  if (timeSpan === 1) {
    useLastDate ? newDate.setMonth(newDate.getMonth() + 1, 0) : newDate.setDate(1);
  } else {
    useLastDate ? newDate.setFullYear(newDate.getFullYear() + 1, 0, 0) : newDate.setMonth(0, 1);
  }
  return newDate.setHours(0, 0, 0, 0);
}

// node_modules/vanillajs-datepicker/js/lib/date-format.js
var reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;
var reNonDateParts = /[\s!-/:-@[-`{-~]+/;
var knownFormats = {};
var parseFns = {
  y(date, year) {
    return new Date(date).setFullYear(parseInt(year, 10));
  },
  m(date, month, locale) {
    const newDate = new Date(date);
    let monthIndex = parseInt(month, 10) - 1;
    if (isNaN(monthIndex)) {
      if (!month) {
        return NaN;
      }
      const monthName = month.toLowerCase();
      const compareNames = (name2) => name2.toLowerCase().startsWith(monthName);
      monthIndex = locale.monthsShort.findIndex(compareNames);
      if (monthIndex < 0) {
        monthIndex = locale.months.findIndex(compareNames);
      }
      if (monthIndex < 0) {
        return NaN;
      }
    }
    newDate.setMonth(monthIndex);
    return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();
  },
  d(date, day) {
    return new Date(date).setDate(parseInt(day, 10));
  }
};
var formatFns = {
  d(date) {
    return date.getDate();
  },
  dd(date) {
    return padZero(date.getDate(), 2);
  },
  D(date, locale) {
    return locale.daysShort[date.getDay()];
  },
  DD(date, locale) {
    return locale.days[date.getDay()];
  },
  m(date) {
    return date.getMonth() + 1;
  },
  mm(date) {
    return padZero(date.getMonth() + 1, 2);
  },
  M(date, locale) {
    return locale.monthsShort[date.getMonth()];
  },
  MM(date, locale) {
    return locale.months[date.getMonth()];
  },
  y(date) {
    return date.getFullYear();
  },
  yy(date) {
    return padZero(date.getFullYear(), 2).slice(-2);
  },
  yyyy(date) {
    return padZero(date.getFullYear(), 4);
  }
};
function normalizeMonth(monthIndex) {
  return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);
}
function padZero(num2, length) {
  return num2.toString().padStart(length, "0");
}
function parseFormatString(format) {
  if (typeof format !== "string") {
    throw new Error("Invalid date format.");
  }
  if (format in knownFormats) {
    return knownFormats[format];
  }
  const separators = format.split(reFormatTokens);
  const parts = format.match(new RegExp(reFormatTokens, "g"));
  if (separators.length === 0 || !parts) {
    throw new Error("Invalid date format.");
  }
  const partFormatters = parts.map((token) => formatFns[token]);
  const partParserKeys = Object.keys(parseFns).reduce((keys, key) => {
    const token = parts.find((part) => part[0] !== "D" && part[0].toLowerCase() === key);
    if (token) {
      keys.push(key);
    }
    return keys;
  }, []);
  return knownFormats[format] = {
    parser(dateStr, locale) {
      const dateParts = dateStr.split(reNonDateParts).reduce((dtParts, part, index) => {
        if (part.length > 0 && parts[index]) {
          const token = parts[index][0];
          if (token === "M") {
            dtParts.m = part;
          } else if (token !== "D") {
            dtParts[token] = part;
          }
        }
        return dtParts;
      }, {});
      return partParserKeys.reduce((origDate, key) => {
        const newDate = parseFns[key](origDate, dateParts[key], locale);
        return isNaN(newDate) ? origDate : newDate;
      }, today());
    },
    formatter(date, locale) {
      let dateStr = partFormatters.reduce((str, fn, index) => {
        return str += `${separators[index]}${fn(date, locale)}`;
      }, "");
      return dateStr += lastItemOf(separators);
    }
  };
}
function parseDate(dateStr, format, locale) {
  if (dateStr instanceof Date || typeof dateStr === "number") {
    const date = stripTime(dateStr);
    return isNaN(date) ? void 0 : date;
  }
  if (!dateStr) {
    return void 0;
  }
  if (dateStr === "today") {
    return today();
  }
  if (format && format.toValue) {
    const date = format.toValue(dateStr, format, locale);
    return isNaN(date) ? void 0 : stripTime(date);
  }
  return parseFormatString(format).parser(dateStr, locale);
}
function formatDate2(date, format, locale) {
  if (isNaN(date) || !date && date !== 0) {
    return "";
  }
  const dateObj = typeof date === "number" ? new Date(date) : date;
  if (format.toDisplay) {
    return format.toDisplay(dateObj, format, locale);
  }
  return parseFormatString(format).formatter(dateObj, locale);
}

// node_modules/vanillajs-datepicker/js/lib/dom.js
var range = document.createRange();
function parseHTML(html) {
  return range.createContextualFragment(html);
}
function getParent(el) {
  return el.parentElement || (el.parentNode instanceof ShadowRoot ? el.parentNode.host : void 0);
}
function isActiveElement2(el) {
  return el.getRootNode().activeElement === el;
}
function hideElement(el) {
  if (el.style.display === "none") {
    return;
  }
  if (el.style.display) {
    el.dataset.styleDisplay = el.style.display;
  }
  el.style.display = "none";
}
function showElement(el) {
  if (el.style.display !== "none") {
    return;
  }
  if (el.dataset.styleDisplay) {
    el.style.display = el.dataset.styleDisplay;
    delete el.dataset.styleDisplay;
  } else {
    el.style.display = "";
  }
}
function emptyChildNodes(el) {
  if (el.firstChild) {
    el.removeChild(el.firstChild);
    emptyChildNodes(el);
  }
}
function replaceChildNodes(el, newChildNodes) {
  emptyChildNodes(el);
  if (newChildNodes instanceof DocumentFragment) {
    el.appendChild(newChildNodes);
  } else if (typeof newChildNodes === "string") {
    el.appendChild(parseHTML(newChildNodes));
  } else if (typeof newChildNodes.forEach === "function") {
    newChildNodes.forEach((node) => {
      el.appendChild(node);
    });
  }
}

// node_modules/vanillajs-datepicker/js/lib/event.js
var listenerRegistry = /* @__PURE__ */ new WeakMap();
var { addEventListener, removeEventListener } = EventTarget.prototype;
function registerListeners(keyObj, listeners) {
  let registered = listenerRegistry.get(keyObj);
  if (!registered) {
    registered = [];
    listenerRegistry.set(keyObj, registered);
  }
  listeners.forEach((listener) => {
    addEventListener.call(...listener);
    registered.push(listener);
  });
}
function unregisterListeners(keyObj) {
  let listeners = listenerRegistry.get(keyObj);
  if (!listeners) {
    return;
  }
  listeners.forEach((listener) => {
    removeEventListener.call(...listener);
  });
  listenerRegistry.delete(keyObj);
}
if (!Event.prototype.composedPath) {
  const getComposedPath = (node, path = []) => {
    path.push(node);
    let parent;
    if (node.parentNode) {
      parent = node.parentNode;
    } else if (node.host) {
      parent = node.host;
    } else if (node.defaultView) {
      parent = node.defaultView;
    }
    return parent ? getComposedPath(parent, path) : path;
  };
  Event.prototype.composedPath = function() {
    return getComposedPath(this.target);
  };
}
function findFromPath(path, criteria, currentTarget) {
  const [node, ...rest] = path;
  if (criteria(node)) {
    return node;
  }
  if (node === currentTarget || node.tagName === "HTML" || rest.length === 0) {
    return;
  }
  return findFromPath(rest, criteria, currentTarget);
}
function findElementInEventPath(ev, selector) {
  const criteria = typeof selector === "function" ? selector : (el) => el instanceof Element && el.matches(selector);
  return findFromPath(ev.composedPath(), criteria, ev.currentTarget);
}

// node_modules/vanillajs-datepicker/js/i18n/base-locales.js
var base_locales_default = {
  en: {
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    today: "Today",
    clear: "Clear",
    titleFormat: "MM y"
  }
};

// node_modules/vanillajs-datepicker/js/options/defaultOptions.js
var defaultOptions_default = {
  autohide: false,
  beforeShowDay: null,
  beforeShowDecade: null,
  beforeShowMonth: null,
  beforeShowYear: null,
  clearButton: false,
  dateDelimiter: ",",
  datesDisabled: [],
  daysOfWeekDisabled: [],
  daysOfWeekHighlighted: [],
  defaultViewDate: void 0,
  // placeholder, defaults to today() by the program
  disableTouchKeyboard: false,
  enableOnReadonly: true,
  format: "mm/dd/yyyy",
  language: "en",
  maxDate: null,
  maxNumberOfDates: 1,
  maxView: 3,
  minDate: null,
  nextArrow: "\xBB",
  orientation: "auto",
  pickLevel: 0,
  prevArrow: "\xAB",
  showDaysOfWeek: true,
  showOnClick: true,
  showOnFocus: true,
  startView: 0,
  title: "",
  todayButton: false,
  todayButtonMode: 0,
  todayHighlight: false,
  updateOnBlur: true,
  weekNumbers: 0,
  weekStart: 0
};

// node_modules/vanillajs-datepicker/js/options/processOptions.js
var {
  language: defaultLang,
  format: defaultFormat,
  weekStart: defaultWeekStart
} = defaultOptions_default;
function sanitizeDOW(dow, day) {
  return dow.length < 6 && day >= 0 && day < 7 ? pushUnique(dow, day) : dow;
}
function determineGetWeekMethod(numberingMode, weekStart) {
  const methodId = numberingMode === 4 ? weekStart === 6 ? 3 : !weekStart + 1 : numberingMode;
  switch (methodId) {
    case 1:
      return getIsoWeek;
    case 2:
      return getWesternTradWeek;
    case 3:
      return getMidEasternWeek;
  }
}
function updateWeekStart(newValue, config2, weekNumbers) {
  config2.weekStart = newValue;
  config2.weekEnd = (newValue + 6) % 7;
  if (weekNumbers === 4) {
    config2.getWeekNumber = determineGetWeekMethod(4, newValue);
  }
  return newValue;
}
function validateDate(value2, format, locale, origValue) {
  const date = parseDate(value2, format, locale);
  return date !== void 0 ? date : origValue;
}
function validateViewId(value2, origValue, max = 3) {
  const viewId = parseInt(value2, 10);
  return viewId >= 0 && viewId <= max ? viewId : origValue;
}
function replaceOptions(options, from, to, convert = void 0) {
  if (from in options) {
    if (!(to in options)) {
      options[to] = convert ? convert(options[from]) : options[from];
    }
    delete options[from];
  }
}
function processOptions(options, datepicker) {
  const inOpts = Object.assign({}, options);
  const config2 = {};
  const locales = datepicker.constructor.locales;
  const rangeEnd = !!datepicker.rangeSideIndex;
  let {
    datesDisabled,
    format,
    language,
    locale,
    maxDate,
    maxView,
    minDate,
    pickLevel,
    startView,
    weekNumbers,
    weekStart
  } = datepicker.config || {};
  replaceOptions(inOpts, "calendarWeeks", "weekNumbers", (val) => val ? 1 : 0);
  replaceOptions(inOpts, "clearBtn", "clearButton");
  replaceOptions(inOpts, "todayBtn", "todayButton");
  replaceOptions(inOpts, "todayBtnMode", "todayButtonMode");
  if (inOpts.language) {
    let lang;
    if (inOpts.language !== language) {
      if (locales[inOpts.language]) {
        lang = inOpts.language;
      } else {
        lang = inOpts.language.split("-")[0];
        if (!locales[lang]) {
          lang = false;
        }
      }
    }
    delete inOpts.language;
    if (lang) {
      language = config2.language = lang;
      const origLocale = locale || locales[defaultLang];
      locale = Object.assign({
        format: defaultFormat,
        weekStart: defaultWeekStart
      }, locales[defaultLang]);
      if (language !== defaultLang) {
        Object.assign(locale, locales[language]);
      }
      config2.locale = locale;
      if (format === origLocale.format) {
        format = config2.format = locale.format;
      }
      if (weekStart === origLocale.weekStart) {
        weekStart = updateWeekStart(locale.weekStart, config2, weekNumbers);
      }
    }
  }
  if (inOpts.format) {
    const hasToDisplay = typeof inOpts.format.toDisplay === "function";
    const hasToValue = typeof inOpts.format.toValue === "function";
    const validFormatString = reFormatTokens.test(inOpts.format);
    if (hasToDisplay && hasToValue || validFormatString) {
      format = config2.format = inOpts.format;
    }
    delete inOpts.format;
  }
  let newPickLevel = pickLevel;
  if ("pickLevel" in inOpts) {
    newPickLevel = validateViewId(inOpts.pickLevel, pickLevel, 2);
    delete inOpts.pickLevel;
  }
  if (newPickLevel !== pickLevel) {
    if (newPickLevel > pickLevel) {
      if (!("minDate" in inOpts)) {
        inOpts.minDate = minDate;
      }
      if (!("maxDate" in inOpts)) {
        inOpts.maxDate = maxDate;
      }
    }
    if (datesDisabled && !inOpts.datesDisabled) {
      inOpts.datesDisabled = [];
    }
    pickLevel = config2.pickLevel = newPickLevel;
  }
  let minDt = minDate;
  let maxDt = maxDate;
  if ("minDate" in inOpts) {
    const defaultMinDt = dateValue(0, 0, 1);
    minDt = inOpts.minDate === null ? defaultMinDt : validateDate(inOpts.minDate, format, locale, minDt);
    if (minDt !== defaultMinDt) {
      minDt = regularizeDate(minDt, pickLevel, false);
    }
    delete inOpts.minDate;
  }
  if ("maxDate" in inOpts) {
    maxDt = inOpts.maxDate === null ? void 0 : validateDate(inOpts.maxDate, format, locale, maxDt);
    if (maxDt !== void 0) {
      maxDt = regularizeDate(maxDt, pickLevel, true);
    }
    delete inOpts.maxDate;
  }
  if (maxDt < minDt) {
    minDate = config2.minDate = maxDt;
    maxDate = config2.maxDate = minDt;
  } else {
    if (minDate !== minDt) {
      minDate = config2.minDate = minDt;
    }
    if (maxDate !== maxDt) {
      maxDate = config2.maxDate = maxDt;
    }
  }
  if (inOpts.datesDisabled) {
    const dtsDisabled = inOpts.datesDisabled;
    if (typeof dtsDisabled === "function") {
      config2.datesDisabled = null;
      config2.checkDisabled = (timeValue, viewId) => dtsDisabled(
        new Date(timeValue),
        viewId,
        rangeEnd
      );
    } else {
      const disabled2 = config2.datesDisabled = dtsDisabled.reduce((dates, dt) => {
        const date = parseDate(dt, format, locale);
        return date !== void 0 ? pushUnique(dates, regularizeDate(date, pickLevel, rangeEnd)) : dates;
      }, []);
      config2.checkDisabled = (timeValue) => disabled2.includes(timeValue);
    }
    delete inOpts.datesDisabled;
  }
  if ("defaultViewDate" in inOpts) {
    const viewDate = parseDate(inOpts.defaultViewDate, format, locale);
    if (viewDate !== void 0) {
      config2.defaultViewDate = viewDate;
    }
    delete inOpts.defaultViewDate;
  }
  if ("weekStart" in inOpts) {
    const wkStart = Number(inOpts.weekStart) % 7;
    if (!isNaN(wkStart)) {
      weekStart = updateWeekStart(wkStart, config2, weekNumbers);
    }
    delete inOpts.weekStart;
  }
  if (inOpts.daysOfWeekDisabled) {
    config2.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);
    delete inOpts.daysOfWeekDisabled;
  }
  if (inOpts.daysOfWeekHighlighted) {
    config2.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);
    delete inOpts.daysOfWeekHighlighted;
  }
  if ("weekNumbers" in inOpts) {
    let method = inOpts.weekNumbers;
    if (method) {
      const getWeekNumber = typeof method === "function" ? (timeValue, startOfWeek) => method(new Date(timeValue), startOfWeek) : determineGetWeekMethod(method = parseInt(method, 10), weekStart);
      if (getWeekNumber) {
        weekNumbers = config2.weekNumbers = method;
        config2.getWeekNumber = getWeekNumber;
      }
    } else {
      weekNumbers = config2.weekNumbers = 0;
      config2.getWeekNumber = null;
    }
    delete inOpts.weekNumbers;
  }
  if ("maxNumberOfDates" in inOpts) {
    const maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);
    if (maxNumberOfDates >= 0) {
      config2.maxNumberOfDates = maxNumberOfDates;
      config2.multidate = maxNumberOfDates !== 1;
    }
    delete inOpts.maxNumberOfDates;
  }
  if (inOpts.dateDelimiter) {
    config2.dateDelimiter = String(inOpts.dateDelimiter);
    delete inOpts.dateDelimiter;
  }
  let newMaxView = maxView;
  if ("maxView" in inOpts) {
    newMaxView = validateViewId(inOpts.maxView, maxView);
    delete inOpts.maxView;
  }
  newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;
  if (newMaxView !== maxView) {
    maxView = config2.maxView = newMaxView;
  }
  let newStartView = startView;
  if ("startView" in inOpts) {
    newStartView = validateViewId(inOpts.startView, newStartView);
    delete inOpts.startView;
  }
  if (newStartView < pickLevel) {
    newStartView = pickLevel;
  } else if (newStartView > maxView) {
    newStartView = maxView;
  }
  if (newStartView !== startView) {
    config2.startView = newStartView;
  }
  if (inOpts.prevArrow) {
    const prevArrow = parseHTML(inOpts.prevArrow);
    if (prevArrow.childNodes.length > 0) {
      config2.prevArrow = prevArrow.childNodes;
    }
    delete inOpts.prevArrow;
  }
  if (inOpts.nextArrow) {
    const nextArrow = parseHTML(inOpts.nextArrow);
    if (nextArrow.childNodes.length > 0) {
      config2.nextArrow = nextArrow.childNodes;
    }
    delete inOpts.nextArrow;
  }
  if ("disableTouchKeyboard" in inOpts) {
    config2.disableTouchKeyboard = "ontouchstart" in document && !!inOpts.disableTouchKeyboard;
    delete inOpts.disableTouchKeyboard;
  }
  if (inOpts.orientation) {
    const orientation = inOpts.orientation.toLowerCase().split(/\s+/g);
    config2.orientation = {
      x: orientation.find((x) => x === "left" || x === "right") || "auto",
      y: orientation.find((y) => y === "top" || y === "bottom") || "auto"
    };
    delete inOpts.orientation;
  }
  if ("todayButtonMode" in inOpts) {
    switch (inOpts.todayButtonMode) {
      case 0:
      case 1:
        config2.todayButtonMode = inOpts.todayButtonMode;
    }
    delete inOpts.todayButtonMode;
  }
  Object.entries(inOpts).forEach(([key, value2]) => {
    if (value2 !== void 0 && key in defaultOptions_default) {
      config2[key] = value2;
    }
  });
  return config2;
}

// node_modules/vanillajs-datepicker/js/options/shortcutKeys.js
var defaultShortcutKeys = {
  show: { key: "ArrowDown" },
  hide: null,
  toggle: { key: "Escape" },
  prevButton: { key: "ArrowLeft", ctrlOrMetaKey: true },
  nextButton: { key: "ArrowRight", ctrlOrMetaKey: true },
  viewSwitch: { key: "ArrowUp", ctrlOrMetaKey: true },
  clearButton: { key: "Backspace", ctrlOrMetaKey: true },
  todayButton: { key: ".", ctrlOrMetaKey: true },
  exitEditMode: { key: "ArrowDown", ctrlOrMetaKey: true }
};
function createShortcutKeyConfig(options) {
  return Object.keys(defaultShortcutKeys).reduce((keyDefs, shortcut) => {
    const keyDef = options[shortcut] === void 0 ? defaultShortcutKeys[shortcut] : options[shortcut];
    const key = keyDef && keyDef.key;
    if (!key || typeof key !== "string") {
      return keyDefs;
    }
    const normalizedDef = {
      key,
      ctrlOrMetaKey: !!(keyDef.ctrlOrMetaKey || keyDef.ctrlKey || keyDef.metaKey)
    };
    if (key.length > 1) {
      normalizedDef.altKey = !!keyDef.altKey;
      normalizedDef.shiftKey = !!keyDef.shiftKey;
    }
    keyDefs[shortcut] = normalizedDef;
    return keyDefs;
  }, {});
}

// node_modules/vanillajs-datepicker/js/picker/templates/pickerTemplate.js
var getButtons = (buttonList) => buttonList.map((classes) => `<button type="button" class="%buttonClass% ${classes}" tabindex="-1"></button>`).join("");
var pickerTemplate_default = optimizeTemplateHTML(`<div class="datepicker">
  <div class="datepicker-picker">
    <div class="datepicker-header">
      <div class="datepicker-title"></div>
      <div class="datepicker-controls">
        ${getButtons([
  "prev-button prev-btn",
  "view-switch",
  "next-button next-btn"
])}
      </div>
    </div>
    <div class="datepicker-main"></div>
    <div class="datepicker-footer">
      <div class="datepicker-controls">
        ${getButtons([
  "today-button today-btn",
  "clear-button clear-btn"
])}
      </div>
    </div>
  </div>
</div>`);

// node_modules/vanillajs-datepicker/js/picker/templates/daysTemplate.js
var daysTemplate_default = optimizeTemplateHTML(`<div class="days">
  <div class="days-of-week">${createTagRepeat("span", 7, { class: "dow" })}</div>
  <div class="datepicker-grid">${createTagRepeat("span", 42)}</div>
</div>`);

// node_modules/vanillajs-datepicker/js/picker/templates/weekNumbersTemplate.js
var weekNumbersTemplate_default = optimizeTemplateHTML(`<div class="week-numbers calendar-weeks">
  <div class="days-of-week"><span class="dow"></span></div>
  <div class="weeks">${createTagRepeat("span", 6, { class: "week" })}</div>
</div>`);

// node_modules/vanillajs-datepicker/js/picker/views/View.js
var View = class {
  constructor(picker, config2) {
    Object.assign(this, config2, {
      picker,
      element: parseHTML(`<div class="datepicker-view"></div>`).firstChild,
      selected: [],
      isRangeEnd: !!picker.datepicker.rangeSideIndex
    });
    this.init(this.picker.datepicker.config);
  }
  init(options) {
    if ("pickLevel" in options) {
      this.isMinView = this.id === options.pickLevel;
    }
    this.setOptions(options);
    this.updateFocus();
    this.updateSelection();
  }
  prepareForRender(switchLabel, prevButtonDisabled, nextButtonDisabled) {
    this.disabled = [];
    const picker = this.picker;
    picker.setViewSwitchLabel(switchLabel);
    picker.setPrevButtonDisabled(prevButtonDisabled);
    picker.setNextButtonDisabled(nextButtonDisabled);
  }
  setDisabled(date, classList) {
    classList.add("disabled");
    pushUnique(this.disabled, date);
  }
  // Execute beforeShow() callback and apply the result to the element
  // args:
  performBeforeHook(el, timeValue) {
    let result = this.beforeShow(new Date(timeValue));
    switch (typeof result) {
      case "boolean":
        result = { enabled: result };
        break;
      case "string":
        result = { classes: result };
    }
    if (result) {
      const classList = el.classList;
      if (result.enabled === false) {
        this.setDisabled(timeValue, classList);
      }
      if (result.classes) {
        const extraClasses = result.classes.split(/\s+/);
        classList.add(...extraClasses);
        if (extraClasses.includes("disabled")) {
          this.setDisabled(timeValue, classList);
        }
      }
      if (result.content) {
        replaceChildNodes(el, result.content);
      }
    }
  }
  renderCell(el, content, cellVal, date, { selected, range: range2 }, outOfScope, extraClasses = []) {
    el.textContent = content;
    if (this.isMinView) {
      el.dataset.date = date;
    }
    const classList = el.classList;
    el.className = `datepicker-cell ${this.cellClass}`;
    if (cellVal < this.first) {
      classList.add("prev");
    } else if (cellVal > this.last) {
      classList.add("next");
    }
    classList.add(...extraClasses);
    if (outOfScope || this.checkDisabled(date, this.id)) {
      this.setDisabled(date, classList);
    }
    if (range2) {
      const [rangeStart, rangeEnd] = range2;
      if (cellVal > rangeStart && cellVal < rangeEnd) {
        classList.add("range");
      }
      if (cellVal === rangeStart) {
        classList.add("range-start");
      }
      if (cellVal === rangeEnd) {
        classList.add("range-end");
      }
    }
    if (selected.includes(cellVal)) {
      classList.add("selected");
    }
    if (cellVal === this.focused) {
      classList.add("focused");
    }
    if (this.beforeShow) {
      this.performBeforeHook(el, date);
    }
  }
  refreshCell(el, cellVal, selected, [rangeStart, rangeEnd]) {
    const classList = el.classList;
    classList.remove("range", "range-start", "range-end", "selected", "focused");
    if (cellVal > rangeStart && cellVal < rangeEnd) {
      classList.add("range");
    }
    if (cellVal === rangeStart) {
      classList.add("range-start");
    }
    if (cellVal === rangeEnd) {
      classList.add("range-end");
    }
    if (selected.includes(cellVal)) {
      classList.add("selected");
    }
    if (cellVal === this.focused) {
      classList.add("focused");
    }
  }
  changeFocusedCell(cellIndex) {
    this.grid.querySelectorAll(".focused").forEach((el) => {
      el.classList.remove("focused");
    });
    this.grid.children[cellIndex].classList.add("focused");
  }
};

// node_modules/vanillajs-datepicker/js/picker/views/DaysView.js
var DaysView = class extends View {
  constructor(picker) {
    super(picker, {
      id: 0,
      name: "days",
      cellClass: "day"
    });
  }
  init(options, onConstruction = true) {
    if (onConstruction) {
      const inner = parseHTML(daysTemplate_default).firstChild;
      this.dow = inner.firstChild;
      this.grid = inner.lastChild;
      this.element.appendChild(inner);
    }
    super.init(options);
  }
  setOptions(options) {
    let updateDOW;
    if ("minDate" in options) {
      this.minDate = options.minDate;
    }
    if ("maxDate" in options) {
      this.maxDate = options.maxDate;
    }
    if (options.checkDisabled) {
      this.checkDisabled = options.checkDisabled;
    }
    if (options.daysOfWeekDisabled) {
      this.daysOfWeekDisabled = options.daysOfWeekDisabled;
      updateDOW = true;
    }
    if (options.daysOfWeekHighlighted) {
      this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;
    }
    if ("todayHighlight" in options) {
      this.todayHighlight = options.todayHighlight;
    }
    if ("weekStart" in options) {
      this.weekStart = options.weekStart;
      this.weekEnd = options.weekEnd;
      updateDOW = true;
    }
    if (options.locale) {
      const locale = this.locale = options.locale;
      this.dayNames = locale.daysMin;
      this.switchLabelFormat = locale.titleFormat;
      updateDOW = true;
    }
    if ("beforeShowDay" in options) {
      this.beforeShow = typeof options.beforeShowDay === "function" ? options.beforeShowDay : void 0;
    }
    if ("weekNumbers" in options) {
      if (options.weekNumbers && !this.weekNumbers) {
        const weeksElem = parseHTML(weekNumbersTemplate_default).firstChild;
        this.weekNumbers = {
          element: weeksElem,
          dow: weeksElem.firstChild,
          weeks: weeksElem.lastChild
        };
        this.element.insertBefore(weeksElem, this.element.firstChild);
      } else if (this.weekNumbers && !options.weekNumbers) {
        this.element.removeChild(this.weekNumbers.element);
        this.weekNumbers = null;
      }
    }
    if ("getWeekNumber" in options) {
      this.getWeekNumber = options.getWeekNumber;
    }
    if ("showDaysOfWeek" in options) {
      if (options.showDaysOfWeek) {
        showElement(this.dow);
        if (this.weekNumbers) {
          showElement(this.weekNumbers.dow);
        }
      } else {
        hideElement(this.dow);
        if (this.weekNumbers) {
          hideElement(this.weekNumbers.dow);
        }
      }
    }
    if (updateDOW) {
      Array.from(this.dow.children).forEach((el, index) => {
        const dow = (this.weekStart + index) % 7;
        el.textContent = this.dayNames[dow];
        el.className = this.daysOfWeekDisabled.includes(dow) ? "dow disabled" : "dow";
      });
    }
  }
  // Apply update on the focused date to view's settings
  updateFocus() {
    const viewDate = new Date(this.picker.viewDate);
    const viewYear = viewDate.getFullYear();
    const viewMonth = viewDate.getMonth();
    const firstOfMonth = dateValue(viewYear, viewMonth, 1);
    const start = dayOfTheWeekOf(firstOfMonth, this.weekStart, this.weekStart);
    this.first = firstOfMonth;
    this.last = dateValue(viewYear, viewMonth + 1, 0);
    this.start = start;
    this.focused = this.picker.viewDate;
  }
  // Apply update on the selected dates to view's settings
  updateSelection() {
    const { dates, rangepicker } = this.picker.datepicker;
    this.selected = dates;
    if (rangepicker) {
      this.range = rangepicker.dates;
    }
  }
  // Update the entire view UI
  render() {
    this.today = this.todayHighlight ? today() : void 0;
    this.prepareForRender(
      formatDate2(this.focused, this.switchLabelFormat, this.locale),
      this.first <= this.minDate,
      this.last >= this.maxDate
    );
    if (this.weekNumbers) {
      const weekStart = this.weekStart;
      const startOfWeek = dayOfTheWeekOf(this.first, weekStart, weekStart);
      Array.from(this.weekNumbers.weeks.children).forEach((el, index) => {
        const dateOfWeekStart = addWeeks(startOfWeek, index);
        el.textContent = this.getWeekNumber(dateOfWeekStart, weekStart);
        if (index > 3) {
          el.classList[dateOfWeekStart > this.last ? "add" : "remove"]("next");
        }
      });
    }
    Array.from(this.grid.children).forEach((el, index) => {
      const current = addDays(this.start, index);
      const dateObj = new Date(current);
      const day = dateObj.getDay();
      const extraClasses = [];
      if (this.today === current) {
        extraClasses.push("today");
      }
      if (this.daysOfWeekHighlighted.includes(day)) {
        extraClasses.push("highlighted");
      }
      this.renderCell(
        el,
        dateObj.getDate(),
        current,
        current,
        this,
        current < this.minDate || current > this.maxDate || this.daysOfWeekDisabled.includes(day),
        extraClasses
      );
    });
  }
  // Update the view UI by applying the changes of selected and focused items
  refresh() {
    const range2 = this.range || [];
    Array.from(this.grid.children).forEach((el) => {
      this.refreshCell(el, Number(el.dataset.date), this.selected, range2);
    });
  }
  // Update the view UI by applying the change of focused item
  refreshFocus() {
    this.changeFocusedCell(Math.round((this.focused - this.start) / 864e5));
  }
};

// node_modules/vanillajs-datepicker/js/picker/views/MonthsView.js
function computeMonthRange(range2, thisYear) {
  if (!range2 || !range2[0] || !range2[1]) {
    return;
  }
  const [[startY2, startM], [endY, endM]] = range2;
  if (startY2 > thisYear || endY < thisYear) {
    return;
  }
  return [
    startY2 === thisYear ? startM : -1,
    endY === thisYear ? endM : 12
  ];
}
var MonthsView = class extends View {
  constructor(picker) {
    super(picker, {
      id: 1,
      name: "months",
      cellClass: "month"
    });
  }
  init(options, onConstruction = true) {
    if (onConstruction) {
      this.grid = this.element;
      this.element.classList.add("months", "datepicker-grid");
      this.grid.appendChild(parseHTML(createTagRepeat("span", 12, { "data-month": (ix) => ix })));
      this.first = 0;
      this.last = 11;
    }
    super.init(options);
  }
  setOptions(options) {
    if (options.locale) {
      this.monthNames = options.locale.monthsShort;
    }
    if ("minDate" in options) {
      if (options.minDate === void 0) {
        this.minYear = this.minMonth = this.minDate = void 0;
      } else {
        const minDateObj = new Date(options.minDate);
        this.minYear = minDateObj.getFullYear();
        this.minMonth = minDateObj.getMonth();
        this.minDate = minDateObj.setDate(1);
      }
    }
    if ("maxDate" in options) {
      if (options.maxDate === void 0) {
        this.maxYear = this.maxMonth = this.maxDate = void 0;
      } else {
        const maxDateObj = new Date(options.maxDate);
        this.maxYear = maxDateObj.getFullYear();
        this.maxMonth = maxDateObj.getMonth();
        this.maxDate = dateValue(this.maxYear, this.maxMonth + 1, 0);
      }
    }
    if (options.checkDisabled) {
      this.checkDisabled = this.isMinView || options.datesDisabled === null ? options.checkDisabled : () => false;
    }
    if ("beforeShowMonth" in options) {
      this.beforeShow = typeof options.beforeShowMonth === "function" ? options.beforeShowMonth : void 0;
    }
  }
  // Update view's settings to reflect the viewDate set on the picker
  updateFocus() {
    const viewDate = new Date(this.picker.viewDate);
    this.year = viewDate.getFullYear();
    this.focused = viewDate.getMonth();
  }
  // Update view's settings to reflect the selected dates
  updateSelection() {
    const { dates, rangepicker } = this.picker.datepicker;
    this.selected = dates.reduce((selected, timeValue) => {
      const date = new Date(timeValue);
      const year = date.getFullYear();
      const month = date.getMonth();
      if (selected[year] === void 0) {
        selected[year] = [month];
      } else {
        pushUnique(selected[year], month);
      }
      return selected;
    }, {});
    if (rangepicker && rangepicker.dates) {
      this.range = rangepicker.dates.map((timeValue) => {
        const date = new Date(timeValue);
        return isNaN(date) ? void 0 : [date.getFullYear(), date.getMonth()];
      });
    }
  }
  // Update the entire view UI
  render() {
    this.prepareForRender(
      this.year,
      this.year <= this.minYear,
      this.year >= this.maxYear
    );
    const selected = this.selected[this.year] || [];
    const yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;
    const isMinYear = this.year === this.minYear;
    const isMaxYear = this.year === this.maxYear;
    const range2 = computeMonthRange(this.range, this.year);
    Array.from(this.grid.children).forEach((el, index) => {
      const date = regularizeDate(new Date(this.year, index, 1), 1, this.isRangeEnd);
      this.renderCell(
        el,
        this.monthNames[index],
        index,
        date,
        { selected, range: range2 },
        yrOutOfRange || isMinYear && index < this.minMonth || isMaxYear && index > this.maxMonth
      );
    });
  }
  // Update the view UI by applying the changes of selected and focused items
  refresh() {
    const selected = this.selected[this.year] || [];
    const range2 = computeMonthRange(this.range, this.year) || [];
    Array.from(this.grid.children).forEach((el, index) => {
      this.refreshCell(el, index, selected, range2);
    });
  }
  // Update the view UI by applying the change of focused item
  refreshFocus() {
    this.changeFocusedCell(this.focused);
  }
};

// node_modules/vanillajs-datepicker/js/picker/views/YearsView.js
function toTitleCase(word) {
  return [...word].reduce((str, ch, ix) => str += ix ? ch : ch.toUpperCase(), "");
}
var YearsView = class extends View {
  constructor(picker, config2) {
    super(picker, config2);
  }
  init(options, onConstruction = true) {
    if (onConstruction) {
      this.navStep = this.step * 10;
      this.beforeShowOption = `beforeShow${toTitleCase(this.cellClass)}`;
      this.grid = this.element;
      this.element.classList.add(this.name, "datepicker-grid");
      this.grid.appendChild(parseHTML(createTagRepeat("span", 12)));
    }
    super.init(options);
  }
  setOptions(options) {
    if ("minDate" in options) {
      if (options.minDate === void 0) {
        this.minYear = this.minDate = void 0;
      } else {
        this.minYear = startOfYearPeriod(options.minDate, this.step);
        this.minDate = dateValue(this.minYear, 0, 1);
      }
    }
    if ("maxDate" in options) {
      if (options.maxDate === void 0) {
        this.maxYear = this.maxDate = void 0;
      } else {
        this.maxYear = startOfYearPeriod(options.maxDate, this.step);
        this.maxDate = dateValue(this.maxYear, 11, 31);
      }
    }
    if (options.checkDisabled) {
      this.checkDisabled = this.isMinView || options.datesDisabled === null ? options.checkDisabled : () => false;
    }
    if (this.beforeShowOption in options) {
      const beforeShow = options[this.beforeShowOption];
      this.beforeShow = typeof beforeShow === "function" ? beforeShow : void 0;
    }
  }
  // Update view's settings to reflect the viewDate set on the picker
  updateFocus() {
    const viewDate = new Date(this.picker.viewDate);
    const first = startOfYearPeriod(viewDate, this.navStep);
    const last = first + 9 * this.step;
    this.first = first;
    this.last = last;
    this.start = first - this.step;
    this.focused = startOfYearPeriod(viewDate, this.step);
  }
  // Update view's settings to reflect the selected dates
  updateSelection() {
    const { dates, rangepicker } = this.picker.datepicker;
    this.selected = dates.reduce((years, timeValue) => {
      return pushUnique(years, startOfYearPeriod(timeValue, this.step));
    }, []);
    if (rangepicker && rangepicker.dates) {
      this.range = rangepicker.dates.map((timeValue) => {
        if (timeValue !== void 0) {
          return startOfYearPeriod(timeValue, this.step);
        }
      });
    }
  }
  // Update the entire view UI
  render() {
    this.prepareForRender(
      `${this.first}-${this.last}`,
      this.first <= this.minYear,
      this.last >= this.maxYear
    );
    Array.from(this.grid.children).forEach((el, index) => {
      const current = this.start + index * this.step;
      const date = regularizeDate(new Date(current, 0, 1), 2, this.isRangeEnd);
      el.dataset.year = current;
      this.renderCell(
        el,
        current,
        current,
        date,
        this,
        current < this.minYear || current > this.maxYear
      );
    });
  }
  // Update the view UI by applying the changes of selected and focused items
  refresh() {
    const range2 = this.range || [];
    Array.from(this.grid.children).forEach((el) => {
      this.refreshCell(el, Number(el.textContent), this.selected, range2);
    });
  }
  // Update the view UI by applying the change of focused item
  refreshFocus() {
    this.changeFocusedCell(Math.round((this.focused - this.start) / this.step));
  }
};

// node_modules/vanillajs-datepicker/js/events/functions.js
function triggerDatepickerEvent(datepicker, type) {
  const options = {
    bubbles: true,
    cancelable: true,
    detail: {
      date: datepicker.getDate(),
      viewDate: new Date(datepicker.picker.viewDate),
      viewId: datepicker.picker.currentView.id,
      datepicker
    }
  };
  datepicker.element.dispatchEvent(new CustomEvent(type, options));
}
function goToPrevOrNext(datepicker, direction) {
  const { config: config2, picker } = datepicker;
  const { currentView, viewDate } = picker;
  let newViewDate;
  switch (currentView.id) {
    case 0:
      newViewDate = addMonths(viewDate, direction);
      break;
    case 1:
      newViewDate = addYears(viewDate, direction);
      break;
    default:
      newViewDate = addYears(viewDate, direction * currentView.navStep);
  }
  newViewDate = limitToRange(newViewDate, config2.minDate, config2.maxDate);
  picker.changeFocus(newViewDate).render();
}
function switchView(datepicker) {
  const viewId = datepicker.picker.currentView.id;
  if (viewId === datepicker.config.maxView) {
    return;
  }
  datepicker.picker.changeView(viewId + 1).render();
}
function clearSelection(datepicker) {
  datepicker.setDate({ clear: true });
}
function goToOrSelectToday(datepicker) {
  const currentDate = today();
  if (datepicker.config.todayButtonMode === 1) {
    datepicker.setDate(currentDate, { forceRefresh: true, viewDate: currentDate });
  } else {
    datepicker.setFocusedDate(currentDate, true);
  }
}
function unfocus(datepicker) {
  const onBlur = () => {
    if (datepicker.config.updateOnBlur) {
      datepicker.update({ revert: true });
    } else {
      datepicker.refresh("input");
    }
    datepicker.hide();
  };
  const element3 = datepicker.element;
  if (isActiveElement2(element3)) {
    element3.addEventListener("blur", onBlur, { once: true });
  } else {
    onBlur();
  }
}

// node_modules/vanillajs-datepicker/js/events/pickerListeners.js
function goToSelectedMonthOrYear(datepicker, selection) {
  const picker = datepicker.picker;
  const viewDate = new Date(picker.viewDate);
  const viewId = picker.currentView.id;
  const newDate = viewId === 1 ? addMonths(viewDate, selection - viewDate.getMonth()) : addYears(viewDate, selection - viewDate.getFullYear());
  picker.changeFocus(newDate).changeView(viewId - 1).render();
}
function onClickViewSwitch(datepicker) {
  switchView(datepicker);
}
function onClickPrevButton(datepicker) {
  goToPrevOrNext(datepicker, -1);
}
function onClickNextButton(datepicker) {
  goToPrevOrNext(datepicker, 1);
}
function onClickView(datepicker, ev) {
  const target = findElementInEventPath(ev, ".datepicker-cell");
  if (!target || target.classList.contains("disabled")) {
    return;
  }
  const { id: id2, isMinView } = datepicker.picker.currentView;
  const data = target.dataset;
  if (isMinView) {
    datepicker.setDate(Number(data.date));
  } else if (id2 === 1) {
    goToSelectedMonthOrYear(datepicker, Number(data.month));
  } else {
    goToSelectedMonthOrYear(datepicker, Number(data.year));
  }
}
function onMousedownPicker(ev) {
  ev.preventDefault();
}

// node_modules/vanillajs-datepicker/js/picker/Picker.js
var orientClasses = ["left", "top", "right", "bottom"].reduce((obj, key) => {
  obj[key] = `datepicker-orient-${key}`;
  return obj;
}, {});
var toPx = (num2) => num2 ? `${num2}px` : num2;
function processPickerOptions(picker, options) {
  if ("title" in options) {
    if (options.title) {
      picker.controls.title.textContent = options.title;
      showElement(picker.controls.title);
    } else {
      picker.controls.title.textContent = "";
      hideElement(picker.controls.title);
    }
  }
  if (options.prevArrow) {
    const prevButton = picker.controls.prevButton;
    emptyChildNodes(prevButton);
    options.prevArrow.forEach((node) => {
      prevButton.appendChild(node.cloneNode(true));
    });
  }
  if (options.nextArrow) {
    const nextButton = picker.controls.nextButton;
    emptyChildNodes(nextButton);
    options.nextArrow.forEach((node) => {
      nextButton.appendChild(node.cloneNode(true));
    });
  }
  if (options.locale) {
    picker.controls.todayButton.textContent = options.locale.today;
    picker.controls.clearButton.textContent = options.locale.clear;
  }
  if ("todayButton" in options) {
    if (options.todayButton) {
      showElement(picker.controls.todayButton);
    } else {
      hideElement(picker.controls.todayButton);
    }
  }
  if ("minDate" in options || "maxDate" in options) {
    const { minDate, maxDate } = picker.datepicker.config;
    picker.controls.todayButton.disabled = !isInRange(today(), minDate, maxDate);
  }
  if ("clearButton" in options) {
    if (options.clearButton) {
      showElement(picker.controls.clearButton);
    } else {
      hideElement(picker.controls.clearButton);
    }
  }
}
function computeResetViewDate(datepicker) {
  const { dates, config: config2, rangeSideIndex } = datepicker;
  const viewDate = dates.length > 0 ? lastItemOf(dates) : regularizeDate(config2.defaultViewDate, config2.pickLevel, rangeSideIndex);
  return limitToRange(viewDate, config2.minDate, config2.maxDate);
}
function setViewDate(picker, newDate) {
  if (!("_oldViewDate" in picker) && newDate !== picker.viewDate) {
    picker._oldViewDate = picker.viewDate;
  }
  picker.viewDate = newDate;
  const { id: id2, year, first, last } = picker.currentView;
  const viewYear = new Date(newDate).getFullYear();
  switch (id2) {
    case 0:
      return newDate < first || newDate > last;
    case 1:
      return viewYear !== year;
    default:
      return viewYear < first || viewYear > last;
  }
}
function getTextDirection(el) {
  return window.getComputedStyle(el).direction;
}
function findScrollParents(el) {
  const parent = getParent(el);
  if (parent === document.body || !parent) {
    return;
  }
  return window.getComputedStyle(parent).overflow !== "visible" ? parent : findScrollParents(parent);
}
var Picker = class {
  constructor(datepicker) {
    const { config: config2, inputField } = this.datepicker = datepicker;
    const template = pickerTemplate_default.replace(/%buttonClass%/g, config2.buttonClass);
    const element3 = this.element = parseHTML(template).firstChild;
    const [header, main, footer] = element3.firstChild.children;
    const title = header.firstElementChild;
    const [prevButton, viewSwitch, nextButton] = header.lastElementChild.children;
    const [todayButton, clearButton] = footer.firstChild.children;
    const controls = {
      title,
      prevButton,
      viewSwitch,
      nextButton,
      todayButton,
      clearButton
    };
    this.main = main;
    this.controls = controls;
    const elementClass = inputField ? "dropdown" : "inline";
    element3.classList.add(`datepicker-${elementClass}`);
    processPickerOptions(this, config2);
    this.viewDate = computeResetViewDate(datepicker);
    registerListeners(datepicker, [
      [element3, "mousedown", onMousedownPicker],
      [main, "click", onClickView.bind(null, datepicker)],
      [controls.viewSwitch, "click", onClickViewSwitch.bind(null, datepicker)],
      [controls.prevButton, "click", onClickPrevButton.bind(null, datepicker)],
      [controls.nextButton, "click", onClickNextButton.bind(null, datepicker)],
      [controls.todayButton, "click", goToOrSelectToday.bind(null, datepicker)],
      [controls.clearButton, "click", clearSelection.bind(null, datepicker)]
    ]);
    this.views = [
      new DaysView(this),
      new MonthsView(this),
      new YearsView(this, { id: 2, name: "years", cellClass: "year", step: 1 }),
      new YearsView(this, { id: 3, name: "decades", cellClass: "decade", step: 10 })
    ];
    this.currentView = this.views[config2.startView];
    this.currentView.render();
    this.main.appendChild(this.currentView.element);
    if (config2.container) {
      config2.container.appendChild(this.element);
    } else {
      inputField.after(this.element);
    }
  }
  setOptions(options) {
    processPickerOptions(this, options);
    this.views.forEach((view) => {
      view.init(options, false);
    });
    this.currentView.render();
  }
  detach() {
    this.element.remove();
  }
  show() {
    if (this.active) {
      return;
    }
    const { datepicker, element: element3 } = this;
    const inputField = datepicker.inputField;
    if (inputField) {
      const inputDirection = getTextDirection(inputField);
      if (inputDirection !== getTextDirection(getParent(element3))) {
        element3.dir = inputDirection;
      } else if (element3.dir) {
        element3.removeAttribute("dir");
      }
      this.place();
      element3.classList.add("active");
      if (datepicker.config.disableTouchKeyboard) {
        inputField.blur();
      }
    } else {
      element3.classList.add("active");
    }
    this.active = true;
    triggerDatepickerEvent(datepicker, "show");
  }
  hide() {
    if (!this.active) {
      return;
    }
    this.datepicker.exitEditMode();
    this.element.classList.remove("active");
    this.active = false;
    triggerDatepickerEvent(this.datepicker, "hide");
  }
  place() {
    const { classList, style } = this.element;
    style.display = "block";
    const {
      width: calendarWidth,
      height: calendarHeight
    } = this.element.getBoundingClientRect();
    const offsetParent = this.element.offsetParent;
    style.display = "";
    const { config: config2, inputField } = this.datepicker;
    const {
      left: inputLeft,
      top: inputTop,
      right: inputRight,
      bottom: inputBottom,
      width: inputWidth,
      height: inputHeight
    } = inputField.getBoundingClientRect();
    let { x: orientX, y: orientY } = config2.orientation;
    let left = inputLeft;
    let top = inputTop;
    if (offsetParent === document.body || !offsetParent) {
      left += window.scrollX;
      top += window.scrollY;
    } else {
      const offsetParentRect = offsetParent.getBoundingClientRect();
      left -= offsetParentRect.left - offsetParent.scrollLeft;
      top -= offsetParentRect.top - offsetParent.scrollTop;
    }
    const scrollParent = findScrollParents(inputField);
    let scrollAreaLeft = 0;
    let scrollAreaTop = 0;
    let {
      clientWidth: scrollAreaRight,
      clientHeight: scrollAreaBottom
    } = document.documentElement;
    if (scrollParent) {
      const scrollParentRect = scrollParent.getBoundingClientRect();
      if (scrollParentRect.top > 0) {
        scrollAreaTop = scrollParentRect.top;
      }
      if (scrollParentRect.left > 0) {
        scrollAreaLeft = scrollParentRect.left;
      }
      if (scrollParentRect.right < scrollAreaRight) {
        scrollAreaRight = scrollParentRect.right;
      }
      if (scrollParentRect.bottom < scrollAreaBottom) {
        scrollAreaBottom = scrollParentRect.bottom;
      }
    }
    let adjustment = 0;
    if (orientX === "auto") {
      if (inputLeft < scrollAreaLeft) {
        orientX = "left";
        adjustment = scrollAreaLeft - inputLeft;
      } else if (inputLeft + calendarWidth > scrollAreaRight) {
        orientX = "right";
        if (scrollAreaRight < inputRight) {
          adjustment = scrollAreaRight - inputRight;
        }
      } else if (getTextDirection(inputField) === "rtl") {
        orientX = inputRight - calendarWidth < scrollAreaLeft ? "left" : "right";
      } else {
        orientX = "left";
      }
    }
    if (orientX === "right") {
      left += inputWidth - calendarWidth;
    }
    left += adjustment;
    if (orientY === "auto") {
      if (inputTop - calendarHeight > scrollAreaTop) {
        orientY = inputBottom + calendarHeight > scrollAreaBottom ? "top" : "bottom";
      } else {
        orientY = "bottom";
      }
    }
    if (orientY === "top") {
      top -= calendarHeight;
    } else {
      top += inputHeight;
    }
    classList.remove(...Object.values(orientClasses));
    classList.add(orientClasses[orientX], orientClasses[orientY]);
    style.left = toPx(left);
    style.top = toPx(top);
  }
  setViewSwitchLabel(labelText) {
    this.controls.viewSwitch.textContent = labelText;
  }
  setPrevButtonDisabled(disabled2) {
    this.controls.prevButton.disabled = disabled2;
  }
  setNextButtonDisabled(disabled2) {
    this.controls.nextButton.disabled = disabled2;
  }
  changeView(viewId) {
    const currentView = this.currentView;
    if (viewId !== currentView.id) {
      if (!this._oldView) {
        this._oldView = currentView;
      }
      this.currentView = this.views[viewId];
      this._renderMethod = "render";
    }
    return this;
  }
  // Change the focused date (view date)
  changeFocus(newViewDate) {
    this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refreshFocus";
    this.views.forEach((view) => {
      view.updateFocus();
    });
    return this;
  }
  // Apply the change of the selected dates
  update(viewDate = void 0) {
    const newViewDate = viewDate === void 0 ? computeResetViewDate(this.datepicker) : viewDate;
    this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refresh";
    this.views.forEach((view) => {
      view.updateFocus();
      view.updateSelection();
    });
    return this;
  }
  // Refresh the picker UI
  render(quickRender = true) {
    const { currentView, datepicker, _oldView: oldView } = this;
    const oldViewDate = new Date(this._oldViewDate);
    const renderMethod = quickRender && this._renderMethod || "render";
    delete this._oldView;
    delete this._oldViewDate;
    delete this._renderMethod;
    currentView[renderMethod]();
    if (oldView) {
      this.main.replaceChild(currentView.element, oldView.element);
      triggerDatepickerEvent(datepicker, "changeView");
    }
    if (!isNaN(oldViewDate)) {
      const newViewDate = new Date(this.viewDate);
      if (newViewDate.getFullYear() !== oldViewDate.getFullYear()) {
        triggerDatepickerEvent(datepicker, "changeYear");
      }
      if (newViewDate.getMonth() !== oldViewDate.getMonth()) {
        triggerDatepickerEvent(datepicker, "changeMonth");
      }
    }
  }
};

// node_modules/vanillajs-datepicker/js/events/elementListeners.js
function findNextAvailableOne(date, addFn, increase, testFn, min, max) {
  if (!isInRange(date, min, max)) {
    return;
  }
  if (testFn(date)) {
    const newDate = addFn(date, increase);
    return findNextAvailableOne(newDate, addFn, increase, testFn, min, max);
  }
  return date;
}
function moveByArrowKey(datepicker, direction, vertical) {
  const picker = datepicker.picker;
  const currentView = picker.currentView;
  const step = currentView.step || 1;
  let viewDate = picker.viewDate;
  let addFn;
  switch (currentView.id) {
    case 0:
      viewDate = addDays(viewDate, vertical ? direction * 7 : direction);
      addFn = addDays;
      break;
    case 1:
      viewDate = addMonths(viewDate, vertical ? direction * 4 : direction);
      addFn = addMonths;
      break;
    default:
      viewDate = addYears(viewDate, direction * (vertical ? 4 : 1) * step);
      addFn = addYears;
  }
  viewDate = findNextAvailableOne(
    viewDate,
    addFn,
    direction < 0 ? -step : step,
    (date) => currentView.disabled.includes(date),
    currentView.minDate,
    currentView.maxDate
  );
  if (viewDate !== void 0) {
    picker.changeFocus(viewDate).render();
  }
}
function onKeydown(datepicker, ev) {
  const { config: config2, picker, editMode } = datepicker;
  const active2 = picker.active;
  const { key, altKey, shiftKey } = ev;
  const ctrlOrMetaKey = ev.ctrlKey || ev.metaKey;
  const cancelEvent = () => {
    ev.preventDefault();
    ev.stopPropagation();
  };
  if (key === "Tab") {
    unfocus(datepicker);
    return;
  }
  if (key === "Enter") {
    if (!active2) {
      datepicker.update();
    } else if (editMode) {
      datepicker.exitEditMode({ update: true, autohide: config2.autohide });
    } else {
      const currentView = picker.currentView;
      if (currentView.isMinView) {
        datepicker.setDate(picker.viewDate);
      } else {
        picker.changeView(currentView.id - 1).render();
        cancelEvent();
      }
    }
    return;
  }
  const shortcutKeys = config2.shortcutKeys;
  const keyInfo = { key, ctrlOrMetaKey, altKey, shiftKey };
  const shortcut = Object.keys(shortcutKeys).find((item) => {
    const keyDef = shortcutKeys[item];
    return !Object.keys(keyDef).find((prop) => keyDef[prop] !== keyInfo[prop]);
  });
  if (shortcut) {
    let action;
    if (shortcut === "toggle") {
      action = shortcut;
    } else if (editMode) {
      if (shortcut === "exitEditMode") {
        action = shortcut;
      }
    } else if (active2) {
      if (shortcut === "hide") {
        action = shortcut;
      } else if (shortcut === "prevButton") {
        action = [goToPrevOrNext, [datepicker, -1]];
      } else if (shortcut === "nextButton") {
        action = [goToPrevOrNext, [datepicker, 1]];
      } else if (shortcut === "viewSwitch") {
        action = [switchView, [datepicker]];
      } else if (config2.clearButton && shortcut === "clearButton") {
        action = [clearSelection, [datepicker]];
      } else if (config2.todayButton && shortcut === "todayButton") {
        action = [goToOrSelectToday, [datepicker]];
      }
    } else if (shortcut === "show") {
      action = shortcut;
    }
    if (action) {
      if (Array.isArray(action)) {
        action[0].apply(null, action[1]);
      } else {
        datepicker[action]();
      }
      cancelEvent();
      return;
    }
  }
  if (!active2 || editMode) {
    return;
  }
  const handleArrowKeyPress = (direction, vertical) => {
    if (shiftKey || ctrlOrMetaKey || altKey) {
      datepicker.enterEditMode();
    } else {
      moveByArrowKey(datepicker, direction, vertical);
      ev.preventDefault();
    }
  };
  if (key === "ArrowLeft") {
    handleArrowKeyPress(-1, false);
  } else if (key === "ArrowRight") {
    handleArrowKeyPress(1, false);
  } else if (key === "ArrowUp") {
    handleArrowKeyPress(-1, true);
  } else if (key === "ArrowDown") {
    handleArrowKeyPress(1, true);
  } else if (key === "Backspace" || key === "Delete" || key && key.length === 1 && !ctrlOrMetaKey) {
    datepicker.enterEditMode();
  }
}
function onFocus(datepicker) {
  if (datepicker.config.showOnFocus && !datepicker._showing) {
    datepicker.show();
  }
}
function onMousedown(datepicker, ev) {
  const el = ev.target;
  if (datepicker.picker.active || datepicker.config.showOnClick) {
    el._active = isActiveElement2(el);
    el._clicking = setTimeout(() => {
      delete el._active;
      delete el._clicking;
    }, 2e3);
  }
}
function onClickInput(datepicker, ev) {
  const el = ev.target;
  if (!el._clicking) {
    return;
  }
  clearTimeout(el._clicking);
  delete el._clicking;
  if (el._active) {
    datepicker.enterEditMode();
  }
  delete el._active;
  if (datepicker.config.showOnClick) {
    datepicker.show();
  }
}
function onPaste(datepicker, ev) {
  if (ev.clipboardData.types.includes("text/plain")) {
    datepicker.enterEditMode();
  }
}

// node_modules/vanillajs-datepicker/js/events/otherListeners.js
function onClickOutside(datepicker, ev) {
  const { element: element3, picker } = datepicker;
  if (!picker.active && !isActiveElement2(element3)) {
    return;
  }
  const pickerElem = picker.element;
  if (findElementInEventPath(ev, (el) => el === element3 || el === pickerElem)) {
    return;
  }
  unfocus(datepicker);
}

// node_modules/vanillajs-datepicker/js/Datepicker.js
function stringifyDates(dates, config2) {
  return dates.map((dt) => formatDate2(dt, config2.format, config2.locale)).join(config2.dateDelimiter);
}
function processInputDates(datepicker, inputDates, clear = false) {
  if (inputDates.length === 0) {
    return clear ? [] : void 0;
  }
  const { config: config2, dates: origDates, rangeSideIndex } = datepicker;
  const { pickLevel, maxNumberOfDates } = config2;
  let newDates = inputDates.reduce((dates, dt) => {
    let date = parseDate(dt, config2.format, config2.locale);
    if (date === void 0) {
      return dates;
    }
    date = regularizeDate(date, pickLevel, rangeSideIndex);
    if (isInRange(date, config2.minDate, config2.maxDate) && !dates.includes(date) && !config2.checkDisabled(date, pickLevel) && (pickLevel > 0 || !config2.daysOfWeekDisabled.includes(new Date(date).getDay()))) {
      dates.push(date);
    }
    return dates;
  }, []);
  if (newDates.length === 0) {
    return;
  }
  if (config2.multidate && !clear) {
    newDates = newDates.reduce((dates, date) => {
      if (!origDates.includes(date)) {
        dates.push(date);
      }
      return dates;
    }, origDates.filter((date) => !newDates.includes(date)));
  }
  return maxNumberOfDates && newDates.length > maxNumberOfDates ? newDates.slice(maxNumberOfDates * -1) : newDates;
}
function refreshUI(datepicker, mode = 3, quickRender = true, viewDate = void 0) {
  const { config: config2, picker, inputField } = datepicker;
  if (mode & 2) {
    const newView = picker.active ? config2.pickLevel : config2.startView;
    picker.update(viewDate).changeView(newView).render(quickRender);
  }
  if (mode & 1 && inputField) {
    inputField.value = stringifyDates(datepicker.dates, config2);
  }
}
function setDate(datepicker, inputDates, options) {
  const config2 = datepicker.config;
  let { clear, render, autohide, revert, forceRefresh, viewDate } = options;
  if (render === void 0) {
    render = true;
  }
  if (!render) {
    autohide = forceRefresh = false;
  } else if (autohide === void 0) {
    autohide = config2.autohide;
  }
  viewDate = parseDate(viewDate, config2.format, config2.locale);
  const newDates = processInputDates(datepicker, inputDates, clear);
  if (!newDates && !revert) {
    return;
  }
  if (newDates && newDates.toString() !== datepicker.dates.toString()) {
    datepicker.dates = newDates;
    refreshUI(datepicker, render ? 3 : 1, true, viewDate);
    triggerDatepickerEvent(datepicker, "changeDate");
  } else {
    refreshUI(datepicker, forceRefresh ? 3 : 1, true, viewDate);
  }
  if (autohide) {
    datepicker.hide();
  }
}
function getOutputConverter(datepicker, format) {
  return format ? (date) => formatDate2(date, format, datepicker.config.locale) : (date) => new Date(date);
}
var Datepicker = class {
  /**
   * Create a date picker
   * @param  {Element} element - element to bind a date picker
   * @param  {Object} [options] - config options
   * @param  {DateRangePicker} [rangepicker] - DateRangePicker instance the
   * date picker belongs to. Use this only when creating date picker as a part
   * of date range picker
   */
  constructor(element3, options = {}, rangepicker = void 0) {
    element3.datepicker = this;
    this.element = element3;
    this.dates = [];
    const config2 = this.config = Object.assign({
      buttonClass: options.buttonClass && String(options.buttonClass) || "button",
      container: null,
      defaultViewDate: today(),
      maxDate: void 0,
      minDate: void 0
    }, processOptions(defaultOptions_default, this));
    let inputField;
    if (element3.tagName === "INPUT") {
      inputField = this.inputField = element3;
      inputField.classList.add("datepicker-input");
      if (options.container) {
        config2.container = options.container instanceof HTMLElement ? options.container : document.querySelector(options.container);
      }
    } else {
      config2.container = element3;
    }
    if (rangepicker) {
      const index = rangepicker.inputs.indexOf(inputField);
      const datepickers = rangepicker.datepickers;
      if (index < 0 || index > 1 || !Array.isArray(datepickers)) {
        throw Error("Invalid rangepicker object.");
      }
      datepickers[index] = this;
      this.rangepicker = rangepicker;
      this.rangeSideIndex = index;
    }
    this._options = options;
    Object.assign(config2, processOptions(options, this));
    config2.shortcutKeys = createShortcutKeyConfig(options.shortcutKeys || {});
    const initialDates = stringToArray(
      element3.value || element3.dataset.date,
      config2.dateDelimiter
    );
    delete element3.dataset.date;
    const inputDateValues = processInputDates(this, initialDates);
    if (inputDateValues && inputDateValues.length > 0) {
      this.dates = inputDateValues;
    }
    if (inputField) {
      inputField.value = stringifyDates(this.dates, config2);
    }
    const picker = this.picker = new Picker(this);
    const keydownListener = [element3, "keydown", onKeydown.bind(null, this)];
    if (inputField) {
      registerListeners(this, [
        keydownListener,
        [inputField, "focus", onFocus.bind(null, this)],
        [inputField, "mousedown", onMousedown.bind(null, this)],
        [inputField, "click", onClickInput.bind(null, this)],
        [inputField, "paste", onPaste.bind(null, this)],
        // To detect a click on outside, just listening to mousedown is enough,
        // no need to listen to touchstart.
        // Actually, listening to touchstart can be a problem because, while
        // mousedown is fired only on tapping but not on swiping/pinching,
        // touchstart is fired on swiping/pinching as well.
        // (issue #95)
        [document, "mousedown", onClickOutside.bind(null, this)],
        [window, "resize", picker.place.bind(picker)]
      ]);
    } else {
      registerListeners(this, [keydownListener]);
      this.show();
    }
  }
  /**
   * Format Date object or time value in given format and language
   * @param  {Date|Number} date - date or time value to format
   * @param  {String|Object} format - format string or object that contains
   * toDisplay() custom formatter, whose signature is
   * - args:
   *   - date: {Date} - Date instance of the date passed to the method
   *   - format: {Object} - the format object passed to the method
   *   - locale: {Object} - locale for the language specified by `lang`
   * - return:
   *     {String} formatted date
   * @param  {String} [lang=en] - language code for the locale to use
   * @return {String} formatted date
   */
  static formatDate(date, format, lang) {
    return formatDate2(date, format, lang && base_locales_default[lang] || base_locales_default.en);
  }
  /**
   * Parse date string
   * @param  {String|Date|Number} dateStr - date string, Date object or time
   * value to parse
   * @param  {String|Object} format - format string or object that contains
   * toValue() custom parser, whose signature is
   * - args:
   *   - dateStr: {String|Date|Number} - the dateStr passed to the method
   *   - format: {Object} - the format object passed to the method
   *   - locale: {Object} - locale for the language specified by `lang`
   * - return:
   *     {Date|Number} parsed date or its time value
   * @param  {String} [lang=en] - language code for the locale to use
   * @return {Number} time value of parsed date
   */
  static parseDate(dateStr, format, lang) {
    return parseDate(dateStr, format, lang && base_locales_default[lang] || base_locales_default.en);
  }
  /**
   * @type {Object} - Installed locales in `[languageCode]: localeObject` format
   * en`:_English (US)_ is pre-installed.
   */
  static get locales() {
    return base_locales_default;
  }
  /**
   * @type {Boolean} - Whether the picker element is shown. `true` whne shown
   */
  get active() {
    return !!(this.picker && this.picker.active);
  }
  /**
   * @type {HTMLDivElement} - DOM object of picker element
   */
  get pickerElement() {
    return this.picker ? this.picker.element : void 0;
  }
  /**
   * Set new values to the config options
   * @param {Object} options - config options to update
   */
  setOptions(options) {
    const newOptions = processOptions(options, this);
    Object.assign(this._options, options);
    Object.assign(this.config, newOptions);
    this.picker.setOptions(newOptions);
    refreshUI(this, 3);
  }
  /**
   * Show the picker element
   */
  show() {
    if (this.inputField) {
      const { config: config2, inputField } = this;
      if (inputField.disabled || inputField.readOnly && !config2.enableOnReadonly) {
        return;
      }
      if (!isActiveElement2(inputField) && !config2.disableTouchKeyboard) {
        this._showing = true;
        inputField.focus();
        delete this._showing;
      }
    }
    this.picker.show();
  }
  /**
   * Hide the picker element
   * Not available on inline picker
   */
  hide() {
    if (!this.inputField) {
      return;
    }
    this.picker.hide();
    this.picker.update().changeView(this.config.startView).render();
  }
  /**
   * Toggle the display of the picker element
   * Not available on inline picker
   *
   * Unlike hide(), the picker does not return to the start view when hiding.
   */
  toggle() {
    if (!this.picker.active) {
      this.show();
    } else if (this.inputField) {
      this.picker.hide();
    }
  }
  /**
   * Destroy the Datepicker instance
   * @return {Detepicker} - the instance destroyed
   */
  destroy() {
    this.hide();
    unregisterListeners(this);
    this.picker.detach();
    const element3 = this.element;
    element3.classList.remove("datepicker-input");
    delete element3.datepicker;
    return this;
  }
  /**
   * Get the selected date(s)
   *
   * The method returns a Date object of selected date by default, and returns
   * an array of selected dates in multidate mode. If format string is passed,
   * it returns date string(s) formatted in given format.
   *
   * @param  {String} [format] - format string to stringify the date(s)
   * @return {Date|String|Date[]|String[]} - selected date(s), or if none is
   * selected, empty array in multidate mode and undefined in sigledate mode
   */
  getDate(format = void 0) {
    const callback = getOutputConverter(this, format);
    if (this.config.multidate) {
      return this.dates.map(callback);
    }
    if (this.dates.length > 0) {
      return callback(this.dates[0]);
    }
  }
  /**
   * Set selected date(s)
   *
   * In multidate mode, you can pass multiple dates as a series of arguments
   * or an array. (Since each date is parsed individually, the type of the
   * dates doesn't have to be the same.)
   * The given dates are used to toggle the select status of each date. The
   * number of selected dates is kept from exceeding the length set to
   * maxNumberOfDates.
   *
   * With clear: true option, the method can be used to clear the selection
   * and to replace the selection instead of toggling in multidate mode.
   * If the option is passed with no date arguments or an empty dates array,
   * it works as "clear" (clear the selection then set nothing), and if the
   * option is passed with new dates to select, it works as "replace" (clear
   * the selection then set the given dates)
   *
   * When render: false option is used, the method omits re-rendering the
   * picker element. In this case, you need to call refresh() method later in
   * order for the picker element to reflect the changes. The input field is
   * refreshed always regardless of this option.
   *
   * When invalid (unparsable, repeated, disabled or out-of-range) dates are
   * passed, the method ignores them and applies only valid ones. In the case
   * that all the given dates are invalid, which is distinguished from passing
   * no dates, the method considers it as an error and leaves the selection
   * untouched. (The input field also remains untouched unless revert: true
   * option is used.)
   * Replacing the selection with the same date(s) also causes a similar
   * situation. In both cases, the method does not refresh the picker element
   * unless forceRefresh: true option is used.
   *
   * If viewDate option is used, the method changes the focused date to the
   * specified date instead of the last item of the selection.
   *
   * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date
   * objects, time values or mix of those for new selection
   * @param {Object} [options] - function options
   * - clear: {boolean} - Whether to clear the existing selection
   *     defualt: false
   * - render: {boolean} - Whether to re-render the picker element
   *     default: true
   * - autohide: {boolean} - Whether to hide the picker element after re-render
   *     Ignored when used with render: false
   *     default: config.autohide
   * - revert: {boolean} - Whether to refresh the input field when all the
   *     passed dates are invalid
   *     default: false
   * - forceRefresh: {boolean} - Whether to refresh the picker element when
   *     passed dates don't change the existing selection
   *     default: false
   * - viewDate: {Date|Number|String} - Date to be focused after setiing date(s)
   *     default: The last item of the resulting selection, or defaultViewDate
   *     config option if none is selected
   */
  setDate(...args) {
    const dates = [...args];
    const opts = {};
    const lastArg = lastItemOf(args);
    if (lastArg && typeof lastArg === "object" && !Array.isArray(lastArg) && !(lastArg instanceof Date)) {
      Object.assign(opts, dates.pop());
    }
    const inputDates = Array.isArray(dates[0]) ? dates[0] : dates;
    setDate(this, inputDates, opts);
  }
  /**
   * Update the selected date(s) with input field's value
   * Not available on inline picker
   *
   * The input field will be refreshed with properly formatted date string.
   *
   * In the case that all the entered dates are invalid (unparsable, repeated,
   * disabled or out-of-range), which is distinguished from empty input field,
   * the method leaves the input field untouched as well as the selection by
   * default. If revert: true option is used in this case, the input field is
   * refreshed with the existing selection.
   * The method also doesn't refresh the picker element in this case and when
   * the entered dates are the same as the existing selection. If
   * forceRefresh: true option is used, the picker element is refreshed in
   * these cases too.
   *
   * @param  {Object} [options] - function options
   * - autohide: {boolean} - whether to hide the picker element after refresh
   *     default: false
   * - revert: {boolean} - Whether to refresh the input field when all the
   *     passed dates are invalid
   *     default: false
   * - forceRefresh: {boolean} - Whether to refresh the picer element when
   *     input field's value doesn't change the existing selection
   *     default: false
   */
  update(options = void 0) {
    if (!this.inputField) {
      return;
    }
    const opts = Object.assign(options || {}, { clear: true, render: true, viewDate: void 0 });
    const inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);
    setDate(this, inputDates, opts);
  }
  /**
   * Get the focused date
   *
   * The method returns a Date object of focused date by default. If format
   * string is passed, it returns date string formatted in given format.
   *
   * @param  {String} [format] - format string to stringify the date
   * @return {Date|String} - focused date (viewDate)
   */
  getFocusedDate(format = void 0) {
    return getOutputConverter(this, format)(this.picker.viewDate);
  }
  /**
   * Set focused date
   *
   * By default, the method updates the focus on the view shown at the time,
   * or the one set to the startView config option if the picker is hidden.
   * When resetView: true is passed, the view displayed is changed to the
   * pickLevel config option's if the picker is shown.
   *
   * @param {Date|Number|String} viewDate - date string, Date object, time
   * values of the date to focus
   * @param {Boolean} [resetView] - whether to change the view to pickLevel
   * config option's when the picker is shown. Ignored when the picker is
   * hidden
   */
  setFocusedDate(viewDate, resetView = false) {
    const { config: config2, picker, active: active2, rangeSideIndex } = this;
    const pickLevel = config2.pickLevel;
    const newViewDate = parseDate(viewDate, config2.format, config2.locale);
    if (newViewDate === void 0) {
      return;
    }
    picker.changeFocus(regularizeDate(newViewDate, pickLevel, rangeSideIndex));
    if (active2 && resetView) {
      picker.changeView(pickLevel);
    }
    picker.render();
  }
  /**
   * Refresh the picker element and the associated input field
   * @param {String} [target] - target item when refreshing one item only
   * 'picker' or 'input'
   * @param {Boolean} [forceRender] - whether to re-render the picker element
   * regardless of its state instead of optimized refresh
   */
  refresh(target = void 0, forceRender = false) {
    if (target && typeof target !== "string") {
      forceRender = target;
      target = void 0;
    }
    let mode;
    if (target === "picker") {
      mode = 2;
    } else if (target === "input") {
      mode = 1;
    } else {
      mode = 3;
    }
    refreshUI(this, mode, !forceRender);
  }
  /**
   * Enter edit mode
   * Not available on inline picker or when the picker element is hidden
   */
  enterEditMode() {
    const inputField = this.inputField;
    if (!inputField || inputField.readOnly || !this.picker.active || this.editMode) {
      return;
    }
    this.editMode = true;
    inputField.classList.add("in-edit");
  }
  /**
   * Exit from edit mode
   * Not available on inline picker
   * @param  {Object} [options] - function options
   * - update: {boolean} - whether to call update() after exiting
   *     If false, input field is revert to the existing selection
   *     default: false
   */
  exitEditMode(options = void 0) {
    if (!this.inputField || !this.editMode) {
      return;
    }
    const opts = Object.assign({ update: false }, options);
    delete this.editMode;
    this.inputField.classList.remove("in-edit");
    if (opts.update) {
      this.update(opts);
    }
  }
};

// src/input/input-date/InputDate.svelte
var file11 = "src/input/input-date/InputDate.svelte";
function create_else_block(ctx) {
  let input;
  let input_aria_errormessage_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element2("input");
      attr_dev(input, "type", "text");
      attr_dev(input, "autocomplete", "off");
      attr_dev(input, "class", "prevent-scrolling-on-focus");
      attr_dev(
        input,
        "aria-invalid",
        /*error*/
        ctx[10]
      );
      attr_dev(input, "aria-errormessage", input_aria_errormessage_value = /*error*/
      ctx[10] ? (
        /*errorMessageId*/
        ctx[15]
      ) : void 0);
      attr_dev(
        input,
        "aria-required",
        /*required*/
        ctx[6]
      );
      attr_dev(
        input,
        "placeholder",
        /*placeholder*/
        ctx[4]
      );
      attr_dev(
        input,
        "title",
        /*title*/
        ctx[8]
      );
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[9]
      );
      input.disabled = /*disabled*/
      ctx[5];
      attr_dev(
        input,
        "id",
        /*_id*/
        ctx[14]
      );
      add_location(input, file11, 39, 4, 953);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      ctx[33](input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "changeDate",
            /*onchange*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*oninput*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*onkeydown*/
            ctx[17],
            true,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "show",
            /*onshow*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "hide",
            /*onhide*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*onblur*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_1*/
            ctx[34]
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, dirty) {
      if (dirty[0] & /*error*/
      1024) {
        attr_dev(
          input,
          "aria-invalid",
          /*error*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*error*/
      1024 && input_aria_errormessage_value !== (input_aria_errormessage_value = /*error*/
      ctx2[10] ? (
        /*errorMessageId*/
        ctx2[15]
      ) : void 0)) {
        attr_dev(input, "aria-errormessage", input_aria_errormessage_value);
      }
      if (dirty[0] & /*required*/
      64) {
        attr_dev(
          input,
          "aria-required",
          /*required*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*placeholder*/
      16) {
        attr_dev(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*title*/
      256) {
        attr_dev(
          input,
          "title",
          /*title*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*name*/
      512) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[9]
        );
      }
      if (dirty[0] & /*disabled*/
      32) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*_id*/
      16384) {
        attr_dev(
          input,
          "id",
          /*_id*/
          ctx2[14]
        );
      }
      if (dirty[0] & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[33](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(39:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let input;
  let input_aria_errormessage_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element2("input");
      attr_dev(input, "type", "date");
      attr_dev(input, "class", "prevent-scrolling-on-focus");
      attr_dev(
        input,
        "aria-invalid",
        /*error*/
        ctx[10]
      );
      attr_dev(input, "aria-errormessage", input_aria_errormessage_value = /*error*/
      ctx[10] ? (
        /*errorMessageId*/
        ctx[15]
      ) : void 0);
      attr_dev(
        input,
        "aria-required",
        /*required*/
        ctx[6]
      );
      attr_dev(
        input,
        "title",
        /*title*/
        ctx[8]
      );
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[9]
      );
      input.disabled = /*disabled*/
      ctx[5];
      attr_dev(
        input,
        "id",
        /*_id*/
        ctx[14]
      );
      add_location(input, file11, 25, 4, 608);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      ctx[31](input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*onchange*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[32]
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, dirty) {
      if (dirty[0] & /*error*/
      1024) {
        attr_dev(
          input,
          "aria-invalid",
          /*error*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*error*/
      1024 && input_aria_errormessage_value !== (input_aria_errormessage_value = /*error*/
      ctx2[10] ? (
        /*errorMessageId*/
        ctx2[15]
      ) : void 0)) {
        attr_dev(input, "aria-errormessage", input_aria_errormessage_value);
      }
      if (dirty[0] & /*required*/
      64) {
        attr_dev(
          input,
          "aria-required",
          /*required*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*title*/
      256) {
        attr_dev(
          input,
          "title",
          /*title*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*name*/
      512) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[9]
        );
      }
      if (dirty[0] & /*disabled*/
      32) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*_id*/
      16384) {
        attr_dev(
          input,
          "id",
          /*_id*/
          ctx2[14]
        );
      }
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[31](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(25:3) {#if useNative}",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let div2;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div1;
  let inputerror;
  let t2;
  let div0;
  let button;
  let t3;
  let div2_class_value;
  let current;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[7]
      ),
      disabled: (
        /*disabled*/
        ctx[5]
      ),
      for: (
        /*_id*/
        ctx[14]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[11]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[15]
      ),
      msg: (
        /*error*/
        ctx[10]
      )
    },
    $$inline: true
  });
  button = new Button_default({
    props: {
      link: true,
      icon: "calendar",
      class: "input-date-button",
      tabindex: "-1"
    },
    $$inline: true
  });
  button.$on(
    "mousedown",
    /*onIconMouseDown*/
    ctx[23]
  );
  button.$on(
    "click",
    /*onIconClick*/
    ctx[24]
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*useNative*/
      ctx2[16]
    )
      return create_if_block8;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      div2 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div1 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      div0 = element2("div");
      create_component(button.$$.fragment);
      t3 = space();
      if_block.c();
      attr_dev(div0, "class", "input-row");
      add_location(div0, file11, 15, 2, 404);
      attr_dev(div1, "class", "input-inner");
      toggle_class(
        div1,
        "disabled",
        /*disabled*/
        ctx[5]
      );
      add_location(div1, file11, 12, 1, 307);
      attr_dev(div2, "class", div2_class_value = "input input-date " + /*className*/
      ctx[3]);
      attr_dev(
        div2,
        "aria-expanded",
        /*open*/
        ctx[13]
      );
      toggle_class(
        div2,
        "open",
        /*open*/
        ctx[13]
      );
      toggle_class(
        div2,
        "native",
        /*useNative*/
        ctx[16]
      );
      toggle_class(
        div2,
        "has-error",
        /*error*/
        ctx[10]
      );
      toggle_class(
        div2,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[12] === true || /*labelOnTheLeft*/
        ctx[12] === "true"
      );
      add_location(div2, file11, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      mount_component(label_1, div2, null);
      append_dev(div2, t0);
      mount_component(info_1, div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      mount_component(inputerror, div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      mount_component(button, div0, null);
      append_dev(div0, t3);
      if_block.m(div0, null);
      ctx[35](div2);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const label_1_changes = {};
      if (dirty[0] & /*label*/
      128)
        label_1_changes.label = /*label*/
        ctx2[7];
      if (dirty[0] & /*disabled*/
      32)
        label_1_changes.disabled = /*disabled*/
        ctx2[5];
      if (dirty[0] & /*_id*/
      16384)
        label_1_changes.for = /*_id*/
        ctx2[14];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty[0] & /*info*/
      2048)
        info_1_changes.msg = /*info*/
        ctx2[11];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty[0] & /*error*/
      1024)
        inputerror_changes.msg = /*error*/
        ctx2[10];
      inputerror.$set(inputerror_changes);
      if_block.p(ctx2, dirty);
      if (!current || dirty[0] & /*disabled*/
      32) {
        toggle_class(
          div1,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*className*/
      8 && div2_class_value !== (div2_class_value = "input input-date " + /*className*/
      ctx2[3])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*open*/
      8192) {
        attr_dev(
          div2,
          "aria-expanded",
          /*open*/
          ctx2[13]
        );
      }
      if (!current || dirty[0] & /*className, open*/
      8200) {
        toggle_class(
          div2,
          "open",
          /*open*/
          ctx2[13]
        );
      }
      if (!current || dirty[0] & /*className, useNative*/
      65544) {
        toggle_class(
          div2,
          "native",
          /*useNative*/
          ctx2[16]
        );
      }
      if (!current || dirty[0] & /*className, error*/
      1032) {
        toggle_class(
          div2,
          "has-error",
          /*error*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*className, labelOnTheLeft*/
      4104) {
        toggle_class(
          div2,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[12] === true || /*labelOnTheLeft*/
          ctx2[12] === "true"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      destroy_component(button);
      if_block.d();
      ctx[35](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self2, $$props2, $$invalidate2) {
  let _id2;
  let elevated;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputDate", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { format = "yyyy-mm-dd" } = $$props2;
  let { value: value2 = "" } = $$props2;
  let { placeholder = format } = $$props2;
  let { elevate = false } = $$props2;
  let { showOnFocus = false } = $$props2;
  let { orientation = "auto" } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { required: required2 = void 0 } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { title = void 0 } = $$props2;
  let { name: name2 = void 0 } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { useNativeOnMobile = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { inputElement: inputElement2 = void 0 } = $$props2;
  const errorMessageId2 = guid();
  const dispatch3 = createEventDispatcher();
  const useNative = isMobile() && (useNativeOnMobile === true || useNativeOnMobile === "true");
  let picker;
  let open = !!useNative;
  let isHiding = false;
  onMount(initDatePicker);
  afterUpdate(() => {
    if (value2 !== picker.getDate(format))
      oninput();
  });
  function initDatePicker() {
    if (useNative)
      return;
    picker = new Datepicker(
      inputElement2,
      {
        autohide: true,
        buttonClass: "button button-text",
        container: elevated ? document.body : void 0,
        format,
        todayBtn: true,
        todayBtnMode: 1,
        orientation,
        todayHighlight: true,
        showOnFocus: showOnFocus === "true" || showOnFocus === true,
        prevArrow: getIcon("chevronLeft"),
        nextArrow: getIcon("chevronRight"),
        updateOnBlur: true,
        weekStart: 1
      }
    );
  }
  function onkeydown2(e) {
    const isActive = picker.active;
    const params = { event: e, component: picker };
    if (e.key === "Escape") {
      if (isActive)
        e.stopPropagation();
      else
        dispatch3("keydown", params);
      requestAnimationFrame(() => picker.hide());
    } else if (e.key === "Enter") {
      if (isActive)
        e.preventDefault();
      else
        dispatch3("keydown", params);
      requestAnimationFrame(() => {
        picker.hide();
        if (!inputElement2)
          return;
        if (value2 !== inputElement2.value)
          $$invalidate2(0, value2 = inputElement2.value);
        dispatch3("keydown", params);
      });
    } else
      dispatch3("keydown", params);
  }
  function oninput() {
    const wasOpen = open;
    requestAnimationFrame(() => {
      const d = Datepicker.parseDate(value2, format);
      const df = Datepicker.formatDate(d, format);
      if (df === value2) {
        if (picker)
          picker.setDate(value2);
        if (wasOpen)
          picker.show();
      }
    });
  }
  function onchange5() {
    if (picker)
      $$invalidate2(0, value2 = picker.getDate(format));
    else
      $$invalidate2(0, value2 = inputElement2.value);
    dispatch3("change", value2);
  }
  function onshow() {
    $$invalidate2(13, open = true);
  }
  function onhide() {
    $$invalidate2(13, open = false);
  }
  function onblur() {
    picker.hide();
  }
  function onIconMouseDown() {
    isHiding = open;
  }
  function onIconClick() {
    if (isHiding)
      picker.hide();
    else
      picker.show();
    isHiding = false;
    if (inputElement2)
      inputElement2.focus();
  }
  const writable_props = [
    "class",
    "format",
    "value",
    "placeholder",
    "elevate",
    "showOnFocus",
    "orientation",
    "disabled",
    "required",
    "id",
    "label",
    "title",
    "name",
    "error",
    "info",
    "labelOnTheLeft",
    "useNativeOnMobile",
    "element",
    "inputElement"
  ];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InputDate> was created with unknown prop '${key}'`);
  });
  function input_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(2, inputElement2);
    });
  }
  function input_input_handler2() {
    value2 = this.value;
    $$invalidate2(0, value2);
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(2, inputElement2);
    });
  }
  function input_input_handler_1() {
    value2 = this.value;
    $$invalidate2(0, value2);
  }
  function div2_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(3, className2 = $$props3.class);
    if ("format" in $$props3)
      $$invalidate2(25, format = $$props3.format);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("placeholder" in $$props3)
      $$invalidate2(4, placeholder = $$props3.placeholder);
    if ("elevate" in $$props3)
      $$invalidate2(26, elevate = $$props3.elevate);
    if ("showOnFocus" in $$props3)
      $$invalidate2(27, showOnFocus = $$props3.showOnFocus);
    if ("orientation" in $$props3)
      $$invalidate2(28, orientation = $$props3.orientation);
    if ("disabled" in $$props3)
      $$invalidate2(5, disabled2 = $$props3.disabled);
    if ("required" in $$props3)
      $$invalidate2(6, required2 = $$props3.required);
    if ("id" in $$props3)
      $$invalidate2(29, id2 = $$props3.id);
    if ("label" in $$props3)
      $$invalidate2(7, label2 = $$props3.label);
    if ("title" in $$props3)
      $$invalidate2(8, title = $$props3.title);
    if ("name" in $$props3)
      $$invalidate2(9, name2 = $$props3.name);
    if ("error" in $$props3)
      $$invalidate2(10, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(11, info2 = $$props3.info);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(12, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("useNativeOnMobile" in $$props3)
      $$invalidate2(30, useNativeOnMobile = $$props3.useNativeOnMobile);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("inputElement" in $$props3)
      $$invalidate2(2, inputElement2 = $$props3.inputElement);
  };
  $$self2.$capture_state = () => ({
    onMount,
    afterUpdate,
    createEventDispatcher,
    Datepicker,
    getIcon,
    Button: Button_default,
    guid,
    isMobile,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    format,
    value: value2,
    placeholder,
    elevate,
    showOnFocus,
    orientation,
    disabled: disabled2,
    required: required2,
    id: id2,
    label: label2,
    title,
    name: name2,
    error: error2,
    info: info2,
    labelOnTheLeft: labelOnTheLeft2,
    useNativeOnMobile,
    element: element3,
    inputElement: inputElement2,
    errorMessageId: errorMessageId2,
    dispatch: dispatch3,
    useNative,
    picker,
    open,
    isHiding,
    initDatePicker,
    onkeydown: onkeydown2,
    oninput,
    onchange: onchange5,
    onshow,
    onhide,
    onblur,
    onIconMouseDown,
    onIconClick,
    elevated,
    _id: _id2
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(3, className2 = $$props3.className);
    if ("format" in $$props3)
      $$invalidate2(25, format = $$props3.format);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("placeholder" in $$props3)
      $$invalidate2(4, placeholder = $$props3.placeholder);
    if ("elevate" in $$props3)
      $$invalidate2(26, elevate = $$props3.elevate);
    if ("showOnFocus" in $$props3)
      $$invalidate2(27, showOnFocus = $$props3.showOnFocus);
    if ("orientation" in $$props3)
      $$invalidate2(28, orientation = $$props3.orientation);
    if ("disabled" in $$props3)
      $$invalidate2(5, disabled2 = $$props3.disabled);
    if ("required" in $$props3)
      $$invalidate2(6, required2 = $$props3.required);
    if ("id" in $$props3)
      $$invalidate2(29, id2 = $$props3.id);
    if ("label" in $$props3)
      $$invalidate2(7, label2 = $$props3.label);
    if ("title" in $$props3)
      $$invalidate2(8, title = $$props3.title);
    if ("name" in $$props3)
      $$invalidate2(9, name2 = $$props3.name);
    if ("error" in $$props3)
      $$invalidate2(10, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(11, info2 = $$props3.info);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(12, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("useNativeOnMobile" in $$props3)
      $$invalidate2(30, useNativeOnMobile = $$props3.useNativeOnMobile);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("inputElement" in $$props3)
      $$invalidate2(2, inputElement2 = $$props3.inputElement);
    if ("picker" in $$props3)
      picker = $$props3.picker;
    if ("open" in $$props3)
      $$invalidate2(13, open = $$props3.open);
    if ("isHiding" in $$props3)
      isHiding = $$props3.isHiding;
    if ("elevated" in $$props3)
      elevated = $$props3.elevated;
    if ("_id" in $$props3)
      $$invalidate2(14, _id2 = $$props3._id);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty[0] & /*id, name*/
    536871424) {
      $:
        $$invalidate2(14, _id2 = id2 || name2 || guid());
    }
    if ($$self2.$$.dirty[0] & /*elevate*/
    67108864) {
      $:
        elevated = elevate === true || elevate === "true";
    }
  };
  return [
    value2,
    element3,
    inputElement2,
    className2,
    placeholder,
    disabled2,
    required2,
    label2,
    title,
    name2,
    error2,
    info2,
    labelOnTheLeft2,
    open,
    _id2,
    errorMessageId2,
    useNative,
    onkeydown2,
    oninput,
    onchange5,
    onshow,
    onhide,
    onblur,
    onIconMouseDown,
    onIconClick,
    format,
    elevate,
    showOnFocus,
    orientation,
    id2,
    useNativeOnMobile,
    input_binding2,
    input_input_handler2,
    input_binding_1,
    input_input_handler_1,
    div2_binding2
  ];
}
var InputDate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance16,
      create_fragment16,
      safe_not_equal,
      {
        class: 3,
        format: 25,
        value: 0,
        placeholder: 4,
        elevate: 26,
        showOnFocus: 27,
        orientation: 28,
        disabled: 5,
        required: 6,
        id: 29,
        label: 7,
        title: 8,
        name: 9,
        error: 10,
        info: 11,
        labelOnTheLeft: 12,
        useNativeOnMobile: 30,
        element: 1,
        inputElement: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputDate",
      options,
      id: create_fragment16.name
    });
  }
  get class() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get format() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set format(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get elevate() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set elevate(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showOnFocus() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showOnFocus(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useNativeOnMobile() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useNativeOnMobile(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<InputDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<InputDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputDate_default = InputDate;

// src/input/input-math/InputMath.svelte
var file12 = "src/input/input-math/InputMath.svelte";
function create_fragment17(ctx) {
  let div2;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div1;
  let inputerror;
  let t2;
  let div0;
  let icon;
  let t3;
  let input;
  let input_aria_errormessage_value;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[6]
      ),
      for: (
        /*_id*/
        ctx[10]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[8]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[11]
      ),
      msg: (
        /*error*/
        ctx[7]
      )
    },
    $$inline: true
  });
  icon = new Icon_default({
    props: { name: "calculator" },
    $$inline: true
  });
  let input_levels = [
    { type: "text" },
    { autocomplete: "off" },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    { id: (
      /*_id*/
      ctx[10]
    ) },
    /*$$restProps*/
    ctx[14],
    { "aria-invalid": (
      /*error*/
      ctx[7]
    ) },
    {
      "aria-errormessage": input_aria_errormessage_value = /*error*/
      ctx[7] ? (
        /*errorMessageId*/
        ctx[11]
      ) : void 0
    },
    { "aria-required": (
      /*required*/
      ctx[4]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div1 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      div0 = element2("div");
      create_component(icon.$$.fragment);
      t3 = space();
      input = element2("input");
      set_attributes(input, input_data);
      add_location(input, file12, 14, 3, 385);
      attr_dev(div0, "class", "input-row");
      add_location(div0, file12, 12, 2, 329);
      attr_dev(div1, "class", "input-inner");
      toggle_class(
        div1,
        "disabled",
        /*disabled*/
        ctx[5]
      );
      add_location(div1, file12, 9, 1, 232);
      attr_dev(div2, "class", div2_class_value = "input input-math " + /*className*/
      ctx[3]);
      toggle_class(
        div2,
        "has-error",
        /*error*/
        ctx[7]
      );
      toggle_class(
        div2,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[9] === true || /*labelOnTheLeft*/
        ctx[9] === "true"
      );
      add_location(div2, file12, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      mount_component(label_1, div2, null);
      append_dev(div2, t0);
      mount_component(info_1, div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      mount_component(inputerror, div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      mount_component(icon, div0, null);
      append_dev(div0, t3);
      append_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[19](input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[21](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[20]
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*onkeydown*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*onchange*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      const label_1_changes = {};
      if (dirty & /*label*/
      64)
        label_1_changes.label = /*label*/
        ctx2[6];
      if (dirty & /*_id*/
      1024)
        label_1_changes.for = /*_id*/
        ctx2[10];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty & /*info*/
      256)
        info_1_changes.msg = /*info*/
        ctx2[8];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty & /*error*/
      128)
        inputerror_changes.msg = /*error*/
        ctx2[7];
      inputerror.$set(inputerror_changes);
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        { autocomplete: "off" },
        (!current || dirty & /*disabled*/
        32) && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        (!current || dirty & /*_id*/
        1024) && { id: (
          /*_id*/
          ctx2[10]
        ) },
        dirty & /*$$restProps*/
        16384 && /*$$restProps*/
        ctx2[14],
        (!current || dirty & /*error*/
        128) && { "aria-invalid": (
          /*error*/
          ctx2[7]
        ) },
        (!current || dirty & /*error*/
        128 && input_aria_errormessage_value !== (input_aria_errormessage_value = /*error*/
        ctx2[7] ? (
          /*errorMessageId*/
          ctx2[11]
        ) : void 0)) && {
          "aria-errormessage": input_aria_errormessage_value
        },
        (!current || dirty & /*required*/
        16) && { "aria-required": (
          /*required*/
          ctx2[4]
        ) }
      ]));
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*disabled*/
      32) {
        toggle_class(
          div1,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*className*/
      8 && div2_class_value !== (div2_class_value = "input input-math " + /*className*/
      ctx2[3])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*className, error*/
      136) {
        toggle_class(
          div2,
          "has-error",
          /*error*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*className, labelOnTheLeft*/
      520) {
        toggle_class(
          div2,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[9] === true || /*labelOnTheLeft*/
          ctx2[9] === "true"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      destroy_component(icon);
      ctx[19](null);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var DECIMAL_SEPARATOR = ".";
function instance17($$self, $$props, $$invalidate) {
  let _id;
  const omit_props_names = [
    "class",
    "id",
    "required",
    "disabled",
    "value",
    "label",
    "error",
    "info",
    "labelOnTheLeft",
    "element",
    "inputElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputMath", slots, []);
  let { class: className = "" } = $$props;
  let { id = "" } = $$props;
  let { required = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { value = "" } = $$props;
  let { label = "" } = $$props;
  let { error = void 0 } = $$props;
  let { info = void 0 } = $$props;
  let { labelOnTheLeft = false } = $$props;
  let { element = void 0 } = $$props;
  let { inputElement = void 0 } = $$props;
  const errorMessageId = guid();
  const dispatch = createEventDispatcher();
  const allowedKeys = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "-",
    "/",
    "*",
    "(",
    ")",
    "ArrowLeft",
    "ArrowDown",
    "ArrowUp",
    "ArrowRight",
    "Meta",
    "Ctrl",
    "Shift",
    "Backspace",
    "Delete",
    "Tab",
    "Enter",
    "Escape"
  ];
  function onkeydown(e) {
    dispatch("keydown", e);
    if (e.key === "Enter") {
      const num2 = parseAmount(value);
      $$invalidate(0, value = isNaN(num2) ? "" : num2);
      return;
    }
    if (allowedKeys.includes(e.key))
      return;
    if (e.metaKey || e.ctrlKey)
      return;
    if (e.key === DECIMAL_SEPARATOR)
      return;
    e.preventDefault();
  }
  function onchange(e) {
    const num2 = parseAmount(value);
    $$invalidate(0, value = isNaN(num2) ? "" : num2);
    dispatch("change", e);
  }
  function parseAmount(amount) {
    if (!amount)
      return "";
    amount = ("" + amount).replace(/[\s,]/g, "");
    if (!/^[+\-\\*/()\d.]+$/i.test(amount))
      return 0;
    if (/[+\-\\*/.]+/i.test(amount)) {
      try {
        amount = eval(amount);
      } catch {
        amount = 0;
      }
    }
    const num = parseFloat(amount);
    return num === Infinity || isNaN(num) ? 0 : roundAmount(num);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(2, inputElement);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element = $$value;
      $$invalidate(1, element);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("id" in $$new_props)
      $$invalidate(15, id = $$new_props.id);
    if ("required" in $$new_props)
      $$invalidate(4, required = $$new_props.required);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("label" in $$new_props)
      $$invalidate(6, label = $$new_props.label);
    if ("error" in $$new_props)
      $$invalidate(7, error = $$new_props.error);
    if ("info" in $$new_props)
      $$invalidate(8, info = $$new_props.info);
    if ("labelOnTheLeft" in $$new_props)
      $$invalidate(9, labelOnTheLeft = $$new_props.labelOnTheLeft);
    if ("element" in $$new_props)
      $$invalidate(1, element = $$new_props.element);
    if ("inputElement" in $$new_props)
      $$invalidate(2, inputElement = $$new_props.inputElement);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    Icon: Icon_default,
    roundAmount,
    guid,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className,
    id,
    required,
    disabled,
    value,
    label,
    error,
    info,
    labelOnTheLeft,
    element,
    inputElement,
    errorMessageId,
    dispatch,
    DECIMAL_SEPARATOR,
    allowedKeys,
    onkeydown,
    onchange,
    parseAmount,
    _id
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("id" in $$props)
      $$invalidate(15, id = $$new_props.id);
    if ("required" in $$props)
      $$invalidate(4, required = $$new_props.required);
    if ("disabled" in $$props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("label" in $$props)
      $$invalidate(6, label = $$new_props.label);
    if ("error" in $$props)
      $$invalidate(7, error = $$new_props.error);
    if ("info" in $$props)
      $$invalidate(8, info = $$new_props.info);
    if ("labelOnTheLeft" in $$props)
      $$invalidate(9, labelOnTheLeft = $$new_props.labelOnTheLeft);
    if ("element" in $$props)
      $$invalidate(1, element = $$new_props.element);
    if ("inputElement" in $$props)
      $$invalidate(2, inputElement = $$new_props.inputElement);
    if ("_id" in $$props)
      $$invalidate(10, _id = $$new_props._id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(10, _id = id || $$restProps.name || guid());
  };
  return [
    value,
    element,
    inputElement,
    className,
    required,
    disabled,
    label,
    error,
    info,
    labelOnTheLeft,
    _id,
    errorMessageId,
    onkeydown,
    onchange,
    $$restProps,
    id,
    input_handler,
    focus_handler,
    blur_handler,
    input_binding,
    input_input_handler,
    div2_binding
  ];
}
var InputMath = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, {
      class: 3,
      id: 15,
      required: 4,
      disabled: 5,
      value: 0,
      label: 6,
      error: 7,
      info: 8,
      labelOnTheLeft: 9,
      element: 1,
      inputElement: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputMath",
      options,
      id: create_fragment17.name
    });
  }
  get class() {
    throw new Error("<InputMath>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<InputMath>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InputMath>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<InputMath>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<InputMath>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value2) {
    throw new Error("<InputMath>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<InputMath>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<InputMath>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<InputMath>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<InputMath>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<InputMath>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<InputMath>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<InputMath>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<InputMath>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<InputMath>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<InputMath>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<InputMath>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<InputMath>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<InputMath>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<InputMath>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<InputMath>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<InputMath>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputMath_default = InputMath;

// src/input/input-number/InputNumber.svelte
var file13 = "src/input/input-number/InputNumber.svelte";
function create_fragment18(ctx) {
  let div1;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div0;
  let inputerror;
  let t2;
  let input;
  let input_aria_errormessage_value;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[7]
      ),
      disabled: (
        /*disabled*/
        ctx[5]
      ),
      for: (
        /*_id*/
        ctx[11]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[9]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[12]
      ),
      msg: (
        /*error*/
        ctx[8]
      )
    },
    $$inline: true
  });
  let input_levels = [
    { type: "text" },
    { autocomplete: "off" },
    { name: (
      /*name*/
      ctx[4]
    ) },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    { id: (
      /*_id*/
      ctx[11]
    ) },
    /*$$restProps*/
    ctx[15],
    { "aria-invalid": (
      /*error*/
      ctx[8]
    ) },
    {
      "aria-errormessage": input_aria_errormessage_value = /*error*/
      ctx[8] ? (
        /*errorMessageId*/
        ctx[12]
      ) : void 0
    },
    { "aria-required": (
      /*required*/
      ctx[6]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div0 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      input = element2("input");
      set_attributes(input, input_data);
      add_location(input, file13, 12, 2, 327);
      attr_dev(div0, "class", "input-inner");
      add_location(div0, file13, 9, 1, 245);
      attr_dev(div1, "class", div1_class_value = "input input-number " + /*className*/
      ctx[3]);
      toggle_class(
        div1,
        "has-error",
        /*error*/
        ctx[8]
      );
      toggle_class(
        div1,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[10] === true || /*labelOnTheLeft*/
        ctx[10] === "true"
      );
      add_location(div1, file13, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      mount_component(label_1, div1, null);
      append_dev(div1, t0);
      mount_component(info_1, div1, null);
      append_dev(div1, t1);
      append_dev(div1, div0);
      mount_component(inputerror, div0, null);
      append_dev(div0, t2);
      append_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[21](input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[23](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[22]
          ),
          listen_dev(
            input,
            "keydown",
            /*onkeydown*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*onchange*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      const label_1_changes = {};
      if (dirty & /*label*/
      128)
        label_1_changes.label = /*label*/
        ctx2[7];
      if (dirty & /*disabled*/
      32)
        label_1_changes.disabled = /*disabled*/
        ctx2[5];
      if (dirty & /*_id*/
      2048)
        label_1_changes.for = /*_id*/
        ctx2[11];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty & /*info*/
      512)
        info_1_changes.msg = /*info*/
        ctx2[9];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty & /*error*/
      256)
        inputerror_changes.msg = /*error*/
        ctx2[8];
      inputerror.$set(inputerror_changes);
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        { autocomplete: "off" },
        (!current || dirty & /*name*/
        16) && { name: (
          /*name*/
          ctx2[4]
        ) },
        (!current || dirty & /*disabled*/
        32) && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        (!current || dirty & /*_id*/
        2048) && { id: (
          /*_id*/
          ctx2[11]
        ) },
        dirty & /*$$restProps*/
        32768 && /*$$restProps*/
        ctx2[15],
        (!current || dirty & /*error*/
        256) && { "aria-invalid": (
          /*error*/
          ctx2[8]
        ) },
        (!current || dirty & /*error*/
        256 && input_aria_errormessage_value !== (input_aria_errormessage_value = /*error*/
        ctx2[8] ? (
          /*errorMessageId*/
          ctx2[12]
        ) : void 0)) && {
          "aria-errormessage": input_aria_errormessage_value
        },
        (!current || dirty & /*required*/
        64) && { "aria-required": (
          /*required*/
          ctx2[6]
        ) }
      ]));
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*className*/
      8 && div1_class_value !== (div1_class_value = "input input-number " + /*className*/
      ctx2[3])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*className, error*/
      264) {
        toggle_class(
          div1,
          "has-error",
          /*error*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*className, labelOnTheLeft*/
      1032) {
        toggle_class(
          div1,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[10] === true || /*labelOnTheLeft*/
          ctx2[10] === "true"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      ctx[21](null);
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self2, $$props2, $$invalidate2) {
  let _id2;
  const omit_props_names2 = [
    "class",
    "id",
    "name",
    "disabled",
    "required",
    "value",
    "label",
    "error",
    "info",
    "separator",
    "labelOnTheLeft",
    "element",
    "inputElement"
  ];
  let $$restProps2 = compute_rest_props($$props2, omit_props_names2);
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputNumber", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { name: name2 = guid() } = $$props2;
  let { disabled: disabled2 = void 0 } = $$props2;
  let { required: required2 = void 0 } = $$props2;
  let { value: value2 = "" } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { separator = "." } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { inputElement: inputElement2 = void 0 } = $$props2;
  const dispatch3 = createEventDispatcher();
  const errorMessageId2 = guid();
  const allowedKeys2 = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "ArrowLeft",
    "ArrowDown",
    "ArrowUp",
    "ArrowRight",
    "Meta",
    "Ctrl",
    "Shift",
    "Backspace",
    "Delete",
    "Tab",
    "Enter",
    "Escape"
  ];
  function fireKeydown(event) {
    dispatch3("keydown", { event, value: value2 });
  }
  function onkeydown2(e) {
    const key = e.key;
    const val = "" + value2;
    if (allowedKeys2.includes(key))
      return fireKeydown(e);
    if (key === "-" && !val.includes("-"))
      return fireKeydown(e);
    if (key === separator && !val.includes(separator))
      return fireKeydown(e);
    e.preventDefault();
  }
  function onchange5() {
    const v = ("" + value2).replace(separator, ".");
    const num2 = parseFloat(v);
    $$invalidate2(0, value2 = isNaN(num2) ? "" : ("" + num2).replace(".", separator));
    dispatch3("change", { value: value2 });
  }
  function input_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function focus_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function blur_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function input_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(2, inputElement2);
    });
  }
  function input_input_handler2() {
    value2 = this.value;
    $$invalidate2(0, value2);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$new_props) => {
    $$props2 = assign(assign({}, $$props2), exclude_internal_props($$new_props));
    $$invalidate2(15, $$restProps2 = compute_rest_props($$props2, omit_props_names2));
    if ("class" in $$new_props)
      $$invalidate2(3, className2 = $$new_props.class);
    if ("id" in $$new_props)
      $$invalidate2(16, id2 = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate2(4, name2 = $$new_props.name);
    if ("disabled" in $$new_props)
      $$invalidate2(5, disabled2 = $$new_props.disabled);
    if ("required" in $$new_props)
      $$invalidate2(6, required2 = $$new_props.required);
    if ("value" in $$new_props)
      $$invalidate2(0, value2 = $$new_props.value);
    if ("label" in $$new_props)
      $$invalidate2(7, label2 = $$new_props.label);
    if ("error" in $$new_props)
      $$invalidate2(8, error2 = $$new_props.error);
    if ("info" in $$new_props)
      $$invalidate2(9, info2 = $$new_props.info);
    if ("separator" in $$new_props)
      $$invalidate2(17, separator = $$new_props.separator);
    if ("labelOnTheLeft" in $$new_props)
      $$invalidate2(10, labelOnTheLeft2 = $$new_props.labelOnTheLeft);
    if ("element" in $$new_props)
      $$invalidate2(1, element3 = $$new_props.element);
    if ("inputElement" in $$new_props)
      $$invalidate2(2, inputElement2 = $$new_props.inputElement);
  };
  $$self2.$capture_state = () => ({
    createEventDispatcher,
    guid,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    id: id2,
    name: name2,
    disabled: disabled2,
    required: required2,
    value: value2,
    label: label2,
    error: error2,
    info: info2,
    separator,
    labelOnTheLeft: labelOnTheLeft2,
    element: element3,
    inputElement: inputElement2,
    dispatch: dispatch3,
    errorMessageId: errorMessageId2,
    allowedKeys: allowedKeys2,
    fireKeydown,
    onkeydown: onkeydown2,
    onchange: onchange5,
    _id: _id2
  });
  $$self2.$inject_state = ($$new_props) => {
    if ("className" in $$props2)
      $$invalidate2(3, className2 = $$new_props.className);
    if ("id" in $$props2)
      $$invalidate2(16, id2 = $$new_props.id);
    if ("name" in $$props2)
      $$invalidate2(4, name2 = $$new_props.name);
    if ("disabled" in $$props2)
      $$invalidate2(5, disabled2 = $$new_props.disabled);
    if ("required" in $$props2)
      $$invalidate2(6, required2 = $$new_props.required);
    if ("value" in $$props2)
      $$invalidate2(0, value2 = $$new_props.value);
    if ("label" in $$props2)
      $$invalidate2(7, label2 = $$new_props.label);
    if ("error" in $$props2)
      $$invalidate2(8, error2 = $$new_props.error);
    if ("info" in $$props2)
      $$invalidate2(9, info2 = $$new_props.info);
    if ("separator" in $$props2)
      $$invalidate2(17, separator = $$new_props.separator);
    if ("labelOnTheLeft" in $$props2)
      $$invalidate2(10, labelOnTheLeft2 = $$new_props.labelOnTheLeft);
    if ("element" in $$props2)
      $$invalidate2(1, element3 = $$new_props.element);
    if ("inputElement" in $$props2)
      $$invalidate2(2, inputElement2 = $$new_props.inputElement);
    if ("_id" in $$props2)
      $$invalidate2(11, _id2 = $$new_props._id);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*id, name*/
    65552) {
      $:
        $$invalidate2(11, _id2 = id2 || name2 || guid());
    }
  };
  return [
    value2,
    element3,
    inputElement2,
    className2,
    name2,
    disabled2,
    required2,
    label2,
    error2,
    info2,
    labelOnTheLeft2,
    _id2,
    errorMessageId2,
    onkeydown2,
    onchange5,
    $$restProps2,
    id2,
    separator,
    input_handler2,
    focus_handler2,
    blur_handler2,
    input_binding2,
    input_input_handler2,
    div1_binding
  ];
}
var InputNumber = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {
      class: 3,
      id: 16,
      name: 4,
      disabled: 5,
      required: 6,
      value: 0,
      label: 7,
      error: 8,
      info: 9,
      separator: 17,
      labelOnTheLeft: 10,
      element: 1,
      inputElement: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputNumber",
      options,
      id: create_fragment18.name
    });
  }
  get class() {
    throw new Error("<InputNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<InputNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InputNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<InputNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<InputNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value2) {
    throw new Error("<InputNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<InputNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<InputNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<InputNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value2) {
    throw new Error("<InputNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<InputNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<InputNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<InputNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<InputNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<InputNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<InputNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<InputNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<InputNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get separator() {
    throw new Error("<InputNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set separator(value2) {
    throw new Error("<InputNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<InputNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<InputNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<InputNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<InputNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<InputNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<InputNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputNumber_default = InputNumber;

// src/input/input-password/InputPassword.svelte
var file14 = "src/input/input-password/InputPassword.svelte";
function create_if_block9(ctx) {
  let div2;
  let div1;
  let div0;
  let div0_class_value;
  let t0;
  let div4;
  let div3;
  let h2;
  let t1;
  let t2;
  let small;
  let div3_class_value;
  const block = {
    c: function create() {
      div2 = element2("div");
      div1 = element2("div");
      div0 = element2("div");
      t0 = space();
      div4 = element2("div");
      div3 = element2("div");
      h2 = element2("h2");
      t1 = text(
        /*quality*/
        ctx[13]
      );
      t2 = space();
      small = element2("small");
      attr_dev(div0, "class", div0_class_value = "password-strength-progress " + /*colorClass*/
      ctx[16]);
      set_style(
        div0,
        "width",
        /*percent*/
        ctx[14] + "%"
      );
      add_location(div0, file14, 36, 5, 967);
      attr_dev(div1, "class", "password-strength");
      attr_dev(
        div1,
        "title",
        /*quality*/
        ctx[13]
      );
      add_location(div1, file14, 35, 4, 912);
      attr_dev(div2, "class", "input-row");
      add_location(div2, file14, 34, 3, 884);
      add_location(h2, file14, 41, 5, 1160);
      add_location(small, file14, 42, 5, 1184);
      attr_dev(div3, "class", div3_class_value = "password-strength-info " + /*colorClass*/
      ctx[16]);
      add_location(div3, file14, 40, 4, 1105);
      attr_dev(div4, "class", "input-row");
      add_location(div4, file14, 39, 3, 1077);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div1);
      append_dev(div1, div0);
      insert_dev(target, t0, anchor);
      insert_dev(target, div4, anchor);
      append_dev(div4, div3);
      append_dev(div3, h2);
      append_dev(h2, t1);
      append_dev(div3, t2);
      append_dev(div3, small);
      small.innerHTML = /*strengthInfoText*/
      ctx[15];
    },
    p: function update2(ctx2, dirty) {
      if (dirty[0] & /*colorClass*/
      65536 && div0_class_value !== (div0_class_value = "password-strength-progress " + /*colorClass*/
      ctx2[16])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty[0] & /*percent*/
      16384) {
        set_style(
          div0,
          "width",
          /*percent*/
          ctx2[14] + "%"
        );
      }
      if (dirty[0] & /*quality*/
      8192) {
        attr_dev(
          div1,
          "title",
          /*quality*/
          ctx2[13]
        );
      }
      if (dirty[0] & /*quality*/
      8192)
        set_data_dev(
          t1,
          /*quality*/
          ctx2[13]
        );
      if (dirty[0] & /*strengthInfoText*/
      32768)
        small.innerHTML = /*strengthInfoText*/
        ctx2[15];
      ;
      if (dirty[0] & /*colorClass*/
      65536 && div3_class_value !== (div3_class_value = "password-strength-info " + /*colorClass*/
      ctx2[16])) {
        attr_dev(div3, "class", div3_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
        detach_dev(t0);
        detach_dev(div4);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(34:2) {#if strength && lib && value}",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let div2;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div1;
  let inputerror;
  let t2;
  let div0;
  let input;
  let input_aria_errormessage_value;
  let t3;
  let button;
  let t4;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[7]
      ),
      disabled: (
        /*disabled*/
        ctx[5]
      ),
      for: (
        /*_id*/
        ctx[17]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[9]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[19]
      ),
      msg: (
        /*error*/
        ctx[8]
      )
    },
    $$inline: true
  });
  let input_levels = [
    { id: (
      /*_id*/
      ctx[17]
    ) },
    { autocomplete: "off" },
    { type: (
      /*type*/
      ctx[18]
    ) },
    { value: (
      /*value*/
      ctx[0]
    ) },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    /*$$restProps*/
    ctx[22],
    { "aria-invalid": (
      /*error*/
      ctx[8]
    ) },
    {
      "aria-errormessage": input_aria_errormessage_value = /*error*/
      ctx[8] ? (
        /*errorMessageId*/
        ctx[19]
      ) : void 0
    },
    { "aria-required": (
      /*required*/
      ctx[4]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  button = new Button_default({
    props: {
      link: true,
      icon: (
        /*visible*/
        ctx[11] ? "eye" : "eyeOff"
      ),
      class: "input-password-button"
    },
    $$inline: true
  });
  button.$on(
    "click",
    /*toggle*/
    ctx[21]
  );
  let if_block = (
    /*strength*/
    ctx[6] && /*lib*/
    ctx[12] && /*value*/
    ctx[0] && create_if_block9(ctx)
  );
  const block = {
    c: function create() {
      div2 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div1 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      div0 = element2("div");
      input = element2("input");
      t3 = space();
      create_component(button.$$.fragment);
      t4 = space();
      if (if_block)
        if_block.c();
      set_attributes(input, input_data);
      add_location(input, file14, 14, 3, 400);
      attr_dev(div0, "class", "input-row");
      toggle_class(
        div0,
        "visible",
        /*visible*/
        ctx[11]
      );
      add_location(div0, file14, 13, 2, 359);
      attr_dev(div1, "class", "input-inner");
      toggle_class(
        div1,
        "disabled",
        /*disabled*/
        ctx[5]
      );
      add_location(div1, file14, 10, 1, 262);
      attr_dev(div2, "class", div2_class_value = "input input-password " + /*className*/
      ctx[3]);
      toggle_class(
        div2,
        "has-error",
        /*error*/
        ctx[8]
      );
      toggle_class(
        div2,
        "visible",
        /*visible*/
        ctx[11]
      );
      toggle_class(
        div2,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[10] === true || /*labelOnTheLeft*/
        ctx[10] === "true"
      );
      add_location(div2, file14, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      mount_component(label_1, div2, null);
      append_dev(div2, t0);
      mount_component(info_1, div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      mount_component(inputerror, div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      append_dev(div0, input);
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      if (input.autofocus)
        input.focus();
      ctx[28](input);
      append_dev(div0, t3);
      mount_component(button, div0, null);
      append_dev(div1, t4);
      if (if_block)
        if_block.m(div1, null);
      ctx[29](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*oninput*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, dirty) {
      const label_1_changes = {};
      if (dirty[0] & /*label*/
      128)
        label_1_changes.label = /*label*/
        ctx2[7];
      if (dirty[0] & /*disabled*/
      32)
        label_1_changes.disabled = /*disabled*/
        ctx2[5];
      if (dirty[0] & /*_id*/
      131072)
        label_1_changes.for = /*_id*/
        ctx2[17];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty[0] & /*info*/
      512)
        info_1_changes.msg = /*info*/
        ctx2[9];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty[0] & /*error*/
      256)
        inputerror_changes.msg = /*error*/
        ctx2[8];
      inputerror.$set(inputerror_changes);
      set_attributes(input, input_data = get_spread_update(input_levels, [
        (!current || dirty[0] & /*_id*/
        131072) && { id: (
          /*_id*/
          ctx2[17]
        ) },
        { autocomplete: "off" },
        (!current || dirty[0] & /*type*/
        262144) && { type: (
          /*type*/
          ctx2[18]
        ) },
        (!current || dirty[0] & /*value*/
        1 && input.value !== /*value*/
        ctx2[0]) && { value: (
          /*value*/
          ctx2[0]
        ) },
        (!current || dirty[0] & /*disabled*/
        32) && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        (!current || dirty[0] & /*error*/
        256) && { "aria-invalid": (
          /*error*/
          ctx2[8]
        ) },
        (!current || dirty[0] & /*error*/
        256 && input_aria_errormessage_value !== (input_aria_errormessage_value = /*error*/
        ctx2[8] ? (
          /*errorMessageId*/
          ctx2[19]
        ) : void 0)) && {
          "aria-errormessage": input_aria_errormessage_value
        },
        (!current || dirty[0] & /*required*/
        16) && { "aria-required": (
          /*required*/
          ctx2[4]
        ) }
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      const button_changes = {};
      if (dirty[0] & /*visible*/
      2048)
        button_changes.icon = /*visible*/
        ctx2[11] ? "eye" : "eyeOff";
      button.$set(button_changes);
      if (!current || dirty[0] & /*visible*/
      2048) {
        toggle_class(
          div0,
          "visible",
          /*visible*/
          ctx2[11]
        );
      }
      if (
        /*strength*/
        ctx2[6] && /*lib*/
        ctx2[12] && /*value*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty[0] & /*disabled*/
      32) {
        toggle_class(
          div1,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*className*/
      8 && div2_class_value !== (div2_class_value = "input input-password " + /*className*/
      ctx2[3])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*className, error*/
      264) {
        toggle_class(
          div2,
          "has-error",
          /*error*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*className, visible*/
      2056) {
        toggle_class(
          div2,
          "visible",
          /*visible*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*className, labelOnTheLeft*/
      1032) {
        toggle_class(
          div2,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[10] === true || /*labelOnTheLeft*/
          ctx2[10] === "true"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      ctx[28](null);
      destroy_component(button);
      if (if_block)
        if_block.d();
      ctx[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self2, $$props2, $$invalidate2) {
  let type;
  let _id2;
  const omit_props_names2 = [
    "class",
    "id",
    "required",
    "disabled",
    "value",
    "strength",
    "label",
    "error",
    "info",
    "labelOnTheLeft",
    "element",
    "inputElement"
  ];
  let $$restProps2 = compute_rest_props($$props2, omit_props_names2);
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputPassword", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { required: required2 = void 0 } = $$props2;
  let { disabled: disabled2 = void 0 } = $$props2;
  let { value: value2 = "" } = $$props2;
  let { strength = false } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { inputElement: inputElement2 = void 0 } = $$props2;
  const qualities = ["Very Poor", "Poor", "Average", "Safe", "Excellent"];
  const colorClassNames = ["danger", "danger", "warning", "info", "success"];
  const dispatch3 = createEventDispatcher();
  const errorMessageId2 = guid();
  let visible = false;
  let lib;
  let quality = "";
  let percent = 0;
  let strengthInfoText = "";
  let colorClass = "";
  onMount(() => {
    requestAnimationFrame(checkLib);
  });
  function oninput(e) {
    $$invalidate2(0, value2 = e.target.value);
    dispatch3("input", { event: e, value: value2 });
  }
  function checkLib() {
    $$invalidate2(12, lib = window.zxcvbn);
  }
  function measure(pass) {
    if (strength && !lib)
      checkLib();
    if (!lib || !pass || !strength)
      return { score: 0, info: "" };
    const res = lib(pass);
    const warning = res.feedback.warning;
    const suggestion = res.feedback.suggestions;
    const text2 = [warning, ...suggestion].filter((i) => i.length).join(".<br>");
    return { score: res.score, text: text2 };
  }
  function toggle() {
    $$invalidate2(11, visible = !visible);
    requestAnimationFrame(() => element3.querySelector("input").focus());
  }
  function keydown_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function focus_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function blur_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function input_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(2, inputElement2);
    });
  }
  function div2_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$new_props) => {
    $$props2 = assign(assign({}, $$props2), exclude_internal_props($$new_props));
    $$invalidate2(22, $$restProps2 = compute_rest_props($$props2, omit_props_names2));
    if ("class" in $$new_props)
      $$invalidate2(3, className2 = $$new_props.class);
    if ("id" in $$new_props)
      $$invalidate2(23, id2 = $$new_props.id);
    if ("required" in $$new_props)
      $$invalidate2(4, required2 = $$new_props.required);
    if ("disabled" in $$new_props)
      $$invalidate2(5, disabled2 = $$new_props.disabled);
    if ("value" in $$new_props)
      $$invalidate2(0, value2 = $$new_props.value);
    if ("strength" in $$new_props)
      $$invalidate2(6, strength = $$new_props.strength);
    if ("label" in $$new_props)
      $$invalidate2(7, label2 = $$new_props.label);
    if ("error" in $$new_props)
      $$invalidate2(8, error2 = $$new_props.error);
    if ("info" in $$new_props)
      $$invalidate2(9, info2 = $$new_props.info);
    if ("labelOnTheLeft" in $$new_props)
      $$invalidate2(10, labelOnTheLeft2 = $$new_props.labelOnTheLeft);
    if ("element" in $$new_props)
      $$invalidate2(1, element3 = $$new_props.element);
    if ("inputElement" in $$new_props)
      $$invalidate2(2, inputElement2 = $$new_props.inputElement);
  };
  $$self2.$capture_state = () => ({
    onMount,
    createEventDispatcher,
    Button: Button_default,
    guid,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    id: id2,
    required: required2,
    disabled: disabled2,
    value: value2,
    strength,
    label: label2,
    error: error2,
    info: info2,
    labelOnTheLeft: labelOnTheLeft2,
    element: element3,
    inputElement: inputElement2,
    qualities,
    colorClassNames,
    dispatch: dispatch3,
    errorMessageId: errorMessageId2,
    visible,
    lib,
    quality,
    percent,
    strengthInfoText,
    colorClass,
    oninput,
    checkLib,
    measure,
    toggle,
    _id: _id2,
    type
  });
  $$self2.$inject_state = ($$new_props) => {
    if ("className" in $$props2)
      $$invalidate2(3, className2 = $$new_props.className);
    if ("id" in $$props2)
      $$invalidate2(23, id2 = $$new_props.id);
    if ("required" in $$props2)
      $$invalidate2(4, required2 = $$new_props.required);
    if ("disabled" in $$props2)
      $$invalidate2(5, disabled2 = $$new_props.disabled);
    if ("value" in $$props2)
      $$invalidate2(0, value2 = $$new_props.value);
    if ("strength" in $$props2)
      $$invalidate2(6, strength = $$new_props.strength);
    if ("label" in $$props2)
      $$invalidate2(7, label2 = $$new_props.label);
    if ("error" in $$props2)
      $$invalidate2(8, error2 = $$new_props.error);
    if ("info" in $$props2)
      $$invalidate2(9, info2 = $$new_props.info);
    if ("labelOnTheLeft" in $$props2)
      $$invalidate2(10, labelOnTheLeft2 = $$new_props.labelOnTheLeft);
    if ("element" in $$props2)
      $$invalidate2(1, element3 = $$new_props.element);
    if ("inputElement" in $$props2)
      $$invalidate2(2, inputElement2 = $$new_props.inputElement);
    if ("visible" in $$props2)
      $$invalidate2(11, visible = $$new_props.visible);
    if ("lib" in $$props2)
      $$invalidate2(12, lib = $$new_props.lib);
    if ("quality" in $$props2)
      $$invalidate2(13, quality = $$new_props.quality);
    if ("percent" in $$props2)
      $$invalidate2(14, percent = $$new_props.percent);
    if ("strengthInfoText" in $$props2)
      $$invalidate2(15, strengthInfoText = $$new_props.strengthInfoText);
    if ("colorClass" in $$props2)
      $$invalidate2(16, colorClass = $$new_props.colorClass);
    if ("_id" in $$props2)
      $$invalidate2(17, _id2 = $$new_props._id);
    if ("type" in $$props2)
      $$invalidate2(18, type = $$new_props.type);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty[0] & /*visible*/
    2048) {
      $:
        $$invalidate2(18, type = visible ? "text" : "password");
    }
    $:
      $$invalidate2(17, _id2 = id2 || $$restProps2.name || guid());
    if ($$self2.$$.dirty[0] & /*value*/
    1) {
      $: {
        const { score, text: text2 } = measure(value2);
        $$invalidate2(13, quality = qualities[score]);
        $$invalidate2(14, percent = score ? score * 25 : 5);
        $$invalidate2(16, colorClass = colorClassNames[score]);
        $$invalidate2(15, strengthInfoText = text2);
      }
    }
  };
  return [
    value2,
    element3,
    inputElement2,
    className2,
    required2,
    disabled2,
    strength,
    label2,
    error2,
    info2,
    labelOnTheLeft2,
    visible,
    lib,
    quality,
    percent,
    strengthInfoText,
    colorClass,
    _id2,
    type,
    errorMessageId2,
    oninput,
    toggle,
    $$restProps2,
    id2,
    keydown_handler,
    change_handler,
    focus_handler2,
    blur_handler2,
    input_binding2,
    div2_binding2
  ];
}
var InputPassword = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance19,
      create_fragment19,
      safe_not_equal,
      {
        class: 3,
        id: 23,
        required: 4,
        disabled: 5,
        value: 0,
        strength: 6,
        label: 7,
        error: 8,
        info: 9,
        labelOnTheLeft: 10,
        element: 1,
        inputElement: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputPassword",
      options,
      id: create_fragment19.name
    });
  }
  get class() {
    throw new Error("<InputPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<InputPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InputPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<InputPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<InputPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value2) {
    throw new Error("<InputPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<InputPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<InputPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<InputPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<InputPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strength() {
    throw new Error("<InputPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strength(value2) {
    throw new Error("<InputPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<InputPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<InputPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<InputPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<InputPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<InputPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<InputPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<InputPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<InputPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<InputPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<InputPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<InputPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<InputPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputPassword_default = InputPassword;

// src/input/input-rating/InputRating.svelte
var file15 = "src/input/input-rating/InputRating.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[39] = list[i];
  return child_ctx;
}
function create_each_block3(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      link: true,
      icon: (
        /*icon*/
        ctx[12]
      ),
      tabindex: "-1",
      "data-star": (
        /*star*/
        ctx[39]
      ),
      class: (
        /*value*/
        ctx[0] >= /*star*/
        ctx[39] ? "active" : ""
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button_changes = {};
      if (dirty[0] & /*icon*/
      4096)
        button_changes.icon = /*icon*/
        ctx2[12];
      if (dirty[0] & /*stars*/
      65536)
        button_changes["data-star"] = /*star*/
        ctx2[39];
      if (dirty[0] & /*value, stars*/
      65537)
        button_changes.class = /*value*/
        ctx2[0] >= /*star*/
        ctx2[39] ? "active" : "";
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(24:3) {#each stars as star}",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let div2;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div1;
  let inputerror;
  let t2;
  let div0;
  let t3;
  let button;
  let t4;
  let input;
  let input_aria_errormessage_value;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[8]
      ),
      disabled: (
        /*disabled*/
        ctx[5]
      ),
      for: (
        /*_id*/
        ctx[15]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[10]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[17]
      ),
      msg: (
        /*error*/
        ctx[9]
      )
    },
    $$inline: true
  });
  let each_value = ensure_array_like_dev(
    /*stars*/
    ctx[16]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  button = new Button_default({
    props: {
      link: true,
      icon: "close",
      class: "btn-reset",
      disabled: (
        /*value*/
        ctx[0] === ""
      )
    },
    $$inline: true
  });
  button.$on(
    "click",
    /*reset*/
    ctx[19]
  );
  const block = {
    c: function create() {
      div2 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div1 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      div0 = element2("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      create_component(button.$$.fragment);
      t4 = space();
      input = element2("input");
      attr_dev(input, "type", "hidden");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[4]
      );
      input.disabled = /*disabled*/
      ctx[5];
      attr_dev(
        input,
        "id",
        /*_id*/
        ctx[15]
      );
      attr_dev(
        input,
        "aria-invalid",
        /*error*/
        ctx[9]
      );
      attr_dev(input, "aria-errormessage", input_aria_errormessage_value = /*error*/
      ctx[9] ? (
        /*errorMessageId*/
        ctx[17]
      ) : void 0);
      attr_dev(
        input,
        "aria-required",
        /*required*/
        ctx[6]
      );
      add_location(input, file15, 40, 3, 958);
      attr_dev(div0, "class", "input-row");
      add_location(div0, file15, 22, 2, 567);
      attr_dev(div1, "class", "input-inner");
      attr_dev(div1, "tabindex", "0");
      add_location(div1, file15, 12, 1, 358);
      attr_dev(
        div2,
        "title",
        /*title*/
        ctx[7]
      );
      attr_dev(div2, "class", div2_class_value = "input input-rating " + /*className*/
      ctx[3]);
      toggle_class(
        div2,
        "has-error",
        /*error*/
        ctx[9]
      );
      toggle_class(
        div2,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[11] === true || /*labelOnTheLeft*/
        ctx[11] === "true"
      );
      toggle_class(
        div2,
        "light",
        /*light*/
        ctx[13]
      );
      add_location(div2, file15, 1, 0, 91);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      mount_component(label_1, div2, null);
      append_dev(div2, t0);
      mount_component(info_1, div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      mount_component(inputerror, div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append_dev(div0, t3);
      mount_component(button, div0, null);
      append_dev(div0, t4);
      append_dev(div0, input);
      ctx[26](input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[28](div1);
      ctx[29](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[27]
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "touchstart",
            /*onMouseDown*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mousedown",
            /*onMouseDown*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keydown",
            /*onKey*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, dirty) {
      const label_1_changes = {};
      if (dirty[0] & /*label*/
      256)
        label_1_changes.label = /*label*/
        ctx2[8];
      if (dirty[0] & /*disabled*/
      32)
        label_1_changes.disabled = /*disabled*/
        ctx2[5];
      if (dirty[0] & /*_id*/
      32768)
        label_1_changes.for = /*_id*/
        ctx2[15];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty[0] & /*info*/
      1024)
        info_1_changes.msg = /*info*/
        ctx2[10];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty[0] & /*error*/
      512)
        inputerror_changes.msg = /*error*/
        ctx2[9];
      inputerror.$set(inputerror_changes);
      if (dirty[0] & /*icon, stars, value*/
      69633) {
        each_value = ensure_array_like_dev(
          /*stars*/
          ctx2[16]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, t3);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      const button_changes = {};
      if (dirty[0] & /*value*/
      1)
        button_changes.disabled = /*value*/
        ctx2[0] === "";
      button.$set(button_changes);
      if (!current || dirty[0] & /*name*/
      16) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      32) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*_id*/
      32768) {
        attr_dev(
          input,
          "id",
          /*_id*/
          ctx2[15]
        );
      }
      if (!current || dirty[0] & /*error*/
      512) {
        attr_dev(
          input,
          "aria-invalid",
          /*error*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*error*/
      512 && input_aria_errormessage_value !== (input_aria_errormessage_value = /*error*/
      ctx2[9] ? (
        /*errorMessageId*/
        ctx2[17]
      ) : void 0)) {
        attr_dev(input, "aria-errormessage", input_aria_errormessage_value);
      }
      if (!current || dirty[0] & /*required*/
      64) {
        attr_dev(
          input,
          "aria-required",
          /*required*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*title*/
      128) {
        attr_dev(
          div2,
          "title",
          /*title*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*className*/
      8 && div2_class_value !== (div2_class_value = "input input-rating " + /*className*/
      ctx2[3])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*className, error*/
      520) {
        toggle_class(
          div2,
          "has-error",
          /*error*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*className, labelOnTheLeft*/
      2056) {
        toggle_class(
          div2,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[11] === true || /*labelOnTheLeft*/
          ctx2[11] === "true"
        );
      }
      if (!current || dirty[0] & /*className, light*/
      8200) {
        toggle_class(
          div2,
          "light",
          /*light*/
          ctx2[13]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      destroy_each(each_blocks, detaching);
      destroy_component(button);
      ctx[26](null);
      ctx[28](null);
      ctx[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self2, $$props2, $$invalidate2) {
  let stars;
  let _id2;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputRating", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { name: name2 = guid() } = $$props2;
  let { disabled: disabled2 = void 0 } = $$props2;
  let { required: required2 = void 0 } = $$props2;
  let { value: value2 = "" } = $$props2;
  let { title = "" } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { max = 5 } = $$props2;
  let { icon = "star" } = $$props2;
  let { light = void 0 } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { inputElement: inputElement2 = void 0 } = $$props2;
  let innerBox = void 0;
  let mouseY = 0;
  const dispatch3 = createEventDispatcher();
  const errorMessageId2 = guid();
  function fireKeydown(event) {
    dispatch3("keydown", { event, value: value2 });
  }
  function onKey2(e) {
    if (e.target.closest(".btn-reset"))
      return;
    const key = e.key, v = parseInt(value2, 10) || 0;
    if (key === "ArrowRight")
      set(Math.min(v + 1, max));
    else if (key === "ArrowLeft")
      set(Math.max(v - 1, 0));
    else if (key === "Escape")
      set();
    if (key)
      return fireKeydown(e);
    e.preventDefault();
  }
  function reset(e) {
    e.preventDefault();
    e.stopPropagation();
    set();
  }
  function set(v) {
    if (typeof v !== "undefined" && v !== "") {
      const num2 = parseFloat("" + v);
      $$invalidate2(0, value2 = isNaN(num2) ? "" : "" + num2);
    } else
      $$invalidate2(0, value2 = "");
    element3.querySelector(".input-inner").focus();
    dispatch3("change", value2);
  }
  function setStarFromCursor(e) {
    const mouseX = getMouseX(e);
    const target = document.elementFromPoint(mouseX, mouseY);
    if (target && target.dataset)
      set(target.dataset.star);
  }
  function onMouseDown(e) {
    e.preventDefault();
    mouseY = getMouseY(e);
    addEventListeners();
  }
  function onMouseMove(e) {
    setStarFromCursor(e);
  }
  function onMouseUp(e) {
    setStarFromCursor(e);
    removeEventListeners();
  }
  function addEventListeners() {
    document.addEventListener("mouseup", onMouseUp);
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("touchend", onMouseUp);
    document.addEventListener("touchmove", onMouseMove);
  }
  function removeEventListeners() {
    document.removeEventListener("mouseup", onMouseUp);
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("touchend", onMouseUp);
    document.removeEventListener("touchmove", onMouseMove);
  }
  const writable_props = [
    "class",
    "id",
    "name",
    "disabled",
    "required",
    "value",
    "title",
    "label",
    "error",
    "info",
    "labelOnTheLeft",
    "max",
    "icon",
    "light",
    "element",
    "inputElement"
  ];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InputRating> was created with unknown prop '${key}'`);
  });
  function input_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function focus_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function blur_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function input_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(2, inputElement2);
    });
  }
  function input_input_handler2() {
    value2 = this.value;
    $$invalidate2(0, value2);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerBox = $$value;
      $$invalidate2(14, innerBox);
    });
  }
  function div2_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(3, className2 = $$props3.class);
    if ("id" in $$props3)
      $$invalidate2(21, id2 = $$props3.id);
    if ("name" in $$props3)
      $$invalidate2(4, name2 = $$props3.name);
    if ("disabled" in $$props3)
      $$invalidate2(5, disabled2 = $$props3.disabled);
    if ("required" in $$props3)
      $$invalidate2(6, required2 = $$props3.required);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("title" in $$props3)
      $$invalidate2(7, title = $$props3.title);
    if ("label" in $$props3)
      $$invalidate2(8, label2 = $$props3.label);
    if ("error" in $$props3)
      $$invalidate2(9, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(10, info2 = $$props3.info);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(11, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("max" in $$props3)
      $$invalidate2(22, max = $$props3.max);
    if ("icon" in $$props3)
      $$invalidate2(12, icon = $$props3.icon);
    if ("light" in $$props3)
      $$invalidate2(13, light = $$props3.light);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("inputElement" in $$props3)
      $$invalidate2(2, inputElement2 = $$props3.inputElement);
  };
  $$self2.$capture_state = () => ({
    Button: Button_default,
    createEventDispatcher,
    guid,
    getMouseY,
    getMouseX,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    id: id2,
    name: name2,
    disabled: disabled2,
    required: required2,
    value: value2,
    title,
    label: label2,
    error: error2,
    info: info2,
    labelOnTheLeft: labelOnTheLeft2,
    max,
    icon,
    light,
    element: element3,
    inputElement: inputElement2,
    innerBox,
    mouseY,
    dispatch: dispatch3,
    errorMessageId: errorMessageId2,
    fireKeydown,
    onKey: onKey2,
    reset,
    set,
    setStarFromCursor,
    onMouseDown,
    onMouseMove,
    onMouseUp,
    addEventListeners,
    removeEventListeners,
    _id: _id2,
    stars
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(3, className2 = $$props3.className);
    if ("id" in $$props3)
      $$invalidate2(21, id2 = $$props3.id);
    if ("name" in $$props3)
      $$invalidate2(4, name2 = $$props3.name);
    if ("disabled" in $$props3)
      $$invalidate2(5, disabled2 = $$props3.disabled);
    if ("required" in $$props3)
      $$invalidate2(6, required2 = $$props3.required);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("title" in $$props3)
      $$invalidate2(7, title = $$props3.title);
    if ("label" in $$props3)
      $$invalidate2(8, label2 = $$props3.label);
    if ("error" in $$props3)
      $$invalidate2(9, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(10, info2 = $$props3.info);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(11, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("max" in $$props3)
      $$invalidate2(22, max = $$props3.max);
    if ("icon" in $$props3)
      $$invalidate2(12, icon = $$props3.icon);
    if ("light" in $$props3)
      $$invalidate2(13, light = $$props3.light);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("inputElement" in $$props3)
      $$invalidate2(2, inputElement2 = $$props3.inputElement);
    if ("innerBox" in $$props3)
      $$invalidate2(14, innerBox = $$props3.innerBox);
    if ("mouseY" in $$props3)
      mouseY = $$props3.mouseY;
    if ("_id" in $$props3)
      $$invalidate2(15, _id2 = $$props3._id);
    if ("stars" in $$props3)
      $$invalidate2(16, stars = $$props3.stars);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty[0] & /*max*/
    4194304) {
      $:
        $$invalidate2(16, stars = new Array(+max).fill(0).map((_, i) => i + 1));
    }
    if ($$self2.$$.dirty[0] & /*id, name*/
    2097168) {
      $:
        $$invalidate2(15, _id2 = id2 || name2 || guid());
    }
  };
  return [
    value2,
    element3,
    inputElement2,
    className2,
    name2,
    disabled2,
    required2,
    title,
    label2,
    error2,
    info2,
    labelOnTheLeft2,
    icon,
    light,
    innerBox,
    _id2,
    stars,
    errorMessageId2,
    onKey2,
    reset,
    onMouseDown,
    id2,
    max,
    input_handler2,
    focus_handler2,
    blur_handler2,
    input_binding2,
    input_input_handler2,
    div1_binding,
    div2_binding2
  ];
}
var InputRating = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance20,
      create_fragment20,
      safe_not_equal,
      {
        class: 3,
        id: 21,
        name: 4,
        disabled: 5,
        required: 6,
        value: 0,
        title: 7,
        label: 8,
        error: 9,
        info: 10,
        labelOnTheLeft: 11,
        max: 22,
        icon: 12,
        light: 13,
        element: 1,
        inputElement: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputRating",
      options,
      id: create_fragment20.name
    });
  }
  get class() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<InputRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<InputRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputRating_default = InputRating;

// src/input/input-search/InputSearch.svelte
var file16 = "src/input/input-search/InputSearch.svelte";
function create_fragment21(ctx) {
  let div2;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div1;
  let inputerror;
  let t2;
  let div0;
  let icon;
  let t3;
  let input;
  let input_aria_errormessage_value;
  let t4;
  let button;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[6]
      ),
      disabled: (
        /*disabled*/
        ctx[5]
      ),
      for: (
        /*_id*/
        ctx[10]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[8]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[11]
      ),
      msg: (
        /*error*/
        ctx[7]
      )
    },
    $$inline: true
  });
  icon = new Icon_default({
    props: { name: "search" },
    $$inline: true
  });
  let input_levels = [
    { id: (
      /*_id*/
      ctx[10]
    ) },
    { autocomplete: "off" },
    { type: "search" },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    /*$$restProps*/
    ctx[14],
    { "aria-invalid": (
      /*error*/
      ctx[7]
    ) },
    {
      "aria-errormessage": input_aria_errormessage_value = /*error*/
      ctx[7] ? (
        /*errorMessageId*/
        ctx[11]
      ) : void 0
    },
    { "aria-required": (
      /*required*/
      ctx[4]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  button = new Button_default({
    props: {
      link: true,
      icon: "close",
      class: "input-search-button " + /*value*/
      (ctx[0] !== "" && !/*disabled*/
      ctx[5] ? "visible" : "")
    },
    $$inline: true
  });
  button.$on(
    "click",
    /*clear*/
    ctx[12]
  );
  const block = {
    c: function create() {
      div2 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div1 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      div0 = element2("div");
      create_component(icon.$$.fragment);
      t3 = space();
      input = element2("input");
      t4 = space();
      create_component(button.$$.fragment);
      set_attributes(input, input_data);
      add_location(input, file16, 16, 3, 429);
      attr_dev(div0, "class", "input-row");
      add_location(div0, file16, 13, 2, 376);
      attr_dev(div1, "class", "input-inner");
      toggle_class(
        div1,
        "disabled",
        /*disabled*/
        ctx[5]
      );
      add_location(div1, file16, 10, 1, 279);
      attr_dev(div2, "class", div2_class_value = "input input-search " + /*className*/
      ctx[3]);
      toggle_class(
        div2,
        "has-error",
        /*error*/
        ctx[7]
      );
      toggle_class(
        div2,
        "has-value",
        /*value*/
        ctx[0] !== ""
      );
      toggle_class(
        div2,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[9] === true || /*labelOnTheLeft*/
        ctx[9] === "true"
      );
      add_location(div2, file16, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      mount_component(label_1, div2, null);
      append_dev(div2, t0);
      mount_component(info_1, div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      mount_component(inputerror, div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      mount_component(icon, div0, null);
      append_dev(div0, t3);
      append_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[20](input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      append_dev(div0, t4);
      mount_component(button, div0, null);
      ctx[22](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[21]
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*onkeydown*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      const label_1_changes = {};
      if (dirty & /*label*/
      64)
        label_1_changes.label = /*label*/
        ctx2[6];
      if (dirty & /*disabled*/
      32)
        label_1_changes.disabled = /*disabled*/
        ctx2[5];
      if (dirty & /*_id*/
      1024)
        label_1_changes.for = /*_id*/
        ctx2[10];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty & /*info*/
      256)
        info_1_changes.msg = /*info*/
        ctx2[8];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty & /*error*/
      128)
        inputerror_changes.msg = /*error*/
        ctx2[7];
      inputerror.$set(inputerror_changes);
      set_attributes(input, input_data = get_spread_update(input_levels, [
        (!current || dirty & /*_id*/
        1024) && { id: (
          /*_id*/
          ctx2[10]
        ) },
        { autocomplete: "off" },
        { type: "search" },
        (!current || dirty & /*disabled*/
        32) && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        dirty & /*$$restProps*/
        16384 && /*$$restProps*/
        ctx2[14],
        (!current || dirty & /*error*/
        128) && { "aria-invalid": (
          /*error*/
          ctx2[7]
        ) },
        (!current || dirty & /*error*/
        128 && input_aria_errormessage_value !== (input_aria_errormessage_value = /*error*/
        ctx2[7] ? (
          /*errorMessageId*/
          ctx2[11]
        ) : void 0)) && {
          "aria-errormessage": input_aria_errormessage_value
        },
        (!current || dirty & /*required*/
        16) && { "aria-required": (
          /*required*/
          ctx2[4]
        ) }
      ]));
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      const button_changes = {};
      if (dirty & /*value, disabled*/
      33)
        button_changes.class = "input-search-button " + /*value*/
        (ctx2[0] !== "" && !/*disabled*/
        ctx2[5] ? "visible" : "");
      button.$set(button_changes);
      if (!current || dirty & /*disabled*/
      32) {
        toggle_class(
          div1,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*className*/
      8 && div2_class_value !== (div2_class_value = "input input-search " + /*className*/
      ctx2[3])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*className, error*/
      136) {
        toggle_class(
          div2,
          "has-error",
          /*error*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*className, value*/
      9) {
        toggle_class(
          div2,
          "has-value",
          /*value*/
          ctx2[0] !== ""
        );
      }
      if (!current || dirty & /*className, labelOnTheLeft*/
      520) {
        toggle_class(
          div2,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[9] === true || /*labelOnTheLeft*/
          ctx2[9] === "true"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      transition_in(icon.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      transition_out(icon.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      destroy_component(icon);
      ctx[20](null);
      destroy_component(button);
      ctx[22](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self2, $$props2, $$invalidate2) {
  let _id2;
  const omit_props_names2 = [
    "class",
    "id",
    "required",
    "disabled",
    "value",
    "label",
    "error",
    "info",
    "labelOnTheLeft",
    "element",
    "inputElement"
  ];
  let $$restProps2 = compute_rest_props($$props2, omit_props_names2);
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputSearch", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { required: required2 = void 0 } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { value: value2 = "" } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { inputElement: inputElement2 = void 0 } = $$props2;
  const errorMessageId2 = guid();
  function clear() {
    $$invalidate2(0, value2 = "");
  }
  function onkeydown2(event) {
    if (event.key === "Escape")
      clear();
  }
  function input_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function focus_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function blur_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function input_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(2, inputElement2);
    });
  }
  function input_input_handler2() {
    value2 = this.value;
    $$invalidate2(0, value2);
  }
  function div2_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$new_props) => {
    $$props2 = assign(assign({}, $$props2), exclude_internal_props($$new_props));
    $$invalidate2(14, $$restProps2 = compute_rest_props($$props2, omit_props_names2));
    if ("class" in $$new_props)
      $$invalidate2(3, className2 = $$new_props.class);
    if ("id" in $$new_props)
      $$invalidate2(15, id2 = $$new_props.id);
    if ("required" in $$new_props)
      $$invalidate2(4, required2 = $$new_props.required);
    if ("disabled" in $$new_props)
      $$invalidate2(5, disabled2 = $$new_props.disabled);
    if ("value" in $$new_props)
      $$invalidate2(0, value2 = $$new_props.value);
    if ("label" in $$new_props)
      $$invalidate2(6, label2 = $$new_props.label);
    if ("error" in $$new_props)
      $$invalidate2(7, error2 = $$new_props.error);
    if ("info" in $$new_props)
      $$invalidate2(8, info2 = $$new_props.info);
    if ("labelOnTheLeft" in $$new_props)
      $$invalidate2(9, labelOnTheLeft2 = $$new_props.labelOnTheLeft);
    if ("element" in $$new_props)
      $$invalidate2(1, element3 = $$new_props.element);
    if ("inputElement" in $$new_props)
      $$invalidate2(2, inputElement2 = $$new_props.inputElement);
  };
  $$self2.$capture_state = () => ({
    guid,
    Button: Button_default,
    Icon: Icon_default,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    id: id2,
    required: required2,
    disabled: disabled2,
    value: value2,
    label: label2,
    error: error2,
    info: info2,
    labelOnTheLeft: labelOnTheLeft2,
    element: element3,
    inputElement: inputElement2,
    errorMessageId: errorMessageId2,
    clear,
    onkeydown: onkeydown2,
    _id: _id2
  });
  $$self2.$inject_state = ($$new_props) => {
    if ("className" in $$props2)
      $$invalidate2(3, className2 = $$new_props.className);
    if ("id" in $$props2)
      $$invalidate2(15, id2 = $$new_props.id);
    if ("required" in $$props2)
      $$invalidate2(4, required2 = $$new_props.required);
    if ("disabled" in $$props2)
      $$invalidate2(5, disabled2 = $$new_props.disabled);
    if ("value" in $$props2)
      $$invalidate2(0, value2 = $$new_props.value);
    if ("label" in $$props2)
      $$invalidate2(6, label2 = $$new_props.label);
    if ("error" in $$props2)
      $$invalidate2(7, error2 = $$new_props.error);
    if ("info" in $$props2)
      $$invalidate2(8, info2 = $$new_props.info);
    if ("labelOnTheLeft" in $$props2)
      $$invalidate2(9, labelOnTheLeft2 = $$new_props.labelOnTheLeft);
    if ("element" in $$props2)
      $$invalidate2(1, element3 = $$new_props.element);
    if ("inputElement" in $$props2)
      $$invalidate2(2, inputElement2 = $$new_props.inputElement);
    if ("_id" in $$props2)
      $$invalidate2(10, _id2 = $$new_props._id);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*id*/
    32768) {
      $:
        $$invalidate2(10, _id2 = id2 || name || guid());
    }
  };
  return [
    value2,
    element3,
    inputElement2,
    className2,
    required2,
    disabled2,
    label2,
    error2,
    info2,
    labelOnTheLeft2,
    _id2,
    errorMessageId2,
    clear,
    onkeydown2,
    $$restProps2,
    id2,
    input_handler2,
    change_handler,
    focus_handler2,
    blur_handler2,
    input_binding2,
    input_input_handler2,
    div2_binding2
  ];
}
var InputSearch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {
      class: 3,
      id: 15,
      required: 4,
      disabled: 5,
      value: 0,
      label: 6,
      error: 7,
      info: 8,
      labelOnTheLeft: 9,
      element: 1,
      inputElement: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputSearch",
      options,
      id: create_fragment21.name
    });
  }
  get class() {
    throw new Error("<InputSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<InputSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InputSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<InputSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<InputSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value2) {
    throw new Error("<InputSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<InputSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<InputSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<InputSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<InputSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<InputSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<InputSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<InputSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<InputSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<InputSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<InputSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<InputSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<InputSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<InputSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<InputSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<InputSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<InputSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputSearch_default = InputSearch;

// src/input/input-text/InputText.svelte
var file17 = "src/input/input-text/InputText.svelte";
function create_fragment22(ctx) {
  let div1;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div0;
  let inputerror;
  let t2;
  let input;
  let input_aria_errormessage_value;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[6]
      ),
      disabled: (
        /*disabled*/
        ctx[5]
      ),
      for: (
        /*_id*/
        ctx[10]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[8]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[11]
      ),
      msg: (
        /*error*/
        ctx[7]
      )
    },
    $$inline: true
  });
  let input_levels = [
    { id: (
      /*_id*/
      ctx[10]
    ) },
    { autocomplete: "off" },
    { type: "text" },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    /*$$restProps*/
    ctx[12],
    { "aria-invalid": (
      /*error*/
      ctx[7]
    ) },
    {
      "aria-errormessage": input_aria_errormessage_value = /*error*/
      ctx[7] ? (
        /*errorMessageId*/
        ctx[11]
      ) : void 0
    },
    { "aria-required": (
      /*required*/
      ctx[4]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div0 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      input = element2("input");
      set_attributes(input, input_data);
      add_location(input, file17, 12, 2, 340);
      attr_dev(div0, "class", "input-inner");
      toggle_class(
        div0,
        "disabled",
        /*disabled*/
        ctx[5]
      );
      add_location(div0, file17, 9, 1, 243);
      attr_dev(div1, "class", div1_class_value = "input input-text " + /*className*/
      ctx[3]);
      toggle_class(
        div1,
        "has-error",
        /*error*/
        ctx[7]
      );
      toggle_class(
        div1,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[9] === true || /*labelOnTheLeft*/
        ctx[9] === "true"
      );
      add_location(div1, file17, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      mount_component(label_1, div1, null);
      append_dev(div1, t0);
      mount_component(info_1, div1, null);
      append_dev(div1, t1);
      append_dev(div1, div0);
      mount_component(inputerror, div0, null);
      append_dev(div0, t2);
      append_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[19](input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[21](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[20]
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      const label_1_changes = {};
      if (dirty & /*label*/
      64)
        label_1_changes.label = /*label*/
        ctx2[6];
      if (dirty & /*disabled*/
      32)
        label_1_changes.disabled = /*disabled*/
        ctx2[5];
      if (dirty & /*_id*/
      1024)
        label_1_changes.for = /*_id*/
        ctx2[10];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty & /*info*/
      256)
        info_1_changes.msg = /*info*/
        ctx2[8];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty & /*error*/
      128)
        inputerror_changes.msg = /*error*/
        ctx2[7];
      inputerror.$set(inputerror_changes);
      set_attributes(input, input_data = get_spread_update(input_levels, [
        (!current || dirty & /*_id*/
        1024) && { id: (
          /*_id*/
          ctx2[10]
        ) },
        { autocomplete: "off" },
        { type: "text" },
        (!current || dirty & /*disabled*/
        32) && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12],
        (!current || dirty & /*error*/
        128) && { "aria-invalid": (
          /*error*/
          ctx2[7]
        ) },
        (!current || dirty & /*error*/
        128 && input_aria_errormessage_value !== (input_aria_errormessage_value = /*error*/
        ctx2[7] ? (
          /*errorMessageId*/
          ctx2[11]
        ) : void 0)) && {
          "aria-errormessage": input_aria_errormessage_value
        },
        (!current || dirty & /*required*/
        16) && { "aria-required": (
          /*required*/
          ctx2[4]
        ) }
      ]));
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*disabled*/
      32) {
        toggle_class(
          div0,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*className*/
      8 && div1_class_value !== (div1_class_value = "input input-text " + /*className*/
      ctx2[3])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*className, error*/
      136) {
        toggle_class(
          div1,
          "has-error",
          /*error*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*className, labelOnTheLeft*/
      520) {
        toggle_class(
          div1,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[9] === true || /*labelOnTheLeft*/
          ctx2[9] === "true"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      ctx[19](null);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self2, $$props2, $$invalidate2) {
  let _id2;
  const omit_props_names2 = [
    "class",
    "id",
    "required",
    "disabled",
    "value",
    "label",
    "error",
    "info",
    "labelOnTheLeft",
    "element",
    "inputElement"
  ];
  let $$restProps2 = compute_rest_props($$props2, omit_props_names2);
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputText", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { required: required2 = void 0 } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { value: value2 = "" } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { inputElement: inputElement2 = void 0 } = $$props2;
  const errorMessageId2 = guid();
  function input_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function focus_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function blur_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function input_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(2, inputElement2);
    });
  }
  function input_input_handler2() {
    value2 = this.value;
    $$invalidate2(0, value2);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$new_props) => {
    $$props2 = assign(assign({}, $$props2), exclude_internal_props($$new_props));
    $$invalidate2(12, $$restProps2 = compute_rest_props($$props2, omit_props_names2));
    if ("class" in $$new_props)
      $$invalidate2(3, className2 = $$new_props.class);
    if ("id" in $$new_props)
      $$invalidate2(13, id2 = $$new_props.id);
    if ("required" in $$new_props)
      $$invalidate2(4, required2 = $$new_props.required);
    if ("disabled" in $$new_props)
      $$invalidate2(5, disabled2 = $$new_props.disabled);
    if ("value" in $$new_props)
      $$invalidate2(0, value2 = $$new_props.value);
    if ("label" in $$new_props)
      $$invalidate2(6, label2 = $$new_props.label);
    if ("error" in $$new_props)
      $$invalidate2(7, error2 = $$new_props.error);
    if ("info" in $$new_props)
      $$invalidate2(8, info2 = $$new_props.info);
    if ("labelOnTheLeft" in $$new_props)
      $$invalidate2(9, labelOnTheLeft2 = $$new_props.labelOnTheLeft);
    if ("element" in $$new_props)
      $$invalidate2(1, element3 = $$new_props.element);
    if ("inputElement" in $$new_props)
      $$invalidate2(2, inputElement2 = $$new_props.inputElement);
  };
  $$self2.$capture_state = () => ({
    guid,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    id: id2,
    required: required2,
    disabled: disabled2,
    value: value2,
    label: label2,
    error: error2,
    info: info2,
    labelOnTheLeft: labelOnTheLeft2,
    element: element3,
    inputElement: inputElement2,
    errorMessageId: errorMessageId2,
    _id: _id2
  });
  $$self2.$inject_state = ($$new_props) => {
    if ("className" in $$props2)
      $$invalidate2(3, className2 = $$new_props.className);
    if ("id" in $$props2)
      $$invalidate2(13, id2 = $$new_props.id);
    if ("required" in $$props2)
      $$invalidate2(4, required2 = $$new_props.required);
    if ("disabled" in $$props2)
      $$invalidate2(5, disabled2 = $$new_props.disabled);
    if ("value" in $$props2)
      $$invalidate2(0, value2 = $$new_props.value);
    if ("label" in $$props2)
      $$invalidate2(6, label2 = $$new_props.label);
    if ("error" in $$props2)
      $$invalidate2(7, error2 = $$new_props.error);
    if ("info" in $$props2)
      $$invalidate2(8, info2 = $$new_props.info);
    if ("labelOnTheLeft" in $$props2)
      $$invalidate2(9, labelOnTheLeft2 = $$new_props.labelOnTheLeft);
    if ("element" in $$props2)
      $$invalidate2(1, element3 = $$new_props.element);
    if ("inputElement" in $$props2)
      $$invalidate2(2, inputElement2 = $$new_props.inputElement);
    if ("_id" in $$props2)
      $$invalidate2(10, _id2 = $$new_props._id);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*id*/
    8192) {
      $:
        $$invalidate2(10, _id2 = id2 || name || guid());
    }
  };
  return [
    value2,
    element3,
    inputElement2,
    className2,
    required2,
    disabled2,
    label2,
    error2,
    info2,
    labelOnTheLeft2,
    _id2,
    errorMessageId2,
    $$restProps2,
    id2,
    input_handler2,
    keydown_handler,
    change_handler,
    focus_handler2,
    blur_handler2,
    input_binding2,
    input_input_handler2,
    div1_binding
  ];
}
var InputText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {
      class: 3,
      id: 13,
      required: 4,
      disabled: 5,
      value: 0,
      label: 6,
      error: 7,
      info: 8,
      labelOnTheLeft: 9,
      element: 1,
      inputElement: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputText",
      options,
      id: create_fragment22.name
    });
  }
  get class() {
    throw new Error("<InputText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<InputText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InputText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<InputText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<InputText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value2) {
    throw new Error("<InputText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<InputText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<InputText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<InputText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<InputText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<InputText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<InputText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<InputText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<InputText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<InputText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<InputText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<InputText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<InputText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<InputText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<InputText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<InputText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<InputText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputText_default = InputText;

// src/popover/utils.js
function addArias(el) {
  if (!el)
    return;
  el.setAttribute("aria-haspopup", "true");
  el.setAttribute("aria-expanded", "true");
}
function removeArias(selectorOrEl) {
  if (typeof selectorOrEl === "string" && selectorOrEl !== "body") {
    const elems = document.querySelectorAll(selectorOrEl);
    if (elems && elems.length)
      elems.forEach((el) => el.setAttribute("aria-expanded", "false"));
  } else if (selectorOrEl instanceof Element) {
    selectorOrEl.setAttribute("aria-expanded", "false");
  }
}

// src/popover/Popover.svelte
var file18 = "src/popover/Popover.svelte";
function create_if_block10(ctx) {
  let div4;
  let div3;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let div4_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  const block = {
    c: function create() {
      div4 = element2("div");
      div3 = element2("div");
      div0 = element2("div");
      t0 = space();
      div1 = element2("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      div2 = element2("div");
      attr_dev(div0, "tabindex", "0");
      attr_dev(div0, "class", "focus-trap focus-trap-top");
      add_location(div0, file18, 7, 3, 226);
      attr_dev(div1, "class", "popover-content");
      add_location(div1, file18, 8, 3, 311);
      attr_dev(div2, "tabindex", "0");
      attr_dev(div2, "class", "focus-trap focus-trap-bottom");
      add_location(div2, file18, 11, 3, 390);
      attr_dev(div3, "class", "popover");
      add_location(div3, file18, 6, 2, 201);
      attr_dev(div4, "class", div4_class_value = "popover-plate popover-" + /*_position*/
      ctx[6] + " " + /*className*/
      ctx[2] + " " + /*hideTip*/
      (ctx[3] ? "hide-tip" : ""));
      toggle_class(
        div4,
        "opening",
        /*opening*/
        ctx[5]
      );
      add_location(div4, file18, 2, 1, 69);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div4, anchor);
      append_dev(div4, div3);
      append_dev(div3, div0);
      append_dev(div3, t0);
      append_dev(div3, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      ctx[19](div1);
      append_dev(div3, t1);
      append_dev(div3, div2);
      ctx[20](div4);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div0,
            "focus",
            /*focusLast*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "focus",
            /*focusFirst*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*_position, className, hideTip*/
      76 && div4_class_value !== (div4_class_value = "popover-plate popover-" + /*_position*/
      ctx2[6] + " " + /*className*/
      ctx2[2] + " " + /*hideTip*/
      (ctx2[3] ? "hide-tip" : ""))) {
        attr_dev(div4, "class", div4_class_value);
      }
      if (!current || dirty[0] & /*_position, className, hideTip, opening*/
      108) {
        toggle_class(
          div4,
          "opening",
          /*opening*/
          ctx2[5]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div4);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[19](null);
      ctx[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(2:0) {#if opened}",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*opened*/
    ctx[4] && create_if_block10(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (
        /*opened*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*opened*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block10(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Popover", slots2, ["default"]);
  const dispatch3 = createEventDispatcher();
  let { class: className2 = "" } = $$props2;
  let { offset = 2 } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { contentEl = void 0 } = $$props2;
  let { position = "bottom" } = $$props2;
  let { hideTip = false } = $$props2;
  let { dontHideOnTargetClick = false } = $$props2;
  let { setMinWidthToTarget = false } = $$props2;
  let targetEl, opened = false;
  let opening = false, closing = false;
  let eventsAdded = false;
  let _position = position;
  const observer = new MutationObserver(updatePosition);
  function updatePosition() {
    if (!opened)
      return;
    $$invalidate2(6, _position = alignItem({
      element: element3,
      target: targetEl,
      alignH: "center",
      alignV: position,
      offsetV: +offset,
      setMinWidthToTarget
    }));
  }
  const isOpened = () => opened;
  function open(e) {
    if (closing)
      return Promise.resolve();
    if (opened)
      return close();
    $$invalidate2(4, opened = true);
    $$invalidate2(5, opening = true);
    if (e && e.detail && e.detail instanceof Event)
      e = e.detail;
    if (e instanceof Event)
      targetEl = e && e.target;
    if (e instanceof HTMLElement)
      targetEl = e;
    if (targetEl)
      addArias(targetEl);
    return new Promise((resolve) => requestAnimationFrame(() => {
      if (element3 && element3.parentElement !== document.body) {
        document.body.appendChild(element3);
      }
      updatePosition();
      focusFirst();
      addEventListeners();
      requestAnimationFrame(() => {
        updatePosition();
        $$invalidate2(5, opening = false);
      });
      dispatch3("open", { event: e, target: targetEl });
      resolve();
    }));
  }
  function close() {
    if (!opened)
      return Promise.resolve();
    if (targetEl)
      targetEl.focus();
    $$invalidate2(4, opened = false);
    closing = true;
    removeArias(targetEl);
    return new Promise((resolve) => requestAnimationFrame(() => {
      removeEventListeners();
      resolve();
      dispatch3("close", { target: targetEl });
      setTimeout(() => closing = false, 300);
    }));
  }
  function focusFirst() {
    let first = getFocusableElements().shift();
    const last = getFocusableElements().pop();
    if (!first && !last) {
      contentEl.setAttribute("tabindex", 0);
      first = contentEl;
    }
    if (first)
      first.focus();
  }
  function focusLast() {
    const first = getFocusableElements().shift();
    let last = getFocusableElements().pop();
    if (!first && !last) {
      contentEl.setAttribute("tabindex", 0);
      last = contentEl;
    }
    if (last)
      last.focus();
  }
  function getFocusableElements() {
    if (!contentEl)
      return [];
    return Array.from(contentEl.querySelectorAll(FOCUSABLE_SELECTOR));
  }
  const throttledResize = throttle(updatePosition, 50);
  const debouncedResize = debounce(updatePosition, 50);
  function onResize() {
    throttledResize();
    debouncedResize();
  }
  function onDocumentClick(e) {
    if (!element3)
      return;
    if (element3.contains(e.target))
      return;
    if (dontHideOnTargetClick && targetEl && (targetEl === e.target || targetEl.contains(e.target)))
      return;
    close();
  }
  function onKeydown2(e) {
    const hasFocus = element3.contains(document.activeElement);
    if (e.key === "Tab") {
      e.stopPropagation();
      if (!hasFocus)
        focusFirst();
      return;
    }
    if (e.key === "Escape") {
      e.stopPropagation();
      return close();
    }
  }
  function addEventListeners() {
    if (eventsAdded)
      return;
    document.addEventListener("click", onDocumentClick, true);
    document.addEventListener("keydown", onKeydown2, true);
    window.addEventListener("resize", onResize);
    window.addEventListener("scroll", onResize, true);
    observer.observe(element3, {
      attributes: false,
      childList: true,
      subtree: true
    });
    eventsAdded = true;
  }
  function removeEventListeners() {
    document.removeEventListener("click", onDocumentClick, true);
    document.removeEventListener("keydown", onKeydown2, true);
    window.removeEventListener("resize", onResize);
    window.removeEventListener("scroll", onResize, true);
    observer.disconnect();
    eventsAdded = false;
  }
  const writable_props = [
    "class",
    "offset",
    "element",
    "contentEl",
    "position",
    "hideTip",
    "dontHideOnTargetClick",
    "setMinWidthToTarget"
  ];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Popover> was created with unknown prop '${key}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentEl = $$value;
      $$invalidate2(1, contentEl);
    });
  }
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(2, className2 = $$props3.class);
    if ("offset" in $$props3)
      $$invalidate2(9, offset = $$props3.offset);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("contentEl" in $$props3)
      $$invalidate2(1, contentEl = $$props3.contentEl);
    if ("position" in $$props3)
      $$invalidate2(10, position = $$props3.position);
    if ("hideTip" in $$props3)
      $$invalidate2(3, hideTip = $$props3.hideTip);
    if ("dontHideOnTargetClick" in $$props3)
      $$invalidate2(11, dontHideOnTargetClick = $$props3.dontHideOnTargetClick);
    if ("setMinWidthToTarget" in $$props3)
      $$invalidate2(12, setMinWidthToTarget = $$props3.setMinWidthToTarget);
    if ("$$scope" in $$props3)
      $$invalidate2(17, $$scope2 = $$props3.$$scope);
  };
  $$self2.$capture_state = () => ({
    createEventDispatcher,
    addArias,
    removeArias,
    alignItem,
    throttle,
    debounce,
    FOCUSABLE_SELECTOR,
    dispatch: dispatch3,
    className: className2,
    offset,
    element: element3,
    contentEl,
    position,
    hideTip,
    dontHideOnTargetClick,
    setMinWidthToTarget,
    targetEl,
    opened,
    opening,
    closing,
    eventsAdded,
    _position,
    observer,
    updatePosition,
    isOpened,
    open,
    close,
    focusFirst,
    focusLast,
    getFocusableElements,
    throttledResize,
    debouncedResize,
    onResize,
    onDocumentClick,
    onKeydown: onKeydown2,
    addEventListeners,
    removeEventListeners
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(2, className2 = $$props3.className);
    if ("offset" in $$props3)
      $$invalidate2(9, offset = $$props3.offset);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("contentEl" in $$props3)
      $$invalidate2(1, contentEl = $$props3.contentEl);
    if ("position" in $$props3)
      $$invalidate2(10, position = $$props3.position);
    if ("hideTip" in $$props3)
      $$invalidate2(3, hideTip = $$props3.hideTip);
    if ("dontHideOnTargetClick" in $$props3)
      $$invalidate2(11, dontHideOnTargetClick = $$props3.dontHideOnTargetClick);
    if ("setMinWidthToTarget" in $$props3)
      $$invalidate2(12, setMinWidthToTarget = $$props3.setMinWidthToTarget);
    if ("targetEl" in $$props3)
      targetEl = $$props3.targetEl;
    if ("opened" in $$props3)
      $$invalidate2(4, opened = $$props3.opened);
    if ("opening" in $$props3)
      $$invalidate2(5, opening = $$props3.opening);
    if ("closing" in $$props3)
      closing = $$props3.closing;
    if ("eventsAdded" in $$props3)
      eventsAdded = $$props3.eventsAdded;
    if ("_position" in $$props3)
      $$invalidate2(6, _position = $$props3._position);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    element3,
    contentEl,
    className2,
    hideTip,
    opened,
    opening,
    _position,
    focusFirst,
    focusLast,
    offset,
    position,
    dontHideOnTargetClick,
    setMinWidthToTarget,
    updatePosition,
    isOpened,
    open,
    close,
    $$scope2,
    slots2,
    div1_binding,
    div4_binding
  ];
}
var Popover = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance23,
      create_fragment23,
      safe_not_equal,
      {
        class: 2,
        offset: 9,
        element: 0,
        contentEl: 1,
        position: 10,
        hideTip: 3,
        dontHideOnTargetClick: 11,
        setMinWidthToTarget: 12,
        updatePosition: 13,
        isOpened: 14,
        open: 15,
        close: 16
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popover",
      options,
      id: create_fragment23.name
    });
  }
  get class() {
    return this.$$.ctx[2];
  }
  set class(className2) {
    this.$$set({ class: className2 });
    flush();
  }
  get offset() {
    return this.$$.ctx[9];
  }
  set offset(offset) {
    this.$$set({ offset });
    flush();
  }
  get element() {
    return this.$$.ctx[0];
  }
  set element(element3) {
    this.$$set({ element: element3 });
    flush();
  }
  get contentEl() {
    return this.$$.ctx[1];
  }
  set contentEl(contentEl) {
    this.$$set({ contentEl });
    flush();
  }
  get position() {
    return this.$$.ctx[10];
  }
  set position(position) {
    this.$$set({ position });
    flush();
  }
  get hideTip() {
    return this.$$.ctx[3];
  }
  set hideTip(hideTip) {
    this.$$set({ hideTip });
    flush();
  }
  get dontHideOnTargetClick() {
    return this.$$.ctx[11];
  }
  set dontHideOnTargetClick(dontHideOnTargetClick) {
    this.$$set({ dontHideOnTargetClick });
    flush();
  }
  get setMinWidthToTarget() {
    return this.$$.ctx[12];
  }
  set setMinWidthToTarget(setMinWidthToTarget) {
    this.$$set({ setMinWidthToTarget });
    flush();
  }
  get updatePosition() {
    return this.$$.ctx[13];
  }
  set updatePosition(value2) {
    throw new Error("<Popover>: Cannot set read-only property 'updatePosition'");
  }
  get isOpened() {
    return this.$$.ctx[14];
  }
  set isOpened(value2) {
    throw new Error("<Popover>: Cannot set read-only property 'isOpened'");
  }
  get open() {
    return this.$$.ctx[15];
  }
  set open(value2) {
    throw new Error("<Popover>: Cannot set read-only property 'open'");
  }
  get close() {
    return this.$$.ctx[16];
  }
  set close(value2) {
    throw new Error("<Popover>: Cannot set read-only property 'close'");
  }
};
var Popover_default = Popover;

// src/tag/Tag.svelte
var file19 = "src/tag/Tag.svelte";
function create_if_block11(ctx) {
  let icon_1;
  let current;
  icon_1 = new Icon_default({
    props: { name: (
      /*icon*/
      ctx[3]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(icon_1, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const icon_1_changes = {};
      if (dirty & /*icon*/
      8)
        icon_1_changes.name = /*icon*/
        ctx2[3];
      icon_1.$set(icon_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(15:1) {#if icon}",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let div1;
  let t;
  let div0;
  let div1_class_value;
  let div1_style_value;
  let div1_tabindex_value;
  let div1_inert_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*icon*/
    ctx[3] && create_if_block11(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const block = {
    c: function create() {
      div1 = element2("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element2("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div0, "class", "ui-tag-label");
      add_location(div0, file19, 17, 1, 454);
      attr_dev(div1, "class", div1_class_value = "ui-tag " + /*className*/
      ctx[1] + " " + /*colorClass*/
      ctx[7]);
      attr_dev(div1, "style", div1_style_value = /*color*/
      ctx[4] ? `background-color: ${/*color*/
      ctx[4]};` : "");
      attr_dev(div1, "role", "button");
      attr_dev(div1, "tabindex", div1_tabindex_value = /*disabled*/
      ctx[5] || !/*clickable*/
      ctx[6] ? void 0 : 0);
      div1.inert = div1_inert_value = /*disabled*/
      ctx[5] || !/*clickable*/
      ctx[6];
      toggle_class(
        div1,
        "round",
        /*round*/
        ctx[2]
      );
      toggle_class(
        div1,
        "dark",
        /*color*/
        ctx[4] && isColorDark(
          /*color*/
          ctx[4]
        )
      );
      toggle_class(
        div1,
        "light",
        /*color*/
        ctx[4] && !isColorDark(
          /*color*/
          ctx[4]
        )
      );
      toggle_class(
        div1,
        "disabled",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        div1,
        "clickable",
        /*clickable*/
        ctx[6]
      );
      add_location(div1, file19, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append_dev(div1, t);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[12](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "keydown",
            /*onkeydown*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "click",
            /*onclick*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      if (
        /*icon*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*icon*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block11(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*className, colorClass*/
      130 && div1_class_value !== (div1_class_value = "ui-tag " + /*className*/
      ctx2[1] + " " + /*colorClass*/
      ctx2[7])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*color*/
      16 && div1_style_value !== (div1_style_value = /*color*/
      ctx2[4] ? `background-color: ${/*color*/
      ctx2[4]};` : "")) {
        attr_dev(div1, "style", div1_style_value);
      }
      if (!current || dirty & /*disabled, clickable*/
      96 && div1_tabindex_value !== (div1_tabindex_value = /*disabled*/
      ctx2[5] || !/*clickable*/
      ctx2[6] ? void 0 : 0)) {
        attr_dev(div1, "tabindex", div1_tabindex_value);
      }
      if (!current || dirty & /*disabled, clickable*/
      96 && div1_inert_value !== (div1_inert_value = /*disabled*/
      ctx2[5] || !/*clickable*/
      ctx2[6])) {
        prop_dev(div1, "inert", div1_inert_value);
      }
      if (!current || dirty & /*className, colorClass, round*/
      134) {
        toggle_class(
          div1,
          "round",
          /*round*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*className, colorClass, color*/
      146) {
        toggle_class(
          div1,
          "dark",
          /*color*/
          ctx2[4] && isColorDark(
            /*color*/
            ctx2[4]
          )
        );
      }
      if (!current || dirty & /*className, colorClass, color*/
      146) {
        toggle_class(
          div1,
          "light",
          /*color*/
          ctx2[4] && !isColorDark(
            /*color*/
            ctx2[4]
          )
        );
      }
      if (!current || dirty & /*className, colorClass, disabled*/
      162) {
        toggle_class(
          div1,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*className, colorClass, clickable*/
      194) {
        toggle_class(
          div1,
          "clickable",
          /*clickable*/
          ctx2[6]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self2, $$props2, $$invalidate2) {
  let colorClass;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Tag", slots2, ["default"]);
  const dispatch3 = createEventDispatcher();
  let { class: className2 = "" } = $$props2;
  let { round = false } = $$props2;
  let { icon = void 0 } = $$props2;
  let { color = void 0 } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { clickable = false } = $$props2;
  function onclick4(e) {
    dispatch3("click", { target: element3, originalEvent: e });
  }
  function onkeydown2(e) {
    if (e.key === "Enter" || e.key === " ")
      onclick4(e);
  }
  const writable_props = ["class", "round", "icon", "color", "element", "disabled", "clickable"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tag> was created with unknown prop '${key}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("round" in $$props3)
      $$invalidate2(2, round = $$props3.round);
    if ("icon" in $$props3)
      $$invalidate2(3, icon = $$props3.icon);
    if ("color" in $$props3)
      $$invalidate2(4, color = $$props3.color);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("disabled" in $$props3)
      $$invalidate2(5, disabled2 = $$props3.disabled);
    if ("clickable" in $$props3)
      $$invalidate2(6, clickable = $$props3.clickable);
    if ("$$scope" in $$props3)
      $$invalidate2(10, $$scope2 = $$props3.$$scope);
  };
  $$self2.$capture_state = () => ({
    createEventDispatcher,
    Icon: Icon_default,
    isColorDark,
    dispatch: dispatch3,
    className: className2,
    round,
    icon,
    color,
    element: element3,
    disabled: disabled2,
    clickable,
    onclick: onclick4,
    onkeydown: onkeydown2,
    colorClass
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("round" in $$props3)
      $$invalidate2(2, round = $$props3.round);
    if ("icon" in $$props3)
      $$invalidate2(3, icon = $$props3.icon);
    if ("color" in $$props3)
      $$invalidate2(4, color = $$props3.color);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("disabled" in $$props3)
      $$invalidate2(5, disabled2 = $$props3.disabled);
    if ("clickable" in $$props3)
      $$invalidate2(6, clickable = $$props3.clickable);
    if ("colorClass" in $$props3)
      $$invalidate2(7, colorClass = $$props3.colorClass);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*color*/
    16) {
      $:
        $$invalidate2(7, colorClass = ["info", "warning", "danger", "success"].includes(color) ? color : "");
    }
  };
  return [
    element3,
    className2,
    round,
    icon,
    color,
    disabled2,
    clickable,
    colorClass,
    onclick4,
    onkeydown2,
    $$scope2,
    slots2,
    div1_binding
  ];
}
var Tag = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {
      class: 1,
      round: 2,
      icon: 3,
      color: 4,
      element: 0,
      disabled: 5,
      clickable: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tag",
      options,
      id: create_fragment24.name
    });
  }
  get class() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get round() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set round(value2) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value2) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value2) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clickable() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clickable(value2) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tag_default = Tag;

// src/input/input-tag/InputTag.svelte
var file20 = "src/input/input-tag/InputTag.svelte";
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i];
  return child_ctx;
}
function create_default_slot_2(ctx) {
  let t_value = (
    /*tag*/
    ctx[41] + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (dirty[0] & /*_value*/
      65536 && t_value !== (t_value = /*tag*/
      ctx2[41] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: '(27:4) <Tag icon=\\"close\\" clickable on:click=\\"{e => removeTagFromValue(tag, e)}\\">',
    ctx
  });
  return block;
}
function create_each_block_12(ctx) {
  let tag_1;
  let current;
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[27](
        /*tag*/
        ctx[41],
        ...args
      )
    );
  }
  tag_1 = new Tag_default({
    props: {
      icon: "close",
      clickable: true,
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tag_1.$on("click", click_handler);
  const block = {
    c: function create() {
      create_component(tag_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tag_1, target, anchor);
      current = true;
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      const tag_1_changes = {};
      if (dirty[0] & /*_value*/
      65536 | dirty[1] & /*$$scope*/
      32768) {
        tag_1_changes.$$scope = { dirty, ctx };
      }
      tag_1.$set(tag_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tag_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tag_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tag_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_12.name,
    type: "each",
    source: "(26:3) {#each _value as tag}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let t_value = (
    /*tag*/
    ctx[41].text + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (dirty[0] & /*_tags*/
      32768 && t_value !== (t_value = /*tag*/
      ctx2[41].text + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: '(52:3) <Tag clickable icon=\\"add\\" disabled=\\"{tag.disabled}\\" on:click=\\"{() => addTagToValue(tag.text)}\\">',
    ctx
  });
  return block;
}
function create_each_block4(key_1, ctx) {
  let first;
  let tag_1;
  let current;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[32](
        /*tag*/
        ctx[41]
      )
    );
  }
  tag_1 = new Tag_default({
    props: {
      clickable: true,
      icon: "add",
      disabled: (
        /*tag*/
        ctx[41].disabled
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tag_1.$on("click", click_handler_1);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(tag_1.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(tag_1, target, anchor);
      current = true;
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      const tag_1_changes = {};
      if (dirty[0] & /*_tags*/
      32768)
        tag_1_changes.disabled = /*tag*/
        ctx[41].disabled;
      if (dirty[0] & /*_tags*/
      32768 | dirty[1] & /*$$scope*/
      32768) {
        tag_1_changes.$$scope = { dirty, ctx };
      }
      tag_1.$set(tag_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tag_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tag_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(tag_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(51:2) {#each _tags as tag(tag.text)}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let form;
  let inputtext;
  let updating_value;
  let t1;
  let button;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(
    /*_tags*/
    ctx[15]
  );
  const get_key = (ctx2) => (
    /*tag*/
    ctx2[41].text
  );
  validate_each_keys(ctx, each_value, get_each_context4, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block4(key, child_ctx));
  }
  function inputtext_value_binding(value2) {
    ctx[33](value2);
  }
  let inputtext_props = {};
  if (
    /*newTagName*/
    ctx[13] !== void 0
  ) {
    inputtext_props.value = /*newTagName*/
    ctx[13];
  }
  inputtext = new InputText_default({ props: inputtext_props, $$inline: true });
  binding_callbacks.push(() => bind(inputtext, "value", inputtext_value_binding));
  button = new Button_default({
    props: { submit: true, link: true, icon: "add" },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element2("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      form = element2("form");
      create_component(inputtext.$$.fragment);
      t1 = space();
      create_component(button.$$.fragment);
      attr_dev(div, "class", "input-tag-list-tags");
      add_location(div, file20, 49, 1, 1083);
      attr_dev(form, "class", "input-tag-list-add-row");
      add_location(form, file20, 54, 1, 1284);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      insert_dev(target, t0, anchor);
      insert_dev(target, form, anchor);
      mount_component(inputtext, form, null);
      append_dev(form, t1);
      mount_component(button, form, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(form, "submit", prevent_default(
          /*addNewTag*/
          ctx[24]
        ), false, true, false, false);
        mounted = true;
      }
    },
    p: function update2(ctx2, dirty) {
      if (dirty[0] & /*_tags, addTagToValue*/
      4227072) {
        each_value = ensure_array_like_dev(
          /*_tags*/
          ctx2[15]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context4, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block4, null, get_each_context4);
        check_outros();
      }
      const inputtext_changes = {};
      if (!updating_value && dirty[0] & /*newTagName*/
      8192) {
        updating_value = true;
        inputtext_changes.value = /*newTagName*/
        ctx2[13];
        add_flush_callback(() => updating_value = false);
      }
      inputtext.$set(inputtext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(inputtext.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(inputtext.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t0);
        detach_dev(form);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      destroy_component(inputtext);
      destroy_component(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: '(41:0) <Popover  hideTip  dontHideOnTargetClick  setMinWidthToTarget  class=\\"input-tag-popover\\"  on:close=\\"{onclose}\\"  bind:element=\\"{listElement}\\"  bind:this=\\"{listPopover}\\">',
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let div2;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div1;
  let inputerror;
  let t2;
  let div0;
  let icon;
  let t3;
  let t4;
  let input;
  let div2_class_value;
  let t5;
  let popover;
  let updating_element;
  let current;
  let mounted;
  let dispose;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[9]
      ),
      disabled: (
        /*disabled*/
        ctx[7]
      ),
      for: (
        /*_id*/
        ctx[17]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[11]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[18]
      ),
      msg: (
        /*error*/
        ctx[10]
      )
    },
    $$inline: true
  });
  icon = new Icon_default({ props: { name: "tag" }, $$inline: true });
  let each_value_1 = ensure_array_like_dev(
    /*_value*/
    ctx[16]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  function popover_element_binding(value2) {
    ctx[34](value2);
  }
  let popover_props = {
    hideTip: true,
    dontHideOnTargetClick: true,
    setMinWidthToTarget: true,
    class: "input-tag-popover",
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  if (
    /*listElement*/
    ctx[4] !== void 0
  ) {
    popover_props.element = /*listElement*/
    ctx[4];
  }
  popover = new Popover_default({ props: popover_props, $$inline: true });
  binding_callbacks.push(() => bind(popover, "element", popover_element_binding));
  ctx[35](popover);
  popover.$on(
    "close",
    /*onclose*/
    ctx[20]
  );
  const block = {
    c: function create() {
      div2 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div1 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      div0 = element2("div");
      create_component(icon.$$.fragment);
      t3 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      input = element2("input");
      t5 = space();
      create_component(popover.$$.fragment);
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[6]
      );
      input.disabled = /*disabled*/
      ctx[7];
      attr_dev(
        input,
        "id",
        /*_id*/
        ctx[17]
      );
      attr_dev(input, "type", "hidden");
      add_location(input, file20, 29, 3, 763);
      attr_dev(div0, "class", "input-row");
      add_location(div0, file20, 23, 2, 588);
      attr_dev(div1, "class", "input-inner");
      div1.inert = /*disabled*/
      ctx[7];
      attr_dev(div1, "tabindex", "0");
      toggle_class(
        div1,
        "disabled",
        /*disabled*/
        ctx[7]
      );
      add_location(div1, file20, 12, 1, 376);
      attr_dev(
        div2,
        "title",
        /*title*/
        ctx[8]
      );
      attr_dev(div2, "class", div2_class_value = "input input-tag " + /*className*/
      ctx[5]);
      toggle_class(
        div2,
        "has-error",
        /*error*/
        ctx[10]
      );
      toggle_class(
        div2,
        "has-value",
        /*value*/
        ctx[0] !== ""
      );
      toggle_class(
        div2,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[12] === true || /*labelOnTheLeft*/
        ctx[12] === "true"
      );
      add_location(div2, file20, 1, 0, 91);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      mount_component(label_1, div2, null);
      append_dev(div2, t0);
      mount_component(info_1, div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      mount_component(inputerror, div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      mount_component(icon, div0, null);
      append_dev(div0, t3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append_dev(div0, t4);
      append_dev(div0, input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[29](input);
      ctx[30](div1);
      ctx[31](div2);
      insert_dev(target, t5, anchor);
      mount_component(popover, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[28]
          ),
          listen_dev(
            div1,
            "keydown",
            /*onkeydown*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "click",
            /*open*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, dirty) {
      const label_1_changes = {};
      if (dirty[0] & /*label*/
      512)
        label_1_changes.label = /*label*/
        ctx2[9];
      if (dirty[0] & /*disabled*/
      128)
        label_1_changes.disabled = /*disabled*/
        ctx2[7];
      if (dirty[0] & /*_id*/
      131072)
        label_1_changes.for = /*_id*/
        ctx2[17];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty[0] & /*info*/
      2048)
        info_1_changes.msg = /*info*/
        ctx2[11];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty[0] & /*error*/
      1024)
        inputerror_changes.msg = /*error*/
        ctx2[10];
      inputerror.$set(inputerror_changes);
      if (dirty[0] & /*removeTagFromValue, _value*/
      8454144) {
        each_value_1 = ensure_array_like_dev(
          /*_value*/
          ctx2[16]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, t4);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty[0] & /*name*/
      64) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      128) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*_id*/
      131072) {
        attr_dev(
          input,
          "id",
          /*_id*/
          ctx2[17]
        );
      }
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      128) {
        prop_dev(
          div1,
          "inert",
          /*disabled*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      128) {
        toggle_class(
          div1,
          "disabled",
          /*disabled*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*title*/
      256) {
        attr_dev(
          div2,
          "title",
          /*title*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*className*/
      32 && div2_class_value !== (div2_class_value = "input input-tag " + /*className*/
      ctx2[5])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*className, error*/
      1056) {
        toggle_class(
          div2,
          "has-error",
          /*error*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*className, value*/
      33) {
        toggle_class(
          div2,
          "has-value",
          /*value*/
          ctx2[0] !== ""
        );
      }
      if (!current || dirty[0] & /*className, labelOnTheLeft*/
      4128) {
        toggle_class(
          div2,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[12] === true || /*labelOnTheLeft*/
          ctx2[12] === "true"
        );
      }
      const popover_changes = {};
      if (dirty[0] & /*newTagName, _tags*/
      40960 | dirty[1] & /*$$scope*/
      32768) {
        popover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty[0] & /*listElement*/
      16) {
        updating_element = true;
        popover_changes.element = /*listElement*/
        ctx2[4];
        add_flush_callback(() => updating_element = false);
      }
      popover.$set(popover_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      transition_in(icon.$$.fragment, local);
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(popover.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      transition_out(icon.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(popover.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
        detach_dev(t5);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      destroy_component(icon);
      destroy_each(each_blocks, detaching);
      ctx[29](null);
      ctx[30](null);
      ctx[31](null);
      ctx[35](null);
      destroy_component(popover, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function valueToArray(val) {
  return val.split(/[, ;]/).map((tag) => tag.trim()).filter((tag) => tag !== "");
}
function instance25($$self2, $$props2, $$invalidate2) {
  let _id2;
  let _value;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputTag", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { name: name2 = "" } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { title = false } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { value: value2 = "" } = $$props2;
  let { tags = [] } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { inputElement: inputElement2 = void 0 } = $$props2;
  let { boxElement = void 0 } = $$props2;
  let { listElement = void 0 } = $$props2;
  const dispatch3 = createEventDispatcher();
  const errorMessageId2 = guid();
  let newTagName = "";
  let opened = false;
  let listPopover;
  let _tags = [];
  beforeUpdate(hydrateTags);
  function hydrateTags() {
    const val = valueToArray(value2);
    $$invalidate2(15, _tags = tags.map((tag) => {
      return { text: tag, disabled: val.includes(tag) };
    }));
  }
  function open() {
    if (opened)
      return;
    return listPopover.open(boxElement).then(() => opened = listPopover.isOpened());
  }
  function onclose2() {
    opened = false;
  }
  function updatePosition() {
    requestAnimationFrame(listPopover.updatePosition);
  }
  function onkeydown2(e) {
    if (e.key === "Enter")
      return open();
    if (e.key === "ArrowDown") {
      e.preventDefault();
      return open().then(() => {
        listElement.querySelector(".ui-tag").focus();
      });
    }
  }
  function setValue(arr) {
    $$invalidate2(0, value2 = [...new Set(arr)].join(", "));
    updatePosition();
    dispatch3("change", { value: value2 });
  }
  function addTagToValue(tag) {
    const val = valueToArray(value2);
    val.push(tag);
    setValue(val);
  }
  function removeTagFromValue(tag, e) {
    if (e && e.detail && e.detail.originalEvent)
      e.detail.originalEvent.stopPropagation();
    const val = valueToArray(value2).filter((t) => t !== tag);
    requestAnimationFrame(() => setValue(val));
  }
  function addNewTag() {
    const val = valueToArray(value2);
    const newTags = valueToArray(newTagName);
    $$invalidate2(13, newTagName = "");
    requestAnimationFrame(() => setValue([...val, ...newTags]));
  }
  const writable_props = [
    "class",
    "id",
    "name",
    "disabled",
    "title",
    "label",
    "error",
    "info",
    "labelOnTheLeft",
    "value",
    "tags",
    "element",
    "inputElement",
    "boxElement",
    "listElement"
  ];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InputTag> was created with unknown prop '${key}'`);
  });
  const click_handler = (tag, e) => removeTagFromValue(tag, e);
  function input_input_handler2() {
    value2 = this.value;
    $$invalidate2(0, value2);
  }
  function input_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(2, inputElement2);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      boxElement = $$value;
      $$invalidate2(3, boxElement);
    });
  }
  function div2_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  const click_handler_1 = (tag) => addTagToValue(tag.text);
  function inputtext_value_binding(value3) {
    newTagName = value3;
    $$invalidate2(13, newTagName);
  }
  function popover_element_binding(value3) {
    listElement = value3;
    $$invalidate2(4, listElement);
  }
  function popover_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      listPopover = $$value;
      $$invalidate2(14, listPopover);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(5, className2 = $$props3.class);
    if ("id" in $$props3)
      $$invalidate2(25, id2 = $$props3.id);
    if ("name" in $$props3)
      $$invalidate2(6, name2 = $$props3.name);
    if ("disabled" in $$props3)
      $$invalidate2(7, disabled2 = $$props3.disabled);
    if ("title" in $$props3)
      $$invalidate2(8, title = $$props3.title);
    if ("label" in $$props3)
      $$invalidate2(9, label2 = $$props3.label);
    if ("error" in $$props3)
      $$invalidate2(10, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(11, info2 = $$props3.info);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(12, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("tags" in $$props3)
      $$invalidate2(26, tags = $$props3.tags);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("inputElement" in $$props3)
      $$invalidate2(2, inputElement2 = $$props3.inputElement);
    if ("boxElement" in $$props3)
      $$invalidate2(3, boxElement = $$props3.boxElement);
    if ("listElement" in $$props3)
      $$invalidate2(4, listElement = $$props3.listElement);
  };
  $$self2.$capture_state = () => ({
    beforeUpdate,
    createEventDispatcher,
    InputText: InputText_default,
    Button: Button_default,
    Popover: Popover_default,
    Tag: Tag_default,
    guid,
    Icon: Icon_default,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    id: id2,
    name: name2,
    disabled: disabled2,
    title,
    label: label2,
    error: error2,
    info: info2,
    labelOnTheLeft: labelOnTheLeft2,
    value: value2,
    tags,
    element: element3,
    inputElement: inputElement2,
    boxElement,
    listElement,
    dispatch: dispatch3,
    errorMessageId: errorMessageId2,
    newTagName,
    opened,
    listPopover,
    _tags,
    hydrateTags,
    open,
    onclose: onclose2,
    updatePosition,
    onkeydown: onkeydown2,
    valueToArray,
    setValue,
    addTagToValue,
    removeTagFromValue,
    addNewTag,
    _value,
    _id: _id2
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(5, className2 = $$props3.className);
    if ("id" in $$props3)
      $$invalidate2(25, id2 = $$props3.id);
    if ("name" in $$props3)
      $$invalidate2(6, name2 = $$props3.name);
    if ("disabled" in $$props3)
      $$invalidate2(7, disabled2 = $$props3.disabled);
    if ("title" in $$props3)
      $$invalidate2(8, title = $$props3.title);
    if ("label" in $$props3)
      $$invalidate2(9, label2 = $$props3.label);
    if ("error" in $$props3)
      $$invalidate2(10, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(11, info2 = $$props3.info);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(12, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("tags" in $$props3)
      $$invalidate2(26, tags = $$props3.tags);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("inputElement" in $$props3)
      $$invalidate2(2, inputElement2 = $$props3.inputElement);
    if ("boxElement" in $$props3)
      $$invalidate2(3, boxElement = $$props3.boxElement);
    if ("listElement" in $$props3)
      $$invalidate2(4, listElement = $$props3.listElement);
    if ("newTagName" in $$props3)
      $$invalidate2(13, newTagName = $$props3.newTagName);
    if ("opened" in $$props3)
      opened = $$props3.opened;
    if ("listPopover" in $$props3)
      $$invalidate2(14, listPopover = $$props3.listPopover);
    if ("_tags" in $$props3)
      $$invalidate2(15, _tags = $$props3._tags);
    if ("_value" in $$props3)
      $$invalidate2(16, _value = $$props3._value);
    if ("_id" in $$props3)
      $$invalidate2(17, _id2 = $$props3._id);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty[0] & /*id, name*/
    33554496) {
      $:
        $$invalidate2(17, _id2 = id2 || name2 || guid());
    }
    if ($$self2.$$.dirty[0] & /*value*/
    1) {
      $:
        $$invalidate2(16, _value = valueToArray(value2));
    }
  };
  return [
    value2,
    element3,
    inputElement2,
    boxElement,
    listElement,
    className2,
    name2,
    disabled2,
    title,
    label2,
    error2,
    info2,
    labelOnTheLeft2,
    newTagName,
    listPopover,
    _tags,
    _value,
    _id2,
    errorMessageId2,
    open,
    onclose2,
    onkeydown2,
    addTagToValue,
    removeTagFromValue,
    addNewTag,
    id2,
    tags,
    click_handler,
    input_input_handler2,
    input_binding2,
    div1_binding,
    div2_binding2,
    click_handler_1,
    inputtext_value_binding,
    popover_element_binding,
    popover_binding
  ];
}
var InputTag = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance25,
      create_fragment25,
      safe_not_equal,
      {
        class: 5,
        id: 25,
        name: 6,
        disabled: 7,
        title: 8,
        label: 9,
        error: 10,
        info: 11,
        labelOnTheLeft: 12,
        value: 0,
        tags: 26,
        element: 1,
        inputElement: 2,
        boxElement: 3,
        listElement: 4
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputTag",
      options,
      id: create_fragment25.name
    });
  }
  get class() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tags() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tags(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get boxElement() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set boxElement(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listElement() {
    throw new Error("<InputTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listElement(value2) {
    throw new Error("<InputTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputTag_default = InputTag;

// src/input/input-time/InputTime.svelte
var file21 = "src/input/input-time/InputTime.svelte";
function create_fragment26(ctx) {
  let div2;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div1;
  let inputerror;
  let t2;
  let div0;
  let icon;
  let t3;
  let input;
  let input_aria_errormessage_value;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[6]
      ),
      disabled: (
        /*disabled*/
        ctx[5]
      ),
      for: (
        /*_id*/
        ctx[10]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[8]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[11]
      ),
      msg: (
        /*error*/
        ctx[7]
      )
    },
    $$inline: true
  });
  icon = new Icon_default({ props: { name: "clock" }, $$inline: true });
  let input_levels = [
    { id: (
      /*_id*/
      ctx[10]
    ) },
    { autocomplete: "off" },
    { type: "time" },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    /*$$restProps*/
    ctx[12],
    { "aria-invalid": (
      /*error*/
      ctx[7]
    ) },
    {
      "aria-errormessage": input_aria_errormessage_value = /*error*/
      ctx[7] ? (
        /*errorMessageId*/
        ctx[11]
      ) : void 0
    },
    { "aria-required": (
      /*required*/
      ctx[4]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div1 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      div0 = element2("div");
      create_component(icon.$$.fragment);
      t3 = space();
      input = element2("input");
      set_attributes(input, input_data);
      add_location(input, file21, 16, 3, 426);
      attr_dev(div0, "class", "input-row");
      add_location(div0, file21, 13, 2, 374);
      attr_dev(div1, "class", "input-inner");
      toggle_class(
        div1,
        "disabled",
        /*disabled*/
        ctx[5]
      );
      add_location(div1, file21, 10, 1, 277);
      attr_dev(div2, "class", div2_class_value = "input input-time " + /*className*/
      ctx[3]);
      toggle_class(
        div2,
        "has-error",
        /*error*/
        ctx[7]
      );
      toggle_class(
        div2,
        "has-value",
        /*value*/
        ctx[0] !== ""
      );
      toggle_class(
        div2,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[9] === true || /*labelOnTheLeft*/
        ctx[9] === "true"
      );
      add_location(div2, file21, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      mount_component(label_1, div2, null);
      append_dev(div2, t0);
      mount_component(info_1, div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      mount_component(inputerror, div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      mount_component(icon, div0, null);
      append_dev(div0, t3);
      append_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[18](input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[20](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[19]
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      const label_1_changes = {};
      if (dirty & /*label*/
      64)
        label_1_changes.label = /*label*/
        ctx2[6];
      if (dirty & /*disabled*/
      32)
        label_1_changes.disabled = /*disabled*/
        ctx2[5];
      if (dirty & /*_id*/
      1024)
        label_1_changes.for = /*_id*/
        ctx2[10];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty & /*info*/
      256)
        info_1_changes.msg = /*info*/
        ctx2[8];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty & /*error*/
      128)
        inputerror_changes.msg = /*error*/
        ctx2[7];
      inputerror.$set(inputerror_changes);
      set_attributes(input, input_data = get_spread_update(input_levels, [
        (!current || dirty & /*_id*/
        1024) && { id: (
          /*_id*/
          ctx2[10]
        ) },
        { autocomplete: "off" },
        { type: "time" },
        (!current || dirty & /*disabled*/
        32) && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12],
        (!current || dirty & /*error*/
        128) && { "aria-invalid": (
          /*error*/
          ctx2[7]
        ) },
        (!current || dirty & /*error*/
        128 && input_aria_errormessage_value !== (input_aria_errormessage_value = /*error*/
        ctx2[7] ? (
          /*errorMessageId*/
          ctx2[11]
        ) : void 0)) && {
          "aria-errormessage": input_aria_errormessage_value
        },
        (!current || dirty & /*required*/
        16) && { "aria-required": (
          /*required*/
          ctx2[4]
        ) }
      ]));
      if (dirty & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*disabled*/
      32) {
        toggle_class(
          div1,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*className*/
      8 && div2_class_value !== (div2_class_value = "input input-time " + /*className*/
      ctx2[3])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*className, error*/
      136) {
        toggle_class(
          div2,
          "has-error",
          /*error*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*className, value*/
      9) {
        toggle_class(
          div2,
          "has-value",
          /*value*/
          ctx2[0] !== ""
        );
      }
      if (!current || dirty & /*className, labelOnTheLeft*/
      520) {
        toggle_class(
          div2,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[9] === true || /*labelOnTheLeft*/
          ctx2[9] === "true"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      destroy_component(icon);
      ctx[18](null);
      ctx[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self2, $$props2, $$invalidate2) {
  let _id2;
  const omit_props_names2 = [
    "class",
    "id",
    "required",
    "disabled",
    "value",
    "label",
    "error",
    "info",
    "labelOnTheLeft",
    "element",
    "inputElement"
  ];
  let $$restProps2 = compute_rest_props($$props2, omit_props_names2);
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputTime", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { required: required2 = void 0 } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { value: value2 = "" } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { inputElement: inputElement2 = void 0 } = $$props2;
  const errorMessageId2 = guid();
  function input_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function focus_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function blur_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function input_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(2, inputElement2);
    });
  }
  function input_input_handler2() {
    value2 = this.value;
    $$invalidate2(0, value2);
  }
  function div2_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$new_props) => {
    $$props2 = assign(assign({}, $$props2), exclude_internal_props($$new_props));
    $$invalidate2(12, $$restProps2 = compute_rest_props($$props2, omit_props_names2));
    if ("class" in $$new_props)
      $$invalidate2(3, className2 = $$new_props.class);
    if ("id" in $$new_props)
      $$invalidate2(13, id2 = $$new_props.id);
    if ("required" in $$new_props)
      $$invalidate2(4, required2 = $$new_props.required);
    if ("disabled" in $$new_props)
      $$invalidate2(5, disabled2 = $$new_props.disabled);
    if ("value" in $$new_props)
      $$invalidate2(0, value2 = $$new_props.value);
    if ("label" in $$new_props)
      $$invalidate2(6, label2 = $$new_props.label);
    if ("error" in $$new_props)
      $$invalidate2(7, error2 = $$new_props.error);
    if ("info" in $$new_props)
      $$invalidate2(8, info2 = $$new_props.info);
    if ("labelOnTheLeft" in $$new_props)
      $$invalidate2(9, labelOnTheLeft2 = $$new_props.labelOnTheLeft);
    if ("element" in $$new_props)
      $$invalidate2(1, element3 = $$new_props.element);
    if ("inputElement" in $$new_props)
      $$invalidate2(2, inputElement2 = $$new_props.inputElement);
  };
  $$self2.$capture_state = () => ({
    guid,
    Icon: Icon_default,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    id: id2,
    required: required2,
    disabled: disabled2,
    value: value2,
    label: label2,
    error: error2,
    info: info2,
    labelOnTheLeft: labelOnTheLeft2,
    element: element3,
    inputElement: inputElement2,
    errorMessageId: errorMessageId2,
    _id: _id2
  });
  $$self2.$inject_state = ($$new_props) => {
    if ("className" in $$props2)
      $$invalidate2(3, className2 = $$new_props.className);
    if ("id" in $$props2)
      $$invalidate2(13, id2 = $$new_props.id);
    if ("required" in $$props2)
      $$invalidate2(4, required2 = $$new_props.required);
    if ("disabled" in $$props2)
      $$invalidate2(5, disabled2 = $$new_props.disabled);
    if ("value" in $$props2)
      $$invalidate2(0, value2 = $$new_props.value);
    if ("label" in $$props2)
      $$invalidate2(6, label2 = $$new_props.label);
    if ("error" in $$props2)
      $$invalidate2(7, error2 = $$new_props.error);
    if ("info" in $$props2)
      $$invalidate2(8, info2 = $$new_props.info);
    if ("labelOnTheLeft" in $$props2)
      $$invalidate2(9, labelOnTheLeft2 = $$new_props.labelOnTheLeft);
    if ("element" in $$props2)
      $$invalidate2(1, element3 = $$new_props.element);
    if ("inputElement" in $$props2)
      $$invalidate2(2, inputElement2 = $$new_props.inputElement);
    if ("_id" in $$props2)
      $$invalidate2(10, _id2 = $$new_props._id);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*id*/
    8192) {
      $:
        $$invalidate2(10, _id2 = id2 || name || guid());
    }
  };
  return [
    value2,
    element3,
    inputElement2,
    className2,
    required2,
    disabled2,
    label2,
    error2,
    info2,
    labelOnTheLeft2,
    _id2,
    errorMessageId2,
    $$restProps2,
    id2,
    input_handler2,
    change_handler,
    focus_handler2,
    blur_handler2,
    input_binding2,
    input_input_handler2,
    div2_binding2
  ];
}
var InputTime = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, {
      class: 3,
      id: 13,
      required: 4,
      disabled: 5,
      value: 0,
      label: 6,
      error: 7,
      info: 8,
      labelOnTheLeft: 9,
      element: 1,
      inputElement: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputTime",
      options,
      id: create_fragment26.name
    });
  }
  get class() {
    throw new Error("<InputTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<InputTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InputTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<InputTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<InputTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value2) {
    throw new Error("<InputTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<InputTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<InputTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<InputTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<InputTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<InputTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<InputTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<InputTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<InputTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<InputTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<InputTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<InputTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<InputTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<InputTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<InputTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<InputTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<InputTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputTime_default = InputTime;

// src/input/radio/Radio.svelte
var file22 = "src/input/radio/Radio.svelte";
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_each_block5(key_1, ctx) {
  let div;
  let input;
  let input_id_value;
  let input_value_value;
  let input_checked_value;
  let input_disabled_value;
  let t0;
  let label_1;
  let t1;
  let current;
  let mounted;
  let dispose;
  function change_handler(...args) {
    return (
      /*change_handler*/
      ctx[16](
        /*item*/
        ctx[19],
        ...args
      )
    );
  }
  label_1 = new Label_default({
    props: {
      disabled: (
        /*disabled*/
        ctx[7] || /*item*/
        ctx[19].disabled
      ),
      for: (
        /*item*/
        ctx[19].id
      ),
      label: (
        /*item*/
        ctx[19].name
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div = element2("div");
      input = element2("input");
      t0 = space();
      create_component(label_1.$$.fragment);
      t1 = space();
      attr_dev(input, "type", "radio");
      attr_dev(input, "id", input_id_value = /*item*/
      ctx[19].id);
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[4]
      );
      input.value = input_value_value = /*item*/
      ctx[19].value;
      input.checked = input_checked_value = /*item*/
      ctx[19].value === /*value*/
      ctx[0];
      input.disabled = input_disabled_value = /*disabled*/
      ctx[7] || /*item*/
      ctx[19].disabled;
      add_location(input, file22, 23, 5, 656);
      attr_dev(div, "class", "radio-item");
      toggle_class(
        div,
        "disabled",
        /*disabled*/
        ctx[7] || /*item*/
        ctx[19].disabled
      );
      add_location(div, file22, 18, 4, 486);
      this.first = div;
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, input);
      append_dev(div, t0);
      mount_component(label_1, div, null);
      append_dev(div, t1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", change_handler, false, false, false, false),
          listen_dev(div, "touchstart", onmousedown, true, false, false, false),
          listen_dev(div, "mousedown", onmousedown, true, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*_items*/
      2048 && input_id_value !== (input_id_value = /*item*/
      ctx[19].id)) {
        attr_dev(input, "id", input_id_value);
      }
      if (!current || dirty & /*name*/
      16) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx[4]
        );
      }
      if (!current || dirty & /*_items*/
      2048 && input_value_value !== (input_value_value = /*item*/
      ctx[19].value)) {
        prop_dev(input, "value", input_value_value);
      }
      if (!current || dirty & /*_items, value*/
      2049 && input_checked_value !== (input_checked_value = /*item*/
      ctx[19].value === /*value*/
      ctx[0])) {
        prop_dev(input, "checked", input_checked_value);
      }
      if (!current || dirty & /*disabled, _items*/
      2176 && input_disabled_value !== (input_disabled_value = /*disabled*/
      ctx[7] || /*item*/
      ctx[19].disabled)) {
        prop_dev(input, "disabled", input_disabled_value);
      }
      const label_1_changes = {};
      if (dirty & /*disabled, _items*/
      2176)
        label_1_changes.disabled = /*disabled*/
        ctx[7] || /*item*/
        ctx[19].disabled;
      if (dirty & /*_items*/
      2048)
        label_1_changes.for = /*item*/
        ctx[19].id;
      if (dirty & /*_items*/
      2048)
        label_1_changes.label = /*item*/
        ctx[19].name;
      label_1.$set(label_1_changes);
      if (!current || dirty & /*disabled, _items*/
      2176) {
        toggle_class(
          div,
          "disabled",
          /*disabled*/
          ctx[7] || /*item*/
          ctx[19].disabled
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(label_1);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(18:3) {#each _items as item (item.id)}",
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let div2;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div1;
  let inputerror;
  let t2;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div2_class_value;
  let current;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[6]
      ),
      disabled: (
        /*disabled*/
        ctx[7]
      ),
      for: (
        /*_id*/
        ctx[12]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[9]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[13]
      ),
      msg: (
        /*error*/
        ctx[8]
      )
    },
    $$inline: true
  });
  let each_value = ensure_array_like_dev(
    /*_items*/
    ctx[11]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[19].id
  );
  validate_each_keys(ctx, each_value, get_each_context5, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context5(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block5(key, child_ctx));
  }
  const block = {
    c: function create() {
      div2 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div1 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      div0 = element2("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div0, "class", "radio-items");
      add_location(div0, file22, 16, 2, 420);
      attr_dev(div1, "class", "radio-inner");
      toggle_class(
        div1,
        "disabled",
        /*disabled*/
        ctx[7]
      );
      add_location(div1, file22, 13, 1, 323);
      attr_dev(
        div2,
        "id",
        /*id*/
        ctx[3]
      );
      attr_dev(
        div2,
        "title",
        /*title*/
        ctx[5]
      );
      attr_dev(div2, "class", div2_class_value = "check-and-radio radio " + /*className*/
      ctx[2]);
      toggle_class(
        div2,
        "has-error",
        /*error*/
        ctx[8]
      );
      toggle_class(
        div2,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[10] === true || /*labelOnTheLeft*/
        ctx[10] === "true"
      );
      add_location(div2, file22, 1, 0, 59);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      mount_component(label_1, div2, null);
      append_dev(div2, t0);
      mount_component(info_1, div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      mount_component(inputerror, div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      ctx[17](div2);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const label_1_changes = {};
      if (dirty & /*label*/
      64)
        label_1_changes.label = /*label*/
        ctx2[6];
      if (dirty & /*disabled*/
      128)
        label_1_changes.disabled = /*disabled*/
        ctx2[7];
      if (dirty & /*_id*/
      4096)
        label_1_changes.for = /*_id*/
        ctx2[12];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty & /*info*/
      512)
        info_1_changes.msg = /*info*/
        ctx2[9];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty & /*error*/
      256)
        inputerror_changes.msg = /*error*/
        ctx2[8];
      inputerror.$set(inputerror_changes);
      if (dirty & /*disabled, _items, onmousedown, name, value, onchange*/
      18577) {
        each_value = ensure_array_like_dev(
          /*_items*/
          ctx2[11]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context5, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block5, null, get_each_context5);
        check_outros();
      }
      if (!current || dirty & /*disabled*/
      128) {
        toggle_class(
          div1,
          "disabled",
          /*disabled*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*id*/
      8) {
        attr_dev(
          div2,
          "id",
          /*id*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*title*/
      32) {
        attr_dev(
          div2,
          "title",
          /*title*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*className*/
      4 && div2_class_value !== (div2_class_value = "check-and-radio radio " + /*className*/
      ctx2[2])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*className, error*/
      260) {
        toggle_class(
          div2,
          "has-error",
          /*error*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*className, labelOnTheLeft*/
      1028) {
        toggle_class(
          div2,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[10] === true || /*labelOnTheLeft*/
          ctx2[10] === "true"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[17](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function onmousedown(e) {
  const inp = e.target.closest(".radio-item").querySelector("input");
  if (inp && !inp.disabled) {
    e.preventDefault();
    inp.click();
    inp.focus();
  }
}
function instance27($$self2, $$props2, $$invalidate2) {
  let _id2;
  let _items;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Radio", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { name: name2 = guid() } = $$props2;
  let { title = void 0 } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { items = [] } = $$props2;
  let { value: value2 = "" } = $$props2;
  let { error: error2 = "" } = $$props2;
  let { info: info2 = "" } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  const dispatch3 = createEventDispatcher();
  const errorMessageId2 = guid();
  function onchange5(event, item) {
    $$invalidate2(0, value2 = item.value);
    dispatch3("change", { event, value: value2, item });
  }
  const writable_props = [
    "class",
    "id",
    "name",
    "title",
    "label",
    "disabled",
    "items",
    "value",
    "error",
    "info",
    "labelOnTheLeft",
    "element"
  ];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Radio> was created with unknown prop '${key}'`);
  });
  const change_handler = (item, e) => onchange5(e, item);
  function div2_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(2, className2 = $$props3.class);
    if ("id" in $$props3)
      $$invalidate2(3, id2 = $$props3.id);
    if ("name" in $$props3)
      $$invalidate2(4, name2 = $$props3.name);
    if ("title" in $$props3)
      $$invalidate2(5, title = $$props3.title);
    if ("label" in $$props3)
      $$invalidate2(6, label2 = $$props3.label);
    if ("disabled" in $$props3)
      $$invalidate2(7, disabled2 = $$props3.disabled);
    if ("items" in $$props3)
      $$invalidate2(15, items = $$props3.items);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("error" in $$props3)
      $$invalidate2(8, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(9, info2 = $$props3.info);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(10, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
  };
  $$self2.$capture_state = () => ({
    createEventDispatcher,
    guid,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    id: id2,
    name: name2,
    title,
    label: label2,
    disabled: disabled2,
    items,
    value: value2,
    error: error2,
    info: info2,
    labelOnTheLeft: labelOnTheLeft2,
    element: element3,
    dispatch: dispatch3,
    errorMessageId: errorMessageId2,
    onmousedown,
    onchange: onchange5,
    _items,
    _id: _id2
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(2, className2 = $$props3.className);
    if ("id" in $$props3)
      $$invalidate2(3, id2 = $$props3.id);
    if ("name" in $$props3)
      $$invalidate2(4, name2 = $$props3.name);
    if ("title" in $$props3)
      $$invalidate2(5, title = $$props3.title);
    if ("label" in $$props3)
      $$invalidate2(6, label2 = $$props3.label);
    if ("disabled" in $$props3)
      $$invalidate2(7, disabled2 = $$props3.disabled);
    if ("items" in $$props3)
      $$invalidate2(15, items = $$props3.items);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("error" in $$props3)
      $$invalidate2(8, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(9, info2 = $$props3.info);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(10, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("_items" in $$props3)
      $$invalidate2(11, _items = $$props3._items);
    if ("_id" in $$props3)
      $$invalidate2(12, _id2 = $$props3._id);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*id, name*/
    24) {
      $:
        $$invalidate2(12, _id2 = id2 || name2 || guid());
    }
    if ($$self2.$$.dirty & /*items*/
    32768) {
      $:
        $$invalidate2(11, _items = items.map((item) => {
          if (typeof item === "string")
            item = { name: item, value: item };
          item.id = item.id || guid();
          return item;
        }));
    }
  };
  return [
    value2,
    element3,
    className2,
    id2,
    name2,
    title,
    label2,
    disabled2,
    error2,
    info2,
    labelOnTheLeft2,
    _items,
    _id2,
    errorMessageId2,
    onchange5,
    items,
    change_handler,
    div2_binding2
  ];
}
var Radio = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, {
      class: 2,
      id: 3,
      name: 4,
      title: 5,
      label: 6,
      disabled: 7,
      items: 15,
      value: 0,
      error: 8,
      info: 9,
      labelOnTheLeft: 10,
      element: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Radio",
      options,
      id: create_fragment27.name
    });
  }
  get class() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value2) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value2) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value2) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Radio_default = Radio;

// src/input/range/Range.svelte
var file23 = "src/input/range/Range.svelte";
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i];
  return child_ctx;
}
function create_if_block12(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = ensure_array_like_dev(
    /*ticks*/
    ctx[15]
  );
  const get_key = (ctx2) => (
    /*tick*/
    ctx2[27]
  );
  validate_each_keys(ctx, each_value, get_each_context6, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context6(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block6(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element2("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "range-ticks");
      add_location(div, file23, 15, 3, 374);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*onTickClick, ticks*/
      557056) {
        each_value = ensure_array_like_dev(
          /*ticks*/
          ctx2[15]
        );
        validate_each_keys(ctx2, each_value, get_each_context6, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block6, null, get_each_context6);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(15:2) {#if !hideTicks}",
    ctx
  });
  return block;
}
function create_each_block6(key_1, ctx) {
  let span;
  let t_value = (
    /*tick*/
    ctx[27] + ""
  );
  let t;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[23](
        /*tick*/
        ctx[27]
      )
    );
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      span = element2("span");
      t = text(t_value);
      add_location(span, file23, 18, 5, 535);
      this.first = span;
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
      if (!mounted) {
        dispose = listen_dev(span, "click", click_handler, false, false, false, false);
        mounted = true;
      }
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*ticks*/
      32768 && t_value !== (t_value = /*tick*/
      ctx[27] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(18:4) {#each ticks as tick (tick)}",
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let div1;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div0;
  let inputerror;
  let t2;
  let t3;
  let input;
  let input_aria_errormessage_value;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[5]
      ),
      disabled: (
        /*disabled*/
        ctx[4]
      ),
      for: (
        /*_id*/
        ctx[17]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[7]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[18]
      ),
      msg: (
        /*error*/
        ctx[6]
      )
    },
    $$inline: true
  });
  let if_block = !/*hideTicks*/
  ctx[14] && create_if_block12(ctx);
  const block = {
    c: function create() {
      div1 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div0 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      input = element2("input");
      attr_dev(input, "type", "range");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[9]
      );
      input.disabled = /*disabled*/
      ctx[4];
      attr_dev(
        input,
        "min",
        /*min*/
        ctx[11]
      );
      attr_dev(
        input,
        "max",
        /*max*/
        ctx[12]
      );
      attr_dev(
        input,
        "step",
        /*step*/
        ctx[13]
      );
      attr_dev(
        input,
        "id",
        /*_id*/
        ctx[17]
      );
      set_style(
        input,
        "background-size",
        /*progress*/
        ctx[16] + "% 100%"
      );
      attr_dev(
        input,
        "aria-invalid",
        /*error*/
        ctx[6]
      );
      attr_dev(input, "aria-errormessage", input_aria_errormessage_value = /*error*/
      ctx[6] ? (
        /*errorMessageId*/
        ctx[18]
      ) : void 0);
      add_location(input, file23, 23, 2, 625);
      attr_dev(div0, "class", "range-inner");
      toggle_class(
        div0,
        "disabled",
        /*disabled*/
        ctx[4]
      );
      add_location(div0, file23, 11, 1, 257);
      attr_dev(div1, "class", div1_class_value = "range " + /*className*/
      ctx[3]);
      attr_dev(
        div1,
        "title",
        /*title*/
        ctx[8]
      );
      toggle_class(
        div1,
        "has-error",
        /*error*/
        ctx[6]
      );
      toggle_class(
        div1,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[10] === true || /*labelOnTheLeft*/
        ctx[10] === "true"
      );
      toggle_class(
        div1,
        "disabled",
        /*disabled*/
        ctx[4]
      );
      add_location(div1, file23, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      mount_component(label_1, div1, null);
      append_dev(div1, t0);
      mount_component(info_1, div1, null);
      append_dev(div1, t1);
      append_dev(div1, div0);
      mount_component(inputerror, div0, null);
      append_dev(div0, t2);
      if (if_block)
        if_block.m(div0, null);
      append_dev(div0, t3);
      append_dev(div0, input);
      ctx[24](input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[26](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_input_handler*/
            ctx[25]
          ),
          listen_dev(
            input,
            "input",
            /*input_change_input_handler*/
            ctx[25]
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      const label_1_changes = {};
      if (dirty & /*label*/
      32)
        label_1_changes.label = /*label*/
        ctx2[5];
      if (dirty & /*disabled*/
      16)
        label_1_changes.disabled = /*disabled*/
        ctx2[4];
      if (dirty & /*_id*/
      131072)
        label_1_changes.for = /*_id*/
        ctx2[17];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty & /*info*/
      128)
        info_1_changes.msg = /*info*/
        ctx2[7];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty & /*error*/
      64)
        inputerror_changes.msg = /*error*/
        ctx2[6];
      inputerror.$set(inputerror_changes);
      if (!/*hideTicks*/
      ctx2[14]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block12(ctx2);
          if_block.c();
          if_block.m(div0, t3);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*name*/
      512) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[9]
        );
      }
      if (!current || dirty & /*disabled*/
      16) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*min*/
      2048) {
        attr_dev(
          input,
          "min",
          /*min*/
          ctx2[11]
        );
      }
      if (!current || dirty & /*max*/
      4096) {
        attr_dev(
          input,
          "max",
          /*max*/
          ctx2[12]
        );
      }
      if (!current || dirty & /*step*/
      8192) {
        attr_dev(
          input,
          "step",
          /*step*/
          ctx2[13]
        );
      }
      if (!current || dirty & /*_id*/
      131072) {
        attr_dev(
          input,
          "id",
          /*_id*/
          ctx2[17]
        );
      }
      if (!current || dirty & /*progress*/
      65536) {
        set_style(
          input,
          "background-size",
          /*progress*/
          ctx2[16] + "% 100%"
        );
      }
      if (!current || dirty & /*error*/
      64) {
        attr_dev(
          input,
          "aria-invalid",
          /*error*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*error*/
      64 && input_aria_errormessage_value !== (input_aria_errormessage_value = /*error*/
      ctx2[6] ? (
        /*errorMessageId*/
        ctx2[18]
      ) : void 0)) {
        attr_dev(input, "aria-errormessage", input_aria_errormessage_value);
      }
      if (dirty & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*disabled*/
      16) {
        toggle_class(
          div0,
          "disabled",
          /*disabled*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*className*/
      8 && div1_class_value !== (div1_class_value = "range " + /*className*/
      ctx2[3])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*title*/
      256) {
        attr_dev(
          div1,
          "title",
          /*title*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*className, error*/
      72) {
        toggle_class(
          div1,
          "has-error",
          /*error*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*className, labelOnTheLeft*/
      1032) {
        toggle_class(
          div1,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[10] === true || /*labelOnTheLeft*/
          ctx2[10] === "true"
        );
      }
      if (!current || dirty & /*className, disabled*/
      24) {
        toggle_class(
          div1,
          "disabled",
          /*disabled*/
          ctx2[4]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      if (if_block)
        if_block.d();
      ctx[24](null);
      ctx[26](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self2, $$props2, $$invalidate2) {
  let _id2;
  let progress;
  let ticks;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Range", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { title = void 0 } = $$props2;
  let { name: name2 = void 0 } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { min = 0 } = $$props2;
  let { max = 10 } = $$props2;
  let { step = 1 } = $$props2;
  let { value: value2 = min } = $$props2;
  let { hideTicks = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { inputElement: inputElement2 = void 0 } = $$props2;
  const errorMessageId2 = guid();
  function onTickClick(tick2) {
    if (tick2 === value2 || disabled2)
      return;
    $$invalidate2(2, inputElement2.value = $$invalidate2(0, value2 = tick2), inputElement2);
    inputElement2.dispatchEvent(new Event("change"));
  }
  const writable_props = [
    "class",
    "id",
    "disabled",
    "label",
    "error",
    "info",
    "title",
    "name",
    "labelOnTheLeft",
    "min",
    "max",
    "step",
    "value",
    "hideTicks",
    "element",
    "inputElement"
  ];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Range> was created with unknown prop '${key}'`);
  });
  function change_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function input_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  const click_handler = (tick2) => onTickClick(tick2);
  function input_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(2, inputElement2);
    });
  }
  function input_change_input_handler() {
    value2 = to_number(this.value);
    $$invalidate2(0, value2);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(3, className2 = $$props3.class);
    if ("id" in $$props3)
      $$invalidate2(20, id2 = $$props3.id);
    if ("disabled" in $$props3)
      $$invalidate2(4, disabled2 = $$props3.disabled);
    if ("label" in $$props3)
      $$invalidate2(5, label2 = $$props3.label);
    if ("error" in $$props3)
      $$invalidate2(6, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(7, info2 = $$props3.info);
    if ("title" in $$props3)
      $$invalidate2(8, title = $$props3.title);
    if ("name" in $$props3)
      $$invalidate2(9, name2 = $$props3.name);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(10, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("min" in $$props3)
      $$invalidate2(11, min = $$props3.min);
    if ("max" in $$props3)
      $$invalidate2(12, max = $$props3.max);
    if ("step" in $$props3)
      $$invalidate2(13, step = $$props3.step);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("hideTicks" in $$props3)
      $$invalidate2(14, hideTicks = $$props3.hideTicks);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("inputElement" in $$props3)
      $$invalidate2(2, inputElement2 = $$props3.inputElement);
  };
  $$self2.$capture_state = () => ({
    guid,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    id: id2,
    disabled: disabled2,
    label: label2,
    error: error2,
    info: info2,
    title,
    name: name2,
    labelOnTheLeft: labelOnTheLeft2,
    min,
    max,
    step,
    value: value2,
    hideTicks,
    element: element3,
    inputElement: inputElement2,
    errorMessageId: errorMessageId2,
    onTickClick,
    ticks,
    progress,
    _id: _id2
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(3, className2 = $$props3.className);
    if ("id" in $$props3)
      $$invalidate2(20, id2 = $$props3.id);
    if ("disabled" in $$props3)
      $$invalidate2(4, disabled2 = $$props3.disabled);
    if ("label" in $$props3)
      $$invalidate2(5, label2 = $$props3.label);
    if ("error" in $$props3)
      $$invalidate2(6, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(7, info2 = $$props3.info);
    if ("title" in $$props3)
      $$invalidate2(8, title = $$props3.title);
    if ("name" in $$props3)
      $$invalidate2(9, name2 = $$props3.name);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(10, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("min" in $$props3)
      $$invalidate2(11, min = $$props3.min);
    if ("max" in $$props3)
      $$invalidate2(12, max = $$props3.max);
    if ("step" in $$props3)
      $$invalidate2(13, step = $$props3.step);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("hideTicks" in $$props3)
      $$invalidate2(14, hideTicks = $$props3.hideTicks);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("inputElement" in $$props3)
      $$invalidate2(2, inputElement2 = $$props3.inputElement);
    if ("ticks" in $$props3)
      $$invalidate2(15, ticks = $$props3.ticks);
    if ("progress" in $$props3)
      $$invalidate2(16, progress = $$props3.progress);
    if ("_id" in $$props3)
      $$invalidate2(17, _id2 = $$props3._id);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*id, name*/
    1049088) {
      $:
        $$invalidate2(17, _id2 = id2 || name2 || guid());
    }
    if ($$self2.$$.dirty & /*value, min, max*/
    6145) {
      $:
        $$invalidate2(16, progress = (value2 - min) / (max - min) * 100);
    }
    if ($$self2.$$.dirty & /*min, max*/
    6144) {
      $:
        $$invalidate2(15, ticks = Array.from({ length: 6 }, (_, i) => +min + i * ((max - min) / 5)));
    }
  };
  return [
    value2,
    element3,
    inputElement2,
    className2,
    disabled2,
    label2,
    error2,
    info2,
    title,
    name2,
    labelOnTheLeft2,
    min,
    max,
    step,
    hideTicks,
    ticks,
    progress,
    _id2,
    errorMessageId2,
    onTickClick,
    id2,
    change_handler,
    input_handler2,
    click_handler,
    input_binding2,
    input_change_input_handler,
    div1_binding
  ];
}
var Range = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {
      class: 3,
      id: 20,
      disabled: 4,
      label: 5,
      error: 6,
      info: 7,
      title: 8,
      name: 9,
      labelOnTheLeft: 10,
      min: 11,
      max: 12,
      step: 13,
      value: 0,
      hideTicks: 14,
      element: 1,
      inputElement: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Range",
      options,
      id: create_fragment28.name
    });
  }
  get class() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideTicks() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideTicks(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Range_default = Range;

// src/input/select/Select.svelte
var { Object: Object_1 } = globals;
var file24 = "src/input/select/Select.svelte";
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i];
  return child_ctx;
}
function create_if_block_12(ctx) {
  let option;
  let t;
  const block = {
    c: function create() {
      option = element2("option");
      t = text(
        /*placeholder*/
        ctx[6]
      );
      option.__value = "";
      set_input_value(option, option.__value);
      add_location(option, file24, 28, 5, 644);
    },
    m: function mount(target, anchor) {
      insert_dev(target, option, anchor);
      append_dev(option, t);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*placeholder*/
      64)
        set_data_dev(
          t,
          /*placeholder*/
          ctx2[6]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(28:4) {#if placeholder}",
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let option;
  let t_value = (
    /*group*/
    ctx[22].name + ""
  );
  let t;
  let option_value_value;
  const block = {
    c: function create() {
      option = element2("option");
      t = text(t_value);
      option.__value = option_value_value = /*group*/
      ctx[22].id;
      set_input_value(option, option.__value);
      add_location(option, file24, 38, 6, 925);
    },
    m: function mount(target, anchor) {
      insert_dev(target, option, anchor);
      append_dev(option, t);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*groups*/
      8192 && t_value !== (t_value = /*group*/
      ctx2[22].name + ""))
        set_data_dev(t, t_value);
      if (dirty & /*groups*/
      8192 && option_value_value !== (option_value_value = /*group*/
      ctx2[22].id)) {
        prop_dev(option, "__value", option_value_value);
        set_input_value(option, option.__value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(38:5) {:else}",
    ctx
  });
  return block;
}
function create_if_block13(ctx) {
  let optgroup;
  let optgroup_label_value;
  let each_value_1 = ensure_array_like_dev(
    /*group*/
    ctx[22].items
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      optgroup = element2("optgroup");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(optgroup, "label", optgroup_label_value = /*group*/
      ctx[22].name);
      add_location(optgroup, file24, 32, 6, 751);
    },
    m: function mount(target, anchor) {
      insert_dev(target, optgroup, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(optgroup, null);
        }
      }
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*groups*/
      8192) {
        each_value_1 = ensure_array_like_dev(
          /*group*/
          ctx2[22].items
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_13(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_13(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(optgroup, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*groups*/
      8192 && optgroup_label_value !== (optgroup_label_value = /*group*/
      ctx2[22].name)) {
        attr_dev(optgroup, "label", optgroup_label_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(optgroup);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(32:5) {#if group.items}",
    ctx
  });
  return block;
}
function create_each_block_13(ctx) {
  let option;
  let t_value = (
    /*item*/
    ctx[25].name + ""
  );
  let t;
  let option_value_value;
  const block = {
    c: function create() {
      option = element2("option");
      t = text(t_value);
      option.__value = option_value_value = /*item*/
      ctx[25].id;
      set_input_value(option, option.__value);
      add_location(option, file24, 34, 8, 826);
    },
    m: function mount(target, anchor) {
      insert_dev(target, option, anchor);
      append_dev(option, t);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*groups*/
      8192 && t_value !== (t_value = /*item*/
      ctx2[25].name + ""))
        set_data_dev(t, t_value);
      if (dirty & /*groups*/
      8192 && option_value_value !== (option_value_value = /*item*/
      ctx2[25].id)) {
        prop_dev(option, "__value", option_value_value);
        set_input_value(option, option.__value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_13.name,
    type: "each",
    source: "(34:7) {#each group.items as item}",
    ctx
  });
  return block;
}
function create_each_block7(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*group*/
      ctx2[22].items
    )
      return create_if_block13;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(31:4) {#each groups as group}",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let div2;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div1;
  let inputerror;
  let t2;
  let div0;
  let select;
  let if_block_anchor;
  let select_aria_errormessage_value;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[9]
      ),
      disabled: (
        /*disabled*/
        ctx[4]
      ),
      for: (
        /*_id*/
        ctx[14]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[11]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[15]
      ),
      msg: (
        /*error*/
        ctx[10]
      )
    },
    $$inline: true
  });
  let if_block = (
    /*placeholder*/
    ctx[6] && create_if_block_12(ctx)
  );
  let each_value = ensure_array_like_dev(
    /*groups*/
    ctx[13]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div2 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div1 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      div0 = element2("div");
      select = element2("select");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(
        select,
        "id",
        /*_id*/
        ctx[14]
      );
      attr_dev(
        select,
        "title",
        /*title*/
        ctx[7]
      );
      attr_dev(
        select,
        "name",
        /*name*/
        ctx[8]
      );
      select.disabled = /*disabled*/
      ctx[4];
      attr_dev(
        select,
        "aria-invalid",
        /*error*/
        ctx[10]
      );
      attr_dev(select, "aria-errormessage", select_aria_errormessage_value = /*error*/
      ctx[10] ? (
        /*errorMessageId*/
        ctx[15]
      ) : void 0);
      attr_dev(
        select,
        "aria-required",
        /*required*/
        ctx[5]
      );
      if (
        /*value*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[19].call(select)
        ));
      add_location(select, file24, 13, 3, 363);
      attr_dev(div0, "class", "input-row");
      add_location(div0, file24, 12, 2, 336);
      attr_dev(div1, "class", "input-inner");
      toggle_class(
        div1,
        "disabled",
        /*disabled*/
        ctx[4]
      );
      add_location(div1, file24, 9, 1, 239);
      attr_dev(div2, "class", div2_class_value = "input select " + /*className*/
      ctx[3]);
      toggle_class(
        div2,
        "has-error",
        /*error*/
        ctx[10]
      );
      toggle_class(
        div2,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[12] === true || /*labelOnTheLeft*/
        ctx[12] === "true"
      );
      add_location(div2, file24, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      mount_component(label_1, div2, null);
      append_dev(div2, t0);
      mount_component(info_1, div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      mount_component(inputerror, div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      append_dev(div0, select);
      if (if_block)
        if_block.m(select, null);
      append_dev(select, if_block_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*value*/
        ctx[0],
        true
      );
      ctx[20](select);
      ctx[21](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[19]
          ),
          listen_dev(
            select,
            "change",
            /*change_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      const label_1_changes = {};
      if (dirty & /*label*/
      512)
        label_1_changes.label = /*label*/
        ctx2[9];
      if (dirty & /*disabled*/
      16)
        label_1_changes.disabled = /*disabled*/
        ctx2[4];
      if (dirty & /*_id*/
      16384)
        label_1_changes.for = /*_id*/
        ctx2[14];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty & /*info*/
      2048)
        info_1_changes.msg = /*info*/
        ctx2[11];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty & /*error*/
      1024)
        inputerror_changes.msg = /*error*/
        ctx2[10];
      inputerror.$set(inputerror_changes);
      if (
        /*placeholder*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          if_block.m(select, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*groups*/
      8192) {
        each_value = ensure_array_like_dev(
          /*groups*/
          ctx2[13]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & /*_id*/
      16384) {
        attr_dev(
          select,
          "id",
          /*_id*/
          ctx2[14]
        );
      }
      if (!current || dirty & /*title*/
      128) {
        attr_dev(
          select,
          "title",
          /*title*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*name*/
      256) {
        attr_dev(
          select,
          "name",
          /*name*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*disabled*/
      16) {
        prop_dev(
          select,
          "disabled",
          /*disabled*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*error*/
      1024) {
        attr_dev(
          select,
          "aria-invalid",
          /*error*/
          ctx2[10]
        );
      }
      if (!current || dirty & /*error*/
      1024 && select_aria_errormessage_value !== (select_aria_errormessage_value = /*error*/
      ctx2[10] ? (
        /*errorMessageId*/
        ctx2[15]
      ) : void 0)) {
        attr_dev(select, "aria-errormessage", select_aria_errormessage_value);
      }
      if (!current || dirty & /*required*/
      32) {
        attr_dev(
          select,
          "aria-required",
          /*required*/
          ctx2[5]
        );
      }
      if (dirty & /*value*/
      1) {
        select_option(
          select,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*disabled*/
      16) {
        toggle_class(
          div1,
          "disabled",
          /*disabled*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*className*/
      8 && div2_class_value !== (div2_class_value = "input select " + /*className*/
      ctx2[3])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*className, error*/
      1032) {
        toggle_class(
          div2,
          "has-error",
          /*error*/
          ctx2[10]
        );
      }
      if (!current || dirty & /*className, labelOnTheLeft*/
      4104) {
        toggle_class(
          div2,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[12] === true || /*labelOnTheLeft*/
          ctx2[12] === "true"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      ctx[20](null);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self2, $$props2, $$invalidate2) {
  let _id2;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Select", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { required: required2 = void 0 } = $$props2;
  let { value: value2 = void 0 } = $$props2;
  let { placeholder = void 0 } = $$props2;
  let { items = [] } = $$props2;
  let { title = void 0 } = $$props2;
  let { name: name2 = void 0 } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { inputElement: inputElement2 = void 0 } = $$props2;
  let groups = [];
  const errorMessageId2 = guid();
  const writable_props = [
    "class",
    "id",
    "disabled",
    "required",
    "value",
    "placeholder",
    "items",
    "title",
    "name",
    "label",
    "error",
    "info",
    "labelOnTheLeft",
    "element",
    "inputElement"
  ];
  Object_1.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Select> was created with unknown prop '${key}'`);
  });
  function change_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function select_change_handler() {
    value2 = select_value(this);
    $$invalidate2(0, value2);
  }
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(2, inputElement2);
      $$invalidate2(13, groups), $$invalidate2(17, items);
    });
  }
  function div2_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(3, className2 = $$props3.class);
    if ("id" in $$props3)
      $$invalidate2(16, id2 = $$props3.id);
    if ("disabled" in $$props3)
      $$invalidate2(4, disabled2 = $$props3.disabled);
    if ("required" in $$props3)
      $$invalidate2(5, required2 = $$props3.required);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("placeholder" in $$props3)
      $$invalidate2(6, placeholder = $$props3.placeholder);
    if ("items" in $$props3)
      $$invalidate2(17, items = $$props3.items);
    if ("title" in $$props3)
      $$invalidate2(7, title = $$props3.title);
    if ("name" in $$props3)
      $$invalidate2(8, name2 = $$props3.name);
    if ("label" in $$props3)
      $$invalidate2(9, label2 = $$props3.label);
    if ("error" in $$props3)
      $$invalidate2(10, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(11, info2 = $$props3.info);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(12, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("inputElement" in $$props3)
      $$invalidate2(2, inputElement2 = $$props3.inputElement);
  };
  $$self2.$capture_state = () => ({
    guid,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    id: id2,
    disabled: disabled2,
    required: required2,
    value: value2,
    placeholder,
    items,
    title,
    name: name2,
    label: label2,
    error: error2,
    info: info2,
    labelOnTheLeft: labelOnTheLeft2,
    element: element3,
    inputElement: inputElement2,
    groups,
    errorMessageId: errorMessageId2,
    _id: _id2
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(3, className2 = $$props3.className);
    if ("id" in $$props3)
      $$invalidate2(16, id2 = $$props3.id);
    if ("disabled" in $$props3)
      $$invalidate2(4, disabled2 = $$props3.disabled);
    if ("required" in $$props3)
      $$invalidate2(5, required2 = $$props3.required);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("placeholder" in $$props3)
      $$invalidate2(6, placeholder = $$props3.placeholder);
    if ("items" in $$props3)
      $$invalidate2(17, items = $$props3.items);
    if ("title" in $$props3)
      $$invalidate2(7, title = $$props3.title);
    if ("name" in $$props3)
      $$invalidate2(8, name2 = $$props3.name);
    if ("label" in $$props3)
      $$invalidate2(9, label2 = $$props3.label);
    if ("error" in $$props3)
      $$invalidate2(10, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(11, info2 = $$props3.info);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(12, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("inputElement" in $$props3)
      $$invalidate2(2, inputElement2 = $$props3.inputElement);
    if ("groups" in $$props3)
      $$invalidate2(13, groups = $$props3.groups);
    if ("_id" in $$props3)
      $$invalidate2(14, _id2 = $$props3._id);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*id, name*/
    65792) {
      $:
        $$invalidate2(14, _id2 = id2 || name2 || guid());
    }
    if ($$self2.$$.dirty & /*items*/
    131072) {
      $: {
        const nogroup = [];
        const _groups = {};
        items.forEach((item) => {
          if (!item.group)
            return nogroup.push(item);
          _groups[item.group] = _groups[item.group] || { name: item.group, items: [] };
          _groups[item.group].items.push(item);
        });
        let all = [...nogroup, ...Object.values(_groups)];
        if (typeof all[0] === "string") {
          all = all.map((item) => ({ id: item, name: item }));
        }
        $$invalidate2(13, groups = all);
      }
    }
  };
  return [
    value2,
    element3,
    inputElement2,
    className2,
    disabled2,
    required2,
    placeholder,
    title,
    name2,
    label2,
    error2,
    info2,
    labelOnTheLeft2,
    groups,
    _id2,
    errorMessageId2,
    id2,
    items,
    change_handler,
    select_change_handler,
    select_binding,
    div2_binding2
  ];
}
var Select = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {
      class: 3,
      id: 16,
      disabled: 4,
      required: 5,
      value: 0,
      placeholder: 6,
      items: 17,
      title: 7,
      name: 8,
      label: 9,
      error: 10,
      info: 11,
      labelOnTheLeft: 12,
      element: 1,
      inputElement: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select",
      options,
      id: create_fragment29.name
    });
  }
  get class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Select_default = Select;

// src/input/textarea/Textarea.svelte
var file25 = "src/input/textarea/Textarea.svelte";
function create_fragment30(ctx) {
  let div1;
  let label_1;
  let t0;
  let info_1;
  let t1;
  let div0;
  let inputerror;
  let t2;
  let textarea;
  let textarea_aria_errormessage_value;
  let div0_data_value_value;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  label_1 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[7]
      ),
      disabled: (
        /*disabled*/
        ctx[6]
      ),
      for: (
        /*_id*/
        ctx[11]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[9]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[12]
      ),
      msg: (
        /*error*/
        ctx[8]
      )
    },
    $$inline: true
  });
  let textarea_levels = [
    { id: (
      /*_id*/
      ctx[11]
    ) },
    { disabled: (
      /*disabled*/
      ctx[6]
    ) },
    /*$$restProps*/
    ctx[13],
    { "aria-invalid": (
      /*error*/
      ctx[8]
    ) },
    {
      "aria-errormessage": textarea_aria_errormessage_value = /*error*/
      ctx[8] ? (
        /*errorMessageId*/
        ctx[12]
      ) : void 0
    },
    { "aria-required": (
      /*required*/
      ctx[5]
    ) }
  ];
  let textarea_data = {};
  for (let i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element2("div");
      create_component(label_1.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      div0 = element2("div");
      create_component(inputerror.$$.fragment);
      t2 = space();
      textarea = element2("textarea");
      set_attributes(textarea, textarea_data);
      add_location(textarea, file25, 13, 2, 395);
      attr_dev(div0, "class", "textarea-inner");
      attr_dev(div0, "data-value", div0_data_value_value = /*autogrow*/
      ctx[4] ? (
        /*value*/
        ctx[0]
      ) : void 0);
      toggle_class(
        div0,
        "disabled",
        /*disabled*/
        ctx[6]
      );
      add_location(div0, file25, 10, 1, 251);
      attr_dev(div1, "class", div1_class_value = "textarea " + /*className*/
      ctx[3]);
      toggle_class(
        div1,
        "autogrow",
        /*autogrow*/
        ctx[4]
      );
      toggle_class(
        div1,
        "has-error",
        /*error*/
        ctx[8]
      );
      toggle_class(
        div1,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[10] === true || /*labelOnTheLeft*/
        ctx[10] === "true"
      );
      add_location(div1, file25, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      mount_component(label_1, div1, null);
      append_dev(div1, t0);
      mount_component(info_1, div1, null);
      append_dev(div1, t1);
      append_dev(div1, div0);
      mount_component(inputerror, div0, null);
      append_dev(div0, t2);
      append_dev(div0, textarea);
      if (textarea.autofocus)
        textarea.focus();
      ctx[17](textarea);
      set_input_value(
        textarea,
        /*value*/
        ctx[0]
      );
      ctx[19](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[18]
          ),
          listen_dev(
            textarea,
            "change",
            /*change_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "input",
            /*input_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      const label_1_changes = {};
      if (dirty & /*label*/
      128)
        label_1_changes.label = /*label*/
        ctx2[7];
      if (dirty & /*disabled*/
      64)
        label_1_changes.disabled = /*disabled*/
        ctx2[6];
      if (dirty & /*_id*/
      2048)
        label_1_changes.for = /*_id*/
        ctx2[11];
      label_1.$set(label_1_changes);
      const info_1_changes = {};
      if (dirty & /*info*/
      512)
        info_1_changes.msg = /*info*/
        ctx2[9];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty & /*error*/
      256)
        inputerror_changes.msg = /*error*/
        ctx2[8];
      inputerror.$set(inputerror_changes);
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        (!current || dirty & /*_id*/
        2048) && { id: (
          /*_id*/
          ctx2[11]
        ) },
        (!current || dirty & /*disabled*/
        64) && { disabled: (
          /*disabled*/
          ctx2[6]
        ) },
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx2[13],
        (!current || dirty & /*error*/
        256) && { "aria-invalid": (
          /*error*/
          ctx2[8]
        ) },
        (!current || dirty & /*error*/
        256 && textarea_aria_errormessage_value !== (textarea_aria_errormessage_value = /*error*/
        ctx2[8] ? (
          /*errorMessageId*/
          ctx2[12]
        ) : void 0)) && {
          "aria-errormessage": textarea_aria_errormessage_value
        },
        (!current || dirty & /*required*/
        32) && { "aria-required": (
          /*required*/
          ctx2[5]
        ) }
      ]));
      if (dirty & /*value*/
      1) {
        set_input_value(
          textarea,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*autogrow, value*/
      17 && div0_data_value_value !== (div0_data_value_value = /*autogrow*/
      ctx2[4] ? (
        /*value*/
        ctx2[0]
      ) : void 0)) {
        attr_dev(div0, "data-value", div0_data_value_value);
      }
      if (!current || dirty & /*disabled*/
      64) {
        toggle_class(
          div0,
          "disabled",
          /*disabled*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*className*/
      8 && div1_class_value !== (div1_class_value = "textarea " + /*className*/
      ctx2[3])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*className, autogrow*/
      24) {
        toggle_class(
          div1,
          "autogrow",
          /*autogrow*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*className, error*/
      264) {
        toggle_class(
          div1,
          "has-error",
          /*error*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*className, labelOnTheLeft*/
      1032) {
        toggle_class(
          div1,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[10] === true || /*labelOnTheLeft*/
          ctx2[10] === "true"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_component(label_1);
      destroy_component(info_1);
      destroy_component(inputerror);
      ctx[17](null);
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self2, $$props2, $$invalidate2) {
  let _id2;
  const omit_props_names2 = [
    "class",
    "id",
    "value",
    "autogrow",
    "required",
    "disabled",
    "label",
    "error",
    "info",
    "labelOnTheLeft",
    "element",
    "inputElement"
  ];
  let $$restProps2 = compute_rest_props($$props2, omit_props_names2);
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Textarea", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { value: value2 = "" } = $$props2;
  let { autogrow = false } = $$props2;
  let { required: required2 = void 0 } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { inputElement: inputElement2 = void 0 } = $$props2;
  const errorMessageId2 = guid();
  function change_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function input_handler2(event) {
    bubble.call(this, $$self2, event);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(2, inputElement2);
    });
  }
  function textarea_input_handler() {
    value2 = this.value;
    $$invalidate2(0, value2);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$new_props) => {
    $$props2 = assign(assign({}, $$props2), exclude_internal_props($$new_props));
    $$invalidate2(13, $$restProps2 = compute_rest_props($$props2, omit_props_names2));
    if ("class" in $$new_props)
      $$invalidate2(3, className2 = $$new_props.class);
    if ("id" in $$new_props)
      $$invalidate2(14, id2 = $$new_props.id);
    if ("value" in $$new_props)
      $$invalidate2(0, value2 = $$new_props.value);
    if ("autogrow" in $$new_props)
      $$invalidate2(4, autogrow = $$new_props.autogrow);
    if ("required" in $$new_props)
      $$invalidate2(5, required2 = $$new_props.required);
    if ("disabled" in $$new_props)
      $$invalidate2(6, disabled2 = $$new_props.disabled);
    if ("label" in $$new_props)
      $$invalidate2(7, label2 = $$new_props.label);
    if ("error" in $$new_props)
      $$invalidate2(8, error2 = $$new_props.error);
    if ("info" in $$new_props)
      $$invalidate2(9, info2 = $$new_props.info);
    if ("labelOnTheLeft" in $$new_props)
      $$invalidate2(10, labelOnTheLeft2 = $$new_props.labelOnTheLeft);
    if ("element" in $$new_props)
      $$invalidate2(1, element3 = $$new_props.element);
    if ("inputElement" in $$new_props)
      $$invalidate2(2, inputElement2 = $$new_props.inputElement);
  };
  $$self2.$capture_state = () => ({
    guid,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    className: className2,
    id: id2,
    value: value2,
    autogrow,
    required: required2,
    disabled: disabled2,
    label: label2,
    error: error2,
    info: info2,
    labelOnTheLeft: labelOnTheLeft2,
    element: element3,
    inputElement: inputElement2,
    errorMessageId: errorMessageId2,
    _id: _id2
  });
  $$self2.$inject_state = ($$new_props) => {
    if ("className" in $$props2)
      $$invalidate2(3, className2 = $$new_props.className);
    if ("id" in $$props2)
      $$invalidate2(14, id2 = $$new_props.id);
    if ("value" in $$props2)
      $$invalidate2(0, value2 = $$new_props.value);
    if ("autogrow" in $$props2)
      $$invalidate2(4, autogrow = $$new_props.autogrow);
    if ("required" in $$props2)
      $$invalidate2(5, required2 = $$new_props.required);
    if ("disabled" in $$props2)
      $$invalidate2(6, disabled2 = $$new_props.disabled);
    if ("label" in $$props2)
      $$invalidate2(7, label2 = $$new_props.label);
    if ("error" in $$props2)
      $$invalidate2(8, error2 = $$new_props.error);
    if ("info" in $$props2)
      $$invalidate2(9, info2 = $$new_props.info);
    if ("labelOnTheLeft" in $$props2)
      $$invalidate2(10, labelOnTheLeft2 = $$new_props.labelOnTheLeft);
    if ("element" in $$props2)
      $$invalidate2(1, element3 = $$new_props.element);
    if ("inputElement" in $$props2)
      $$invalidate2(2, inputElement2 = $$new_props.inputElement);
    if ("_id" in $$props2)
      $$invalidate2(11, _id2 = $$new_props._id);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*id*/
    16384) {
      $:
        $$invalidate2(11, _id2 = id2 || name || guid());
    }
  };
  return [
    value2,
    element3,
    inputElement2,
    className2,
    autogrow,
    required2,
    disabled2,
    label2,
    error2,
    info2,
    labelOnTheLeft2,
    _id2,
    errorMessageId2,
    $$restProps2,
    id2,
    change_handler,
    input_handler2,
    textarea_binding,
    textarea_input_handler,
    div1_binding
  ];
}
var Textarea = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      class: 3,
      id: 14,
      value: 0,
      autogrow: 4,
      required: 5,
      disabled: 6,
      label: 7,
      error: 8,
      info: 9,
      labelOnTheLeft: 10,
      element: 1,
      inputElement: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Textarea",
      options,
      id: create_fragment30.name
    });
  }
  get class() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autogrow() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autogrow(value2) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value2) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Textarea_default = Textarea;

// src/input/toggle/utils.js
var isTouchDevice = "ontouchstart" in document.documentElement;
function initialMeasure(toggleEl) {
  const isHidden = toggleEl.offsetParent === null;
  if (isHidden) {
    toggleEl = toggleEl.cloneNode(true);
    document.body.appendChild(toggleEl);
  }
  const toggleInnerEl = toggleEl.querySelector(".toggle-inner");
  const toggleInner = toggleInnerEl.getBoundingClientRect();
  const toggle = getComputedStyle(toggleEl);
  const togglePadding = parseFloat(toggle.paddingBlock);
  if (isHidden && toggleEl)
    toggleEl.remove();
  return {
    scrollerStartX: toggleInner.height - toggleInner.width,
    scrollerEndX: 0,
    handleStartX: toggleInner.height / 2 + togglePadding,
    handleEndX: toggleInner.width + togglePadding - toggleInner.height / 2
  };
}

// src/input/toggle/Toggle.svelte
var file26 = "src/input/toggle/Toggle.svelte";
function create_fragment31(ctx) {
  let div6;
  let label0;
  let t0;
  let info_1;
  let t1;
  let inputerror;
  let t2;
  let div5;
  let label1;
  let div4;
  let div0;
  let t3;
  let div2;
  let div1;
  let t4;
  let div3;
  let t5;
  let input;
  let input_aria_errormessage_value;
  let div6_class_value;
  let div6_tabindex_value;
  let current;
  let mounted;
  let dispose;
  label0 = new Label_default({
    props: {
      label: (
        /*label*/
        ctx[8]
      ),
      disabled: (
        /*disabled*/
        ctx[7]
      ),
      for: (
        /*_id*/
        ctx[14]
      )
    },
    $$inline: true
  });
  info_1 = new Info_default({
    props: { msg: (
      /*info*/
      ctx[10]
    ) },
    $$inline: true
  });
  inputerror = new InputError_default({
    props: {
      id: (
        /*errorMessageId*/
        ctx[15]
      ),
      msg: (
        /*error*/
        ctx[9]
      ),
      animOpacity: "true"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div6 = element2("div");
      create_component(label0.$$.fragment);
      t0 = space();
      create_component(info_1.$$.fragment);
      t1 = space();
      create_component(inputerror.$$.fragment);
      t2 = space();
      div5 = element2("div");
      label1 = element2("label");
      div4 = element2("div");
      div0 = element2("div");
      t3 = space();
      div2 = element2("div");
      div1 = element2("div");
      t4 = space();
      div3 = element2("div");
      t5 = space();
      input = element2("input");
      attr_dev(div0, "class", "toggle-option");
      add_location(div0, file26, 22, 4, 639);
      attr_dev(div1, "class", "toggle-knob");
      add_location(div1, file26, 23, 52, 725);
      attr_dev(div2, "class", "toggle-handle");
      add_location(div2, file26, 23, 4, 677);
      attr_dev(div3, "class", "toggle-option");
      add_location(div3, file26, 24, 4, 767);
      attr_dev(
        input,
        "id",
        /*_id*/
        ctx[14]
      );
      attr_dev(input, "type", "checkbox");
      attr_dev(input, "class", "toggle-input");
      input.disabled = /*disabled*/
      ctx[7];
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[4]
      );
      attr_dev(
        input,
        "aria-invalid",
        /*error*/
        ctx[9]
      );
      attr_dev(input, "aria-errormessage", input_aria_errormessage_value = /*error*/
      ctx[9] ? (
        /*errorMessageId*/
        ctx[15]
      ) : void 0);
      attr_dev(
        input,
        "aria-required",
        /*required*/
        ctx[6]
      );
      add_location(input, file26, 25, 4, 805);
      attr_dev(div4, "class", "toggle-scroller");
      add_location(div4, file26, 21, 3, 582);
      attr_dev(label1, "class", "toggle-label");
      attr_dev(
        label1,
        "title",
        /*title*/
        ctx[5]
      );
      add_location(label1, file26, 20, 2, 542);
      attr_dev(div5, "class", "toggle-inner");
      add_location(div5, file26, 19, 1, 513);
      attr_dev(div6, "class", div6_class_value = "toggle " + /*className*/
      ctx[3]);
      attr_dev(div6, "role", "switch");
      attr_dev(
        div6,
        "aria-checked",
        /*value*/
        ctx[0]
      );
      attr_dev(div6, "tabindex", div6_tabindex_value = /*disabled*/
      ctx[7] ? void 0 : 0);
      toggle_class(
        div6,
        "has-error",
        /*error*/
        ctx[9]
      );
      toggle_class(
        div6,
        "label-on-the-left",
        /*labelOnTheLeft*/
        ctx[11] === true || /*labelOnTheLeft*/
        ctx[11] === "true"
      );
      add_location(div6, file26, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div6, anchor);
      mount_component(label0, div6, null);
      append_dev(div6, t0);
      mount_component(info_1, div6, null);
      append_dev(div6, t1);
      mount_component(inputerror, div6, null);
      append_dev(div6, t2);
      append_dev(div6, div5);
      append_dev(div5, label1);
      append_dev(label1, div4);
      append_dev(div4, div0);
      append_dev(div4, t3);
      append_dev(div4, div2);
      append_dev(div2, div1);
      ctx[21](div2);
      append_dev(div4, t4);
      append_dev(div4, div3);
      append_dev(div4, t5);
      append_dev(div4, input);
      ctx[22](input);
      input.checked = /*value*/
      ctx[0];
      ctx[24](div4);
      ctx[25](div6);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[23]
          ),
          listen_dev(
            div6,
            "keydown",
            /*onKey*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div6,
            "touchstart",
            /*dragStart*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div6,
            "mousedown",
            /*dragStart*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(div6, "contextmenu", prevent_default(
            /*contextmenu_handler*/
            ctx[19]
          ), false, true, false, false),
          listen_dev(div6, "click", prevent_default(
            /*click_handler*/
            ctx[20]
          ), false, true, false, false)
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, dirty) {
      const label0_changes = {};
      if (dirty[0] & /*label*/
      256)
        label0_changes.label = /*label*/
        ctx2[8];
      if (dirty[0] & /*disabled*/
      128)
        label0_changes.disabled = /*disabled*/
        ctx2[7];
      if (dirty[0] & /*_id*/
      16384)
        label0_changes.for = /*_id*/
        ctx2[14];
      label0.$set(label0_changes);
      const info_1_changes = {};
      if (dirty[0] & /*info*/
      1024)
        info_1_changes.msg = /*info*/
        ctx2[10];
      info_1.$set(info_1_changes);
      const inputerror_changes = {};
      if (dirty[0] & /*error*/
      512)
        inputerror_changes.msg = /*error*/
        ctx2[9];
      inputerror.$set(inputerror_changes);
      if (!current || dirty[0] & /*_id*/
      16384) {
        attr_dev(
          input,
          "id",
          /*_id*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      128) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*name*/
      16) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*error*/
      512) {
        attr_dev(
          input,
          "aria-invalid",
          /*error*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*error*/
      512 && input_aria_errormessage_value !== (input_aria_errormessage_value = /*error*/
      ctx2[9] ? (
        /*errorMessageId*/
        ctx2[15]
      ) : void 0)) {
        attr_dev(input, "aria-errormessage", input_aria_errormessage_value);
      }
      if (!current || dirty[0] & /*required*/
      64) {
        attr_dev(
          input,
          "aria-required",
          /*required*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*value*/
      1) {
        input.checked = /*value*/
        ctx2[0];
      }
      if (!current || dirty[0] & /*title*/
      32) {
        attr_dev(
          label1,
          "title",
          /*title*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*className*/
      8 && div6_class_value !== (div6_class_value = "toggle " + /*className*/
      ctx2[3])) {
        attr_dev(div6, "class", div6_class_value);
      }
      if (!current || dirty[0] & /*value*/
      1) {
        attr_dev(
          div6,
          "aria-checked",
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      128 && div6_tabindex_value !== (div6_tabindex_value = /*disabled*/
      ctx2[7] ? void 0 : 0)) {
        attr_dev(div6, "tabindex", div6_tabindex_value);
      }
      if (!current || dirty[0] & /*className, error*/
      520) {
        toggle_class(
          div6,
          "has-error",
          /*error*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*className, labelOnTheLeft*/
      2056) {
        toggle_class(
          div6,
          "label-on-the-left",
          /*labelOnTheLeft*/
          ctx2[11] === true || /*labelOnTheLeft*/
          ctx2[11] === "true"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label0.$$.fragment, local);
      transition_in(info_1.$$.fragment, local);
      transition_in(inputerror.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label0.$$.fragment, local);
      transition_out(info_1.$$.fragment, local);
      transition_out(inputerror.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div6);
      }
      destroy_component(label0);
      destroy_component(info_1);
      destroy_component(inputerror);
      ctx[21](null);
      ctx[22](null);
      ctx[24](null);
      ctx[25](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self2, $$props2, $$invalidate2) {
  let _id2;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Toggle", slots2, []);
  const dispatch3 = createEventDispatcher();
  let { class: className2 = "" } = $$props2;
  let { id: id2 = "" } = $$props2;
  let { name: name2 = guid() } = $$props2;
  let { title = "" } = $$props2;
  let { required: required2 = void 0 } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { label: label2 = "" } = $$props2;
  let { error: error2 = void 0 } = $$props2;
  let { info: info2 = void 0 } = $$props2;
  let { value: value2 = false } = $$props2;
  let { labelOnTheLeft: labelOnTheLeft2 = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { inputElement: inputElement2 = void 0 } = $$props2;
  const errorMessageId2 = guid();
  let scroller, handle, startX2, currentX = 0;
  let scrollerStartX, scrollerEndX, handleStartX;
  let isClick = false, isDragging = false;
  let oldValue;
  onMount(() => {
    toggleTransitions(false);
    ({ scrollerStartX, scrollerEndX, handleStartX } = initialMeasure(element3));
  });
  afterUpdate(() => {
    if (typeof value2 !== "boolean")
      $$invalidate2(0, value2 = !!value2);
    setValue(value2);
  });
  function setValue(v = false, force = false) {
    if (typeof v !== "boolean")
      v = !!v;
    if (v !== value2)
      return $$invalidate2(0, value2 = v);
    if (value2 === oldValue && !force)
      return;
    startX2 = currentX = value2 ? scrollerEndX : scrollerStartX;
    oldValue = value2;
    setKnobPosition();
    dispatch3("change", value2);
  }
  function onKey2(e) {
    toggleTransitions(true);
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      setValue(!value2);
    }
  }
  function dragStart(e) {
    const target = e.target;
    if (!target.closest(".toggle-inner, .toggle>label"))
      return;
    if (isTouchDevice && e.type !== "touchstart")
      return;
    if (e.type === "touchstart") {
      document.addEventListener("touchend", dragEnd);
      document.addEventListener("touchmove", drag, { passive: false });
    } else {
      document.addEventListener("mouseup", dragEnd);
      document.addEventListener("mousemove", drag, { passive: false });
    }
    toggleTransitions(false);
    startX2 = getMouseX(e) - currentX;
    isDragging = true;
    isClick = true;
  }
  function dragEnd() {
    document.removeEventListener("mouseup", dragEnd);
    document.removeEventListener("mousemove", drag);
    document.removeEventListener("touchend", dragEnd);
    document.removeEventListener("touchmove", drag);
    toggleTransitions(true);
    isDragging = false;
    if (isClick)
      setValue(!value2);
    else {
      setValue(currentX - scrollerStartX >= (scrollerEndX - scrollerStartX) / 2, true);
    }
  }
  function drag(e) {
    if (!isDragging)
      return;
    isClick = false;
    e.preventDefault();
    currentX = getMouseX(e) - startX2 - scrollerEndX;
    setKnobPosition();
  }
  function toggleTransitions(enable) {
    $$invalidate2(13, handle.style.transition = enable ? "" : "none", handle);
    $$invalidate2(12, scroller.style.transition = enable ? "" : "none", scroller);
  }
  function setKnobPosition() {
    if (currentX < scrollerStartX)
      currentX = scrollerStartX;
    if (currentX > scrollerEndX)
      currentX = scrollerEndX;
    $$invalidate2(12, scroller.style.marginLeft = Math.round(currentX) + "px", scroller);
    let handleLeft = handleStartX;
    if (isDragging || value2)
      handleLeft -= scrollerStartX;
    if (isDragging)
      handleLeft += currentX;
    $$invalidate2(13, handle.style.left = `${Math.round(handleLeft - 1)}px`, handle);
  }
  const writable_props = [
    "class",
    "id",
    "name",
    "title",
    "required",
    "disabled",
    "label",
    "error",
    "info",
    "value",
    "labelOnTheLeft",
    "element",
    "inputElement"
  ];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Toggle> was created with unknown prop '${key}'`);
  });
  function contextmenu_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function div2_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      handle = $$value;
      $$invalidate2(13, handle);
    });
  }
  function input_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement2 = $$value;
      $$invalidate2(2, inputElement2);
    });
  }
  function input_change_handler() {
    value2 = this.checked;
    $$invalidate2(0, value2);
  }
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      scroller = $$value;
      $$invalidate2(12, scroller);
    });
  }
  function div6_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(3, className2 = $$props3.class);
    if ("id" in $$props3)
      $$invalidate2(18, id2 = $$props3.id);
    if ("name" in $$props3)
      $$invalidate2(4, name2 = $$props3.name);
    if ("title" in $$props3)
      $$invalidate2(5, title = $$props3.title);
    if ("required" in $$props3)
      $$invalidate2(6, required2 = $$props3.required);
    if ("disabled" in $$props3)
      $$invalidate2(7, disabled2 = $$props3.disabled);
    if ("label" in $$props3)
      $$invalidate2(8, label2 = $$props3.label);
    if ("error" in $$props3)
      $$invalidate2(9, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(10, info2 = $$props3.info);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(11, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("inputElement" in $$props3)
      $$invalidate2(2, inputElement2 = $$props3.inputElement);
  };
  $$self2.$capture_state = () => ({
    onMount,
    afterUpdate,
    createEventDispatcher,
    guid,
    getMouseX,
    isTouchDevice,
    initialMeasure,
    Info: Info_default,
    InputError: InputError_default,
    Label: Label_default,
    dispatch: dispatch3,
    className: className2,
    id: id2,
    name: name2,
    title,
    required: required2,
    disabled: disabled2,
    label: label2,
    error: error2,
    info: info2,
    value: value2,
    labelOnTheLeft: labelOnTheLeft2,
    element: element3,
    inputElement: inputElement2,
    errorMessageId: errorMessageId2,
    scroller,
    handle,
    startX: startX2,
    currentX,
    scrollerStartX,
    scrollerEndX,
    handleStartX,
    isClick,
    isDragging,
    oldValue,
    setValue,
    onKey: onKey2,
    dragStart,
    dragEnd,
    drag,
    toggleTransitions,
    setKnobPosition,
    _id: _id2
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(3, className2 = $$props3.className);
    if ("id" in $$props3)
      $$invalidate2(18, id2 = $$props3.id);
    if ("name" in $$props3)
      $$invalidate2(4, name2 = $$props3.name);
    if ("title" in $$props3)
      $$invalidate2(5, title = $$props3.title);
    if ("required" in $$props3)
      $$invalidate2(6, required2 = $$props3.required);
    if ("disabled" in $$props3)
      $$invalidate2(7, disabled2 = $$props3.disabled);
    if ("label" in $$props3)
      $$invalidate2(8, label2 = $$props3.label);
    if ("error" in $$props3)
      $$invalidate2(9, error2 = $$props3.error);
    if ("info" in $$props3)
      $$invalidate2(10, info2 = $$props3.info);
    if ("value" in $$props3)
      $$invalidate2(0, value2 = $$props3.value);
    if ("labelOnTheLeft" in $$props3)
      $$invalidate2(11, labelOnTheLeft2 = $$props3.labelOnTheLeft);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("inputElement" in $$props3)
      $$invalidate2(2, inputElement2 = $$props3.inputElement);
    if ("scroller" in $$props3)
      $$invalidate2(12, scroller = $$props3.scroller);
    if ("handle" in $$props3)
      $$invalidate2(13, handle = $$props3.handle);
    if ("startX" in $$props3)
      startX2 = $$props3.startX;
    if ("currentX" in $$props3)
      currentX = $$props3.currentX;
    if ("scrollerStartX" in $$props3)
      scrollerStartX = $$props3.scrollerStartX;
    if ("scrollerEndX" in $$props3)
      scrollerEndX = $$props3.scrollerEndX;
    if ("handleStartX" in $$props3)
      handleStartX = $$props3.handleStartX;
    if ("isClick" in $$props3)
      isClick = $$props3.isClick;
    if ("isDragging" in $$props3)
      isDragging = $$props3.isDragging;
    if ("oldValue" in $$props3)
      oldValue = $$props3.oldValue;
    if ("_id" in $$props3)
      $$invalidate2(14, _id2 = $$props3._id);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty[0] & /*id, name*/
    262160) {
      $:
        $$invalidate2(14, _id2 = id2 || name2 || guid());
    }
  };
  return [
    value2,
    element3,
    inputElement2,
    className2,
    name2,
    title,
    required2,
    disabled2,
    label2,
    error2,
    info2,
    labelOnTheLeft2,
    scroller,
    handle,
    _id2,
    errorMessageId2,
    onKey2,
    dragStart,
    id2,
    contextmenu_handler,
    click_handler,
    div2_binding2,
    input_binding2,
    input_change_handler,
    div4_binding,
    div6_binding
  ];
}
var Toggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance31,
      create_fragment31,
      safe_not_equal,
      {
        class: 3,
        id: 18,
        name: 4,
        title: 5,
        required: 6,
        disabled: 7,
        label: 8,
        error: 9,
        info: 10,
        value: 0,
        labelOnTheLeft: 11,
        element: 1,
        inputElement: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toggle",
      options,
      id: create_fragment31.name
    });
  }
  get class() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value2) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value2) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value2) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value2) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value2) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOnTheLeft() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOnTheLeft(value2) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value2) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toggle_default = Toggle;

// src/grid/parts/GridHeadTh.svelte
var file27 = "src/grid/parts/GridHeadTh.svelte";
function create_if_block14(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: { name: (
      /*sortIcon*/
      ctx[3]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & /*sortIcon*/
      8)
        icon_changes.name = /*sortIcon*/
        ctx2[3];
      icon.$set(icon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(9:3) {#if column.field === $sortField}",
    ctx
  });
  return block;
}
function create_fragment32(ctx) {
  let th;
  let div;
  let span;
  let t0_value = (
    /*column*/
    (ctx[0].label || /*column*/
    ctx[0].field) + ""
  );
  let t0;
  let t1;
  let th_title_value;
  let th_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*column*/
    ctx[0].field === /*$sortField*/
    ctx[6] && create_if_block14(ctx)
  );
  const block = {
    c: function create() {
      th = element2("th");
      div = element2("div");
      span = element2("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      add_location(span, file27, 7, 3, 174);
      attr_dev(div, "class", "cell-aligner");
      add_location(div, file27, 6, 2, 144);
      attr_dev(th, "title", th_title_value = /*column*/
      ctx[0].label);
      attr_dev(th, "class", th_class_value = "th-sortable th-" + /*type*/
      ctx[2]);
      attr_dev(th, "tabindex", "0");
      add_location(th, file27, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
      append_dev(th, div);
      append_dev(div, span);
      append_dev(span, t0);
      append_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            th,
            "keydown",
            /*keydown_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            th,
            "click",
            /*sort*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      if ((!current || dirty & /*column*/
      1) && t0_value !== (t0_value = /*column*/
      (ctx2[0].label || /*column*/
      ctx2[0].field) + ""))
        set_data_dev(t0, t0_value);
      if (
        /*column*/
        ctx2[0].field === /*$sortField*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*column, $sortField*/
          65) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*column*/
      1 && th_title_value !== (th_title_value = /*column*/
      ctx2[0].label)) {
        attr_dev(th, "title", th_title_value);
      }
      if (!current || dirty & /*type*/
      4 && th_class_value !== (th_class_value = "th-sortable th-" + /*type*/
      ctx2[2])) {
        attr_dev(th, "class", th_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self2, $$props2, $$invalidate2) {
  let sortField;
  let sortOrder;
  let sortIcon;
  let type;
  let $sortOrder, $$unsubscribe_sortOrder = noop, $$subscribe_sortOrder = () => ($$unsubscribe_sortOrder(), $$unsubscribe_sortOrder = subscribe(sortOrder, ($$value) => $$invalidate2(8, $sortOrder = $$value)), sortOrder);
  let $sortField, $$unsubscribe_sortField = noop, $$subscribe_sortField = () => ($$unsubscribe_sortField(), $$unsubscribe_sortField = subscribe(sortField, ($$value) => $$invalidate2(6, $sortField = $$value)), sortField);
  let $Data, $$unsubscribe_Data = noop, $$subscribe_Data = () => ($$unsubscribe_Data(), $$unsubscribe_Data = subscribe(Data, ($$value) => $$invalidate2(9, $Data = $$value)), Data);
  $$self2.$$.on_destroy.push(() => $$unsubscribe_sortOrder());
  $$self2.$$.on_destroy.push(() => $$unsubscribe_sortField());
  $$self2.$$.on_destroy.push(() => $$unsubscribe_Data());
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("GridHeadTh", slots2, []);
  let { column = {} } = $$props2;
  let { Data = [] } = $$props2;
  validate_store(Data, "Data");
  $$subscribe_Data();
  function sort() {
    if ($sortField === column.field) {
      set_store_value(sortOrder, $sortOrder = $sortOrder === "ASC" ? "DESC" : "ASC", $sortOrder);
    } else {
      set_store_value(sortField, $sortField = column.field, $sortField);
      set_store_value(sortOrder, $sortOrder = "ASC", $sortOrder);
    }
  }
  const writable_props = ["column", "Data"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GridHeadTh> was created with unknown prop '${key}'`);
  });
  const keydown_handler = (e) => e.key === "Enter" && sort();
  $$self2.$$set = ($$props3) => {
    if ("column" in $$props3)
      $$invalidate2(0, column = $$props3.column);
    if ("Data" in $$props3)
      $$subscribe_Data($$invalidate2(1, Data = $$props3.Data));
  };
  $$self2.$capture_state = () => ({
    Icon: Icon_default,
    column,
    Data,
    sort,
    type,
    sortIcon,
    sortOrder,
    sortField,
    $sortOrder,
    $sortField,
    $Data
  });
  $$self2.$inject_state = ($$props3) => {
    if ("column" in $$props3)
      $$invalidate2(0, column = $$props3.column);
    if ("Data" in $$props3)
      $$subscribe_Data($$invalidate2(1, Data = $$props3.Data));
    if ("type" in $$props3)
      $$invalidate2(2, type = $$props3.type);
    if ("sortIcon" in $$props3)
      $$invalidate2(3, sortIcon = $$props3.sortIcon);
    if ("sortOrder" in $$props3)
      $$subscribe_sortOrder($$invalidate2(4, sortOrder = $$props3.sortOrder));
    if ("sortField" in $$props3)
      $$subscribe_sortField($$invalidate2(5, sortField = $$props3.sortField));
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*Data*/
    2) {
      $:
        $$subscribe_sortField($$invalidate2(5, sortField = Data.sortField));
    }
    if ($$self2.$$.dirty & /*Data*/
    2) {
      $:
        $$subscribe_sortOrder($$invalidate2(4, sortOrder = Data.sortOrder));
    }
    if ($$self2.$$.dirty & /*$sortOrder*/
    256) {
      $:
        $$invalidate2(3, sortIcon = $sortOrder === "ASC" ? "arrowNarrowDown" : "arrowNarrowUp");
    }
    if ($$self2.$$.dirty & /*$Data, column*/
    513) {
      $:
        $$invalidate2(2, type = typeof $Data[0][column.field]);
    }
  };
  return [
    column,
    Data,
    type,
    sortIcon,
    sortOrder,
    sortField,
    $sortField,
    sort,
    $sortOrder,
    $Data,
    keydown_handler
  ];
}
var GridHeadTh = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, { column: 0, Data: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GridHeadTh",
      options,
      id: create_fragment32.name
    });
  }
  get column() {
    throw new Error("<GridHeadTh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set column(value2) {
    throw new Error("<GridHeadTh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Data() {
    throw new Error("<GridHeadTh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Data(value2) {
    throw new Error("<GridHeadTh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GridHeadTh_default = GridHeadTh;

// src/grid/parts/GridHead.svelte
var file28 = "src/grid/parts/GridHead.svelte";
function get_each_context8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_if_block_13(ctx) {
  let th;
  let checkbox;
  let current;
  let mounted;
  let dispose;
  checkbox = new Checkbox_default({
    props: {
      indeterminate: (
        /*$indeterminate*/
        ctx[5]
      ),
      checked: (
        /*$checked*/
        ctx[6]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      th = element2("th");
      create_component(checkbox.$$.fragment);
      attr_dev(th, "class", "column-check");
      add_location(th, file28, 3, 3, 37);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
      mount_component(checkbox, th, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          th,
          "click",
          /*toggleSelectAll*/
          ctx[8],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update2(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & /*$indeterminate*/
      32)
        checkbox_changes.indeterminate = /*$indeterminate*/
        ctx2[5];
      if (dirty & /*$checked*/
      64)
        checkbox_changes.checked = /*$checked*/
        ctx2[6];
      checkbox.$set(checkbox_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      destroy_component(checkbox);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(3:2) {#if multiselect}",
    ctx
  });
  return block;
}
function create_if_block15(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*$columns*/
    ctx[7]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block8(get_each_context8(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*$columns, Data*/
      130) {
        each_value = ensure_array_like_dev(
          /*$columns*/
          ctx2[7]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block8(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(8:2) {#if $columns}",
    ctx
  });
  return block;
}
function create_each_block8(ctx) {
  let headth;
  let current;
  headth = new GridHeadTh_default({
    props: {
      column: (
        /*column*/
        ctx[9]
      ),
      Data: (
        /*Data*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(headth.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(headth, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const headth_changes = {};
      if (dirty & /*$columns*/
      128)
        headth_changes.column = /*column*/
        ctx2[9];
      if (dirty & /*Data*/
      2)
        headth_changes.Data = /*Data*/
        ctx2[1];
      headth.$set(headth_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(headth.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(headth.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(headth, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block8.name,
    type: "each",
    source: "(9:3) {#each $columns as column}",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let thead;
  let tr;
  let t;
  let current;
  let if_block0 = (
    /*multiselect*/
    ctx[0] && create_if_block_13(ctx)
  );
  let if_block1 = (
    /*$columns*/
    ctx[7] && create_if_block15(ctx)
  );
  const block = {
    c: function create() {
      thead = element2("thead");
      tr = element2("tr");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      add_location(tr, file28, 1, 1, 9);
      add_location(thead, file28, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, thead, anchor);
      append_dev(thead, tr);
      if (if_block0)
        if_block0.m(tr, null);
      append_dev(tr, t);
      if (if_block1)
        if_block1.m(tr, null);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      if (
        /*multiselect*/
        ctx2[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*multiselect*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(tr, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$columns*/
        ctx2[7]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$columns*/
          128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block15(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(tr, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(thead);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self2, $$props2, $$invalidate2) {
  let columns;
  let checked;
  let indeterminate;
  let $indeterminate, $$unsubscribe_indeterminate = noop, $$subscribe_indeterminate = () => ($$unsubscribe_indeterminate(), $$unsubscribe_indeterminate = subscribe(indeterminate, ($$value) => $$invalidate2(5, $indeterminate = $$value)), indeterminate);
  let $checked, $$unsubscribe_checked = noop, $$subscribe_checked = () => ($$unsubscribe_checked(), $$unsubscribe_checked = subscribe(checked, ($$value) => $$invalidate2(6, $checked = $$value)), checked);
  let $columns, $$unsubscribe_columns = noop, $$subscribe_columns = () => ($$unsubscribe_columns(), $$unsubscribe_columns = subscribe(columns, ($$value) => $$invalidate2(7, $columns = $$value)), columns);
  $$self2.$$.on_destroy.push(() => $$unsubscribe_indeterminate());
  $$self2.$$.on_destroy.push(() => $$unsubscribe_checked());
  $$self2.$$.on_destroy.push(() => $$unsubscribe_columns());
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("GridHead", slots2, []);
  let { multiselect = false } = $$props2;
  let { Data = [] } = $$props2;
  function toggleSelectAll() {
    Data.toggleSelectAll(!$checked && !$indeterminate);
  }
  const writable_props = ["multiselect", "Data"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GridHead> was created with unknown prop '${key}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("multiselect" in $$props3)
      $$invalidate2(0, multiselect = $$props3.multiselect);
    if ("Data" in $$props3)
      $$invalidate2(1, Data = $$props3.Data);
  };
  $$self2.$capture_state = () => ({
    Checkbox: Checkbox_default,
    HeadTh: GridHeadTh_default,
    multiselect,
    Data,
    toggleSelectAll,
    indeterminate,
    checked,
    columns,
    $indeterminate,
    $checked,
    $columns
  });
  $$self2.$inject_state = ($$props3) => {
    if ("multiselect" in $$props3)
      $$invalidate2(0, multiselect = $$props3.multiselect);
    if ("Data" in $$props3)
      $$invalidate2(1, Data = $$props3.Data);
    if ("indeterminate" in $$props3)
      $$subscribe_indeterminate($$invalidate2(2, indeterminate = $$props3.indeterminate));
    if ("checked" in $$props3)
      $$subscribe_checked($$invalidate2(3, checked = $$props3.checked));
    if ("columns" in $$props3)
      $$subscribe_columns($$invalidate2(4, columns = $$props3.columns));
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*Data*/
    2) {
      $:
        $$subscribe_columns($$invalidate2(4, columns = Data.columns));
    }
    if ($$self2.$$.dirty & /*Data*/
    2) {
      $:
        $$subscribe_checked($$invalidate2(3, checked = Data.allSelected));
    }
    if ($$self2.$$.dirty & /*Data*/
    2) {
      $:
        $$subscribe_indeterminate($$invalidate2(2, indeterminate = Data.someSelected));
    }
  };
  return [
    multiselect,
    Data,
    indeterminate,
    checked,
    columns,
    $indeterminate,
    $checked,
    $columns,
    toggleSelectAll
  ];
}
var GridHead = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, { multiselect: 0, Data: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GridHead",
      options,
      id: create_fragment33.name
    });
  }
  get multiselect() {
    throw new Error("<GridHead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiselect(value2) {
    throw new Error("<GridHead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Data() {
    throw new Error("<GridHead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Data(value2) {
    throw new Error("<GridHead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GridHead_default = GridHead;

// src/grid/parts/GridRow.svelte
var file29 = "src/grid/parts/GridRow.svelte";
function get_each_context9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_if_block16(ctx) {
  let td;
  let checkbox;
  let updating_checked;
  let current;
  function checkbox_checked_binding(value2) {
    ctx[8](value2);
  }
  let checkbox_props = { tabindex: "-1" };
  if (
    /*item*/
    ctx[0].selected !== void 0
  ) {
    checkbox_props.checked = /*item*/
    ctx[0].selected;
  }
  checkbox = new Checkbox_default({ props: checkbox_props, $$inline: true });
  binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
  const block = {
    c: function create() {
      td = element2("td");
      create_component(checkbox.$$.fragment);
      attr_dev(td, "class", "column-check");
      add_location(td, file29, 9, 3, 185);
    },
    m: function mount(target, anchor) {
      insert_dev(target, td, anchor);
      mount_component(checkbox, td, null);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const checkbox_changes = {};
      if (!updating_checked && dirty & /*item*/
      1) {
        updating_checked = true;
        checkbox_changes.checked = /*item*/
        ctx2[0].selected;
        add_flush_callback(() => updating_checked = false);
      }
      checkbox.$set(checkbox_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      destroy_component(checkbox);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(9:2) {#if multiselect}",
    ctx
  });
  return block;
}
function create_each_block9(ctx) {
  let td;
  let html_tag;
  let raw_value = (
    /*cellRenderer*/
    ctx[7](
      /*column*/
      ctx[10],
      /*item*/
      ctx[0]
    ) + ""
  );
  let t;
  let td_class_value;
  const block = {
    c: function create() {
      td = element2("td");
      html_tag = new HtmlTag(false);
      t = space();
      html_tag.a = t;
      attr_dev(td, "class", td_class_value = "td-" + /*getType*/
      ctx[6](
        /*column*/
        ctx[10]
      ));
      add_location(td, file29, 14, 3, 321);
    },
    m: function mount(target, anchor) {
      insert_dev(target, td, anchor);
      html_tag.m(raw_value, td);
      append_dev(td, t);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*$columns, item*/
      33 && raw_value !== (raw_value = /*cellRenderer*/
      ctx2[7](
        /*column*/
        ctx2[10],
        /*item*/
        ctx2[0]
      ) + ""))
        html_tag.p(raw_value);
      if (dirty & /*$columns*/
      32 && td_class_value !== (td_class_value = "td-" + /*getType*/
      ctx2[6](
        /*column*/
        ctx2[10]
      ))) {
        attr_dev(td, "class", td_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block9.name,
    type: "each",
    source: "(14:2) {#each $columns as column}",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let tbody;
  let tr;
  let t;
  let tbody_class_value;
  let current;
  let if_block = (
    /*multiselect*/
    ctx[1] && create_if_block16(ctx)
  );
  let each_value = ensure_array_like_dev(
    /*$columns*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block9(get_each_context9(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      tbody = element2("tbody");
      tr = element2("tr");
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      add_location(tr, file29, 7, 1, 157);
      attr_dev(
        tbody,
        "data-id",
        /*id*/
        ctx[3]
      );
      attr_dev(tbody, "class", tbody_class_value = "item item-" + /*id*/
      ctx[3]);
      attr_dev(tbody, "tabindex", "0");
      toggle_class(
        tbody,
        "row-selected",
        /*item*/
        ctx[0].selected
      );
      add_location(tbody, file29, 1, 0, 55);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, tbody, anchor);
      append_dev(tbody, tr);
      if (if_block)
        if_block.m(tr, null);
      append_dev(tr, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      if (
        /*multiselect*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*multiselect*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block16(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(tr, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & /*getType, $columns, cellRenderer, item*/
      225) {
        each_value = ensure_array_like_dev(
          /*$columns*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block9(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & /*id*/
      8) {
        attr_dev(
          tbody,
          "data-id",
          /*id*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*id*/
      8 && tbody_class_value !== (tbody_class_value = "item item-" + /*id*/
      ctx2[3])) {
        attr_dev(tbody, "class", tbody_class_value);
      }
      if (!current || dirty & /*id, item*/
      9) {
        toggle_class(
          tbody,
          "row-selected",
          /*item*/
          ctx2[0].selected
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tbody);
      }
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self2, $$props2, $$invalidate2) {
  let columns;
  let id2;
  let $Data, $$unsubscribe_Data = noop, $$subscribe_Data = () => ($$unsubscribe_Data(), $$unsubscribe_Data = subscribe(Data, ($$value) => $$invalidate2(9, $Data = $$value)), Data);
  let $columns, $$unsubscribe_columns = noop, $$subscribe_columns = () => ($$unsubscribe_columns(), $$unsubscribe_columns = subscribe(columns, ($$value) => $$invalidate2(5, $columns = $$value)), columns);
  $$self2.$$.on_destroy.push(() => $$unsubscribe_Data());
  $$self2.$$.on_destroy.push(() => $$unsubscribe_columns());
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("GridRow", slots2, []);
  let { item = {} } = $$props2;
  let { multiselect = false } = $$props2;
  let { Data = [] } = $$props2;
  validate_store(Data, "Data");
  $$subscribe_Data();
  function getType(column) {
    return typeof $Data[0][column.field];
  }
  function cellRenderer(column, _item) {
    if (column.renderer)
      return column.renderer(_item);
    return item[column.field] || "";
  }
  const writable_props = ["item", "multiselect", "Data"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GridRow> was created with unknown prop '${key}'`);
  });
  function checkbox_checked_binding(value2) {
    if ($$self2.$$.not_equal(item.selected, value2)) {
      item.selected = value2;
      $$invalidate2(0, item);
    }
  }
  $$self2.$$set = ($$props3) => {
    if ("item" in $$props3)
      $$invalidate2(0, item = $$props3.item);
    if ("multiselect" in $$props3)
      $$invalidate2(1, multiselect = $$props3.multiselect);
    if ("Data" in $$props3)
      $$subscribe_Data($$invalidate2(2, Data = $$props3.Data));
  };
  $$self2.$capture_state = () => ({
    Checkbox: Checkbox_default,
    item,
    multiselect,
    Data,
    getType,
    cellRenderer,
    id: id2,
    columns,
    $Data,
    $columns
  });
  $$self2.$inject_state = ($$props3) => {
    if ("item" in $$props3)
      $$invalidate2(0, item = $$props3.item);
    if ("multiselect" in $$props3)
      $$invalidate2(1, multiselect = $$props3.multiselect);
    if ("Data" in $$props3)
      $$subscribe_Data($$invalidate2(2, Data = $$props3.Data));
    if ("id" in $$props3)
      $$invalidate2(3, id2 = $$props3.id);
    if ("columns" in $$props3)
      $$subscribe_columns($$invalidate2(4, columns = $$props3.columns));
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*Data*/
    4) {
      $:
        $$subscribe_columns($$invalidate2(4, columns = Data.columns));
    }
    if ($$self2.$$.dirty & /*item*/
    1) {
      $:
        $$invalidate2(3, id2 = item.id || item.field);
    }
  };
  return [
    item,
    multiselect,
    Data,
    id2,
    columns,
    $columns,
    getType,
    cellRenderer,
    checkbox_checked_binding
  ];
}
var GridRow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, { item: 0, multiselect: 1, Data: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GridRow",
      options,
      id: create_fragment34.name
    });
  }
  get item() {
    throw new Error("<GridRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set item(value2) {
    throw new Error("<GridRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiselect() {
    throw new Error("<GridRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiselect(value2) {
    throw new Error("<GridRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Data() {
    throw new Error("<GridRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Data(value2) {
    throw new Error("<GridRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GridRow_default = GridRow;

// src/grid/parts/GridBody.svelte
function get_each_context10(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block10(ctx) {
  let gridrow;
  let current;
  gridrow = new GridRow_default({
    props: {
      item: (
        /*item*/
        ctx[3]
      ),
      multiselect: (
        /*multiselect*/
        ctx[0]
      ),
      Data: (
        /*Data*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(gridrow.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(gridrow, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const gridrow_changes = {};
      if (dirty & /*$Data*/
      4)
        gridrow_changes.item = /*item*/
        ctx2[3];
      if (dirty & /*multiselect*/
      1)
        gridrow_changes.multiselect = /*multiselect*/
        ctx2[0];
      if (dirty & /*Data*/
      2)
        gridrow_changes.Data = /*Data*/
        ctx2[1];
      gridrow.$set(gridrow_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(gridrow.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(gridrow.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(gridrow, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block10.name,
    type: "each",
    source: "(1:0) {#each $Data as item}",
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*$Data*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block10(get_each_context10(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      if (dirty & /*$Data, multiselect, Data*/
      7) {
        each_value = ensure_array_like_dev(
          /*$Data*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context10(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block10(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self2, $$props2, $$invalidate2) {
  let $Data, $$unsubscribe_Data = noop, $$subscribe_Data = () => ($$unsubscribe_Data(), $$unsubscribe_Data = subscribe(Data, ($$value) => $$invalidate2(2, $Data = $$value)), Data);
  $$self2.$$.on_destroy.push(() => $$unsubscribe_Data());
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("GridBody", slots2, []);
  let { multiselect = false } = $$props2;
  let { Data = [] } = $$props2;
  validate_store(Data, "Data");
  $$subscribe_Data();
  const writable_props = ["multiselect", "Data"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GridBody> was created with unknown prop '${key}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("multiselect" in $$props3)
      $$invalidate2(0, multiselect = $$props3.multiselect);
    if ("Data" in $$props3)
      $$subscribe_Data($$invalidate2(1, Data = $$props3.Data));
  };
  $$self2.$capture_state = () => ({ GridRow: GridRow_default, multiselect, Data, $Data });
  $$self2.$inject_state = ($$props3) => {
    if ("multiselect" in $$props3)
      $$invalidate2(0, multiselect = $$props3.multiselect);
    if ("Data" in $$props3)
      $$subscribe_Data($$invalidate2(1, Data = $$props3.Data));
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [multiselect, Data, $Data];
}
var GridBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, { multiselect: 0, Data: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GridBody",
      options,
      id: create_fragment35.name
    });
  }
  get multiselect() {
    throw new Error("<GridBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiselect(value2) {
    throw new Error("<GridBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Data() {
    throw new Error("<GridBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Data(value2) {
    throw new Error("<GridBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GridBody_default = GridBody;

// src/grid/parts/GridFoot.svelte
var file30 = "src/grid/parts/GridFoot.svelte";
function get_each_context11(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_if_block17(ctx) {
  let td;
  const block = {
    c: function create() {
      td = element2("td");
      add_location(td, file30, 3, 3, 37);
    },
    m: function mount(target, anchor) {
      insert_dev(target, td, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(3:2) {#if multiselect}",
    ctx
  });
  return block;
}
function create_each_block11(ctx) {
  let td;
  let t_value = (
    /*column*/
    (ctx[7].total ? (
      /*sumColumn*/
      ctx[4](
        /*column*/
        ctx[7]
      )
    ) : "") + ""
  );
  let t;
  let td_class_value;
  const block = {
    c: function create() {
      td = element2("td");
      t = text(t_value);
      attr_dev(td, "class", td_class_value = "td-" + /*getType*/
      ctx[5](
        /*column*/
        ctx[7]
      ));
      add_location(td, file30, 6, 3, 87);
    },
    m: function mount(target, anchor) {
      insert_dev(target, td, anchor);
      append_dev(td, t);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*$columns*/
      8 && t_value !== (t_value = /*column*/
      (ctx2[7].total ? (
        /*sumColumn*/
        ctx2[4](
          /*column*/
          ctx2[7]
        )
      ) : "") + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$columns*/
      8 && td_class_value !== (td_class_value = "td-" + /*getType*/
      ctx2[5](
        /*column*/
        ctx2[7]
      ))) {
        attr_dev(td, "class", td_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block11.name,
    type: "each",
    source: "(6:2) {#each $columns as column}",
    ctx
  });
  return block;
}
function create_fragment36(ctx) {
  let tfoot;
  let tr;
  let t;
  let if_block = (
    /*multiselect*/
    ctx[0] && create_if_block17(ctx)
  );
  let each_value = ensure_array_like_dev(
    /*$columns*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block11(get_each_context11(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      tfoot = element2("tfoot");
      tr = element2("tr");
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      add_location(tr, file30, 1, 1, 9);
      add_location(tfoot, file30, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, tfoot, anchor);
      append_dev(tfoot, tr);
      if (if_block)
        if_block.m(tr, null);
      append_dev(tr, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
    },
    p: function update2(ctx2, [dirty]) {
      if (
        /*multiselect*/
        ctx2[0]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block17(ctx2);
          if_block.c();
          if_block.m(tr, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*getType, $columns, sumColumn*/
      56) {
        each_value = ensure_array_like_dev(
          /*$columns*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context11(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block11(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tfoot);
      }
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self2, $$props2, $$invalidate2) {
  let columns;
  let $Data, $$unsubscribe_Data = noop, $$subscribe_Data = () => ($$unsubscribe_Data(), $$unsubscribe_Data = subscribe(Data, ($$value) => $$invalidate2(6, $Data = $$value)), Data);
  let $columns, $$unsubscribe_columns = noop, $$subscribe_columns = () => ($$unsubscribe_columns(), $$unsubscribe_columns = subscribe(columns, ($$value) => $$invalidate2(3, $columns = $$value)), columns);
  $$self2.$$.on_destroy.push(() => $$unsubscribe_Data());
  $$self2.$$.on_destroy.push(() => $$unsubscribe_columns());
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("GridFoot", slots2, []);
  let { multiselect = false } = $$props2;
  let { Data = [] } = $$props2;
  validate_store(Data, "Data");
  $$subscribe_Data();
  function sumColumn(column) {
    return $Data.reduce((acc, row) => acc + +row[column.field], 0);
  }
  function getType(column) {
    return typeof $Data[0][column.field];
  }
  const writable_props = ["multiselect", "Data"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GridFoot> was created with unknown prop '${key}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("multiselect" in $$props3)
      $$invalidate2(0, multiselect = $$props3.multiselect);
    if ("Data" in $$props3)
      $$subscribe_Data($$invalidate2(1, Data = $$props3.Data));
  };
  $$self2.$capture_state = () => ({
    multiselect,
    Data,
    sumColumn,
    getType,
    columns,
    $Data,
    $columns
  });
  $$self2.$inject_state = ($$props3) => {
    if ("multiselect" in $$props3)
      $$invalidate2(0, multiselect = $$props3.multiselect);
    if ("Data" in $$props3)
      $$subscribe_Data($$invalidate2(1, Data = $$props3.Data));
    if ("columns" in $$props3)
      $$subscribe_columns($$invalidate2(2, columns = $$props3.columns));
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*Data*/
    2) {
      $:
        $$subscribe_columns($$invalidate2(2, columns = Data.columns));
    }
  };
  return [multiselect, Data, columns, $columns, sumColumn, getType];
}
var GridFoot = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, { multiselect: 0, Data: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GridFoot",
      options,
      id: create_fragment36.name
    });
  }
  get multiselect() {
    throw new Error("<GridFoot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiselect(value2) {
    throw new Error("<GridFoot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Data() {
    throw new Error("<GridFoot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Data(value2) {
    throw new Error("<GridFoot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GridFoot_default = GridFoot;

// src/grid/Grid.svelte
var file31 = "src/grid/Grid.svelte";
function create_if_block18(ctx) {
  let h1;
  let t;
  const block = {
    c: function create() {
      h1 = element2("h1");
      t = text(
        /*title*/
        ctx[2]
      );
      attr_dev(h1, "class", "grid-title");
      add_location(h1, file31, 11, 2, 304);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h1, anchor);
      append_dev(h1, t);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*title*/
      4)
        set_data_dev(
          t,
          /*title*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(11:1) {#if title}",
    ctx
  });
  return block;
}
function create_fragment37(ctx) {
  let div;
  let t0;
  let table;
  let gridhead;
  let t1;
  let gridbody;
  let t2;
  let gridfoot;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*title*/
    ctx[2] && create_if_block18(ctx)
  );
  gridhead = new GridHead_default({
    props: {
      multiselect: (
        /*multiselect*/
        ctx[4]
      ),
      Data: (
        /*Data*/
        ctx[6]
      )
    },
    $$inline: true
  });
  gridbody = new GridBody_default({
    props: {
      multiselect: (
        /*multiselect*/
        ctx[4]
      ),
      Data: (
        /*Data*/
        ctx[6]
      )
    },
    $$inline: true
  });
  gridfoot = new GridFoot_default({
    props: {
      multiselect: (
        /*multiselect*/
        ctx[4]
      ),
      Data: (
        /*Data*/
        ctx[6]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element2("div");
      if (if_block)
        if_block.c();
      t0 = space();
      table = element2("table");
      create_component(gridhead.$$.fragment);
      t1 = space();
      create_component(gridbody.$$.fragment);
      t2 = space();
      create_component(gridfoot.$$.fragment);
      add_location(table, file31, 13, 1, 348);
      attr_dev(div, "class", div_class_value = "table grid grid-sortable " + /*className*/
      ctx[1]);
      toggle_class(
        div,
        "round",
        /*round*/
        ctx[3]
      );
      toggle_class(
        div,
        "interactive",
        /*_interactive*/
        ctx[5]
      );
      add_location(div, file31, 1, 0, 59);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t0);
      append_dev(div, table);
      mount_component(gridhead, table, null);
      append_dev(table, t1);
      mount_component(gridbody, table, null);
      append_dev(table, t2);
      mount_component(gridfoot, table, null);
      ctx[17](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*onClick*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "focus",
            /*onFocus*/
            ctx[7],
            true,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*onKeyDown*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "dblclick",
            /*onDblClick*/
            ctx[9],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block18(ctx2);
          if_block.c();
          if_block.m(div, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const gridhead_changes = {};
      if (dirty & /*multiselect*/
      16)
        gridhead_changes.multiselect = /*multiselect*/
        ctx2[4];
      gridhead.$set(gridhead_changes);
      const gridbody_changes = {};
      if (dirty & /*multiselect*/
      16)
        gridbody_changes.multiselect = /*multiselect*/
        ctx2[4];
      gridbody.$set(gridbody_changes);
      const gridfoot_changes = {};
      if (dirty & /*multiselect*/
      16)
        gridfoot_changes.multiselect = /*multiselect*/
        ctx2[4];
      gridfoot.$set(gridfoot_changes);
      if (!current || dirty & /*className*/
      2 && div_class_value !== (div_class_value = "table grid grid-sortable " + /*className*/
      ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*className, round*/
      10) {
        toggle_class(
          div,
          "round",
          /*round*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*className, _interactive*/
      34) {
        toggle_class(
          div,
          "interactive",
          /*_interactive*/
          ctx2[5]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(gridhead.$$.fragment, local);
      transition_in(gridbody.$$.fragment, local);
      transition_in(gridfoot.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(gridhead.$$.fragment, local);
      transition_out(gridbody.$$.fragment, local);
      transition_out(gridfoot.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block)
        if_block.d();
      destroy_component(gridhead);
      destroy_component(gridbody);
      destroy_component(gridfoot);
      ctx[17](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var rowSelector = "tbody";
function instance37($$self2, $$props2, $$invalidate2) {
  let _interactive;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Grid", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { title = "" } = $$props2;
  let { interactive = true } = $$props2;
  let { round = false } = $$props2;
  let { scrollContainer = void 0 } = $$props2;
  let { scrollCorrectionOffset = "0" } = $$props2;
  let { columns = [] } = $$props2;
  let { data = [] } = $$props2;
  let { multiselect = false } = $$props2;
  let { dblClickDelay = 500 } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  const dispatch3 = createEventDispatcher();
  let headerHeight = 0;
  const Data = DataStore();
  let selectedIdx = -1;
  let clickTimer;
  let previousKey;
  onMount(() => {
    if (_interactive) {
      requestAnimationFrame(() => headerHeight = getHeaderHeight(element3));
    }
  });
  beforeUpdate(() => {
    if (data)
      Data.set(data);
    if (columns)
      Data.columns.set(columns);
  });
  function selectPrev() {
    const rows = getSelectableItems(element3);
    if (selectedIdx <= 0)
      return;
    selectedIdx -= 1;
    const rowEl = rows[selectedIdx];
    rowEl.focus();
    dispatch3("select", { selectedItem: rowEl });
  }
  function selectNext() {
    const rows = getSelectableItems(element3);
    if (selectedIdx >= rows.length - 1)
      return;
    selectedIdx += 1;
    const rowEl = rows[selectedIdx];
    rowEl.focus();
    dispatch3("select", { selectedItem: rowEl });
  }
  function selectRow(e, rowEl) {
    if (!rowEl)
      return;
    if (rowEl !== document.activeElement)
      rowEl.focus();
    const oldIdx = selectedIdx;
    const rows = getSelectableItems(element3);
    selectedIdx = rows.findIndex((item) => item === rowEl);
    if (oldIdx !== selectedIdx)
      dispatch3("select", { event: e, selectedItem: rowEl });
    const scrollEl = getScrollContainer(element3, scrollContainer);
    if (!scrollEl)
      return;
    const topMargin = scrollEl === element3 ? 0 : element3.offsetTop;
    const scrollCorrection = parseFloat(scrollCorrectionOffset);
    const paddingTop = 10;
    const paddingBottom = 2;
    let top = rowEl.offsetTop + topMargin + scrollCorrection + paddingTop;
    if (scrollEl.scrollTop > top)
      scrollEl.scrollTo({ top: Math.round(top) });
    else {
      top = rowEl.offsetTop + rowEl.offsetHeight - scrollEl.offsetHeight + headerHeight + topMargin + scrollCorrection + paddingBottom;
      if (scrollEl.scrollTop < top)
        scrollEl.scrollTo({ top: Math.round(top) });
    }
  }
  function onFocus2(e) {
    if (shouldSkipNav(e, element3))
      return;
    const notRowFocus = !e.target.matches(rowSelector);
    if (notRowFocus || !_interactive)
      return;
    const rowEl = e.target.closest(rowSelector);
    if (rowEl) {
      selectRow(e, rowEl);
      dispatch3("focus", { event: e, selectedItem: rowEl });
    }
  }
  function onClick(e) {
    if (shouldSkipNav(e, element3))
      return;
    const rowEl = e.target.closest(rowSelector);
    if (!rowEl)
      return;
    if (e.target.closest(".column-check")) {
      const item = { id: +rowEl.dataset.id };
      Data.toggleSelection(item, e);
    }
    selectRow(e, rowEl);
    if (clickTimer)
      clearTimeout(clickTimer);
    clickTimer = setTimeout(() => dispatch3("click", { event: e, selectedItem: rowEl }), dblClickDelay);
  }
  function onDblClick(e) {
    if (!_interactive)
      return;
    if (shouldSkipNav(e, element3))
      return;
    if (clickTimer)
      clearTimeout(clickTimer);
    const rowEl = e.target.closest(rowSelector);
    if (!rowEl)
      return;
    const item = { id: +rowEl.dataset.id };
    Data.toggleSelection(item, e, false);
    requestAnimationFrame(() => {
      const selectedItem = getSelectableItems(element3)[selectedIdx];
      dispatch3("dblclick", { event: e, selectedItem });
    });
  }
  function onKeyDown(e) {
    if (!_interactive)
      return;
    if (shouldSkipNav(e, element3))
      return;
    if (e.key === "ArrowUp" || e.key === "k") {
      e.preventDefault();
      selectPrev();
    }
    if (e.key === "ArrowDown" || e.key === "j") {
      e.preventDefault();
      selectNext();
    }
    if (e.key === "ArrowLeft" || e.key === "g" && previousKey === "g") {
      e.preventDefault();
      selectedIdx = -1;
      selectNext();
    }
    if (e.key === "ArrowRight" || e.key === "G") {
      e.preventDefault();
      const rows = getSelectableItems(element3);
      selectedIdx = rows && rows.length - 2;
      selectNext();
    }
    const rowEl = e && e.target && e.target.closest(rowSelector);
    if (rowEl && e.key === " ") {
      e.preventDefault();
      Data.toggleSelection({ id: +rowEl.dataset.id }, e);
    } else if (e.metaKey) {
      if (e.key === "a") {
        e.preventDefault();
        Data.toggleSelectAll(true);
      } else if (e.key === "0")
        Data.toggleSelectAll(false);
    }
    previousKey = e.key;
    const selectedItem = getSelectableItems(element3)[selectedIdx];
    dispatch3("keydown", { event: e, key: e.key, selectedItem });
  }
  const writable_props = [
    "class",
    "title",
    "interactive",
    "round",
    "scrollContainer",
    "scrollCorrectionOffset",
    "columns",
    "data",
    "multiselect",
    "dblClickDelay",
    "element"
  ];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Grid> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("title" in $$props3)
      $$invalidate2(2, title = $$props3.title);
    if ("interactive" in $$props3)
      $$invalidate2(11, interactive = $$props3.interactive);
    if ("round" in $$props3)
      $$invalidate2(3, round = $$props3.round);
    if ("scrollContainer" in $$props3)
      $$invalidate2(12, scrollContainer = $$props3.scrollContainer);
    if ("scrollCorrectionOffset" in $$props3)
      $$invalidate2(13, scrollCorrectionOffset = $$props3.scrollCorrectionOffset);
    if ("columns" in $$props3)
      $$invalidate2(14, columns = $$props3.columns);
    if ("data" in $$props3)
      $$invalidate2(15, data = $$props3.data);
    if ("multiselect" in $$props3)
      $$invalidate2(4, multiselect = $$props3.multiselect);
    if ("dblClickDelay" in $$props3)
      $$invalidate2(16, dblClickDelay = $$props3.dblClickDelay);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
  };
  $$self2.$capture_state = () => ({
    onMount,
    createEventDispatcher,
    beforeUpdate,
    shouldSkipNav,
    getSelectableItems,
    getScrollContainer,
    getHeaderHeight,
    DataStore,
    GridHead: GridHead_default,
    GridFoot: GridFoot_default,
    GridBody: GridBody_default,
    className: className2,
    title,
    interactive,
    round,
    scrollContainer,
    scrollCorrectionOffset,
    columns,
    data,
    multiselect,
    dblClickDelay,
    element: element3,
    dispatch: dispatch3,
    headerHeight,
    rowSelector,
    Data,
    selectedIdx,
    clickTimer,
    previousKey,
    selectPrev,
    selectNext,
    selectRow,
    onFocus: onFocus2,
    onClick,
    onDblClick,
    onKeyDown,
    _interactive
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("title" in $$props3)
      $$invalidate2(2, title = $$props3.title);
    if ("interactive" in $$props3)
      $$invalidate2(11, interactive = $$props3.interactive);
    if ("round" in $$props3)
      $$invalidate2(3, round = $$props3.round);
    if ("scrollContainer" in $$props3)
      $$invalidate2(12, scrollContainer = $$props3.scrollContainer);
    if ("scrollCorrectionOffset" in $$props3)
      $$invalidate2(13, scrollCorrectionOffset = $$props3.scrollCorrectionOffset);
    if ("columns" in $$props3)
      $$invalidate2(14, columns = $$props3.columns);
    if ("data" in $$props3)
      $$invalidate2(15, data = $$props3.data);
    if ("multiselect" in $$props3)
      $$invalidate2(4, multiselect = $$props3.multiselect);
    if ("dblClickDelay" in $$props3)
      $$invalidate2(16, dblClickDelay = $$props3.dblClickDelay);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("headerHeight" in $$props3)
      headerHeight = $$props3.headerHeight;
    if ("selectedIdx" in $$props3)
      selectedIdx = $$props3.selectedIdx;
    if ("clickTimer" in $$props3)
      clickTimer = $$props3.clickTimer;
    if ("previousKey" in $$props3)
      previousKey = $$props3.previousKey;
    if ("_interactive" in $$props3)
      $$invalidate2(5, _interactive = $$props3._interactive);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*interactive*/
    2048) {
      $:
        $$invalidate2(5, _interactive = interactive === true || interactive === "true");
    }
  };
  return [
    element3,
    className2,
    title,
    round,
    multiselect,
    _interactive,
    Data,
    onFocus2,
    onClick,
    onDblClick,
    onKeyDown,
    interactive,
    scrollContainer,
    scrollCorrectionOffset,
    columns,
    data,
    dblClickDelay,
    div_binding
  ];
}
var Grid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, {
      class: 1,
      title: 2,
      interactive: 11,
      round: 3,
      scrollContainer: 12,
      scrollCorrectionOffset: 13,
      columns: 14,
      data: 15,
      multiselect: 4,
      dblClickDelay: 16,
      element: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Grid",
      options,
      id: create_fragment37.name
    });
  }
  get class() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value2) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value2) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get round() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set round(value2) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollContainer() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollContainer(value2) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollCorrectionOffset() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollCorrectionOffset(value2) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columns() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columns(value2) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value2) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiselect() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiselect(value2) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dblClickDelay() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dblClickDelay(value2) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Grid_default = Grid;

// src/menu/utils.js
function addArias2(el) {
  if (!el)
    return;
  el.setAttribute("aria-haspopup", "true");
  el.setAttribute("aria-expanded", "true");
}
function removeArias2(selectorOrEl) {
  if (typeof selectorOrEl === "string" && selectorOrEl !== "body") {
    const elems = document.querySelectorAll(selectorOrEl);
    if (elems && elems.length)
      elems.forEach((el) => el.setAttribute("aria-expanded", "false"));
  } else if (selectorOrEl instanceof Element) {
    selectorOrEl.setAttribute("aria-expanded", "false");
  }
}

// src/menu/longpress.js
var maxDiffX = 10;
var maxDiffY = 10;
var startX = 0;
var startY = 0;
var EVENT_NAME = "longpress";
var DELAY = 500;
var timer = null;
function fireLongPressEvent(originalEvent) {
  clearTimer();
  originalEvent = unifyEvent(originalEvent);
  const event = new CustomEvent(EVENT_NAME, {
    bubbles: true,
    cancelable: true,
    detail: {
      x: originalEvent.clientX,
      y: originalEvent.clientY
    }
  });
  originalEvent.target.dispatchEvent(event);
}
function unifyEvent(e) {
  if (e.changedTouches !== void 0)
    return e.changedTouches[0];
  return e;
}
function startTimer(e) {
  clearTimer();
  timer = setTimeout(() => fireLongPressEvent(e), DELAY);
}
function clearTimer() {
  if (!timer)
    return;
  clearTimeout(timer);
  timer = null;
}
function mouseDownHandler(e) {
  if (e.pointerType === "mouse" && e.button !== 0)
    return;
  e = unifyEvent(e);
  startX = e.clientX;
  startY = e.clientY;
  startTimer(e);
}
function mouseMoveHandler(e) {
  e = unifyEvent(e);
  const diffX = Math.abs(startX - e.clientX);
  const diffY = Math.abs(startY - e.clientY);
  if (diffX >= maxDiffX || diffY >= maxDiffY)
    clearTimer();
}
function init2(delay = 500, eventName = "longpress") {
  if (window.longPressEventInitialised)
    return;
  DELAY = delay;
  EVENT_NAME = eventName;
  const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
  const hasPointerEvents = "PointerEvent" in window || navigator && "msPointerEnabled" in navigator;
  const mouseDown = isTouch ? "touchstart" : hasPointerEvents ? "pointerdown" : "mousedown";
  const mouseUp = isTouch ? "touchend" : hasPointerEvents ? "pointerup" : "mouseup";
  const mouseMove = isTouch ? "touchmove" : hasPointerEvents ? "pointermove" : "mousemove";
  document.addEventListener(mouseDown, mouseDownHandler, true);
  document.addEventListener(mouseMove, mouseMoveHandler, true);
  document.addEventListener(mouseUp, clearTimer, true);
  document.addEventListener("scroll", clearTimer, true);
  window.longPressEventInitialised = true;
}

// src/menu/Menu.svelte
var file32 = "src/menu/Menu.svelte";
function create_if_block19(ctx) {
  let menu;
  let menu_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const block = {
    c: function create() {
      menu = element2("menu");
      if (default_slot)
        default_slot.c();
      attr_dev(menu, "tabindex", "0");
      attr_dev(menu, "class", menu_class_value = "menu " + /*className*/
      ctx[1]);
      add_location(menu, file32, 2, 1, 69);
    },
    m: function mount(target, anchor) {
      insert_dev(target, menu, anchor);
      if (default_slot) {
        default_slot.m(menu, null);
      }
      ctx[12](menu);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*className*/
      2 && menu_class_value !== (menu_class_value = "menu " + /*className*/
      ctx2[1])) {
        attr_dev(menu, "class", menu_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(menu);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[12](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(2:0) {#if opened}",
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*opened*/
    ctx[2] && create_if_block19(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (
        /*opened*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*opened*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block19(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var buttonSelector = ".menu-item:not(.disabled,.menu-separator)";
function instance38($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Menu", slots2, ["default"]);
  const dispatch3 = createEventDispatcher();
  const isAnyMobile = isMobile();
  const isMobileSafari = navigator.userAgent.match(/safari/i) && navigator.vendor.match(/apple/i) && navigator.maxTouchPoints;
  const contextmenuEventName = isMobileSafari ? "longpress" : "contextmenu";
  let { class: className2 = "" } = $$props2;
  let { type = void 0 } = $$props2;
  let { targetSelector = "body" } = $$props2;
  let { closeOnClick = true } = $$props2;
  let { align = void 0 } = $$props2;
  let { valign = void 0 } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  const menuButtons = [];
  let targetEl, focusedEl, opened = false;
  let hovering = false;
  let closing = false;
  let eventsAdded = false;
  let typeQuery = "", typeTimer;
  let openEvent;
  setContext("MenuContext", { targetEl: () => targetEl });
  onMount(() => {
    if (type === "context") {
      if (isMobileSafari)
        init2();
      if (isAnyMobile)
        document.addEventListener("touchend", onTouchend);
      document.addEventListener(contextmenuEventName, onContextMenu);
    }
  });
  onDestroy(() => {
    if (type === "context") {
      if (isAnyMobile)
        document.removeEventListener("touchend", onTouchend);
      document.removeEventListener(contextmenuEventName, onContextMenu);
    }
    if (element3)
      element3.remove();
    removeEventListeners();
  });
  function open(e) {
    if (closing)
      return;
    if (opened) {
      if (type !== "context")
        return close();
      return Promise.resolve();
    }
    $$invalidate2(2, opened = true);
    focusedEl = null;
    if (e && e.detail && e.detail instanceof Event)
      e = e.detail;
    if (type !== "context")
      targetEl = e && e.target;
    if (targetEl) {
      removeArias2(targetSelector);
      addArias2(targetEl);
    }
    openEvent = e;
    return new Promise((resolve) => requestAnimationFrame(() => {
      if (element3.parentElement !== document.body) {
        document.body.appendChild(element3);
      }
      indexButtons();
      updatePosition();
      dispatch3("open", { event: e, target: targetEl });
      if (element3)
        element3.focus();
      requestAnimationFrame(resolve);
      if (!isAnyMobile || type !== "context")
        addEventListeners();
    }));
  }
  function close(e) {
    if (!opened)
      return Promise.resolve();
    if (e && e.detail && e.detail.target)
      e = e.detail;
    if (e && e.target)
      e.target.focus();
    return new Promise((resolve) => {
      setTimeout(
        () => {
          if (!e || !e.defaultPrevented)
            _close().then(() => resolve());
          else
            resolve();
        },
        220
      );
    });
  }
  function _close() {
    if (!opened)
      return Promise.resolve();
    $$invalidate2(2, opened = false);
    closing = true;
    removeArias2(targetSelector);
    removeArias2(targetEl);
    return new Promise((resolve) => requestAnimationFrame(() => {
      dispatch3("close", { target: targetEl });
      removeEventListeners();
      focusTarget();
      requestAnimationFrame(resolve);
      setTimeout(() => closing = false, 300);
    }));
  }
  function updatePosition() {
    const isContextMobile = type === "context" && isAnyMobile;
    const alignH = align || (isContextMobile ? "center" : "left");
    const alignV = valign || (isContextMobile ? "top" : "bottom");
    const offsetV = isContextMobile ? 20 : 2;
    alignItem({
      element: element3,
      target: openEvent,
      alignH,
      alignV,
      offsetV
    });
  }
  function onTouchend(e) {
    if (opened && !eventsAdded) {
      e.preventDefault();
      requestAnimationFrame(addEventListeners);
    }
  }
  function onContextMenu(e) {
    _close();
    targetEl = e.target.closest(targetSelector);
    if (!targetEl)
      return;
    e.preventDefault();
    open(e);
  }
  function onDocumentClick(e) {
    if (!element3)
      return;
    if (!element3.contains(e.target))
      _close();
    else {
      const shouldClose = closeOnClick === true || closeOnClick === "true";
      const clickedOnItem = !!e.target.closest(buttonSelector);
      if (shouldClose && clickedOnItem)
        close(e);
    }
  }
  function onMouseOver(e) {
    const isOverMenu = e.target.closest(".menu");
    if (isOverMenu && !hovering)
      hovering = true;
    else if (!isOverMenu && hovering)
      hovering = false;
    if (hovering) {
      const btn = e.target.closest(buttonSelector);
      if (btn)
        highlightElement(btn);
    } else
      highlightElement(null);
  }
  function onKeydown2(e) {
    if (!element3)
      return;
    if (e.key === "Escape" || !element3.contains(e.target))
      return _close();
    if (e.key === "Enter")
      return;
    if (e.key === " " && !typeQuery)
      return;
    if (e.key === "Tab") {
      e.preventDefault();
      e.stopPropagation();
      if (e.shiftKey)
        return focusPrev();
      return focusNext();
    }
    if (e.key.startsWith("Arrow") || e.key.startsWith(" "))
      e.preventDefault();
    if (e.key === "ArrowDown")
      return focusNext();
    if (e.key === "ArrowUp")
      return focusPrev();
    if (e.key === "ArrowLeft")
      return focusFirst();
    if (e.key === "ArrowRight")
      return focusLast();
    const btn = matchQuery(menuButtons, e.key);
    if (btn && btn.el)
      highlightElement(btn.el);
  }
  function matchQuery(buttons, key) {
    if (!/^[\w| ]+$/i.test(key))
      return;
    if (typeTimer)
      clearTimeout(typeTimer);
    typeTimer = setTimeout(() => typeQuery = "", 300);
    typeQuery += key;
    const reg = new RegExp(`^${typeQuery}`, "i");
    const btns = buttons.filter((b) => reg.test(b.text));
    if (!btns.length)
      return;
    if (btns.length === 1 || btns[0].el !== focusedEl)
      return btns[0];
    return btns[1];
  }
  const throttledResize = throttle(updatePosition, 50);
  const debouncedResize = debounce(updatePosition, 50);
  function onResize() {
    throttledResize();
    debouncedResize();
  }
  function addEventListeners() {
    if (eventsAdded)
      return;
    document.addEventListener("click", onDocumentClick);
    if (type !== "context")
      document.addEventListener(contextmenuEventName, onDocumentClick);
    document.addEventListener("keydown", onKeydown2);
    document.addEventListener("mouseover", onMouseOver);
    window.addEventListener("resize", onResize);
    window.addEventListener("scroll", onResize, true);
    eventsAdded = true;
  }
  function removeEventListeners() {
    document.removeEventListener("click", onDocumentClick);
    if (type !== "context")
      document.removeEventListener(contextmenuEventName, onDocumentClick);
    document.removeEventListener("keydown", onKeydown2);
    document.removeEventListener("mouseover", onMouseOver);
    window.removeEventListener("resize", onResize);
    window.removeEventListener("scroll", onResize, true);
    eventsAdded = false;
  }
  function indexButtons() {
    if (!element3)
      return;
    menuButtons.length = 0;
    const addBtn = (el) => menuButtons.push({
      el,
      text: el.textContent.trim().toLowerCase()
    });
    element3.querySelectorAll(buttonSelector).forEach(addBtn);
  }
  function highlightElement(el) {
    focusedEl = el;
    if (focusedEl) {
      focusedEl.scrollIntoView({ block: "nearest" });
      focusedEl.focus();
    } else
      element3 && element3.focus();
  }
  function focusTarget() {
    if (targetEl && targetEl.focus)
      targetEl.focus();
  }
  function focusFirst() {
    const buttons = Array.from(element3.querySelectorAll(buttonSelector));
    highlightElement(buttons[0]);
  }
  function focusLast() {
    const buttons = Array.from(element3.querySelectorAll(buttonSelector));
    highlightElement(buttons[buttons.length - 1]);
  }
  function focusNext() {
    const buttons = Array.from(element3.querySelectorAll(buttonSelector));
    let idx = -1;
    if (focusedEl)
      idx = buttons.findIndex((el) => el === focusedEl);
    if (idx >= buttons.length - 1)
      idx = -1;
    highlightElement(buttons[idx + 1]);
  }
  function focusPrev() {
    const buttons = Array.from(element3.querySelectorAll(buttonSelector));
    let idx = buttons.length;
    if (focusedEl)
      idx = buttons.findIndex((el) => el === focusedEl);
    if (idx <= 0)
      idx = buttons.length;
    highlightElement(buttons[idx - 1]);
  }
  const writable_props = [
    "class",
    "type",
    "targetSelector",
    "closeOnClick",
    "align",
    "valign",
    "element"
  ];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Menu> was created with unknown prop '${key}'`);
  });
  function menu_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("type" in $$props3)
      $$invalidate2(3, type = $$props3.type);
    if ("targetSelector" in $$props3)
      $$invalidate2(4, targetSelector = $$props3.targetSelector);
    if ("closeOnClick" in $$props3)
      $$invalidate2(5, closeOnClick = $$props3.closeOnClick);
    if ("align" in $$props3)
      $$invalidate2(6, align = $$props3.align);
    if ("valign" in $$props3)
      $$invalidate2(7, valign = $$props3.valign);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("$$scope" in $$props3)
      $$invalidate2(10, $$scope2 = $$props3.$$scope);
  };
  $$self2.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    onMount,
    setContext,
    addArias: addArias2,
    removeArias: removeArias2,
    initLongPressEvent: init2,
    alignItem,
    throttle,
    debounce,
    isMobile,
    dispatch: dispatch3,
    isAnyMobile,
    isMobileSafari,
    contextmenuEventName,
    className: className2,
    type,
    targetSelector,
    closeOnClick,
    align,
    valign,
    element: element3,
    menuButtons,
    buttonSelector,
    targetEl,
    focusedEl,
    opened,
    hovering,
    closing,
    eventsAdded,
    typeQuery,
    typeTimer,
    openEvent,
    open,
    close,
    _close,
    updatePosition,
    onTouchend,
    onContextMenu,
    onDocumentClick,
    onMouseOver,
    onKeydown: onKeydown2,
    matchQuery,
    throttledResize,
    debouncedResize,
    onResize,
    addEventListeners,
    removeEventListeners,
    indexButtons,
    highlightElement,
    focusTarget,
    focusFirst,
    focusLast,
    focusNext,
    focusPrev
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("type" in $$props3)
      $$invalidate2(3, type = $$props3.type);
    if ("targetSelector" in $$props3)
      $$invalidate2(4, targetSelector = $$props3.targetSelector);
    if ("closeOnClick" in $$props3)
      $$invalidate2(5, closeOnClick = $$props3.closeOnClick);
    if ("align" in $$props3)
      $$invalidate2(6, align = $$props3.align);
    if ("valign" in $$props3)
      $$invalidate2(7, valign = $$props3.valign);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("targetEl" in $$props3)
      targetEl = $$props3.targetEl;
    if ("focusedEl" in $$props3)
      focusedEl = $$props3.focusedEl;
    if ("opened" in $$props3)
      $$invalidate2(2, opened = $$props3.opened);
    if ("hovering" in $$props3)
      hovering = $$props3.hovering;
    if ("closing" in $$props3)
      closing = $$props3.closing;
    if ("eventsAdded" in $$props3)
      eventsAdded = $$props3.eventsAdded;
    if ("typeQuery" in $$props3)
      typeQuery = $$props3.typeQuery;
    if ("typeTimer" in $$props3)
      typeTimer = $$props3.typeTimer;
    if ("openEvent" in $$props3)
      openEvent = $$props3.openEvent;
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    element3,
    className2,
    opened,
    type,
    targetSelector,
    closeOnClick,
    align,
    valign,
    open,
    close,
    $$scope2,
    slots2,
    menu_binding
  ];
}
var Menu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance38,
      create_fragment38,
      safe_not_equal,
      {
        class: 1,
        type: 3,
        targetSelector: 4,
        closeOnClick: 5,
        align: 6,
        valign: 7,
        element: 0,
        open: 8,
        close: 9
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu",
      options,
      id: create_fragment38.name
    });
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(className2) {
    this.$$set({ class: className2 });
    flush();
  }
  get type() {
    return this.$$.ctx[3];
  }
  set type(type) {
    this.$$set({ type });
    flush();
  }
  get targetSelector() {
    return this.$$.ctx[4];
  }
  set targetSelector(targetSelector) {
    this.$$set({ targetSelector });
    flush();
  }
  get closeOnClick() {
    return this.$$.ctx[5];
  }
  set closeOnClick(closeOnClick) {
    this.$$set({ closeOnClick });
    flush();
  }
  get align() {
    return this.$$.ctx[6];
  }
  set align(align) {
    this.$$set({ align });
    flush();
  }
  get valign() {
    return this.$$.ctx[7];
  }
  set valign(valign) {
    this.$$set({ valign });
    flush();
  }
  get element() {
    return this.$$.ctx[0];
  }
  set element(element3) {
    this.$$set({ element: element3 });
    flush();
  }
  get open() {
    return this.$$.ctx[8];
  }
  set open(value2) {
    throw new Error("<Menu>: Cannot set read-only property 'open'");
  }
  get close() {
    return this.$$.ctx[9];
  }
  set close(value2) {
    throw new Error("<Menu>: Cannot set read-only property 'close'");
  }
};
var Menu_default = Menu;

// src/menu/MenuItem.svelte
var file33 = "src/menu/MenuItem.svelte";
function create_if_block20(ctx) {
  let icon_1;
  let current;
  icon_1 = new Icon_default({
    props: { name: (
      /*icon*/
      ctx[2]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(icon_1, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const icon_1_changes = {};
      if (dirty & /*icon*/
      4)
        icon_1_changes.name = /*icon*/
        ctx2[2];
      icon_1.$set(icon_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(14:2) {#if icon}",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let button;
  let span0;
  let t0;
  let div;
  let t1;
  let span1;
  let t2_value = replaceKeySymbols(
    /*shortcut*/
    ctx[1]
  ) + "";
  let t2;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*icon*/
    ctx[2] && create_if_block20(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let button_levels = [
    { role: "menuitem" },
    {
      class: button_class_value = "menu-item " + /*className*/
      ctx[3]
    },
    /*$$restProps*/
    ctx[9]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element2("button");
      span0 = element2("span");
      if (if_block)
        if_block.c();
      t0 = space();
      div = element2("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      span1 = element2("span");
      t2 = text(t2_value);
      attr_dev(div, "class", "menu-item-text");
      add_location(div, file33, 14, 2, 294);
      attr_dev(span0, "class", "menu-item-content");
      add_location(span0, file33, 12, 1, 219);
      attr_dev(span1, "class", "menu-item-shortcut");
      add_location(span1, file33, 16, 1, 347);
      set_attributes(button, button_data);
      toggle_class(
        button,
        "disabled",
        /*disabled*/
        ctx[7]
      );
      toggle_class(
        button,
        "success",
        /*success*/
        ctx[4]
      );
      toggle_class(
        button,
        "warning",
        /*warning*/
        ctx[5]
      );
      toggle_class(
        button,
        "danger",
        /*danger*/
        ctx[6]
      );
      add_location(button, file33, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      append_dev(button, span0);
      if (if_block)
        if_block.m(span0, null);
      append_dev(span0, t0);
      append_dev(span0, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(button, t1);
      append_dev(button, span1);
      append_dev(span1, t2);
      if (button.autofocus)
        button.focus();
      ctx[13](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "mousedown", prevent_default(
            /*mousedown_handler*/
            ctx[12]
          ), false, true, false, false),
          listen_dev(
            button,
            "click",
            /*onclick*/
            ctx[8],
            true,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      if (
        /*icon*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*icon*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block20(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span0, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if ((!current || dirty & /*shortcut*/
      2) && t2_value !== (t2_value = replaceKeySymbols(
        /*shortcut*/
        ctx2[1]
      ) + ""))
        set_data_dev(t2, t2_value);
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { role: "menuitem" },
        (!current || dirty & /*className*/
        8 && button_class_value !== (button_class_value = "menu-item " + /*className*/
        ctx2[3])) && { class: button_class_value },
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9]
      ]));
      toggle_class(
        button,
        "disabled",
        /*disabled*/
        ctx2[7]
      );
      toggle_class(
        button,
        "success",
        /*success*/
        ctx2[4]
      );
      toggle_class(
        button,
        "warning",
        /*warning*/
        ctx2[5]
      );
      toggle_class(
        button,
        "danger",
        /*danger*/
        ctx2[6]
      );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[13](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function replaceKeySymbols(txt) {
  return ("" + txt).trim().toUpperCase().replace(/\+/g, "").replace(/CMD/g, "\u2318").replace(/ALT|OPTION/g, "\u2325").replace(/SHIFT/g, "\u21E7").replace(/CONTROL|CTRL/g, "\u2303").replace(/DELETE|DEL|BACKSPACE/g, "\u232B").replace(/ENTER|RETURN/g, "\u23CE").replace(/ESCAPE|ESC/g, "\u238B");
}
function instance39($$self2, $$props2, $$invalidate2) {
  const omit_props_names2 = ["shortcut", "icon", "class", "success", "warning", "danger", "disabled", "element"];
  let $$restProps2 = compute_rest_props($$props2, omit_props_names2);
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("MenuItem", slots2, ["default"]);
  let { shortcut = "" } = $$props2;
  let { icon = void 0 } = $$props2;
  let { class: className2 = "" } = $$props2;
  let { success = false } = $$props2;
  let { warning = false } = $$props2;
  let { danger = false } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  const dispatch3 = createEventDispatcher();
  const { targetEl } = getContext("MenuContext");
  function onclick4(e) {
    const btn = e.target.closest(".menu-item");
    if (btn)
      btn.focus();
    blink(btn, 200).then(() => {
      const target = targetEl();
      const res = dispatch3("click", { event: e, target, button: btn }, { cancelable: true });
      if (res === false) {
        e.stopPropagation();
        e.preventDefault();
      }
    });
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self2, event);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$new_props) => {
    $$props2 = assign(assign({}, $$props2), exclude_internal_props($$new_props));
    $$invalidate2(9, $$restProps2 = compute_rest_props($$props2, omit_props_names2));
    if ("shortcut" in $$new_props)
      $$invalidate2(1, shortcut = $$new_props.shortcut);
    if ("icon" in $$new_props)
      $$invalidate2(2, icon = $$new_props.icon);
    if ("class" in $$new_props)
      $$invalidate2(3, className2 = $$new_props.class);
    if ("success" in $$new_props)
      $$invalidate2(4, success = $$new_props.success);
    if ("warning" in $$new_props)
      $$invalidate2(5, warning = $$new_props.warning);
    if ("danger" in $$new_props)
      $$invalidate2(6, danger = $$new_props.danger);
    if ("disabled" in $$new_props)
      $$invalidate2(7, disabled2 = $$new_props.disabled);
    if ("element" in $$new_props)
      $$invalidate2(0, element3 = $$new_props.element);
    if ("$$scope" in $$new_props)
      $$invalidate2(10, $$scope2 = $$new_props.$$scope);
  };
  $$self2.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    Icon: Icon_default,
    blink,
    shortcut,
    icon,
    className: className2,
    success,
    warning,
    danger,
    disabled: disabled2,
    element: element3,
    dispatch: dispatch3,
    targetEl,
    replaceKeySymbols,
    onclick: onclick4
  });
  $$self2.$inject_state = ($$new_props) => {
    if ("shortcut" in $$props2)
      $$invalidate2(1, shortcut = $$new_props.shortcut);
    if ("icon" in $$props2)
      $$invalidate2(2, icon = $$new_props.icon);
    if ("className" in $$props2)
      $$invalidate2(3, className2 = $$new_props.className);
    if ("success" in $$props2)
      $$invalidate2(4, success = $$new_props.success);
    if ("warning" in $$props2)
      $$invalidate2(5, warning = $$new_props.warning);
    if ("danger" in $$props2)
      $$invalidate2(6, danger = $$new_props.danger);
    if ("disabled" in $$props2)
      $$invalidate2(7, disabled2 = $$new_props.disabled);
    if ("element" in $$props2)
      $$invalidate2(0, element3 = $$new_props.element);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    element3,
    shortcut,
    icon,
    className2,
    success,
    warning,
    danger,
    disabled2,
    onclick4,
    $$restProps2,
    $$scope2,
    slots2,
    mousedown_handler,
    button_binding
  ];
}
var MenuItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, {
      shortcut: 1,
      icon: 2,
      class: 3,
      success: 4,
      warning: 5,
      danger: 6,
      disabled: 7,
      element: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuItem",
      options,
      id: create_fragment39.name
    });
  }
  get shortcut() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shortcut(value2) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value2) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get success() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set success(value2) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warning() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warning(value2) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get danger() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set danger(value2) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuItem_default = MenuItem;

// src/menu/MenuSeparator.svelte
var file34 = "src/menu/MenuSeparator.svelte";
function create_fragment40(ctx) {
  let li;
  const block = {
    c: function create() {
      li = element2("li");
      attr_dev(li, "role", "separator");
      attr_dev(li, "class", "menu-item menu-separator");
      add_location(li, file34, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      ctx[1](li);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      ctx[1](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("MenuSeparator", slots2, []);
  let { element: element3 = void 0 } = $$props2;
  const writable_props = ["element"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MenuSeparator> was created with unknown prop '${key}'`);
  });
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
  };
  $$self2.$capture_state = () => ({ element: element3 });
  $$self2.$inject_state = ($$props3) => {
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [element3, li_binding];
}
var MenuSeparator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, { element: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuSeparator",
      options,
      id: create_fragment40.name
    });
  }
  get element() {
    throw new Error("<MenuSeparator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<MenuSeparator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuSeparator_default = MenuSeparator;

// src/message-box/MessageBox.js
var config = writable({});
var MessageType = {
  INFO: "info",
  WARNING: "warning",
  ERROR: "error",
  DANGER: "error",
  SUCCESS: "success"
};
function showMessage(message, type = "", title = "", btnLabel = "OK", cb) {
  if (typeof message === "object")
    return config.set(message);
  const buttons = [{ label: btnLabel, value: btnLabel, type }];
  return config.set({ message, title, cb, type, buttons });
}

// src/message-box/MessageBox.svelte
var file35 = "src/message-box/MessageBox.svelte";
function get_each_context12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_default_slot_12(ctx) {
  let icon;
  let t;
  let div1;
  let div0;
  let raw_value = (
    /*$config*/
    ctx[2].message + ""
  );
  let current;
  icon = new Icon_default({
    props: {
      name: (
        /*$config*/
        ctx[2].icon || /*$config*/
        ctx[2].type
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
      t = space();
      div1 = element2("div");
      div0 = element2("div");
      attr_dev(div0, "class", "message-content");
      add_location(div0, file35, 8, 3, 223);
      attr_dev(div1, "class", "message");
      add_location(div1, file35, 7, 2, 198);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      insert_dev(target, t, anchor);
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      div0.innerHTML = raw_value;
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & /*$config*/
      4)
        icon_changes.name = /*$config*/
        ctx2[2].icon || /*$config*/
        ctx2[2].type;
      icon.$set(icon_changes);
      if ((!current || dirty & /*$config*/
      4) && raw_value !== (raw_value = /*$config*/
      ctx2[2].message + ""))
        div0.innerHTML = raw_value;
      ;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(div1);
      }
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: '(1:0) <Dialog  title=\\"{$config.title}\\"  class=\\"message-box message-{$config.type}\\"  bind:element=\\"{element}\\"  bind:this=\\"{dialog}\\"  on:close=\\"{onclose}\\">',
    ctx
  });
  return block;
}
function create_if_block21(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*$config*/
    ctx[2].buttons
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block12(get_each_context12(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*$config, onclick*/
      12) {
        each_value = ensure_array_like_dev(
          /*$config*/
          ctx2[2].buttons
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context12(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block12(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(12:3) {#if $config.buttons}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let t0_value = (
    /*button*/
    ctx[9].label + ""
  );
  let t0;
  let t1;
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*$config*/
      4 && t0_value !== (t0_value = /*button*/
      ctx2[9].label + ""))
        set_data_dev(t0, t0_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: `(14:5) <Button       info=\\"{button.type === 'info'}\\"       warning=\\"{button.type === 'warning'}\\"       danger=\\"{button.type === 'error' || button.type === 'danger'}\\"       success=\\"{button.type === 'success'}\\"       on:click=\\"{e => onclick(e, button)}\\">`,
    ctx
  });
  return block;
}
function create_each_block12(ctx) {
  let button_1;
  let current;
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[5](
        /*button*/
        ctx[9],
        ...args
      )
    );
  }
  button_1 = new Button_default({
    props: {
      info: (
        /*button*/
        ctx[9].type === "info"
      ),
      warning: (
        /*button*/
        ctx[9].type === "warning"
      ),
      danger: (
        /*button*/
        ctx[9].type === "error" || /*button*/
        ctx[9].type === "danger"
      ),
      success: (
        /*button*/
        ctx[9].type === "success"
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button_1.$on("click", click_handler);
  const block = {
    c: function create() {
      create_component(button_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button_1, target, anchor);
      current = true;
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      const button_1_changes = {};
      if (dirty & /*$config*/
      4)
        button_1_changes.info = /*button*/
        ctx[9].type === "info";
      if (dirty & /*$config*/
      4)
        button_1_changes.warning = /*button*/
        ctx[9].type === "warning";
      if (dirty & /*$config*/
      4)
        button_1_changes.danger = /*button*/
        ctx[9].type === "error" || /*button*/
        ctx[9].type === "danger";
      if (dirty & /*$config*/
      4)
        button_1_changes.success = /*button*/
        ctx[9].type === "success";
      if (dirty & /*$$scope, $config*/
      4100) {
        button_1_changes.$$scope = { dirty, ctx };
      }
      button_1.$set(button_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block12.name,
    type: "each",
    source: "(13:4) {#each $config.buttons as button}",
    ctx
  });
  return block;
}
function create_footer_slot(ctx) {
  let div;
  let current;
  let if_block = (
    /*$config*/
    ctx[2].buttons && create_if_block21(ctx)
  );
  const block = {
    c: function create() {
      div = element2("div");
      if (if_block)
        if_block.c();
      attr_dev(div, "slot", "footer");
      add_location(div, file35, 10, 2, 293);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (
        /*$config*/
        ctx2[2].buttons
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$config*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block21(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_footer_slot.name,
    type: "slot",
    source: "(11:2) ",
    ctx
  });
  return block;
}
function create_fragment41(ctx) {
  let dialog_1;
  let updating_element;
  let current;
  function dialog_1_element_binding(value2) {
    ctx[6](value2);
  }
  let dialog_1_props = {
    title: (
      /*$config*/
      ctx[2].title
    ),
    class: "message-box message-" + /*$config*/
    ctx[2].type,
    $$slots: {
      footer: [create_footer_slot],
      default: [create_default_slot_12]
    },
    $$scope: { ctx }
  };
  if (
    /*element*/
    ctx[0] !== void 0
  ) {
    dialog_1_props.element = /*element*/
    ctx[0];
  }
  dialog_1 = new Dialog_default({ props: dialog_1_props, $$inline: true });
  binding_callbacks.push(() => bind(dialog_1, "element", dialog_1_element_binding));
  ctx[7](dialog_1);
  dialog_1.$on(
    "close",
    /*onclose*/
    ctx[4]
  );
  const block = {
    c: function create() {
      create_component(dialog_1.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(dialog_1, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const dialog_1_changes = {};
      if (dirty & /*$config*/
      4)
        dialog_1_changes.title = /*$config*/
        ctx2[2].title;
      if (dirty & /*$config*/
      4)
        dialog_1_changes.class = "message-box message-" + /*$config*/
        ctx2[2].type;
      if (dirty & /*$$scope, $config*/
      4100) {
        dialog_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        dialog_1_changes.element = /*element*/
        ctx2[0];
        add_flush_callback(() => updating_element = false);
      }
      dialog_1.$set(dialog_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dialog_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dialog_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[7](null);
      destroy_component(dialog_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self2, $$props2, $$invalidate2) {
  let $config;
  validate_store(config, "config");
  component_subscribe($$self2, config, ($$value) => $$invalidate2(2, $config = $$value));
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("MessageBox", slots2, []);
  let { element: element3 = void 0 } = $$props2;
  let dialog, sub;
  onMount(() => {
    sub = config.subscribe((cfg) => {
      if (!dialog)
        return;
      if (cfg && cfg.message)
        dialog.open();
      else
        dialog.close();
    });
  });
  onDestroy(() => {
    sub();
    config.set({});
  });
  function onclick4(e, button) {
    e.preventDefault();
    set_store_value(config, $config.result = button.value || button.label, $config);
    dialog.close();
  }
  function onclose2() {
    if (typeof $config.cb === "function")
      $config.cb($config.result);
    const target = $config.target || document.body;
    requestAnimationFrame(() => target.focus());
  }
  const writable_props = ["element"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MessageBox> was created with unknown prop '${key}'`);
  });
  const click_handler = (button, e) => onclick4(e, button);
  function dialog_1_element_binding(value2) {
    element3 = value2;
    $$invalidate2(0, element3);
  }
  function dialog_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dialog = $$value;
      $$invalidate2(1, dialog);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
  };
  $$self2.$capture_state = () => ({
    onDestroy,
    onMount,
    config,
    Dialog: Dialog_default,
    Button: Button_default,
    Icon: Icon_default,
    element: element3,
    dialog,
    sub,
    onclick: onclick4,
    onclose: onclose2,
    $config
  });
  $$self2.$inject_state = ($$props3) => {
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("dialog" in $$props3)
      $$invalidate2(1, dialog = $$props3.dialog);
    if ("sub" in $$props3)
      sub = $$props3.sub;
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    element3,
    dialog,
    $config,
    onclick4,
    onclose2,
    click_handler,
    dialog_1_element_binding,
    dialog_1_binding
  ];
}
var MessageBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, { element: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MessageBox",
      options,
      id: create_fragment41.name
    });
  }
  get element() {
    throw new Error("<MessageBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<MessageBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MessageBox_default = MessageBox;

// src/push-button/PushButton.svelte
function create_else_block3(ctx) {
  let button;
  let updating_element;
  let current;
  const button_spread_levels = [
    {
      class: "push-button " + /*className*/
      ctx[2]
    },
    { "aria-pressed": (
      /*pressed*/
      ctx[0]
    ) },
    { outline: (
      /*outline*/
      ctx[7]
    ) },
    { info: (
      /*info*/
      ctx[3]
    ) },
    { success: (
      /*success*/
      ctx[4]
    ) },
    { warning: (
      /*warning*/
      ctx[5]
    ) },
    { danger: (
      /*danger*/
      ctx[6]
    ) },
    { round: (
      /*round*/
      ctx[9]
    ) },
    { icon: (
      /*icon*/
      ctx[8]
    ) },
    /*$$restProps*/
    ctx[13]
  ];
  function button_element_binding_1(value2) {
    ctx[16](value2);
  }
  let button_props = {};
  for (let i = 0; i < button_spread_levels.length; i += 1) {
    button_props = assign(button_props, button_spread_levels[i]);
  }
  if (
    /*element*/
    ctx[1] !== void 0
  ) {
    button_props.element = /*element*/
    ctx[1];
  }
  button = new Button_default({ props: button_props, $$inline: true });
  binding_callbacks.push(() => bind(button, "element", button_element_binding_1));
  button.$on(
    "keydown",
    /*onKeydown*/
    ctx[10]
  );
  button.$on(
    "mousedown",
    /*onMouseDown*/
    ctx[11]
  );
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button_changes = dirty & /*className, pressed, outline, info, success, warning, danger, round, icon, $$restProps*/
      9213 ? get_spread_update(button_spread_levels, [
        dirty & /*className*/
        4 && {
          class: "push-button " + /*className*/
          ctx2[2]
        },
        dirty & /*pressed*/
        1 && { "aria-pressed": (
          /*pressed*/
          ctx2[0]
        ) },
        dirty & /*outline*/
        128 && { outline: (
          /*outline*/
          ctx2[7]
        ) },
        dirty & /*info*/
        8 && { info: (
          /*info*/
          ctx2[3]
        ) },
        dirty & /*success*/
        16 && { success: (
          /*success*/
          ctx2[4]
        ) },
        dirty & /*warning*/
        32 && { warning: (
          /*warning*/
          ctx2[5]
        ) },
        dirty & /*danger*/
        64 && { danger: (
          /*danger*/
          ctx2[6]
        ) },
        dirty & /*round*/
        512 && { round: (
          /*round*/
          ctx2[9]
        ) },
        dirty & /*icon*/
        256 && { icon: (
          /*icon*/
          ctx2[8]
        ) },
        dirty & /*$$restProps*/
        8192 && get_spread_object(
          /*$$restProps*/
          ctx2[13]
        )
      ]) : {};
      if (!updating_element && dirty & /*element*/
      2) {
        updating_element = true;
        button_changes.element = /*element*/
        ctx2[1];
        add_flush_callback(() => updating_element = false);
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(18:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block22(ctx) {
  let button;
  let updating_element;
  let current;
  const button_spread_levels = [
    {
      class: "push-button " + /*className*/
      ctx[2]
    },
    { "aria-pressed": (
      /*pressed*/
      ctx[0]
    ) },
    { outline: (
      /*outline*/
      ctx[7]
    ) },
    { info: (
      /*info*/
      ctx[3]
    ) },
    { success: (
      /*success*/
      ctx[4]
    ) },
    { warning: (
      /*warning*/
      ctx[5]
    ) },
    { danger: (
      /*danger*/
      ctx[6]
    ) },
    { round: (
      /*round*/
      ctx[9]
    ) },
    { icon: (
      /*icon*/
      ctx[8]
    ) },
    /*$$restProps*/
    ctx[13]
  ];
  function button_element_binding(value2) {
    ctx[15](value2);
  }
  let button_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button_spread_levels.length; i += 1) {
    button_props = assign(button_props, button_spread_levels[i]);
  }
  if (
    /*element*/
    ctx[1] !== void 0
  ) {
    button_props.element = /*element*/
    ctx[1];
  }
  button = new Button_default({ props: button_props, $$inline: true });
  binding_callbacks.push(() => bind(button, "element", button_element_binding));
  button.$on(
    "keydown",
    /*onKeydown*/
    ctx[10]
  );
  button.$on(
    "mousedown",
    /*onMouseDown*/
    ctx[11]
  );
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button_changes = dirty & /*className, pressed, outline, info, success, warning, danger, round, icon, $$restProps*/
      9213 ? get_spread_update(button_spread_levels, [
        dirty & /*className*/
        4 && {
          class: "push-button " + /*className*/
          ctx2[2]
        },
        dirty & /*pressed*/
        1 && { "aria-pressed": (
          /*pressed*/
          ctx2[0]
        ) },
        dirty & /*outline*/
        128 && { outline: (
          /*outline*/
          ctx2[7]
        ) },
        dirty & /*info*/
        8 && { info: (
          /*info*/
          ctx2[3]
        ) },
        dirty & /*success*/
        16 && { success: (
          /*success*/
          ctx2[4]
        ) },
        dirty & /*warning*/
        32 && { warning: (
          /*warning*/
          ctx2[5]
        ) },
        dirty & /*danger*/
        64 && { danger: (
          /*danger*/
          ctx2[6]
        ) },
        dirty & /*round*/
        512 && { round: (
          /*round*/
          ctx2[9]
        ) },
        dirty & /*icon*/
        256 && { icon: (
          /*icon*/
          ctx2[8]
        ) },
        dirty & /*$$restProps*/
        8192 && get_spread_object(
          /*$$restProps*/
          ctx2[13]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      131072) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty & /*element*/
      2) {
        updating_element = true;
        button_changes.element = /*element*/
        ctx2[1];
        add_flush_callback(() => updating_element = false);
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(1:0) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: '(2:1) <Button   class=\\"push-button {className}\\"   aria-pressed=\\"{pressed}\\"   {outline}   {info}   {success}   {warning}   {danger}   {round}   {icon}   {...$$restProps}   bind:element=\\"{element}\\"   on:keydown=\\"{onKeydown}\\"   on:mousedown=\\"{onMouseDown}\\">',
    ctx
  });
  return block;
}
function create_fragment42(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block22, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[12].default
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self2, $$props2, $$invalidate2) {
  const omit_props_names2 = [
    "class",
    "pressed",
    "info",
    "success",
    "warning",
    "danger",
    "outline",
    "icon",
    "round",
    "element"
  ];
  let $$restProps2 = compute_rest_props($$props2, omit_props_names2);
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("PushButton", slots2, ["default"]);
  const $$slots = compute_slots(slots2);
  let { class: className2 = "" } = $$props2;
  let { pressed = false } = $$props2;
  let { info: info2 = false } = $$props2;
  let { success = false } = $$props2;
  let { warning = false } = $$props2;
  let { danger = false } = $$props2;
  let { outline = false } = $$props2;
  let { icon = void 0 } = $$props2;
  let { round = void 0 } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  const dispatch3 = createEventDispatcher();
  function onKeydown2(e) {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      $$invalidate2(0, pressed = !pressed);
      dispatch3("change", { ...e, pressed });
    }
  }
  function onMouseDown(e) {
    $$invalidate2(0, pressed = !pressed);
    dispatch3("change", { ...e, pressed });
  }
  function button_element_binding(value2) {
    element3 = value2;
    $$invalidate2(1, element3);
  }
  function button_element_binding_1(value2) {
    element3 = value2;
    $$invalidate2(1, element3);
  }
  $$self2.$$set = ($$new_props) => {
    $$props2 = assign(assign({}, $$props2), exclude_internal_props($$new_props));
    $$invalidate2(13, $$restProps2 = compute_rest_props($$props2, omit_props_names2));
    if ("class" in $$new_props)
      $$invalidate2(2, className2 = $$new_props.class);
    if ("pressed" in $$new_props)
      $$invalidate2(0, pressed = $$new_props.pressed);
    if ("info" in $$new_props)
      $$invalidate2(3, info2 = $$new_props.info);
    if ("success" in $$new_props)
      $$invalidate2(4, success = $$new_props.success);
    if ("warning" in $$new_props)
      $$invalidate2(5, warning = $$new_props.warning);
    if ("danger" in $$new_props)
      $$invalidate2(6, danger = $$new_props.danger);
    if ("outline" in $$new_props)
      $$invalidate2(7, outline = $$new_props.outline);
    if ("icon" in $$new_props)
      $$invalidate2(8, icon = $$new_props.icon);
    if ("round" in $$new_props)
      $$invalidate2(9, round = $$new_props.round);
    if ("element" in $$new_props)
      $$invalidate2(1, element3 = $$new_props.element);
    if ("$$scope" in $$new_props)
      $$invalidate2(17, $$scope2 = $$new_props.$$scope);
  };
  $$self2.$capture_state = () => ({
    createEventDispatcher,
    Button: Button_default,
    className: className2,
    pressed,
    info: info2,
    success,
    warning,
    danger,
    outline,
    icon,
    round,
    element: element3,
    dispatch: dispatch3,
    onKeydown: onKeydown2,
    onMouseDown
  });
  $$self2.$inject_state = ($$new_props) => {
    if ("className" in $$props2)
      $$invalidate2(2, className2 = $$new_props.className);
    if ("pressed" in $$props2)
      $$invalidate2(0, pressed = $$new_props.pressed);
    if ("info" in $$props2)
      $$invalidate2(3, info2 = $$new_props.info);
    if ("success" in $$props2)
      $$invalidate2(4, success = $$new_props.success);
    if ("warning" in $$props2)
      $$invalidate2(5, warning = $$new_props.warning);
    if ("danger" in $$props2)
      $$invalidate2(6, danger = $$new_props.danger);
    if ("outline" in $$props2)
      $$invalidate2(7, outline = $$new_props.outline);
    if ("icon" in $$props2)
      $$invalidate2(8, icon = $$new_props.icon);
    if ("round" in $$props2)
      $$invalidate2(9, round = $$new_props.round);
    if ("element" in $$props2)
      $$invalidate2(1, element3 = $$new_props.element);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    pressed,
    element3,
    className2,
    info2,
    success,
    warning,
    danger,
    outline,
    icon,
    round,
    onKeydown2,
    onMouseDown,
    $$slots,
    $$restProps2,
    slots2,
    button_element_binding,
    button_element_binding_1,
    $$scope2
  ];
}
var PushButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, {
      class: 2,
      pressed: 0,
      info: 3,
      success: 4,
      warning: 5,
      danger: 6,
      outline: 7,
      icon: 8,
      round: 9,
      element: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PushButton",
      options,
      id: create_fragment42.name
    });
  }
  get class() {
    throw new Error("<PushButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<PushButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pressed() {
    throw new Error("<PushButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pressed(value2) {
    throw new Error("<PushButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<PushButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<PushButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get success() {
    throw new Error("<PushButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set success(value2) {
    throw new Error("<PushButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warning() {
    throw new Error("<PushButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warning(value2) {
    throw new Error("<PushButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get danger() {
    throw new Error("<PushButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set danger(value2) {
    throw new Error("<PushButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<PushButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value2) {
    throw new Error("<PushButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<PushButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value2) {
    throw new Error("<PushButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get round() {
    throw new Error("<PushButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set round(value2) {
    throw new Error("<PushButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<PushButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<PushButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PushButton_default = PushButton;

// node_modules/svelte/src/runtime/animate/index.js
function flip(node, { from, to }, params = {}) {
  const style = getComputedStyle(node);
  const transform = style.transform === "none" ? "" : style.transform;
  const [ox, oy] = style.transformOrigin.split(" ").map(parseFloat);
  const dx = from.left + from.width * ox / to.width - (to.left + ox);
  const dy = from.top + from.height * oy / to.height - (to.top + oy);
  const { delay = 0, duration: duration2 = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
  return {
    delay,
    duration: is_function(duration2) ? duration2(Math.sqrt(dx * dx + dy * dy)) : duration2,
    easing,
    css: (t, u) => {
      const x = u * dx;
      const y = u * dy;
      const sx = t + u * from.width / to.width;
      const sy = t + u * from.height / to.height;
      return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
    }
  };
}

// src/notification-center/store.js
var Notifications = writable({});
var ArchivedNotifications = writable({});
var Progress = writable({});
var timers = {};
var duration = get_store_value(ANIMATION_SPEED);
var fly2 = (node, params) => fly(node, { duration, x: 500, opacity: 1, ...params });
var slideUp = (node, params) => fly(node, { duration, y: -50, ...params });
var slideDown = (node, params) => fly(node, { duration, y: 50, ...params });
var flip2 = (node, animations, params) => flip(node, animations, { duration, ...params });
var [send, receive] = crossfade({
  duration: (d) => d,
  fallback(node, params) {
    const style = getComputedStyle(node);
    const transform = style.transform === "none" ? "" : style.transform;
    return {
      duration: params.duration || duration,
      css: (t) => `transform: ${transform} scale(${t}); opacity: ${t}`
    };
  }
});
function createTimer(notification, targetEl) {
  if (!notification.showProgress)
    return;
  if (targetEl && targetEl === document.activeElement)
    return;
  const id2 = notification.id;
  let progress = getProgress(id2);
  timers[id2] = setInterval(() => {
    progress += 1;
    setProgress(id2, progress);
    applyProgress(id2, progress);
    if (progress >= 110) {
      clearInterval(timers[id2]);
      hideNotification(id2);
    }
  }, Math.round(notification.timeout / 100));
}
function setProgress(id2, val) {
  Progress.update((list) => {
    list[id2] = val;
    return list;
  });
}
function getProgress(id2) {
  const progress = get_store_value(Progress) || {};
  return progress[id2] || 0;
}
function applyProgress(id2, progress) {
  const el = document.querySelector(`[data-id="${id2}"] .notification-progress`);
  if (el)
    el.style.width = `${progress}%`;
}
function clearTimer2(notification) {
  clearInterval(timers[notification.id]);
}
function showNotification(msg, type = "info", timeout = 5e3, btn, cb = () => {
}) {
  const id2 = guid();
  const showProgress = typeof timeout === "number";
  const timestamp = (/* @__PURE__ */ new Date()).getTime();
  Notifications.update((list) => {
    list[id2] = { type, msg, id: id2, timeout, cb, showProgress, btn, timestamp };
    return list;
  });
  return id2;
}
function hideNotification(id2) {
  return new Promise((resolve) => {
    Notifications.update((list) => {
      addToArchive(list[id2]);
      delete list[id2];
      return list;
    });
    requestAnimationFrame(resolve);
  });
}
function addToArchive(notification) {
  if (!notification)
    return;
  notification = pluck(notification, ["type", "msg", "id", "timestamp"]);
  ArchivedNotifications.update((list) => {
    list[notification.id] = notification;
    return list;
  });
}
function removeFromArchive(id2) {
  return new Promise((resolve) => {
    ArchivedNotifications.update((list) => {
      delete list[id2];
      return list;
    });
    requestAnimationFrame(resolve);
  });
}

// src/notification-center/utils.js
function getNextNotification(el, id2) {
  if (!el)
    return;
  const thisEl = el.querySelector(`[data-id="${id2}"]`);
  const all = el.querySelectorAll(".notification");
  if (!all || !all.length)
    return;
  const index = Array.from(all).indexOf(thisEl);
  if (index < all.length - 1)
    return all[index + 1];
  if (index > 0)
    return all[index - 1];
  return all[0];
}

// src/notification-center/NotificationArchive/NotificationArchive.svelte
var { Object: Object_12 } = globals;
var file36 = "src/notification-center/NotificationArchive/NotificationArchive.svelte";
function get_each_context13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function create_else_block4(ctx) {
  let h2;
  let t1;
  let div;
  let button;
  let current;
  button = new Button_default({
    props: {
      text: true,
      class: "btn-close",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on(
    "click",
    /*click_handler_1*/
    ctx[11]
  );
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "No recent notifications";
      t1 = space();
      div = element2("div");
      create_component(button.$$.fragment);
      add_location(h2, file36, 9, 3, 468);
      attr_dev(div, "class", "notification-archive-buttons");
      add_location(div, file36, 10, 3, 504);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, div, anchor);
      mount_component(button, div, null);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(div);
      }
      destroy_component(button);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(9:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let h2;
  let button0;
  let t0;
  let div;
  let button1;
  let t1;
  let button2;
  let current;
  button0 = new Button_default({
    props: {
      icon: "chevronRight",
      text: true,
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button0.$on(
    "click",
    /*toggle*/
    ctx[5]
  );
  button1 = new Button_default({
    props: {
      text: true,
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1.$on(
    "click",
    /*clearAll*/
    ctx[6]
  );
  button2 = new Button_default({
    props: {
      text: true,
      class: "btn-close",
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button2.$on(
    "click",
    /*click_handler*/
    ctx[10]
  );
  const block = {
    c: function create() {
      h2 = element2("h2");
      create_component(button0.$$.fragment);
      t0 = space();
      div = element2("div");
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
      add_location(h2, file36, 3, 3, 142);
      attr_dev(div, "class", "notification-archive-buttons");
      add_location(div, file36, 4, 3, 258);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      mount_component(button0, h2, null);
      insert_dev(target, t0, anchor);
      insert_dev(target, div, anchor);
      mount_component(button1, div, null);
      append_dev(div, t1);
      mount_component(button2, div, null);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$$scope, archived*/
      2097160) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t0);
        detach_dev(div);
      }
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(3:2) {#if archived.length}",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("\xD7");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: '(12:4) <Button text class=\\"btn-close\\" on:click=\\"{() => (show = false)}\\">',
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let t0;
  let t1_value = (
    /*archived*/
    ctx[3].length + ""
  );
  let t1;
  let t2;
  const block = {
    c: function create() {
      t0 = text("Recent notifications (");
      t1 = text(t1_value);
      t2 = text(")");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, t2, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*archived*/
      8 && t1_value !== (t1_value = /*archived*/
      ctx2[3].length + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: '(4:7) <Button icon=\\"chevronRight\\" text on:click=\\"{toggle}\\">',
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Clear all");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: '(6:4) <Button text on:click=\\"{clearAll}\\">',
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("\xD7");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: '(7:4) <Button text class=\\"btn-close\\" on:click=\\"{() => (show = false)}\\">',
    ctx
  });
  return block;
}
function create_if_block23(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*archived*/
    ctx[3]
  );
  const get_key = (ctx2) => (
    /*notification*/
    ctx2[18].id
  );
  validate_each_keys(ctx, each_value, get_each_context13, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context13(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block13(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*archived, onKeydown, now*/
      152) {
        each_value = ensure_array_like_dev(
          /*archived*/
          ctx2[3]
        );
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        validate_each_keys(ctx2, each_value, get_each_context13, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, fix_and_outro_and_destroy_block, create_each_block13, each_1_anchor, get_each_context13);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(18:1) {#if archived.length && expanded}",
    ctx
  });
  return block;
}
function create_each_block13(key_1, ctx) {
  let div2;
  let div0;
  let raw_value = (
    /*notification*/
    ctx[18].msg + ""
  );
  let div0_role_value;
  let t0;
  let div1;
  let t1_value = timeAgo(
    /*notification*/
    ctx[18].timestamp,
    /*now*/
    ctx[4]
  ) + "";
  let t1;
  let t2;
  let button;
  let t4;
  let div2_data_id_value;
  let div2_class_value;
  let div2_intro;
  let div2_outro;
  let rect;
  let stop_animation = noop;
  let current;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[12](
        /*notification*/
        ctx[18]
      )
    );
  }
  function keydown_handler(...args) {
    return (
      /*keydown_handler*/
      ctx[13](
        /*notification*/
        ctx[18],
        ...args
      )
    );
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div2 = element2("div");
      div0 = element2("div");
      t0 = space();
      div1 = element2("div");
      t1 = text(t1_value);
      t2 = space();
      button = element2("button");
      button.textContent = "\xD7";
      t4 = space();
      attr_dev(div0, "class", "notification-msg");
      attr_dev(div0, "role", div0_role_value = /*notification*/
      ctx[18].type === "info" ? "status" : "alert");
      add_location(div0, file36, 28, 4, 1117);
      attr_dev(div1, "class", "notification-timestamp");
      add_location(div1, file36, 29, 4, 1241);
      attr_dev(button, "class", "notification-close");
      add_location(button, file36, 30, 4, 1326);
      attr_dev(div2, "tabindex", "0");
      attr_dev(div2, "data-id", div2_data_id_value = /*notification*/
      ctx[18].id);
      attr_dev(div2, "class", div2_class_value = "notification notification-" + /*notification*/
      ctx[18].type + " archived");
      add_location(div2, file36, 19, 3, 869);
      this.first = div2;
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      div0.innerHTML = raw_value;
      append_dev(div2, t0);
      append_dev(div2, div1);
      append_dev(div1, t1);
      append_dev(div2, t2);
      append_dev(div2, button);
      append_dev(div2, t4);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", stop_propagation(click_handler_2), false, false, true, false),
          listen_dev(div2, "keydown", keydown_handler, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*archived*/
      8) && raw_value !== (raw_value = /*notification*/
      ctx[18].msg + ""))
        div0.innerHTML = raw_value;
      ;
      if (!current || dirty & /*archived*/
      8 && div0_role_value !== (div0_role_value = /*notification*/
      ctx[18].type === "info" ? "status" : "alert")) {
        attr_dev(div0, "role", div0_role_value);
      }
      if ((!current || dirty & /*archived, now*/
      24) && t1_value !== (t1_value = timeAgo(
        /*notification*/
        ctx[18].timestamp,
        /*now*/
        ctx[4]
      ) + ""))
        set_data_dev(t1, t1_value);
      if (!current || dirty & /*archived*/
      8 && div2_data_id_value !== (div2_data_id_value = /*notification*/
      ctx[18].id)) {
        attr_dev(div2, "data-id", div2_data_id_value);
      }
      if (!current || dirty & /*archived*/
      8 && div2_class_value !== (div2_class_value = "notification notification-" + /*notification*/
      ctx[18].type + " archived")) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    r: function measure() {
      rect = div2.getBoundingClientRect();
    },
    f: function fix() {
      fix_position(div2);
      stop_animation();
      add_transform(div2, rect);
    },
    a: function animate2() {
      stop_animation();
      stop_animation = create_animation(div2, rect, flip2, {});
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div2_outro)
            div2_outro.end(1);
          div2_intro = create_in_transition(
            div2,
            /*_in*/
            ctx[8],
            { key: (
              /*notification*/
              ctx[18].id
            ) }
          );
          div2_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (div2_intro)
        div2_intro.invalidate();
      if (local) {
        div2_outro = create_out_transition(
          div2,
          /*_out*/
          ctx[9],
          {}
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (detaching && div2_outro)
        div2_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block13.name,
    type: "each",
    source: "(19:2) {#each archived as notification (notification.id)}",
    ctx
  });
  return block;
}
function create_fragment43(ctx) {
  let div;
  let header;
  let current_block_type_index;
  let if_block0;
  let t;
  let div_inert_value;
  let current;
  const if_block_creators = [create_if_block_14, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*archived*/
      ctx2[3].length
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*archived*/
    ctx[3].length && /*expanded*/
    ctx[1] && create_if_block23(ctx)
  );
  const block = {
    c: function create() {
      div = element2("div");
      header = element2("header");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      add_location(header, file36, 1, 1, 106);
      attr_dev(div, "class", "notification-archive");
      div.inert = div_inert_value = !/*show*/
      ctx[0];
      toggle_class(
        div,
        "expanded",
        /*expanded*/
        ctx[1]
      );
      toggle_class(div, "inert", !/*show*/
      ctx[0]);
      add_location(div, file36, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, header);
      if_blocks[current_block_type_index].m(header, null);
      append_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      ctx[14](div);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(header, null);
      }
      if (
        /*archived*/
        ctx2[3].length && /*expanded*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*archived, expanded*/
          10) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block23(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*show*/
      1 && div_inert_value !== (div_inert_value = !/*show*/
      ctx2[0])) {
        prop_dev(div, "inert", div_inert_value);
      }
      if (!current || dirty & /*expanded*/
      2) {
        toggle_class(
          div,
          "expanded",
          /*expanded*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*show*/
      1) {
        toggle_class(div, "inert", !/*show*/
        ctx2[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      ctx[14](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self2, $$props2, $$invalidate2) {
  let $ANIMATION_SPEED;
  validate_store(ANIMATION_SPEED, "ANIMATION_SPEED");
  component_subscribe($$self2, ANIMATION_SPEED, ($$value) => $$invalidate2(16, $ANIMATION_SPEED = $$value));
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("NotificationArchive", slots2, []);
  let { show = false } = $$props2;
  let { expanded = false } = $$props2;
  const duration2 = $ANIMATION_SPEED;
  let el;
  let archived = [];
  let timer2;
  let now2 = (/* @__PURE__ */ new Date()).getTime();
  onMount(() => {
    timer2 = setInterval(() => $$invalidate2(4, now2 = (/* @__PURE__ */ new Date()).getTime()), 1e4);
    ArchivedNotifications.subscribe((val) => {
      $$invalidate2(3, archived = Object.values(val).reverse());
    });
  });
  onDestroy(() => {
    clearInterval(timer2);
  });
  function toggle() {
    $$invalidate2(1, expanded = !expanded);
  }
  function clearAll(e) {
    e.stopPropagation();
    ArchivedNotifications.set({});
  }
  function onKeydown2(e, notification) {
    if (e.key === "Escape") {
      const nextEl = getNextNotification(el, notification.id);
      removeFromArchive(notification.id).then(() => {
        if (nextEl)
          nextEl.focus();
      });
    }
  }
  function _in(node, params) {
    if (!show)
      return fly2(node, { duration: 0 });
    if (show && expanded)
      return slideUp(node, params);
    return receive(node, { ...params, delay: 100, duration: duration2 });
  }
  function _out(node, params) {
    if (show && expanded)
      return fly2(node);
    if (show && !expanded)
      return slideUp(node, params);
    return slideUp(node, { duration: 0 });
  }
  const writable_props = ["show", "expanded"];
  Object_12.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NotificationArchive> was created with unknown prop '${key}'`);
  });
  const click_handler = () => $$invalidate2(0, show = false);
  const click_handler_1 = () => $$invalidate2(0, show = false);
  const click_handler_2 = (notification) => removeFromArchive(notification.id);
  const keydown_handler = (notification, e) => onKeydown2(e, notification);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate2(2, el);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("show" in $$props3)
      $$invalidate2(0, show = $$props3.show);
    if ("expanded" in $$props3)
      $$invalidate2(1, expanded = $$props3.expanded);
  };
  $$self2.$capture_state = () => ({
    onDestroy,
    onMount,
    Button: Button_default,
    ArchivedNotifications,
    removeFromArchive,
    receive,
    fly: fly2,
    slideUp,
    flip: flip2,
    ANIMATION_SPEED,
    timeAgo,
    getNextNotification,
    show,
    expanded,
    duration: duration2,
    el,
    archived,
    timer: timer2,
    now: now2,
    toggle,
    clearAll,
    onKeydown: onKeydown2,
    _in,
    _out,
    $ANIMATION_SPEED
  });
  $$self2.$inject_state = ($$props3) => {
    if ("show" in $$props3)
      $$invalidate2(0, show = $$props3.show);
    if ("expanded" in $$props3)
      $$invalidate2(1, expanded = $$props3.expanded);
    if ("el" in $$props3)
      $$invalidate2(2, el = $$props3.el);
    if ("archived" in $$props3)
      $$invalidate2(3, archived = $$props3.archived);
    if ("timer" in $$props3)
      timer2 = $$props3.timer;
    if ("now" in $$props3)
      $$invalidate2(4, now2 = $$props3.now);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*show, el*/
    5) {
      $: {
        if (!show && el)
          el.addEventListener("transitionend", () => $$invalidate2(1, expanded = false), { once: true });
      }
    }
  };
  return [
    show,
    expanded,
    el,
    archived,
    now2,
    toggle,
    clearAll,
    onKeydown2,
    _in,
    _out,
    click_handler,
    click_handler_1,
    click_handler_2,
    keydown_handler,
    div_binding
  ];
}
var NotificationArchive = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, { show: 0, expanded: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NotificationArchive",
      options,
      id: create_fragment43.name
    });
  }
  get show() {
    throw new Error("<NotificationArchive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set show(value2) {
    throw new Error("<NotificationArchive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expanded() {
    throw new Error("<NotificationArchive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value2) {
    throw new Error("<NotificationArchive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NotificationArchive_default = NotificationArchive;

// src/notification-center/NotificationCenter/NotificationCenter.svelte
var { Object: Object_13 } = globals;
var file37 = "src/notification-center/NotificationCenter/NotificationCenter.svelte";
function get_each_context14(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[33] = list[i];
  return child_ctx;
}
function create_if_block_32(ctx) {
  let pushbutton;
  let updating_pressed;
  let current;
  function pushbutton_pressed_binding(value2) {
    ctx[16](value2);
  }
  let pushbutton_props = {
    icon: "bell",
    outline: (
      /*outline*/
      ctx[2]
    ),
    round: (
      /*round*/
      ctx[1]
    ),
    class: "notification-center-button " + /*hasNotifications*/
    ctx[10] + " " + /*hasArchivedNotifications*/
    ctx[5]
  };
  if (
    /*$showArchive*/
    ctx[11] !== void 0
  ) {
    pushbutton_props.pressed = /*$showArchive*/
    ctx[11];
  }
  pushbutton = new PushButton_default({ props: pushbutton_props, $$inline: true });
  binding_callbacks.push(() => bind(pushbutton, "pressed", pushbutton_pressed_binding));
  const block = {
    c: function create() {
      create_component(pushbutton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(pushbutton, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const pushbutton_changes = {};
      if (dirty[0] & /*outline*/
      4)
        pushbutton_changes.outline = /*outline*/
        ctx2[2];
      if (dirty[0] & /*round*/
      2)
        pushbutton_changes.round = /*round*/
        ctx2[1];
      if (dirty[0] & /*hasNotifications, hasArchivedNotifications*/
      1056)
        pushbutton_changes.class = "notification-center-button " + /*hasNotifications*/
        ctx2[10] + " " + /*hasArchivedNotifications*/
        ctx2[5];
      if (!updating_pressed && dirty[0] & /*$showArchive*/
      2048) {
        updating_pressed = true;
        pushbutton_changes.pressed = /*$showArchive*/
        ctx2[11];
        add_flush_callback(() => updating_pressed = false);
      }
      pushbutton.$set(pushbutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pushbutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pushbutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(pushbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(1:0) {#if !hideButton}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let button;
  let t_value = (
    /*notification*/
    ctx[33].btn + ""
  );
  let t;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[17](
        /*notification*/
        ctx[33]
      )
    );
  }
  const block = {
    c: function create() {
      button = element2("button");
      t = text(t_value);
      add_location(button, file37, 36, 5, 1283);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      append_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", prevent_default(click_handler), false, true, false, false);
        mounted = true;
      }
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*notifications*/
      16 && t_value !== (t_value = /*notification*/
      ctx[33].btn + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(36:4) {#if notification.btn}",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let div1;
  let div0;
  const block = {
    c: function create() {
      div1 = element2("div");
      div0 = element2("div");
      attr_dev(div0, "role", "progressbar");
      attr_dev(div0, "class", "notification-progress");
      add_location(div0, file37, 44, 5, 1616);
      attr_dev(div1, "class", "notification-progressbar");
      add_location(div1, file37, 43, 4, 1572);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(43:3) {#if notification.showProgress}",
    ctx
  });
  return block;
}
function create_each_block14(key_1, ctx) {
  let div3;
  let div0;
  let icon;
  let t0;
  let div1;
  let raw_value = (
    /*notification*/
    ctx[33].msg + ""
  );
  let div1_role_value;
  let t1;
  let div2;
  let t2;
  let button;
  let t4;
  let div3_class_value;
  let div3_data_id_value;
  let div3_intro;
  let div3_outro;
  let rect;
  let stop_animation = noop;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: { name: (
      /*notification*/
      ctx[33].type
    ) },
    $$inline: true
  });
  let if_block0 = (
    /*notification*/
    ctx[33].btn && create_if_block_22(ctx)
  );
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[18](
        /*notification*/
        ctx[33]
      )
    );
  }
  let if_block1 = (
    /*notification*/
    ctx[33].showProgress && create_if_block_15(ctx)
  );
  function mouseover_handler() {
    return (
      /*mouseover_handler*/
      ctx[19](
        /*notification*/
        ctx[33]
      )
    );
  }
  function focus_handler2() {
    return (
      /*focus_handler*/
      ctx[20](
        /*notification*/
        ctx[33]
      )
    );
  }
  function mouseleave_handler(...args) {
    return (
      /*mouseleave_handler*/
      ctx[21](
        /*notification*/
        ctx[33],
        ...args
      )
    );
  }
  function blur_handler2(...args) {
    return (
      /*blur_handler*/
      ctx[22](
        /*notification*/
        ctx[33],
        ...args
      )
    );
  }
  function keydown_handler(...args) {
    return (
      /*keydown_handler*/
      ctx[23](
        /*notification*/
        ctx[33],
        ...args
      )
    );
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div3 = element2("div");
      div0 = element2("div");
      create_component(icon.$$.fragment);
      t0 = space();
      div1 = element2("div");
      t1 = space();
      div2 = element2("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      button = element2("button");
      button.textContent = "\xD7";
      t4 = space();
      if (if_block1)
        if_block1.c();
      attr_dev(div0, "class", "notification-icon");
      add_location(div0, file37, 31, 3, 1017);
      attr_dev(div1, "class", "notification-msg");
      attr_dev(div1, "role", div1_role_value = /*notification*/
      ctx[33].type === "info" ? "status" : "alert");
      add_location(div1, file37, 32, 3, 1092);
      attr_dev(button, "class", "notification-close");
      add_location(button, file37, 39, 4, 1401);
      attr_dev(div2, "class", "notification-buttons");
      add_location(div2, file37, 34, 3, 1216);
      attr_dev(div3, "class", div3_class_value = "notification notification-" + /*notification*/
      ctx[33].type);
      attr_dev(div3, "data-id", div3_data_id_value = /*notification*/
      ctx[33].id);
      attr_dev(div3, "tabindex", "0");
      add_location(div3, file37, 18, 2, 569);
      this.first = div3;
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      append_dev(div3, div0);
      mount_component(icon, div0, null);
      append_dev(div3, t0);
      append_dev(div3, div1);
      div1.innerHTML = raw_value;
      append_dev(div3, t1);
      append_dev(div3, div2);
      if (if_block0)
        if_block0.m(div2, null);
      append_dev(div2, t2);
      append_dev(div2, button);
      append_dev(div3, t4);
      if (if_block1)
        if_block1.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", stop_propagation(click_handler_1), false, false, true, false),
          listen_dev(div3, "mouseover", mouseover_handler, false, false, false, false),
          listen_dev(div3, "focus", focus_handler2, false, false, false, false),
          listen_dev(div3, "mouseleave", mouseleave_handler, false, false, false, false),
          listen_dev(div3, "blur", blur_handler2, false, false, false, false),
          listen_dev(div3, "keydown", keydown_handler, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      const icon_changes = {};
      if (dirty[0] & /*notifications*/
      16)
        icon_changes.name = /*notification*/
        ctx[33].type;
      icon.$set(icon_changes);
      if ((!current || dirty[0] & /*notifications*/
      16) && raw_value !== (raw_value = /*notification*/
      ctx[33].msg + ""))
        div1.innerHTML = raw_value;
      ;
      if (!current || dirty[0] & /*notifications*/
      16 && div1_role_value !== (div1_role_value = /*notification*/
      ctx[33].type === "info" ? "status" : "alert")) {
        attr_dev(div1, "role", div1_role_value);
      }
      if (
        /*notification*/
        ctx[33].btn
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_22(ctx);
          if_block0.c();
          if_block0.m(div2, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*notification*/
        ctx[33].showProgress
      ) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_15(ctx);
          if_block1.c();
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty[0] & /*notifications*/
      16 && div3_class_value !== (div3_class_value = "notification notification-" + /*notification*/
      ctx[33].type)) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (!current || dirty[0] & /*notifications*/
      16 && div3_data_id_value !== (div3_data_id_value = /*notification*/
      ctx[33].id)) {
        attr_dev(div3, "data-id", div3_data_id_value);
      }
    },
    r: function measure() {
      rect = div3.getBoundingClientRect();
    },
    f: function fix() {
      fix_position(div3);
      stop_animation();
      add_transform(div3, rect);
    },
    a: function animate2() {
      stop_animation();
      stop_animation = create_animation(div3, rect, flip2, {});
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div3_outro)
            div3_outro.end(1);
          div3_intro = create_in_transition(div3, fly2, {});
          div3_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      if (div3_intro)
        div3_intro.invalidate();
      if (local) {
        div3_outro = create_out_transition(
          div3,
          /*_send*/
          ctx[13],
          { key: (
            /*notification*/
            ctx[33].id
          ) }
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      destroy_component(icon);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (detaching && div3_outro)
        div3_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block14.name,
    type: "each",
    source: "(18:1) {#each notifications as notification (notification.id)}",
    ctx
  });
  return block;
}
function create_if_block24(ctx) {
  let notificationarchive;
  let updating_show;
  let updating_expanded;
  let current;
  function notificationarchive_show_binding(value2) {
    ctx[24](value2);
  }
  function notificationarchive_expanded_binding(value2) {
    ctx[25](value2);
  }
  let notificationarchive_props = {};
  if (
    /*$showArchive*/
    ctx[11] !== void 0
  ) {
    notificationarchive_props.show = /*$showArchive*/
    ctx[11];
  }
  if (
    /*archiveIsExpanded*/
    ctx[7] !== void 0
  ) {
    notificationarchive_props.expanded = /*archiveIsExpanded*/
    ctx[7];
  }
  notificationarchive = new NotificationArchive_default({
    props: notificationarchive_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(notificationarchive, "show", notificationarchive_show_binding));
  binding_callbacks.push(() => bind(notificationarchive, "expanded", notificationarchive_expanded_binding));
  const block = {
    c: function create() {
      create_component(notificationarchive.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(notificationarchive, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const notificationarchive_changes = {};
      if (!updating_show && dirty[0] & /*$showArchive*/
      2048) {
        updating_show = true;
        notificationarchive_changes.show = /*$showArchive*/
        ctx2[11];
        add_flush_callback(() => updating_show = false);
      }
      if (!updating_expanded && dirty[0] & /*archiveIsExpanded*/
      128) {
        updating_expanded = true;
        notificationarchive_changes.expanded = /*archiveIsExpanded*/
        ctx2[7];
        add_flush_callback(() => updating_expanded = false);
      }
      notificationarchive.$set(notificationarchive_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(notificationarchive.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(notificationarchive.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(notificationarchive, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(51:1) {#if !hideButton}",
    ctx
  });
  return block;
}
function create_fragment44(ctx) {
  let t0;
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let div_class_value;
  let current;
  let if_block0 = !/*hideButton*/
  ctx[3] && create_if_block_32(ctx);
  let each_value = ensure_array_like_dev(
    /*notifications*/
    ctx[4]
  );
  const get_key = (ctx2) => (
    /*notification*/
    ctx2[33].id
  );
  validate_each_keys(ctx, each_value, get_each_context14, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context14(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block14(key, child_ctx));
  }
  let if_block1 = !/*hideButton*/
  ctx[3] && create_if_block24(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element2("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (if_block1)
        if_block1.c();
      attr_dev(div, "class", div_class_value = "notification-center " + /*className*/
      ctx[0]);
      toggle_class(
        div,
        "show-archive",
        /*$showArchive*/
        ctx[11]
      );
      toggle_class(
        div,
        "archive-is-visible",
        /*archiveIsVisible*/
        ctx[6]
      );
      toggle_class(
        div,
        "has-active-notifications",
        /*hasActiveNotifications*/
        ctx[9]
      );
      add_location(div, file37, 10, 0, 301);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      ctx[26](div);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (!/*hideButton*/
      ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*hideButton*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_32(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*notifications, onKeydown*/
      16400) {
        each_value = ensure_array_like_dev(
          /*notifications*/
          ctx2[4]
        );
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        validate_each_keys(ctx2, each_value, get_each_context14, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, fix_and_outro_and_destroy_block, create_each_block14, t1, get_each_context14);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
      if (!/*hideButton*/
      ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*hideButton*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block24(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*className*/
      1 && div_class_value !== (div_class_value = "notification-center " + /*className*/
      ctx2[0])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*className, $showArchive*/
      2049) {
        toggle_class(
          div,
          "show-archive",
          /*$showArchive*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*className, archiveIsVisible*/
      65) {
        toggle_class(
          div,
          "archive-is-visible",
          /*archiveIsVisible*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*className, hasActiveNotifications*/
      513) {
        toggle_class(
          div,
          "has-active-notifications",
          /*hasActiveNotifications*/
          ctx2[9]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(div);
      }
      if (if_block0)
        if_block0.d(detaching);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block1)
        if_block1.d();
      ctx[26](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self2, $$props2, $$invalidate2) {
  let hasArchivedNotifications;
  let hasNotifications;
  let $showArchive;
  let $ANIMATION_SPEED;
  let $ArchivedNotifications;
  validate_store(ANIMATION_SPEED, "ANIMATION_SPEED");
  component_subscribe($$self2, ANIMATION_SPEED, ($$value) => $$invalidate2(28, $ANIMATION_SPEED = $$value));
  validate_store(ArchivedNotifications, "ArchivedNotifications");
  component_subscribe($$self2, ArchivedNotifications, ($$value) => $$invalidate2(15, $ArchivedNotifications = $$value));
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("NotificationCenter", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { round = false } = $$props2;
  let { outline = false } = $$props2;
  let { hideButton = false } = $$props2;
  const showArchive = writable(false);
  validate_store(showArchive, "showArchive");
  component_subscribe($$self2, showArchive, (value2) => $$invalidate2(11, $showArchive = value2));
  const duration2 = $ANIMATION_SPEED;
  let archiveIsVisible = false;
  let archiveIsExpanded = false;
  let el;
  let notifications = [];
  let initial = true;
  let hasActiveNotifications = false;
  onMount(() => {
    document.body.appendChild(el);
    Notifications.subscribe((val) => {
      $$invalidate2(4, notifications = Object.values(val).reverse());
      notifications.forEach((t) => {
        if (!timers[t.id])
          createTimer(t);
      });
      if (notifications.length > 0)
        $$invalidate2(9, hasActiveNotifications = true);
      else
        setTimeout(() => $$invalidate2(9, hasActiveNotifications = false), $ANIMATION_SPEED);
    });
    showArchive.subscribe((val) => {
      if (initial)
        return;
      if (val)
        addEvents();
      else
        removeEvents();
    });
    if (initial)
      requestAnimationFrame(() => initial = false);
  });
  onDestroy(() => {
    if (el)
      el.remove();
  });
  function addEvents() {
    $$invalidate2(6, archiveIsVisible = true);
    document.addEventListener("click", onDocClick);
    document.addEventListener("keydown", onDocClick);
  }
  function removeEvents() {
    document.removeEventListener("click", onDocClick);
    document.removeEventListener("keydown", onDocClick);
    el.querySelector(".notification-archive").addEventListener("transitionend", () => $$invalidate2(6, archiveIsVisible = false), { once: true });
  }
  function onDocClick(e) {
    if (e.target.closest(".notification-center-button,.notification-archive,.notification-center"))
      return;
    if (e.type === "keydown" && e.key !== "Escape")
      return;
    showArchive.set(false);
  }
  function _send(node, params) {
    if (!$showArchive)
      return fly2(node);
    if (!archiveIsExpanded)
      return slideDown(node, params);
    return send(node, { ...params, duration: duration2 });
  }
  function onKeydown2(e, notification) {
    if (e.key === "Escape") {
      const nextEl = getNextNotification(el, notification.id);
      hideNotification(notification.id).then(() => {
        if (nextEl)
          nextEl.focus();
      });
    }
  }
  const writable_props = ["class", "round", "outline", "hideButton"];
  Object_13.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NotificationCenter> was created with unknown prop '${key}'`);
  });
  function pushbutton_pressed_binding(value2) {
    $showArchive = value2;
    showArchive.set($showArchive);
  }
  const click_handler = (notification) => notification.cb(notification.id);
  const click_handler_1 = (notification) => hideNotification(notification.id);
  const mouseover_handler = (notification) => clearTimer2(notification);
  const focus_handler2 = (notification) => clearTimer2(notification);
  const mouseleave_handler = (notification, e) => createTimer(notification, e.target);
  const blur_handler2 = (notification, e) => createTimer(notification, e.target);
  const keydown_handler = (notification, e) => onKeydown2(e, notification);
  function notificationarchive_show_binding(value2) {
    $showArchive = value2;
    showArchive.set($showArchive);
  }
  function notificationarchive_expanded_binding(value2) {
    archiveIsExpanded = value2;
    $$invalidate2(7, archiveIsExpanded);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate2(8, el);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(0, className2 = $$props3.class);
    if ("round" in $$props3)
      $$invalidate2(1, round = $$props3.round);
    if ("outline" in $$props3)
      $$invalidate2(2, outline = $$props3.outline);
    if ("hideButton" in $$props3)
      $$invalidate2(3, hideButton = $$props3.hideButton);
  };
  $$self2.$capture_state = () => ({
    onDestroy,
    onMount,
    writable,
    Icon: Icon_default,
    PushButton: PushButton_default,
    Notifications,
    ArchivedNotifications,
    createTimer,
    timers,
    hideNotification,
    clearTimer: clearTimer2,
    send,
    flip: flip2,
    fly: fly2,
    slideDown,
    NotificationArchive: NotificationArchive_default,
    ANIMATION_SPEED,
    getNextNotification,
    className: className2,
    round,
    outline,
    hideButton,
    showArchive,
    duration: duration2,
    archiveIsVisible,
    archiveIsExpanded,
    el,
    notifications,
    initial,
    hasActiveNotifications,
    addEvents,
    removeEvents,
    onDocClick,
    _send,
    onKeydown: onKeydown2,
    hasArchivedNotifications,
    hasNotifications,
    $showArchive,
    $ANIMATION_SPEED,
    $ArchivedNotifications
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(0, className2 = $$props3.className);
    if ("round" in $$props3)
      $$invalidate2(1, round = $$props3.round);
    if ("outline" in $$props3)
      $$invalidate2(2, outline = $$props3.outline);
    if ("hideButton" in $$props3)
      $$invalidate2(3, hideButton = $$props3.hideButton);
    if ("archiveIsVisible" in $$props3)
      $$invalidate2(6, archiveIsVisible = $$props3.archiveIsVisible);
    if ("archiveIsExpanded" in $$props3)
      $$invalidate2(7, archiveIsExpanded = $$props3.archiveIsExpanded);
    if ("el" in $$props3)
      $$invalidate2(8, el = $$props3.el);
    if ("notifications" in $$props3)
      $$invalidate2(4, notifications = $$props3.notifications);
    if ("initial" in $$props3)
      initial = $$props3.initial;
    if ("hasActiveNotifications" in $$props3)
      $$invalidate2(9, hasActiveNotifications = $$props3.hasActiveNotifications);
    if ("hasArchivedNotifications" in $$props3)
      $$invalidate2(5, hasArchivedNotifications = $$props3.hasArchivedNotifications);
    if ("hasNotifications" in $$props3)
      $$invalidate2(10, hasNotifications = $$props3.hasNotifications);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty[0] & /*$ArchivedNotifications*/
    32768) {
      $:
        $$invalidate2(5, hasArchivedNotifications = Object.keys($ArchivedNotifications).length ? "has-archived-notifications" : "");
    }
    if ($$self2.$$.dirty[0] & /*notifications, hasArchivedNotifications*/
    48) {
      $:
        $$invalidate2(10, hasNotifications = notifications.length || hasArchivedNotifications ? "has-notifications" : "");
    }
  };
  return [
    className2,
    round,
    outline,
    hideButton,
    notifications,
    hasArchivedNotifications,
    archiveIsVisible,
    archiveIsExpanded,
    el,
    hasActiveNotifications,
    hasNotifications,
    $showArchive,
    showArchive,
    _send,
    onKeydown2,
    $ArchivedNotifications,
    pushbutton_pressed_binding,
    click_handler,
    click_handler_1,
    mouseover_handler,
    focus_handler2,
    mouseleave_handler,
    blur_handler2,
    keydown_handler,
    notificationarchive_show_binding,
    notificationarchive_expanded_binding,
    div_binding
  ];
}
var NotificationCenter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance44,
      create_fragment44,
      safe_not_equal,
      {
        class: 0,
        round: 1,
        outline: 2,
        hideButton: 3
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NotificationCenter",
      options,
      id: create_fragment44.name
    });
  }
  get class() {
    throw new Error("<NotificationCenter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<NotificationCenter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get round() {
    throw new Error("<NotificationCenter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set round(value2) {
    throw new Error("<NotificationCenter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<NotificationCenter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value2) {
    throw new Error("<NotificationCenter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideButton() {
    throw new Error("<NotificationCenter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideButton(value2) {
    throw new Error("<NotificationCenter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NotificationCenter_default = NotificationCenter;

// src/panel/Panel.svelte
var file38 = "src/panel/Panel.svelte";
function create_else_block5(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      div = element2("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "panel-content");
      add_location(div, file38, 25, 2, 611);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(25:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block25(ctx) {
  let details;
  let summary;
  let t0;
  let t1;
  let summary_inert_value;
  let t2;
  let div;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*collapsible*/
    ctx[5] && create_if_block_16(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      details = element2("details");
      summary = element2("summary");
      t0 = text(
        /*title*/
        ctx[3]
      );
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      div = element2("div");
      if (default_slot)
        default_slot.c();
      attr_dev(summary, "class", "panel-header");
      summary.inert = summary_inert_value = !/*collapsible*/
      ctx[5];
      add_location(summary, file38, 16, 3, 344);
      attr_dev(div, "class", "panel-content");
      add_location(div, file38, 22, 3, 546);
      details.open = /*open*/
      ctx[0];
      add_location(details, file38, 15, 2, 279);
    },
    m: function mount(target, anchor) {
      insert_dev(target, details, anchor);
      append_dev(details, summary);
      append_dev(summary, t0);
      append_dev(summary, t1);
      if (if_block)
        if_block.m(summary, null);
      ctx[16](summary);
      append_dev(details, t2);
      append_dev(details, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            details,
            "keydown",
            /*toggle*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            details,
            "click",
            /*toggle*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, dirty) {
      if (!current || dirty & /*title*/
      8)
        set_data_dev(
          t0,
          /*title*/
          ctx2[3]
        );
      if (
        /*collapsible*/
        ctx2[5]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_16(ctx2);
          if_block.c();
          if_block.m(summary, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*collapsible*/
      32 && summary_inert_value !== (summary_inert_value = !/*collapsible*/
      ctx2[5])) {
        prop_dev(summary, "inert", summary_inert_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*open*/
      1) {
        prop_dev(
          details,
          "open",
          /*open*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(details);
      }
      if (if_block)
        if_block.d();
      ctx[16](null);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block25.name,
    type: "if",
    source: "(15:1) {#if title}",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let div;
  let raw_value = getIcon("chevronRight") + "";
  const block = {
    c: function create() {
      div = element2("div");
      attr_dev(div, "class", "chevron");
      add_location(div, file38, 19, 5, 460);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      div.innerHTML = raw_value;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(19:4) {#if collapsible}",
    ctx
  });
  return block;
}
function create_fragment45(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block25, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*title*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element2("div");
      if_block.c();
      attr_dev(div, "class", div_class_value = "panel " + /*className*/
      ctx[2]);
      div.inert = /*disabled*/
      ctx[6];
      toggle_class(
        div,
        "collapsible",
        /*collapsible*/
        ctx[5]
      );
      toggle_class(
        div,
        "expanded",
        /*expanded*/
        ctx[13]
      );
      toggle_class(
        div,
        "round",
        /*round*/
        ctx[4]
      );
      toggle_class(
        div,
        "disabled",
        /*disabled*/
        ctx[6]
      );
      toggle_class(
        div,
        "info",
        /*info*/
        ctx[7]
      );
      toggle_class(
        div,
        "success",
        /*success*/
        ctx[8]
      );
      toggle_class(
        div,
        "warning",
        /*warning*/
        ctx[9]
      );
      toggle_class(
        div,
        "danger",
        /*danger*/
        ctx[10]
      );
      add_location(div, file38, 1, 0, 67);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[17](div);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*className*/
      4 && div_class_value !== (div_class_value = "panel " + /*className*/
      ctx2[2])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*disabled*/
      64) {
        prop_dev(
          div,
          "inert",
          /*disabled*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*className, collapsible*/
      36) {
        toggle_class(
          div,
          "collapsible",
          /*collapsible*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*className, expanded*/
      8196) {
        toggle_class(
          div,
          "expanded",
          /*expanded*/
          ctx2[13]
        );
      }
      if (!current || dirty & /*className, round*/
      20) {
        toggle_class(
          div,
          "round",
          /*round*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*className, disabled*/
      68) {
        toggle_class(
          div,
          "disabled",
          /*disabled*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*className, info*/
      132) {
        toggle_class(
          div,
          "info",
          /*info*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*className, success*/
      260) {
        toggle_class(
          div,
          "success",
          /*success*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*className, warning*/
      516) {
        toggle_class(
          div,
          "warning",
          /*warning*/
          ctx2[9]
        );
      }
      if (!current || dirty & /*className, danger*/
      1028) {
        toggle_class(
          div,
          "danger",
          /*danger*/
          ctx2[10]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
      ctx[17](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Panel", slots2, ["default"]);
  const dispatch3 = createEventDispatcher();
  let { class: className2 = "" } = $$props2;
  let { title = "" } = $$props2;
  let { open = false } = $$props2;
  let { round = false } = $$props2;
  let { collapsible = false } = $$props2;
  let { disabled: disabled2 = false } = $$props2;
  let { info: info2 = false } = $$props2;
  let { success = false } = $$props2;
  let { warning = false } = $$props2;
  let { danger = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let headerEl, expanded = open || !title;
  const expandedProps = { height: 0 };
  const collapsedProps = { height: 0 };
  onMount(calcHeights);
  function calcHeights() {
    const wasOpen = open;
    $$invalidate2(0, open = true);
    requestAnimationFrame(() => {
      if (!element3)
        return;
      const wrapCss = getComputedStyle(element3);
      const borderTop = parseInt(wrapCss.borderTopWidth || 0, 10);
      const borderBottom = parseInt(wrapCss.borderTopWidth || 0, 10);
      const headerH = headerEl ? headerEl.offsetHeight : 0;
      expandedProps.height = element3.getBoundingClientRect().height + "px";
      collapsedProps.height = headerH + borderTop + borderBottom + "px";
      $$invalidate2(0, open = wasOpen);
    });
  }
  function toggle(e) {
    if (!collapsible) {
      if (e.type === "click" || e.key === "Enter" || e.key === " ")
        e.preventDefault();
      return;
    }
    e ||= {
      target: null,
      type: "click",
      preventDefault: () => {
      }
    };
    const skipToggleOn = ["BUTTON", "INPUT", "A", "SELECT", "TEXTAREA"];
    if (e.target && skipToggleOn.includes(e.target.tagName))
      return;
    if (e.target && e.target.closest(".panel-content"))
      return;
    if (e.type === "keydown" && e.key !== " ")
      return;
    e.preventDefault();
    if (expanded) {
      $$invalidate2(13, expanded = false);
      animate(element3, expandedProps, collapsedProps).then(() => {
        $$invalidate2(0, open = expanded);
        dispatch3("close");
      });
    } else {
      $$invalidate2(13, expanded = true);
      $$invalidate2(0, open = true);
      animate(element3, collapsedProps, expandedProps).then(() => dispatch3("open"));
    }
  }
  const writable_props = [
    "class",
    "title",
    "open",
    "round",
    "collapsible",
    "disabled",
    "info",
    "success",
    "warning",
    "danger",
    "element"
  ];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Panel> was created with unknown prop '${key}'`);
  });
  function summary_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      headerEl = $$value;
      $$invalidate2(12, headerEl);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(2, className2 = $$props3.class);
    if ("title" in $$props3)
      $$invalidate2(3, title = $$props3.title);
    if ("open" in $$props3)
      $$invalidate2(0, open = $$props3.open);
    if ("round" in $$props3)
      $$invalidate2(4, round = $$props3.round);
    if ("collapsible" in $$props3)
      $$invalidate2(5, collapsible = $$props3.collapsible);
    if ("disabled" in $$props3)
      $$invalidate2(6, disabled2 = $$props3.disabled);
    if ("info" in $$props3)
      $$invalidate2(7, info2 = $$props3.info);
    if ("success" in $$props3)
      $$invalidate2(8, success = $$props3.success);
    if ("warning" in $$props3)
      $$invalidate2(9, warning = $$props3.warning);
    if ("danger" in $$props3)
      $$invalidate2(10, danger = $$props3.danger);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("$$scope" in $$props3)
      $$invalidate2(14, $$scope2 = $$props3.$$scope);
  };
  $$self2.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    getIcon,
    animate,
    dispatch: dispatch3,
    className: className2,
    title,
    open,
    round,
    collapsible,
    disabled: disabled2,
    info: info2,
    success,
    warning,
    danger,
    element: element3,
    headerEl,
    expanded,
    expandedProps,
    collapsedProps,
    calcHeights,
    toggle
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(2, className2 = $$props3.className);
    if ("title" in $$props3)
      $$invalidate2(3, title = $$props3.title);
    if ("open" in $$props3)
      $$invalidate2(0, open = $$props3.open);
    if ("round" in $$props3)
      $$invalidate2(4, round = $$props3.round);
    if ("collapsible" in $$props3)
      $$invalidate2(5, collapsible = $$props3.collapsible);
    if ("disabled" in $$props3)
      $$invalidate2(6, disabled2 = $$props3.disabled);
    if ("info" in $$props3)
      $$invalidate2(7, info2 = $$props3.info);
    if ("success" in $$props3)
      $$invalidate2(8, success = $$props3.success);
    if ("warning" in $$props3)
      $$invalidate2(9, warning = $$props3.warning);
    if ("danger" in $$props3)
      $$invalidate2(10, danger = $$props3.danger);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("headerEl" in $$props3)
      $$invalidate2(12, headerEl = $$props3.headerEl);
    if ("expanded" in $$props3)
      $$invalidate2(13, expanded = $$props3.expanded);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    open,
    element3,
    className2,
    title,
    round,
    collapsible,
    disabled2,
    info2,
    success,
    warning,
    danger,
    toggle,
    headerEl,
    expanded,
    $$scope2,
    slots2,
    summary_binding,
    div_binding
  ];
}
var Panel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, {
      class: 2,
      title: 3,
      open: 0,
      round: 4,
      collapsible: 5,
      disabled: 6,
      info: 7,
      success: 8,
      warning: 9,
      danger: 10,
      element: 1,
      toggle: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Panel",
      options,
      id: create_fragment45.name
    });
  }
  get class() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value2) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value2) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get round() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set round(value2) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collapsible() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collapsible(value2) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value2) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get success() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set success(value2) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warning() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warning(value2) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get danger() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set danger(value2) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    return this.$$.ctx[11];
  }
  set toggle(value2) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Panel_default = Panel;

// src/splitter/utils.js
function getFlexFlow(el) {
  const css = getComputedStyle(el);
  return css.flexDirection.replace("-reverse", "");
}
function getCSSvalueInPx(el, name2) {
  const css = getComputedStyle(el);
  return parseFloat(css[name2]);
}
function innerWidth(el) {
  const css = getComputedStyle(el);
  const borders = parseFloat(css.borderLeftWidth) + parseFloat(css.borderRightWidth);
  const padding = parseFloat(css.paddingLeft) + parseFloat(css.paddingRight);
  return el.getBoundingClientRect().width - borders - padding;
}
function innerHeight(el) {
  const css = getComputedStyle(el);
  const borders = parseFloat(css.borderTopWidth) + parseFloat(css.borderBottomWidth);
  const padding = parseFloat(css.paddingTop) + parseFloat(css.paddingBottom);
  return el.getBoundingClientRect().height - borders - padding;
}
var minHeight = (el) => getCSSvalueInPx(el, "minHeight");
var minWidth = (el) => getCSSvalueInPx(el, "minWidth");
var maxWidth = (el) => getCSSvalueInPx(el, "maxWidth");
var maxHeight = (el) => getCSSvalueInPx(el, "maxHeight");

// src/splitter/Splitter.svelte
var file39 = "src/splitter/Splitter.svelte";
function create_fragment46(ctx) {
  let div;
  let div_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element2("div");
      attr_dev(div, "class", div_class_value = "splitter " + /*className*/
      ctx[1]);
      toggle_class(
        div,
        "vertical",
        /*isVertical*/
        ctx[2]
      );
      toggle_class(
        div,
        "is-dragging",
        /*isDragging*/
        ctx[3]
      );
      add_location(div, file39, 1, 0, 59);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      ctx[9](div);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "mousedown",
          /*mousedown*/
          ctx[4],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      if (dirty & /*className*/
      2 && div_class_value !== (div_class_value = "splitter " + /*className*/
      ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty & /*className, isVertical*/
      6) {
        toggle_class(
          div,
          "vertical",
          /*isVertical*/
          ctx2[2]
        );
      }
      if (dirty & /*className, isDragging*/
      10) {
        toggle_class(
          div,
          "is-dragging",
          /*isDragging*/
          ctx2[3]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[9](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Splitter", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  const dispatch3 = createEventDispatcher();
  const size = 8, halfsize = size / 2;
  const Box = {};
  let isVertical = false;
  let parentEl, targetEl;
  let initialTargetBox, startX2, startY2;
  let mousedownTargetBox;
  let isDragging = false, bodyCursor;
  onMount(() => {
    requestAnimationFrame(init3);
  });
  function toggle() {
    setSize(Box.collapsed ? "max" : "min", true);
  }
  function collapse() {
    setSize("min", true);
  }
  function expand() {
    setSize("max", true);
  }
  function setSize(to, withAnimation = false) {
    const prop = isVertical ? "height" : "width";
    const Prop = isVertical ? "Height" : "Width";
    const box = {};
    if (!to || to === "default")
      box[prop] = initialTargetBox[prop];
    if (to === "min")
      box[prop] = initialTargetBox["min" + Prop];
    else if (to === "max")
      box[prop] = initialTargetBox["max" + Prop];
    else if (typeof to === "number")
      box[prop] = to;
    updateSize(box, withAnimation);
  }
  function init3() {
    targetEl = element3.previousElementSibling;
    parentEl = element3.parentElement;
    $$invalidate2(2, isVertical = getFlexFlow(parentEl) === "column");
    initialTargetBox = targetEl.getBoundingClientRect();
    if (isVertical) {
      initialTargetBox.minHeight = minHeight(targetEl);
      initialTargetBox.maxHeight = Math.min(innerHeight(element3.parentElement), maxHeight(targetEl));
    } else {
      initialTargetBox.minWidth = minWidth(targetEl);
      initialTargetBox.maxWidth = Math.min(innerWidth(element3.parentElement), maxWidth(targetEl));
    }
    updateSize(initialTargetBox);
    targetEl.style.flex = "unset";
    targetEl.style.overflow = "auto";
    if (isVertical)
      $$invalidate2(0, element3.style.height = size + "px", element3);
    else
      $$invalidate2(0, element3.style.width = size + "px", element3);
    if (element3 && element3.nextElementSibling)
      $$invalidate2(0, element3.nextElementSibling.style.overflow = "auto", element3);
  }
  function updateSize(box, withAnimation = false) {
    let originalTargetTransition, originalElTransition;
    if (withAnimation) {
      originalTargetTransition = targetEl.style.transition;
      originalElTransition = element3.style.transition;
      const anim = ANIMATION_SPEED + "ms ease-out";
      targetEl.style.transition = `width ${anim}, height ${anim}`;
      $$invalidate2(0, element3.style.transition = `left ${anim}, top ${anim}`, element3);
    }
    if (isVertical) {
      targetEl.style.height = box.height + "px";
      $$invalidate2(0, element3.style.top = box.height - halfsize + "px", element3);
      const collapsed = initialTargetBox.minHeight === box.height;
      Box.height = box.height;
      Box.collapsed = collapsed;
      dispatch3("change", Box);
    } else {
      targetEl.style.width = box.width + "px";
      $$invalidate2(0, element3.style.left = box.width - halfsize + "px", element3);
      const collapsed = initialTargetBox.minWidth === box.width;
      Box.width = box.width;
      Box.collapsed = collapsed;
      dispatch3("change", Box);
    }
    if (withAnimation) {
      setTimeout(
        () => {
          targetEl.style.transition = originalTargetTransition;
          $$invalidate2(0, element3.style.transition = originalElTransition, element3);
          dispatch3("changed", Box);
        },
        ANIMATION_SPEED
      );
    }
  }
  function mousedown(e) {
    if (isDragging)
      return;
    $$invalidate2(3, isDragging = true);
    e.preventDefault();
    document.addEventListener("mouseup", mouseup);
    document.addEventListener("mousemove", mousemove);
    bodyCursor = document.body.style.cursor;
    document.body.style.cursor = (isVertical ? "ns" : "ew") + "-resize";
    if (isVertical)
      startY2 = getMouseY(e);
    else
      startX2 = getMouseX(e);
    mousedownTargetBox = targetEl.getBoundingClientRect();
    updateSize(mousedownTargetBox);
  }
  function mousemove(e) {
    e.preventDefault();
    e.stopPropagation();
    if (isVertical) {
      let height = mousedownTargetBox.height + getMouseY(e) - startY2;
      if (height < initialTargetBox.minHeight)
        height = initialTargetBox.minHeight;
      if (height > initialTargetBox.maxHeight)
        height = initialTargetBox.maxHeight;
      updateSize({ height });
    } else {
      let width = mousedownTargetBox.width + getMouseX(e) - startX2;
      if (width < initialTargetBox.minWidth)
        width = initialTargetBox.minWidth;
      if (width > initialTargetBox.maxWidth)
        width = initialTargetBox.maxWidth;
      updateSize({ width });
    }
  }
  function mouseup() {
    if (!isDragging)
      return;
    $$invalidate2(3, isDragging = false);
    document.removeEventListener("mouseup", mouseup);
    document.removeEventListener("mousemove", mousemove);
    document.body.style.cursor = bodyCursor;
    dispatch3("changed", Box);
  }
  const writable_props = ["class", "element"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Splitter> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
  };
  $$self2.$capture_state = () => ({
    onMount,
    createEventDispatcher,
    innerWidth,
    innerHeight,
    minHeight,
    minWidth,
    maxWidth,
    maxHeight,
    getFlexFlow,
    getMouseX,
    getMouseY,
    ANIMATION_SPEED,
    className: className2,
    element: element3,
    dispatch: dispatch3,
    size,
    halfsize,
    Box,
    isVertical,
    parentEl,
    targetEl,
    initialTargetBox,
    startX: startX2,
    startY: startY2,
    mousedownTargetBox,
    isDragging,
    bodyCursor,
    toggle,
    collapse,
    expand,
    setSize,
    init: init3,
    updateSize,
    mousedown,
    mousemove,
    mouseup
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("isVertical" in $$props3)
      $$invalidate2(2, isVertical = $$props3.isVertical);
    if ("parentEl" in $$props3)
      parentEl = $$props3.parentEl;
    if ("targetEl" in $$props3)
      targetEl = $$props3.targetEl;
    if ("initialTargetBox" in $$props3)
      initialTargetBox = $$props3.initialTargetBox;
    if ("startX" in $$props3)
      startX2 = $$props3.startX;
    if ("startY" in $$props3)
      startY2 = $$props3.startY;
    if ("mousedownTargetBox" in $$props3)
      mousedownTargetBox = $$props3.mousedownTargetBox;
    if ("isDragging" in $$props3)
      $$invalidate2(3, isDragging = $$props3.isDragging);
    if ("bodyCursor" in $$props3)
      bodyCursor = $$props3.bodyCursor;
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    element3,
    className2,
    isVertical,
    isDragging,
    mousedown,
    toggle,
    collapse,
    expand,
    setSize,
    div_binding
  ];
}
var Splitter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, {
      class: 1,
      element: 0,
      toggle: 5,
      collapse: 6,
      expand: 7,
      setSize: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Splitter",
      options,
      id: create_fragment46.name
    });
  }
  get class() {
    throw new Error("<Splitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Splitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Splitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Splitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    return this.$$.ctx[5];
  }
  set toggle(value2) {
    throw new Error("<Splitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collapse() {
    return this.$$.ctx[6];
  }
  set collapse(value2) {
    throw new Error("<Splitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expand() {
    return this.$$.ctx[7];
  }
  set expand(value2) {
    throw new Error("<Splitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setSize() {
    return this.$$.ctx[8];
  }
  set setSize(value2) {
    throw new Error("<Splitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Splitter_default = Splitter;

// src/table/Table.svelte
var { Object: Object_14 } = globals;
var file40 = "src/table/Table.svelte";
function create_fragment47(ctx) {
  let div;
  let table;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  const block = {
    c: function create() {
      div = element2("div");
      table = element2("table");
      if (default_slot)
        default_slot.c();
      add_location(table, file40, 11, 1, 270);
      attr_dev(div, "class", div_class_value = "table " + /*className*/
      ctx[1]);
      toggle_class(
        div,
        "round",
        /*round*/
        ctx[2]
      );
      toggle_class(
        div,
        "selectable",
        /*_selectable*/
        ctx[3]
      );
      add_location(div, file40, 1, 0, 59);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, table);
      if (default_slot) {
        default_slot.m(table, null);
      }
      ctx[15](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*onClick*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "focus",
            /*onFocus*/
            ctx[4],
            true,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*onKeyDown*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "dblclick",
            /*onDblClick*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*className*/
      2 && div_class_value !== (div_class_value = "table " + /*className*/
      ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*className, round*/
      6) {
        toggle_class(
          div,
          "round",
          /*round*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*className, _selectable*/
      10) {
        toggle_class(
          div,
          "selectable",
          /*_selectable*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[15](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function shouldSkipNav2(e) {
  if (!e || !e.target || e.target === document)
    return false;
  const skipEventFor = ["INPUT", "TEXTAREA", "SELECT", "BUTTON"];
  if (skipEventFor.includes(e.target.tagName))
    return true;
  if (e.target.closest(".dialog,.drawer"))
    return true;
  return false;
}
function instance47($$self2, $$props2, $$invalidate2) {
  let _selectable;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Table", slots2, ["default"]);
  const dispatch3 = createEventDispatcher();
  let { class: className2 = "" } = $$props2;
  let { selectable = true } = $$props2;
  let { round = false } = $$props2;
  let { scrollContainer = void 0 } = $$props2;
  let { scrollCorrectionOffset = 0 } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let { rowSelector: rowSelector2 = "tbody tr" } = $$props2;
  let { data = {} } = $$props2;
  let selectedIdx = -1;
  let headerHeight = 0;
  let clickTimer;
  let previousKey;
  onMount(() => {
    Object.assign(element3.dataset, data);
    if (_selectable) {
      makeRowsSelectable();
      requestAnimationFrame(() => {
        const head = element3 && element3.querySelector("thead");
        if (head)
          headerHeight = head.offsetHeight;
      });
    }
  });
  onDestroy(() => {
    if (_selectable)
      makeRowsNotSelectable();
  });
  function getSelectableItems2(getFromAllTables = true) {
    const rootEl = getFromAllTables ? element3.parentNode : element3;
    const rows = rootEl.querySelectorAll(`.table ${rowSelector2}`);
    if (rows && rows.length)
      return Array.from(rows);
    return [];
  }
  function makeRowsSelectable() {
    getSelectableItems2(false).forEach((item) => item.setAttribute("tabindex", 0));
  }
  function makeRowsNotSelectable() {
    getSelectableItems2(false).forEach((item) => item.removeAttribute("tabindex"));
  }
  function selectPrev(skipEvent = false) {
    const rows = getSelectableItems2();
    if (selectedIdx <= 0)
      return;
    selectedIdx -= 1;
    const rowEl = rows[selectedIdx];
    rowEl.focus();
    if (!skipEvent)
      dispatch3("select", { selectedItem: rowEl });
  }
  function selectNext(skipEvent = false) {
    const rows = getSelectableItems2();
    if (selectedIdx >= rows.length - 1)
      return;
    selectedIdx += 1;
    const rowEl = rows[selectedIdx];
    rowEl.focus();
    if (!skipEvent)
      dispatch3("select", { selectedItem: rowEl });
  }
  function getScrollContainer2() {
    let scrlCont;
    if (scrollContainer) {
      if (typeof scrollContainer === "string")
        scrlCont = element3.closest(scrollContainer);
      else
        scrlCont = scrollContainer;
    }
    return scrlCont || element3;
  }
  function selectClicked(skipEvent = false) {
    const rows = getSelectableItems2();
    const rowEl = rows[selectedIdx];
    if (!rowEl)
      return;
    if (rowEl != document.activeElement)
      rowEl.focus();
    const scrlCont = getScrollContainer2();
    if (!scrlCont || !scrlCont.scrollTo)
      return;
    const topMargin = scrlCont === element3 ? 0 : element3.offsetTop;
    let top = rowEl.offsetTop - headerHeight + topMargin + parseFloat(scrollCorrectionOffset);
    if (scrlCont.scrollTop > top)
      scrlCont.scrollTo({ top: Math.round(top) });
    else {
      const paddingBottom = 4;
      top = rowEl.offsetTop + rowEl.offsetHeight - scrlCont.offsetHeight + headerHeight + topMargin + parseFloat(scrollCorrectionOffset) + paddingBottom;
      if (scrlCont.scrollTop < top)
        scrlCont.scrollTo({ top: Math.round(top) });
    }
    if (!skipEvent)
      dispatch3("select", { selectedItem: rowEl });
  }
  function selectFocusedRow(rowEl) {
    if (!rowEl)
      return;
    const rows = getSelectableItems2();
    selectedIdx = rows.findIndex((item) => item === rowEl);
    selectClicked(true);
  }
  function onFocus2(e) {
    if (!_selectable)
      return;
    if (!element3.contains(e.target))
      return;
    if (!e || !e.target || shouldSkipNav2(e))
      return;
    if (e.target === document)
      return;
    if (!e.target.matches(rowSelector2))
      return;
    const rowEl = e.target.closest(rowSelector2);
    if (rowEl) {
      selectFocusedRow(rowEl);
      dispatch3("click", { event: e, selectedItem: rowEl });
    }
  }
  function onClick(e) {
    if (!element3.contains(e.target))
      return;
    if (shouldSkipNav2(e))
      return;
    if (clickTimer)
      clearTimeout(clickTimer);
    clickTimer = setTimeout(() => dispatch3("select", { event: e, selectedItem: rowEl }), 300);
    const rowEl = e.target.closest(rowSelector2);
    if (rowEl) {
      selectFocusedRow(rowEl);
      dispatch3("click", { event: e, selectedItem: rowEl });
    }
  }
  function onDblClick(e) {
    if (!_selectable)
      return;
    if (!element3.contains(e.target))
      return;
    if (shouldSkipNav2(e))
      return;
    if (clickTimer)
      clearTimeout(clickTimer);
    onClick(e);
    requestAnimationFrame(() => {
      const selectedItem = getSelectableItems2()[selectedIdx];
      dispatch3("dblclick", { event: e, selectedItem });
    });
  }
  function onKeyDown(e) {
    if (!_selectable)
      return;
    if (!element3.contains(e.target))
      return;
    if (shouldSkipNav2(e))
      return;
    if (e.key === "ArrowUp" || e.key === "k") {
      e.preventDefault();
      selectPrev();
    }
    if (e.key === "ArrowDown" || e.key === "j") {
      e.preventDefault();
      selectNext();
    }
    if (e.key === "ArrowLeft" || e.key === "g" && previousKey === "g") {
      e.preventDefault();
      selectedIdx = -1;
      selectNext();
    }
    if (e.key === "ArrowRight" || e.key === "G") {
      e.preventDefault();
      const rows = getSelectableItems2();
      selectedIdx = rows && rows.length - 2;
      selectNext();
    }
    previousKey = e.key;
    const selectedItem = getSelectableItems2()[selectedIdx];
    dispatch3("keydown", { event: e, key: e.key, selectedItem });
  }
  const writable_props = [
    "class",
    "selectable",
    "round",
    "scrollContainer",
    "scrollCorrectionOffset",
    "element",
    "rowSelector",
    "data"
  ];
  Object_14.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Table> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("selectable" in $$props3)
      $$invalidate2(8, selectable = $$props3.selectable);
    if ("round" in $$props3)
      $$invalidate2(2, round = $$props3.round);
    if ("scrollContainer" in $$props3)
      $$invalidate2(9, scrollContainer = $$props3.scrollContainer);
    if ("scrollCorrectionOffset" in $$props3)
      $$invalidate2(10, scrollCorrectionOffset = $$props3.scrollCorrectionOffset);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("rowSelector" in $$props3)
      $$invalidate2(11, rowSelector2 = $$props3.rowSelector);
    if ("data" in $$props3)
      $$invalidate2(12, data = $$props3.data);
    if ("$$scope" in $$props3)
      $$invalidate2(13, $$scope2 = $$props3.$$scope);
  };
  $$self2.$capture_state = () => ({
    onDestroy,
    onMount,
    createEventDispatcher,
    dispatch: dispatch3,
    className: className2,
    selectable,
    round,
    scrollContainer,
    scrollCorrectionOffset,
    element: element3,
    rowSelector: rowSelector2,
    data,
    selectedIdx,
    headerHeight,
    clickTimer,
    previousKey,
    getSelectableItems: getSelectableItems2,
    makeRowsSelectable,
    makeRowsNotSelectable,
    selectPrev,
    selectNext,
    getScrollContainer: getScrollContainer2,
    selectClicked,
    selectFocusedRow,
    onFocus: onFocus2,
    onClick,
    onDblClick,
    onKeyDown,
    shouldSkipNav: shouldSkipNav2,
    _selectable
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("selectable" in $$props3)
      $$invalidate2(8, selectable = $$props3.selectable);
    if ("round" in $$props3)
      $$invalidate2(2, round = $$props3.round);
    if ("scrollContainer" in $$props3)
      $$invalidate2(9, scrollContainer = $$props3.scrollContainer);
    if ("scrollCorrectionOffset" in $$props3)
      $$invalidate2(10, scrollCorrectionOffset = $$props3.scrollCorrectionOffset);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("rowSelector" in $$props3)
      $$invalidate2(11, rowSelector2 = $$props3.rowSelector);
    if ("data" in $$props3)
      $$invalidate2(12, data = $$props3.data);
    if ("selectedIdx" in $$props3)
      selectedIdx = $$props3.selectedIdx;
    if ("headerHeight" in $$props3)
      headerHeight = $$props3.headerHeight;
    if ("clickTimer" in $$props3)
      clickTimer = $$props3.clickTimer;
    if ("previousKey" in $$props3)
      previousKey = $$props3.previousKey;
    if ("_selectable" in $$props3)
      $$invalidate2(3, _selectable = $$props3._selectable);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*selectable*/
    256) {
      $:
        $$invalidate2(3, _selectable = selectable === true || selectable === "true");
    }
  };
  return [
    element3,
    className2,
    round,
    _selectable,
    onFocus2,
    onClick,
    onDblClick,
    onKeyDown,
    selectable,
    scrollContainer,
    scrollCorrectionOffset,
    rowSelector2,
    data,
    $$scope2,
    slots2,
    div_binding
  ];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {
      class: 1,
      selectable: 8,
      round: 2,
      scrollContainer: 9,
      scrollCorrectionOffset: 10,
      element: 0,
      rowSelector: 11,
      data: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment47.name
    });
  }
  get class() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectable() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectable(value2) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get round() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set round(value2) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollContainer() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollContainer(value2) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollCorrectionOffset() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollCorrectionOffset(value2) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowSelector() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowSelector(value2) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value2) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// src/tooltip/Tooltip.svelte
var file41 = "src/tooltip/Tooltip.svelte";
function create_if_block26(ctx) {
  let div2;
  let div1;
  let div0;
  let div1_class_value;
  let div2_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      div2 = element2("div");
      div1 = element2("div");
      div0 = element2("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div0, "class", "popover-content tooltip-content");
      add_location(div0, file41, 11, 3, 240);
      attr_dev(div1, "class", div1_class_value = "popover tooltip " + /*className*/
      ctx[1]);
      attr_dev(div1, "role", "tooltip");
      add_location(div1, file41, 10, 2, 180);
      attr_dev(div2, "class", div2_class_value = "popover-plate popover-" + /*_position*/
      ctx[6] + " tooltip-plate");
      toggle_class(
        div2,
        "opened",
        /*opened*/
        ctx[7]
      );
      toggle_class(
        div2,
        "info",
        /*info*/
        ctx[2]
      );
      toggle_class(
        div2,
        "success",
        /*success*/
        ctx[3]
      );
      toggle_class(
        div2,
        "warning",
        /*warning*/
        ctx[4]
      );
      toggle_class(
        div2,
        "danger",
        /*danger*/
        ctx[5]
      );
      add_location(div2, file41, 1, 1, 14);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div1);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[14](div2);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*className*/
      2 && div1_class_value !== (div1_class_value = "popover tooltip " + /*className*/
      ctx2[1])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*_position*/
      64 && div2_class_value !== (div2_class_value = "popover-plate popover-" + /*_position*/
      ctx2[6] + " tooltip-plate")) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*_position, opened*/
      192) {
        toggle_class(
          div2,
          "opened",
          /*opened*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*_position, info*/
      68) {
        toggle_class(
          div2,
          "info",
          /*info*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*_position, success*/
      72) {
        toggle_class(
          div2,
          "success",
          /*success*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*_position, warning*/
      80) {
        toggle_class(
          div2,
          "warning",
          /*warning*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*_position, danger*/
      96) {
        toggle_class(
          div2,
          "danger",
          /*danger*/
          ctx2[5]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[14](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block26.name,
    type: "if",
    source: "(1:0) {#if opened}",
    ctx
  });
  return block;
}
function create_fragment48(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*opened*/
    ctx[7] && create_if_block26(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      if (
        /*opened*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*opened*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block26(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Tooltip", slots2, ["default"]);
  let { target = "" } = $$props2;
  let { delay = 0 } = $$props2;
  let { position = "top" } = $$props2;
  let { offset = 2 } = $$props2;
  let { class: className2 = "" } = $$props2;
  let { info: info2 = false } = $$props2;
  let { success = false } = $$props2;
  let { warning = false } = $$props2;
  let { danger = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  let _position = position;
  let opened = false;
  let showTimer, hideTimer, shownEvent, noHide = false;
  let targetEl;
  onMount(() => {
    targetEl = target ? document.querySelector("#" + target) : document.body;
    addTargetEvents();
  });
  onDestroy(removeTargetEvents);
  afterUpdate(align);
  function show(e) {
    if (hideTimer) {
      clearTimeout(hideTimer);
      hideTimer = null;
    }
    if (opened || showTimer)
      return;
    showTimer = setTimeout(() => _show(e), parseFloat(delay) || 0);
  }
  function _show(e) {
    $$invalidate2(7, opened = true);
    noHide = false;
    showTimer = null;
    shownEvent = e.type;
    requestAnimationFrame(() => {
      if (element3.parentElement !== document.body) {
        document.body.appendChild(element3);
      }
      addTooltipEvents();
      align();
    });
  }
  function align() {
    $$invalidate2(6, _position = alignItem({
      element: element3,
      target: targetEl,
      alignH: "center",
      alignV: position,
      offsetV: +offset
    }));
  }
  function preventHiding() {
    noHide = true;
  }
  function _hide() {
    $$invalidate2(7, opened = false);
    removeTooltipEvents();
  }
  function hide(e) {
    const targetIsSelf = targetEl instanceof Node && e.target instanceof Node && targetEl.contains(e.target);
    const targetIsTooltip = element3 && e.target instanceof Node && element3.contains(e.target);
    if ((e.type === "mousedown" || e.type === "click") && targetIsSelf)
      return;
    if (showTimer && shownEvent !== "click") {
      clearTimeout(showTimer);
      showTimer = null;
    }
    if (!opened)
      return;
    if (e.type === "click" || e.type === "mousedown") {
      if (targetIsSelf || targetIsTooltip)
        return;
      _hide();
    }
    if (shownEvent === "mouseover" && e.type === "mouseout")
      return hideTimer = setTimeout(_hide, 50);
    if (shownEvent === "focus" && e.type === "blur" && !noHide)
      return _hide();
    if (shownEvent === "mousedown" && e.type === "mousedown")
      return _hide();
    if (e.type === "keydown")
      return _hide();
  }
  function onKey2(e) {
    if (e.key === "Escape")
      hide(e);
  }
  function addTooltipEvents() {
    if (!element3)
      return;
    element3.addEventListener("mousedown", preventHiding);
    element3.addEventListener("focus", show);
    element3.addEventListener("blur", hide);
    element3.addEventListener("mouseover", show);
    element3.addEventListener("mouseout", hide);
    document.addEventListener("keydown", onKey2);
  }
  function removeTooltipEvents() {
    if (!element3)
      return;
    element3.removeEventListener("mousedown", preventHiding);
    element3.removeEventListener("focus", show);
    element3.removeEventListener("blur", hide);
    element3.removeEventListener("mouseover", show);
    element3.removeEventListener("mouseout", hide);
    document.removeEventListener("keydown", onKey2);
  }
  function addTargetEvents() {
    if (!targetEl)
      return;
    targetEl.addEventListener("focus", show);
    targetEl.addEventListener("blur", hide);
    targetEl.addEventListener("mouseover", show);
    targetEl.addEventListener("mouseout", hide);
  }
  function removeTargetEvents() {
    if (!targetEl)
      return;
    targetEl.removeEventListener("focus", show);
    targetEl.removeEventListener("blur", hide);
    targetEl.removeEventListener("mouseover", show);
    targetEl.removeEventListener("mouseout", hide);
  }
  const writable_props = [
    "target",
    "delay",
    "position",
    "offset",
    "class",
    "info",
    "success",
    "warning",
    "danger",
    "element"
  ];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tooltip> was created with unknown prop '${key}'`);
  });
  function div2_binding2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("target" in $$props3)
      $$invalidate2(8, target = $$props3.target);
    if ("delay" in $$props3)
      $$invalidate2(9, delay = $$props3.delay);
    if ("position" in $$props3)
      $$invalidate2(10, position = $$props3.position);
    if ("offset" in $$props3)
      $$invalidate2(11, offset = $$props3.offset);
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("info" in $$props3)
      $$invalidate2(2, info2 = $$props3.info);
    if ("success" in $$props3)
      $$invalidate2(3, success = $$props3.success);
    if ("warning" in $$props3)
      $$invalidate2(4, warning = $$props3.warning);
    if ("danger" in $$props3)
      $$invalidate2(5, danger = $$props3.danger);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("$$scope" in $$props3)
      $$invalidate2(12, $$scope2 = $$props3.$$scope);
  };
  $$self2.$capture_state = () => ({
    afterUpdate,
    onDestroy,
    onMount,
    alignItem,
    target,
    delay,
    position,
    offset,
    className: className2,
    info: info2,
    success,
    warning,
    danger,
    element: element3,
    _position,
    opened,
    showTimer,
    hideTimer,
    shownEvent,
    noHide,
    targetEl,
    show,
    _show,
    align,
    preventHiding,
    _hide,
    hide,
    onKey: onKey2,
    addTooltipEvents,
    removeTooltipEvents,
    addTargetEvents,
    removeTargetEvents
  });
  $$self2.$inject_state = ($$props3) => {
    if ("target" in $$props3)
      $$invalidate2(8, target = $$props3.target);
    if ("delay" in $$props3)
      $$invalidate2(9, delay = $$props3.delay);
    if ("position" in $$props3)
      $$invalidate2(10, position = $$props3.position);
    if ("offset" in $$props3)
      $$invalidate2(11, offset = $$props3.offset);
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("info" in $$props3)
      $$invalidate2(2, info2 = $$props3.info);
    if ("success" in $$props3)
      $$invalidate2(3, success = $$props3.success);
    if ("warning" in $$props3)
      $$invalidate2(4, warning = $$props3.warning);
    if ("danger" in $$props3)
      $$invalidate2(5, danger = $$props3.danger);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("_position" in $$props3)
      $$invalidate2(6, _position = $$props3._position);
    if ("opened" in $$props3)
      $$invalidate2(7, opened = $$props3.opened);
    if ("showTimer" in $$props3)
      showTimer = $$props3.showTimer;
    if ("hideTimer" in $$props3)
      hideTimer = $$props3.hideTimer;
    if ("shownEvent" in $$props3)
      shownEvent = $$props3.shownEvent;
    if ("noHide" in $$props3)
      noHide = $$props3.noHide;
    if ("targetEl" in $$props3)
      targetEl = $$props3.targetEl;
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    element3,
    className2,
    info2,
    success,
    warning,
    danger,
    _position,
    opened,
    target,
    delay,
    position,
    offset,
    $$scope2,
    slots2,
    div2_binding2
  ];
}
var Tooltip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance48, create_fragment48, safe_not_equal, {
      target: 8,
      delay: 9,
      position: 10,
      offset: 11,
      class: 1,
      info: 2,
      success: 3,
      warning: 4,
      danger: 5,
      element: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tooltip",
      options,
      id: create_fragment48.name
    });
  }
  get target() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value2) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get delay() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delay(value2) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value2) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value2) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value2) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get success() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set success(value2) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warning() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warning(value2) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get danger() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set danger(value2) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tooltip_default = Tooltip;

// src/tree/TreeNode.svelte
var file42 = "src/tree/TreeNode.svelte";
function get_each_context15(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function get_each_context_14(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i];
  return child_ctx;
}
function create_each_block_14(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create() {
      div = element2("div");
      attr_dev(div, "class", div_class_value = "tree-indent indent-" + /*indent*/
      ctx[12]);
      add_location(div, file42, 16, 3, 454);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*indents*/
      16 && div_class_value !== (div_class_value = "tree-indent indent-" + /*indent*/
      ctx2[12])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_14.name,
    type: "each",
    source: "(16:2) {#each indents as indent}",
    ctx
  });
  return block;
}
function create_if_block27(ctx) {
  let ul;
  let current;
  let each_value = ensure_array_like_dev(
    /*item*/
    ctx[2].items
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block15(get_each_context15(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      ul = element2("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      add_location(ul, file42, 23, 2, 650);
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*level, item*/
      12) {
        each_value = ensure_array_like_dev(
          /*item*/
          ctx2[2].items
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context15(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block15(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block27.name,
    type: "if",
    source: "(23:1) {#if item.items && expanded}",
    ctx
  });
  return block;
}
function create_each_block15(ctx) {
  let treenode;
  let current;
  treenode = new TreeNode({
    props: {
      level: (
        /*level*/
        ctx[3] + 1
      ),
      item: (
        /*subitem*/
        ctx[9]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(treenode.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(treenode, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const treenode_changes = {};
      if (dirty & /*level*/
      8)
        treenode_changes.level = /*level*/
        ctx2[3] + 1;
      if (dirty & /*item*/
      4)
        treenode_changes.item = /*subitem*/
        ctx2[9];
      treenode.$set(treenode_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(treenode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treenode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(treenode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block15.name,
    type: "each",
    source: "(25:3) {#each item.items as subitem}",
    ctx
  });
  return block;
}
function create_fragment49(ctx) {
  let li;
  let div2;
  let t0;
  let div0;
  let div0_class_value;
  let t1;
  let div1;
  let t2_value = (
    /*item*/
    ctx[2].name + ""
  );
  let t2;
  let div2_role_value;
  let div2_aria_label_value;
  let div2_aria_expanded_value;
  let div2_data_expanded_value;
  let div2_data_id_value;
  let t3;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like_dev(
    /*indents*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_14(get_each_context_14(ctx, each_value_1, i));
  }
  let if_block = (
    /*item*/
    ctx[2].items && /*expanded*/
    ctx[0] && create_if_block27(ctx)
  );
  const block = {
    c: function create() {
      li = element2("li");
      div2 = element2("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      div0 = element2("div");
      t1 = space();
      div1 = element2("div");
      t2 = text(t2_value);
      t3 = space();
      if (if_block)
        if_block.c();
      attr_dev(div0, "class", div0_class_value = "tree-icon tree-" + /*nodeType*/
      ctx[5] + "-icon");
      add_location(div0, file42, 18, 2, 514);
      attr_dev(div1, "class", "tree-label");
      add_location(div1, file42, 19, 2, 567);
      attr_dev(div2, "class", "tree-node");
      attr_dev(div2, "role", div2_role_value = /*item*/
      ctx[2].items ? "group" : "treeitem");
      attr_dev(div2, "aria-selected", "false");
      attr_dev(div2, "aria-label", div2_aria_label_value = /*item*/
      ctx[2].name);
      attr_dev(div2, "aria-expanded", div2_aria_expanded_value = /*item*/
      ctx[2].items ? (
        /*expanded*/
        ctx[0]
      ) : void 0);
      attr_dev(
        div2,
        "data-type",
        /*nodeType*/
        ctx[5]
      );
      attr_dev(
        div2,
        "data-level",
        /*level*/
        ctx[3]
      );
      attr_dev(div2, "data-expanded", div2_data_expanded_value = /*item*/
      ctx[2].items ? (
        /*expanded*/
        ctx[0]
      ) : void 0);
      attr_dev(div2, "data-id", div2_data_id_value = /*item*/
      ctx[2].id || void 0);
      toggle_class(
        div2,
        "expanded",
        /*expanded*/
        ctx[0]
      );
      add_location(div2, file42, 1, 1, 28);
      add_location(li, file42, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, div2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      append_dev(div2, t0);
      append_dev(div2, div0);
      append_dev(div2, t1);
      append_dev(div2, div1);
      append_dev(div1, t2);
      append_dev(li, t3);
      if (if_block)
        if_block.m(li, null);
      ctx[8](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div2,
            "click",
            function() {
              if (is_function(
                /*item*/
                ctx[2].items ? (
                  /*toggle*/
                  ctx[6]
                ) : void 0
              ))
                /*item*/
                (ctx[2].items ? (
                  /*toggle*/
                  ctx[6]
                ) : void 0).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "key",
            /*onkey*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*indents*/
      16) {
        each_value_1 = ensure_array_like_dev(
          /*indents*/
          ctx[4]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_14(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_14(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div2, t0);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (!current || dirty & /*nodeType*/
      32 && div0_class_value !== (div0_class_value = "tree-icon tree-" + /*nodeType*/
      ctx[5] + "-icon")) {
        attr_dev(div0, "class", div0_class_value);
      }
      if ((!current || dirty & /*item*/
      4) && t2_value !== (t2_value = /*item*/
      ctx[2].name + ""))
        set_data_dev(t2, t2_value);
      if (!current || dirty & /*item*/
      4 && div2_role_value !== (div2_role_value = /*item*/
      ctx[2].items ? "group" : "treeitem")) {
        attr_dev(div2, "role", div2_role_value);
      }
      if (!current || dirty & /*item*/
      4 && div2_aria_label_value !== (div2_aria_label_value = /*item*/
      ctx[2].name)) {
        attr_dev(div2, "aria-label", div2_aria_label_value);
      }
      if (!current || dirty & /*item, expanded*/
      5 && div2_aria_expanded_value !== (div2_aria_expanded_value = /*item*/
      ctx[2].items ? (
        /*expanded*/
        ctx[0]
      ) : void 0)) {
        attr_dev(div2, "aria-expanded", div2_aria_expanded_value);
      }
      if (!current || dirty & /*nodeType*/
      32) {
        attr_dev(
          div2,
          "data-type",
          /*nodeType*/
          ctx[5]
        );
      }
      if (!current || dirty & /*level*/
      8) {
        attr_dev(
          div2,
          "data-level",
          /*level*/
          ctx[3]
        );
      }
      if (!current || dirty & /*item, expanded*/
      5 && div2_data_expanded_value !== (div2_data_expanded_value = /*item*/
      ctx[2].items ? (
        /*expanded*/
        ctx[0]
      ) : void 0)) {
        attr_dev(div2, "data-expanded", div2_data_expanded_value);
      }
      if (!current || dirty & /*item*/
      4 && div2_data_id_value !== (div2_data_id_value = /*item*/
      ctx[2].id || void 0)) {
        attr_dev(div2, "data-id", div2_data_id_value);
      }
      if (!current || dirty & /*expanded*/
      1) {
        toggle_class(
          div2,
          "expanded",
          /*expanded*/
          ctx[0]
        );
      }
      if (
        /*item*/
        ctx[2].items && /*expanded*/
        ctx[0]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*item, expanded*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block27(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(li, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      ctx[8](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance49($$self2, $$props2, $$invalidate2) {
  let nodeType;
  let indents;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("TreeNode", slots2, []);
  let { item = {} } = $$props2;
  let { level = 0 } = $$props2;
  let { expanded = false } = $$props2;
  let { element: element3 = void 0 } = $$props2;
  function toggle() {
    $$invalidate2(0, expanded = !expanded);
  }
  function onkey3(e) {
    const key = e && e.detail && e.detail.key;
    if (key === "right")
      $$invalidate2(0, expanded = true);
    else if (key === "left")
      $$invalidate2(0, expanded = false);
  }
  const writable_props = ["item", "level", "expanded", "element"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TreeNode> was created with unknown prop '${key}'`);
  });
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(1, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("item" in $$props3)
      $$invalidate2(2, item = $$props3.item);
    if ("level" in $$props3)
      $$invalidate2(3, level = $$props3.level);
    if ("expanded" in $$props3)
      $$invalidate2(0, expanded = $$props3.expanded);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
  };
  $$self2.$capture_state = () => ({
    item,
    level,
    expanded,
    element: element3,
    toggle,
    onkey: onkey3,
    indents,
    nodeType
  });
  $$self2.$inject_state = ($$props3) => {
    if ("item" in $$props3)
      $$invalidate2(2, item = $$props3.item);
    if ("level" in $$props3)
      $$invalidate2(3, level = $$props3.level);
    if ("expanded" in $$props3)
      $$invalidate2(0, expanded = $$props3.expanded);
    if ("element" in $$props3)
      $$invalidate2(1, element3 = $$props3.element);
    if ("indents" in $$props3)
      $$invalidate2(4, indents = $$props3.indents);
    if ("nodeType" in $$props3)
      $$invalidate2(5, nodeType = $$props3.nodeType);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*item*/
    4) {
      $:
        $$invalidate2(5, nodeType = item.items ? "folder" : "file");
    }
    if ($$self2.$$.dirty & /*level*/
    8) {
      $:
        $$invalidate2(4, indents = new Array(level).fill(0));
    }
  };
  return [expanded, element3, item, level, indents, nodeType, toggle, onkey3, li_binding];
}
var TreeNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, {
      item: 2,
      level: 3,
      expanded: 0,
      element: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreeNode",
      options,
      id: create_fragment49.name
    });
  }
  get item() {
    throw new Error("<TreeNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set item(value2) {
    throw new Error("<TreeNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get level() {
    throw new Error("<TreeNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set level(value2) {
    throw new Error("<TreeNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expanded() {
    throw new Error("<TreeNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value2) {
    throw new Error("<TreeNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<TreeNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<TreeNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TreeNode_default = TreeNode;

// src/tree/Tree.svelte
var file43 = "src/tree/Tree.svelte";
function get_each_context16(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
function create_each_block16(ctx) {
  let treenode;
  let current;
  treenode = new TreeNode_default({
    props: { item: (
      /*item*/
      ctx[23]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(treenode.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(treenode, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const treenode_changes = {};
      if (dirty & /*items*/
      4)
        treenode_changes.item = /*item*/
        ctx2[23];
      treenode.$set(treenode_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(treenode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treenode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(treenode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block16.name,
    type: "each",
    source: "(12:1) {#each items as item}",
    ctx
  });
  return block;
}
function create_fragment50(ctx) {
  let ul;
  let ul_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(
    /*items*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block16(get_each_context16(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      ul = element2("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(ul, "class", ul_class_value = "tree " + /*className*/
      ctx[1]);
      attr_dev(ul, "role", "tree");
      attr_dev(
        ul,
        "aria-label",
        /*title*/
        ctx[3]
      );
      attr_dev(
        ul,
        "title",
        /*title*/
        ctx[3]
      );
      attr_dev(ul, "tabindex", "0");
      add_location(ul, file43, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      ctx[7](ul);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            ul,
            "focus",
            /*selectFirst*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "click",
            /*selectClicked*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "keydown",
            /*onkeydown*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      if (dirty & /*items*/
      4) {
        each_value = ensure_array_like_dev(
          /*items*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context16(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block16(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*className*/
      2 && ul_class_value !== (ul_class_value = "tree " + /*className*/
      ctx2[1])) {
        attr_dev(ul, "class", ul_class_value);
      }
      if (!current || dirty & /*title*/
      8) {
        attr_dev(
          ul,
          "aria-label",
          /*title*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*title*/
      8) {
        attr_dev(
          ul,
          "title",
          /*title*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      destroy_each(each_blocks, detaching);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Tree", slots2, []);
  let { class: className2 = "" } = $$props2;
  let { items = [] } = $$props2;
  let { title = void 0 } = $$props2;
  let { element: element3 } = $$props2;
  const dispatch3 = createEventDispatcher();
  let selectedItem;
  function getVisibleNodes() {
    return Array.from(element3.querySelectorAll(".tree .tree-node"));
  }
  function unselectAll() {
    element3.querySelectorAll(".tree .selected").forEach((_el) => _el.classList.remove("selected"));
  }
  function select(node) {
    if (!node || selectedItem === node)
      return;
    unselectAll();
    selectedItem = node;
    selectedItem.classList.add("selected");
    if (selectedItem.scrollIntoView) {
      selectedItem.scrollIntoView({ block: "nearest", inline: "nearest" });
    }
    const item = tryToGetSelectedItem();
    dispatch3("select", { selectedItem, item });
  }
  function selectClicked(e) {
    select(e.target.closest(".tree-node"));
  }
  function selectFirst() {
    select(getVisibleNodes()[0]);
  }
  function selectFirstChild() {
    const children2 = selectedItem.nextElementSibling;
    if (!children2)
      return;
    const firstChild = children2.querySelector(".tree-node");
    if (firstChild)
      select(firstChild);
  }
  function selectPrev() {
    const nodes = getVisibleNodes();
    const idx = nodes.indexOf(selectedItem);
    if (idx > 0)
      select(nodes[idx - 1]);
  }
  function selectNext() {
    const nodes = getVisibleNodes();
    const idx = nodes.indexOf(selectedItem);
    if (idx < nodes.length - 1)
      select(nodes[idx + 1]);
  }
  function selectParent() {
    const level = +selectedItem.dataset.level;
    if (level === 0)
      return selectFirst();
    select(selectedItem.parentElement.parentElement.previousElementSibling);
  }
  function sendKeyToNode(key) {
    const event = new CustomEvent("key", { detail: { key } });
    selectedItem.dispatchEvent(event);
  }
  function goLeft() {
    const isFolder = selectedItem.dataset.type === "folder";
    if (isFolder) {
      const isExpanded = selectedItem.dataset.expanded === "true";
      if (isExpanded)
        sendKeyToNode("left");
      else
        selectParent();
    } else
      selectParent();
  }
  function goRight() {
    const isFolder = selectedItem.dataset.type === "folder";
    if (isFolder) {
      const isExpanded = selectedItem.dataset.expanded === "true";
      if (isExpanded)
        selectFirstChild();
      else
        sendKeyToNode("right");
    }
  }
  function toggle() {
    const isFolder = selectedItem.dataset.type === "folder";
    if (isFolder)
      selectedItem.click();
  }
  function onkeydown2(e) {
    const keyMap = {
      ArrowUp: selectPrev,
      ArrowDown: selectNext,
      ArrowLeft: goLeft,
      ArrowRight: goRight,
      Enter: toggle
    };
    if (typeof keyMap[e.key] === "function") {
      e.preventDefault();
      keyMap[e.key](e);
    }
    const item = tryToGetSelectedItem();
    dispatch3("keydown", { event: e, selectedItem, item });
  }
  function tryToGetSelectedItem() {
    const id2 = selectedItem.dataset.id;
    if (id2)
      return findItem(id2);
  }
  function findItem(id2, nodes) {
    if (!nodes)
      nodes = items;
    for (let found, node, i = 0; node = nodes[i]; i++) {
      if (node.id == id2)
        return node;
      if (node.items)
        found = findItem(id2, node.items);
      if (found)
        return found;
    }
  }
  $$self2.$$.on_mount.push(function() {
    if (element3 === void 0 && !("element" in $$props2 || $$self2.$$.bound[$$self2.$$.props["element"]])) {
      console.warn("<Tree> was created without expected prop 'element'");
    }
  });
  const writable_props = ["class", "items", "title", "element"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tree> was created with unknown prop '${key}'`);
  });
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element3 = $$value;
      $$invalidate2(0, element3);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("class" in $$props3)
      $$invalidate2(1, className2 = $$props3.class);
    if ("items" in $$props3)
      $$invalidate2(2, items = $$props3.items);
    if ("title" in $$props3)
      $$invalidate2(3, title = $$props3.title);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
  };
  $$self2.$capture_state = () => ({
    createEventDispatcher,
    TreeNode: TreeNode_default,
    className: className2,
    items,
    title,
    element: element3,
    dispatch: dispatch3,
    selectedItem,
    getVisibleNodes,
    unselectAll,
    select,
    selectClicked,
    selectFirst,
    selectFirstChild,
    selectPrev,
    selectNext,
    selectParent,
    sendKeyToNode,
    goLeft,
    goRight,
    toggle,
    onkeydown: onkeydown2,
    tryToGetSelectedItem,
    findItem
  });
  $$self2.$inject_state = ($$props3) => {
    if ("className" in $$props3)
      $$invalidate2(1, className2 = $$props3.className);
    if ("items" in $$props3)
      $$invalidate2(2, items = $$props3.items);
    if ("title" in $$props3)
      $$invalidate2(3, title = $$props3.title);
    if ("element" in $$props3)
      $$invalidate2(0, element3 = $$props3.element);
    if ("selectedItem" in $$props3)
      selectedItem = $$props3.selectedItem;
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    element3,
    className2,
    items,
    title,
    selectClicked,
    selectFirst,
    onkeydown2,
    ul_binding
  ];
}
var Tree = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, { class: 1, items: 2, title: 3, element: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tree",
      options,
      id: create_fragment50.name
    });
  }
  get class() {
    throw new Error("<Tree>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value2) {
    throw new Error("<Tree>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<Tree>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value2) {
    throw new Error("<Tree>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Tree>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value2) {
    throw new Error("<Tree>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Tree>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value2) {
    throw new Error("<Tree>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tree_default = Tree;

// src/index.js
document.documentElement.classList.add(isMobile() ? "mobile" : "desktop");

// docs-src/nav/Nav.svelte
var import_vanilla_swipe = __toESM(require_lib());

// docs-src/nav/NavItem.svelte
var file44 = "docs-src/nav/NavItem.svelte";
function create_fragment51(ctx) {
  let a;
  let t;
  let a_href_value;
  const block = {
    c: function create() {
      a = element2("a");
      t = text(
        /*name*/
        ctx[1]
      );
      attr_dev(a, "href", a_href_value = "#" + /*hash*/
      ctx[2]);
      toggle_class(
        a,
        "active",
        /*active*/
        ctx[0] === /*hash*/
        ctx[2]
      );
      add_location(a, file44, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      append_dev(a, t);
    },
    p: function update2(ctx2, [dirty]) {
      if (dirty & /*name*/
      2)
        set_data_dev(
          t,
          /*name*/
          ctx2[1]
        );
      if (dirty & /*hash*/
      4 && a_href_value !== (a_href_value = "#" + /*hash*/
      ctx2[2])) {
        attr_dev(a, "href", a_href_value);
      }
      if (dirty & /*active, hash*/
      5) {
        toggle_class(
          a,
          "active",
          /*active*/
          ctx2[0] === /*hash*/
          ctx2[2]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("NavItem", slots2, []);
  let { active: active2 = location.hash.substr(1) } = $$props2;
  let { name: name2 = "" } = $$props2;
  let { hash: hash2 = name2.replace(/\s/g, "") } = $$props2;
  const writable_props = ["active", "name", "hash"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NavItem> was created with unknown prop '${key}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("active" in $$props3)
      $$invalidate2(0, active2 = $$props3.active);
    if ("name" in $$props3)
      $$invalidate2(1, name2 = $$props3.name);
    if ("hash" in $$props3)
      $$invalidate2(2, hash2 = $$props3.hash);
  };
  $$self2.$capture_state = () => ({ active: active2, name: name2, hash: hash2 });
  $$self2.$inject_state = ($$props3) => {
    if ("active" in $$props3)
      $$invalidate2(0, active2 = $$props3.active);
    if ("name" in $$props3)
      $$invalidate2(1, name2 = $$props3.name);
    if ("hash" in $$props3)
      $$invalidate2(2, hash2 = $$props3.hash);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [active2, name2, hash2];
}
var NavItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, { active: 0, name: 1, hash: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavItem",
      options,
      id: create_fragment51.name
    });
  }
  get active() {
    throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value2) {
    throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value2) {
    throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hash() {
    throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hash(value2) {
    throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavItem_default = NavItem;

// docs-src/pages/start.svelte
var file45 = "docs-src/pages/start.svelte";
function create_fragment52(ctx) {
  let div0;
  let a0;
  let img;
  let img_src_value;
  let t0;
  let h1;
  let span0;
  let em0;
  let sub;
  let t5;
  let p0;
  let t6;
  let em1;
  let t8;
  let a1;
  let t10;
  let t11;
  let div1;
  let h20;
  let t13;
  let h30;
  let t15;
  let pre0;
  let code0;
  let t17;
  let h31;
  let t19;
  let p1;
  let t20;
  let em2;
  let t22;
  let em3;
  let t24;
  let br0;
  let t25;
  let br1;
  let t26;
  let em4;
  let t28;
  let em5;
  let t30;
  let em6;
  let t32;
  let t33;
  let pre1;
  let code1;
  let t35;
  let p2;
  let i0;
  let t37;
  let em7;
  let t39;
  let em8;
  let t41;
  let h32;
  let t43;
  let p3;
  let t44;
  let i1;
  let t46;
  let t47;
  let pre2;
  let code2;
  let t49;
  let div2;
  let h21;
  let t51;
  let p4;
  let t52;
  let em9;
  let t54;
  let t55;
  let h33;
  let t57;
  let p5;
  let t58;
  let em10;
  let t60;
  let br2;
  let t61;
  let em11;
  let t63;
  let t64;
  let pre3;
  let code3;
  let t66;
  let h34;
  let t68;
  let p6;
  let t69;
  let em12;
  let t71;
  let em13;
  let t73;
  let br3;
  let t74;
  let em14;
  let t76;
  let em15;
  let t78;
  let em16;
  let t80;
  let t81;
  let pre4;
  let code4;
  let t83;
  let p7;
  let t85;
  let div3;
  let h22;
  let t87;
  let p8;
  let t89;
  let pre5;
  let code5;
  let t91;
  let p9;
  let t93;
  let div5;
  let h23;
  let t95;
  let ul;
  let li0;
  let a2;
  let t97;
  let li1;
  let t98;
  let a3;
  let t100;
  let li2;
  let span1;
  let t102;
  let a4;
  let t104;
  let div4;
  let a5;
  let svg0;
  let path0;
  let t105;
  let a6;
  let svg1;
  let path1;
  let path2;
  let t106;
  let a7;
  let svg2;
  let path3;
  let path4;
  const block = {
    c: function create() {
      div0 = element2("div");
      a0 = element2("a");
      img = element2("img");
      t0 = space();
      h1 = element2("h1");
      span0 = element2("span");
      span0.textContent = "PerfectThings";
      em0 = element2("em");
      em0.textContent = "UI";
      sub = element2("sub");
      sub.textContent = `v${window.UI_VERSION || ""}`;
      t5 = space();
      p0 = element2("p");
      t6 = text("PerfectThings UI (or ");
      em1 = element2("em");
      em1.textContent = "@perfectthings/ui";
      t8 = text(") is a beautiful UI framework and a simple design system\n	available as an npm module, that strives to provide the best possible UX when building web applications in\n	");
      a1 = element2("a");
      a1.textContent = "svelte";
      t10 = text(".");
      t11 = space();
      div1 = element2("div");
      h20 = element2("h2");
      h20.textContent = "Get started";
      t13 = space();
      h30 = element2("h3");
      h30.textContent = "1. Install as a dev dependency";
      t15 = space();
      pre0 = element2("pre");
      code0 = element2("code");
      code0.textContent = "\n		npm i -D @perfectthings/ui\n	";
      t17 = space();
      h31 = element2("h3");
      h31.textContent = "2. Import the CSS file";
      t19 = space();
      p1 = element2("p");
      t20 = text("You need to import the ");
      em2 = element2("em");
      em2.textContent = "docs/ui.css";
      t22 = text(" into your bundle or add it as a script to the ");
      em3 = element2("em");
      em3.textContent = "index.html";
      t24 = text(".");
      br0 = element2("br");
      t25 = text("\n	There are many ways to do that. We specifically didn't use any css-to-js imports as these restrict the tools & the setup you may want to have.");
      br1 = element2("br");
      t26 = text("\n	The easiest way is to add a ");
      em4 = element2("em");
      em4.textContent = "postinstall";
      t28 = text(" script into your ");
      em5 = element2("em");
      em5.textContent = "package.json";
      t30 = text(" that will just copy the file into your ");
      em6 = element2("em");
      em6.textContent = "dist";
      t32 = text(" folder:");
      t33 = space();
      pre1 = element2("pre");
      code1 = element2("code");
      code1.textContent = '\n	"scripts": {\n		"postinstall": "cp node_modules/@perfectthings/ui/docs/ui.css ./dist/ui.css"\n	}\n	';
      t35 = space();
      p2 = element2("p");
      i0 = element2("i");
      i0.textContent = "Note:";
      t37 = text(" you need to run ");
      em7 = element2("em");
      em7.textContent = "npm install";
      t39 = text(" after adding this line to your ");
      em8 = element2("em");
      em8.textContent = "package.json";
      t41 = space();
      h32 = element2("h3");
      h32.textContent = "3. Svelte components";
      t43 = space();
      p3 = element2("p");
      t44 = text("Just ");
      i1 = element2("i");
      i1.textContent = "import";
      t46 = text(" them from the module, as normal:");
      t47 = space();
      pre2 = element2("pre");
      code2 = element2("code");
      code2.textContent = "\n		import { Button } from '@perfectthings/ui';\n	";
      t49 = space();
      div2 = element2("div");
      h21 = element2("h2");
      h21.textContent = "SvelteKit";
      t51 = space();
      p4 = element2("p");
      t52 = text("This framework works with SvelteKit from version ");
      em9 = element2("em");
      em9.textContent = "6.4.0";
      t54 = text(".");
      t55 = space();
      h33 = element2("h3");
      h33.textContent = "1. Config";
      t57 = space();
      p5 = element2("p");
      t58 = text("Because this is a purely front-end framework and requires a browser to work, it will not work with ");
      em10 = element2("em");
      em10.textContent = "SSR";
      t60 = text(", so it needs to be disabled.");
      br2 = element2("br");
      t61 = text("\n		Create a file: ");
      em11 = element2("em");
      em11.textContent = "src/routes/+layout.js";
      t63 = text(" and add this:");
      t64 = space();
      pre3 = element2("pre");
      code3 = element2("code");
      code3.textContent = "\n	export const ssr = false;\n	";
      t66 = space();
      h34 = element2("h3");
      h34.textContent = "2. CSS";
      t68 = space();
      p6 = element2("p");
      t69 = text("If you're using SvelteKit, you need to add the ");
      em12 = element2("em");
      em12.textContent = "ui.css";
      t71 = text(" file to the ");
      em13 = element2("em");
      em13.textContent = "static";
      t73 = text(" folder,");
      br3 = element2("br");
      t74 = text("\n	and then either import it into your ");
      em14 = element2("em");
      em14.textContent = "global.css";
      t76 = text(" file or add it to the ");
      em15 = element2("em");
      em15.textContent = "head";
      t78 = text(" section of your ");
      em16 = element2("em");
      em16.textContent = "app.html";
      t80 = text(" file:");
      t81 = space();
      pre4 = element2("pre");
      code4 = element2("code");
      code4.textContent = '\n	<head>\n		...\n		<link rel="stylesheet" href="%sveltekit.assets%/ui.css" />\n	</head>\n	';
      t83 = space();
      p7 = element2("p");
      p7.textContent = "Once that's done, you can import the components as normal.";
      t85 = space();
      div3 = element2("div");
      h22 = element2("h2");
      h22.textContent = "Development";
      t87 = space();
      p8 = element2("p");
      p8.textContent = "You need node & npm (obviously). Then, run these:";
      t89 = space();
      pre5 = element2("pre");
      code5 = element2("code");
      code5.textContent = "\n	git clone git@github.com:perfect-things/ui.git perfectthings-ui\n	cd perfectthings-ui\n	npm i && npm start\n	";
      t91 = space();
      p9 = element2("p");
      p9.textContent = "A browser window should open with the demo of the components.";
      t93 = space();
      div5 = element2("div");
      h23 = element2("h2");
      h23.textContent = "Resources & Credits";
      t95 = space();
      ul = element2("ul");
      li0 = element2("li");
      a2 = element2("a");
      a2.textContent = "Human Interface Guidelines";
      t97 = text(" from Apple\n		");
      li1 = element2("li");
      t98 = text("Icons from ");
      a3 = element2("a");
      a3.textContent = "Tabler Icons";
      t100 = space();
      li2 = element2("li");
      span1 = element2("span");
      span1.textContent = "Prime Light";
      t102 = text(" font from ");
      a4 = element2("a");
      a4.textContent = "Fontfabric";
      t104 = space();
      div4 = element2("div");
      a5 = element2("a");
      svg0 = svg_element("svg");
      path0 = svg_element("path");
      t105 = space();
      a6 = element2("a");
      svg1 = svg_element("svg");
      path1 = svg_element("path");
      path2 = svg_element("path");
      t106 = space();
      a7 = element2("a");
      svg2 = svg_element("svg");
      path3 = svg_element("path");
      path4 = svg_element("path");
      attr_dev(img, "class", "logo");
      if (!src_url_equal(img.src, img_src_value = "logo.svg"))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Logo");
      add_location(img, file45, 2, 2, 64);
      add_location(span0, file45, 3, 23, 133);
      add_location(em0, file45, 3, 49, 159);
      add_location(sub, file45, 3, 60, 170);
      attr_dev(h1, "class", "logotype");
      add_location(h1, file45, 3, 2, 112);
      attr_dev(a0, "href", "https://ui.perfectthings.dev");
      add_location(a0, file45, 1, 1, 22);
      attr_dev(div0, "class", "banner");
      add_location(div0, file45, 0, 0, 0);
      add_location(em1, file45, 7, 24, 251);
      attr_dev(a1, "href", "http://svelte.dev");
      add_location(a1, file45, 9, 1, 443);
      add_location(p0, file45, 7, 0, 227);
      add_location(h20, file45, 14, 1, 518);
      add_location(h30, file45, 16, 1, 541);
      attr_dev(code0, "class", "language-bash");
      add_location(code0, file45, 18, 6, 588);
      add_location(pre0, file45, 18, 1, 583);
      add_location(h31, file45, 23, 1, 664);
      add_location(em2, file45, 24, 27, 723);
      add_location(em3, file45, 24, 94, 790);
      add_location(br0, file45, 24, 114, 810);
      add_location(br1, file45, 25, 143, 958);
      add_location(em4, file45, 26, 29, 992);
      add_location(em5, file45, 26, 67, 1030);
      add_location(em6, file45, 26, 128, 1091);
      add_location(p1, file45, 24, 1, 697);
      attr_dev(code1, "class", "language-json");
      add_location(code1, file45, 29, 6, 1126);
      add_location(pre1, file45, 29, 1, 1121);
      add_location(i0, file45, 35, 4, 1285);
      add_location(em7, file45, 35, 33, 1314);
      add_location(em8, file45, 35, 85, 1366);
      add_location(p2, file45, 35, 1, 1282);
      add_location(h32, file45, 38, 1, 1395);
      add_location(i1, file45, 39, 9, 1434);
      add_location(p3, file45, 39, 1, 1426);
      attr_dev(code2, "class", "language-js");
      add_location(code2, file45, 41, 6, 1492);
      add_location(pre2, file45, 41, 1, 1487);
      attr_dev(div1, "class", "sticky-block");
      add_location(div1, file45, 13, 0, 490);
      add_location(h21, file45, 47, 1, 1630);
      add_location(em9, file45, 48, 53, 1702);
      add_location(p4, file45, 48, 1, 1650);
      add_location(h33, file45, 50, 1, 1724);
      add_location(em10, file45, 52, 101, 1849);
      add_location(br2, file45, 52, 142, 1890);
      add_location(em11, file45, 53, 17, 1912);
      add_location(p5, file45, 51, 1, 1744);
      attr_dev(code3, "class", "language-js");
      add_location(code3, file45, 56, 6, 1970);
      add_location(pre3, file45, 56, 1, 1965);
      add_location(h34, file45, 61, 1, 2042);
      add_location(em12, file45, 62, 51, 2109);
      add_location(em13, file45, 62, 79, 2137);
      add_location(br3, file45, 62, 102, 2160);
      add_location(em14, file45, 63, 37, 2202);
      add_location(em15, file45, 63, 79, 2244);
      add_location(em16, file45, 63, 109, 2274);
      add_location(p6, file45, 62, 1, 2059);
      attr_dev(code4, "class", "language-html");
      add_location(code4, file45, 65, 6, 2309);
      add_location(pre4, file45, 65, 1, 2304);
      add_location(p7, file45, 72, 1, 2457);
      attr_dev(div2, "class", "sticky-block");
      add_location(div2, file45, 46, 0, 1602);
      add_location(h22, file45, 78, 1, 2561);
      add_location(p8, file45, 80, 1, 2584);
      attr_dev(code5, "class", "language-bash");
      add_location(code5, file45, 82, 6, 2648);
      add_location(pre5, file45, 82, 1, 2643);
      add_location(p9, file45, 88, 1, 2800);
      attr_dev(div3, "class", "sticky-block");
      add_location(div3, file45, 77, 0, 2533);
      add_location(h23, file45, 93, 1, 2906);
      attr_dev(a2, "href", "https://developer.apple.com/design/human-interface-guidelines/components/");
      add_location(a2, file45, 95, 6, 2947);
      add_location(li0, file45, 95, 2, 2943);
      attr_dev(a3, "href", "https://tablericons.com");
      add_location(a3, file45, 96, 17, 3090);
      add_location(li1, file45, 96, 2, 3075);
      attr_dev(span1, "class", "prime-light");
      add_location(span1, file45, 97, 6, 3147);
      attr_dev(a4, "href", "https://www.fontfabric.com");
      add_location(a4, file45, 97, 61, 3202);
      add_location(li2, file45, 97, 2, 3143);
      add_location(ul, file45, 94, 1, 2936);
      attr_dev(path0, "fill", "currentColor");
      attr_dev(path0, "fill-rule", "evenodd");
      attr_dev(path0, "d", "M64.052 4C28.632 4 0 31.729 0 66.033c0 27.423 18.346 50.635 43.798 58.849 3.18.619 4.348-1.334 4.348-2.976 0-1.439-.106-6.368-.106-11.504-17.818 3.698-21.528-7.396-21.528-7.396-2.864-7.189-7.106-9.037-7.106-9.037-5.832-3.799.424-3.799.424-3.799 6.47.41 9.864 6.368 9.864 6.368 5.726 9.448 14.952 6.777 18.664 5.134.53-4.005 2.228-6.778 4.03-8.318-14.212-1.438-29.164-6.78-29.164-30.609 0-6.777 2.544-12.324 6.574-16.637-.634-1.538-2.862-7.908.64-16.433 0 0 5.406-1.644 17.6 6.368a63.911 63.911 0 0 1 16.014-2.053 63.93 63.93 0 0 1 16.014 2.053c12.196-8.012 17.604-6.368 17.604-6.368 3.5 8.525 1.272 14.893.636 16.433 4.136 4.315 6.574 9.86 6.574 16.64 0 23.827-14.95 29.064-29.268 30.606 2.334 1.95 4.348 5.647 4.348 11.501 0 8.32-.106 14.997-.106 17.049 0 1.644 1.168 3.595 4.348 2.98C109.654 116.666 128 93.456 128 66.033 128.104 31.729 99.366 4 64.052 4Z");
      add_location(path0, file45, 104, 4, 3472);
      attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg0, "width", "128");
      attr_dev(svg0, "height", "128");
      attr_dev(svg0, "viewBox", "0 0 128 128");
      add_location(svg0, file45, 103, 3, 3380);
      attr_dev(a5, "href", "https://github.com/perfect-things/ui/");
      attr_dev(a5, "title", "Github repo");
      attr_dev(a5, "class", "github");
      add_location(a5, file45, 102, 2, 3293);
      attr_dev(path1, "fill", "currentColor");
      attr_dev(path1, "d", "M0 20h365v121.714H182.5V162h-81.111v-20.286H0V20Zm20.278 101.429h40.555V60.57h20.278v60.858h20.278V40.286H20.278v81.143Zm101.389-81.143v101.428h40.555V121.43h40.556V40.286h-81.111Zm40.555 20.285H182.5v40.572h-20.278V60.57Zm60.834-20.285v81.143h40.555V60.57h20.278v60.858h20.278V60.57h20.277v60.858h20.278V40.286H223.056Z");
      add_location(path1, file45, 109, 4, 4584);
      attr_dev(path2, "fill", "none");
      attr_dev(path2, "d", "M23 124h40.5V63.25h20.25V124H104V43H23zM118 40v104h40.5v-20.8H199V40h-81Zm60.75 62.4H158.5V60.8h20.25v41.6ZM223 43v81h39.333V63.25H282V124h19.667V63.25h19.666V124H341V43z");
      add_location(path2, file45, 110, 4, 4941);
      attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg1, "width", "365");
      attr_dev(svg1, "height", "162");
      attr_dev(svg1, "viewBox", "0 0 365 162");
      add_location(svg1, file45, 108, 3, 4492);
      attr_dev(a6, "href", "https://www.npmjs.com/package/@perfectthings/ui");
      attr_dev(a6, "title", "NPM page");
      attr_dev(a6, "class", "npm");
      add_location(a6, file45, 107, 2, 4401);
      attr_dev(path3, "d", "M113.5 10.8853L33.8257 56.8853C24.8531 62.0656 19.3257 71.6393 19.3257 82V174C19.3257 184.361 24.8531 193.934 33.8257 199.115L46 206.144V168.205C45.9669 167.806 45.95 167.404 45.95 167V89C45.95 83.8196 48.7137 79.0328 53.2 76.4426L120.75 37.4426C125.236 34.8525 130.764 34.8525 135.25 37.4426L202.8 76.4426C207.286 79.0328 210.05 83.8196 210.05 89V167C210.05 172.18 207.286 176.967 202.8 179.557L135.25 218.557C130.764 221.148 125.236 221.148 120.75 218.557L73 190.989V221.732L113.5 245.115C122.473 250.295 133.527 250.295 142.5 245.115L222.174 199.115C231.147 193.934 236.674 184.361 236.674 174V82C236.674 71.6393 231.147 62.0656 222.174 56.8853L142.5 10.8853C133.527 5.70491 122.473 5.70491 113.5 10.8853Z");
      add_location(path3, file45, 115, 4, 5348);
      attr_dev(path4, "d", "M80.0469 91.9426L120.75 68.4426C125.236 65.8525 130.764 65.8525 135.25 68.4426L175.953 91.9426C180.44 94.5328 183.203 99.3196 183.203 104.5V151.5C183.203 156.68 180.44 161.467 175.953 164.057L135.25 187.557C130.764 190.148 125.236 190.148 120.75 187.557L80.0469 164.057C75.5606 161.467 72.7969 156.68 72.7969 151.5V104.5C72.7969 99.3196 75.5606 94.5328 80.0469 91.9426ZM154.203 112.871L128 97.743L101.796 112.871V143.128L128 158.256L154.203 143.128V112.871Z");
      add_location(path4, file45, 116, 4, 6073);
      attr_dev(svg2, "width", "256");
      attr_dev(svg2, "height", "256");
      attr_dev(svg2, "viewBox", "0 0 256 256");
      attr_dev(svg2, "fill", "currentColor");
      attr_dev(svg2, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg2, file45, 114, 3, 5236);
      attr_dev(a7, "href", "https://perfectthings.dev");
      attr_dev(a7, "title", "PerfectThings website");
      attr_dev(a7, "class", "pt");
      add_location(a7, file45, 113, 2, 5155);
      attr_dev(div4, "class", "footer-links");
      add_location(div4, file45, 101, 1, 3264);
      attr_dev(div5, "class", "sticky-block");
      add_location(div5, file45, 92, 0, 2878);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div0, anchor);
      append_dev(div0, a0);
      append_dev(a0, img);
      append_dev(a0, t0);
      append_dev(a0, h1);
      append_dev(h1, span0);
      append_dev(h1, em0);
      append_dev(h1, sub);
      insert_dev(target, t5, anchor);
      insert_dev(target, p0, anchor);
      append_dev(p0, t6);
      append_dev(p0, em1);
      append_dev(p0, t8);
      append_dev(p0, a1);
      append_dev(p0, t10);
      insert_dev(target, t11, anchor);
      insert_dev(target, div1, anchor);
      append_dev(div1, h20);
      append_dev(div1, t13);
      append_dev(div1, h30);
      append_dev(div1, t15);
      append_dev(div1, pre0);
      append_dev(pre0, code0);
      append_dev(div1, t17);
      append_dev(div1, h31);
      append_dev(div1, t19);
      append_dev(div1, p1);
      append_dev(p1, t20);
      append_dev(p1, em2);
      append_dev(p1, t22);
      append_dev(p1, em3);
      append_dev(p1, t24);
      append_dev(p1, br0);
      append_dev(p1, t25);
      append_dev(p1, br1);
      append_dev(p1, t26);
      append_dev(p1, em4);
      append_dev(p1, t28);
      append_dev(p1, em5);
      append_dev(p1, t30);
      append_dev(p1, em6);
      append_dev(p1, t32);
      append_dev(div1, t33);
      append_dev(div1, pre1);
      append_dev(pre1, code1);
      append_dev(div1, t35);
      append_dev(div1, p2);
      append_dev(p2, i0);
      append_dev(p2, t37);
      append_dev(p2, em7);
      append_dev(p2, t39);
      append_dev(p2, em8);
      append_dev(div1, t41);
      append_dev(div1, h32);
      append_dev(div1, t43);
      append_dev(div1, p3);
      append_dev(p3, t44);
      append_dev(p3, i1);
      append_dev(p3, t46);
      append_dev(div1, t47);
      append_dev(div1, pre2);
      append_dev(pre2, code2);
      insert_dev(target, t49, anchor);
      insert_dev(target, div2, anchor);
      append_dev(div2, h21);
      append_dev(div2, t51);
      append_dev(div2, p4);
      append_dev(p4, t52);
      append_dev(p4, em9);
      append_dev(p4, t54);
      append_dev(div2, t55);
      append_dev(div2, h33);
      append_dev(div2, t57);
      append_dev(div2, p5);
      append_dev(p5, t58);
      append_dev(p5, em10);
      append_dev(p5, t60);
      append_dev(p5, br2);
      append_dev(p5, t61);
      append_dev(p5, em11);
      append_dev(p5, t63);
      append_dev(div2, t64);
      append_dev(div2, pre3);
      append_dev(pre3, code3);
      append_dev(div2, t66);
      append_dev(div2, h34);
      append_dev(div2, t68);
      append_dev(div2, p6);
      append_dev(p6, t69);
      append_dev(p6, em12);
      append_dev(p6, t71);
      append_dev(p6, em13);
      append_dev(p6, t73);
      append_dev(p6, br3);
      append_dev(p6, t74);
      append_dev(p6, em14);
      append_dev(p6, t76);
      append_dev(p6, em15);
      append_dev(p6, t78);
      append_dev(p6, em16);
      append_dev(p6, t80);
      append_dev(div2, t81);
      append_dev(div2, pre4);
      append_dev(pre4, code4);
      append_dev(div2, t83);
      append_dev(div2, p7);
      insert_dev(target, t85, anchor);
      insert_dev(target, div3, anchor);
      append_dev(div3, h22);
      append_dev(div3, t87);
      append_dev(div3, p8);
      append_dev(div3, t89);
      append_dev(div3, pre5);
      append_dev(pre5, code5);
      append_dev(div3, t91);
      append_dev(div3, p9);
      insert_dev(target, t93, anchor);
      insert_dev(target, div5, anchor);
      append_dev(div5, h23);
      append_dev(div5, t95);
      append_dev(div5, ul);
      append_dev(ul, li0);
      append_dev(li0, a2);
      append_dev(li0, t97);
      append_dev(ul, li1);
      append_dev(li1, t98);
      append_dev(li1, a3);
      append_dev(li1, t100);
      append_dev(ul, li2);
      append_dev(li2, span1);
      append_dev(li2, t102);
      append_dev(li2, a4);
      append_dev(div5, t104);
      append_dev(div5, div4);
      append_dev(div4, a5);
      append_dev(a5, svg0);
      append_dev(svg0, path0);
      append_dev(div4, t105);
      append_dev(div4, a6);
      append_dev(a6, svg1);
      append_dev(svg1, path1);
      append_dev(svg1, path2);
      append_dev(div4, t106);
      append_dev(div4, a7);
      append_dev(a7, svg2);
      append_dev(svg2, path3);
      append_dev(svg2, path4);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div0);
        detach_dev(t5);
        detach_dev(p0);
        detach_dev(t11);
        detach_dev(div1);
        detach_dev(t49);
        detach_dev(div2);
        detach_dev(t85);
        detach_dev(div3);
        detach_dev(t93);
        detach_dev(div5);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self2, $$props2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Start", slots2, []);
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Start> was created with unknown prop '${key}'`);
  });
  return [];
}
var Start = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment52, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Start",
      options,
      id: create_fragment52.name
    });
  }
};
var start_default = Start;

// docs-src/pages/changelog.svelte
var file46 = "docs-src/pages/changelog.svelte";
function create_fragment53(ctx) {
  let h1;
  let t1;
  let h20;
  let t2;
  let em0;
  let t4;
  let ul0;
  let li0;
  let t5;
  let code0;
  let t7;
  let t8;
  let h21;
  let t9;
  let em1;
  let t11;
  let ul1;
  let li1;
  let t12;
  let code1;
  let t14;
  let t15;
  let li2;
  let t17;
  let li3;
  let t18;
  let code2;
  let t20;
  let t21;
  let h22;
  let t22;
  let em2;
  let t24;
  let ul2;
  let li4;
  let t25;
  let code3;
  let t27;
  let code4;
  let t29;
  let t30;
  let li5;
  let t32;
  let h23;
  let t33;
  let em3;
  let t35;
  let ul3;
  let li6;
  let t36;
  let code5;
  let t38;
  let t39;
  let li7;
  let t40;
  let code6;
  let t42;
  let t43;
  let li8;
  let t45;
  let li9;
  let t47;
  let h24;
  let t48;
  let em4;
  let t50;
  let ul4;
  let li10;
  let t51;
  let code7;
  let t53;
  let code8;
  let t55;
  let t56;
  let li11;
  let t58;
  let li12;
  let t59;
  let code9;
  let t61;
  let code10;
  let t63;
  let code11;
  let t65;
  let code12;
  let t67;
  let t68;
  let li13;
  let t69;
  let code13;
  let t71;
  let code14;
  let t73;
  let t74;
  let li14;
  let t75;
  let code15;
  let t77;
  let t78;
  let li15;
  let t79;
  let code16;
  let t81;
  let code17;
  let t83;
  let code18;
  let t85;
  let t86;
  let h25;
  let t87;
  let em5;
  let t89;
  let ul5;
  let li16;
  let t90;
  let code19;
  let t92;
  let t93;
  let li17;
  let t95;
  let h26;
  let t96;
  let em6;
  let t98;
  let ul6;
  let li18;
  let t100;
  let h27;
  let t101;
  let em7;
  let t103;
  let ul7;
  let li19;
  let t105;
  let h28;
  let t106;
  let em8;
  let t108;
  let ul8;
  let li20;
  let t109;
  let code20;
  let t111;
  let code21;
  let t113;
  let t114;
  let h29;
  let t115;
  let em9;
  let t117;
  let ul9;
  let li21;
  let code22;
  let t119;
  let t120;
  let li22;
  let code23;
  let t122;
  let t123;
  let h210;
  let t124;
  let em10;
  let t126;
  let ul10;
  let li23;
  let t127;
  let code24;
  let t129;
  let t130;
  let h211;
  let t131;
  let em11;
  let t133;
  let ul11;
  let li24;
  let t135;
  let li25;
  let t136;
  let code25;
  let t138;
  let code26;
  let t140;
  let t141;
  let h212;
  let t142;
  let em12;
  let t144;
  let ul12;
  let li26;
  let t145;
  let code27;
  let t147;
  let t148;
  let h213;
  let t149;
  let em13;
  let t151;
  let ul13;
  let li27;
  let t152;
  let code28;
  let t154;
  let t155;
  let li28;
  let t156;
  let code29;
  let t158;
  let t159;
  let h214;
  let t160;
  let em14;
  let t162;
  let ul14;
  let li29;
  let t163;
  let code30;
  let t165;
  let t166;
  let li30;
  let t167;
  let code31;
  let t169;
  let code32;
  let t171;
  let code33;
  let t173;
  let t174;
  let h215;
  let t175;
  let em15;
  let t177;
  let ul15;
  let li31;
  let t178;
  let code34;
  let t180;
  let code35;
  let t182;
  let t183;
  let h216;
  let t184;
  let em16;
  let t186;
  let ul16;
  let li32;
  let t187;
  let code36;
  let t189;
  let code37;
  let t191;
  let t192;
  let h217;
  let t193;
  let em17;
  let t195;
  let ul17;
  let li33;
  let t196;
  let code38;
  let t198;
  let code39;
  let t200;
  let t201;
  let h218;
  let t202;
  let em18;
  let t204;
  let ul18;
  let li34;
  let t205;
  let code40;
  let t207;
  let t208;
  let li35;
  let t209;
  let code41;
  let t211;
  let code42;
  let t213;
  let code43;
  let t215;
  let t216;
  let h219;
  let t217;
  let em19;
  let t219;
  let ul19;
  let li36;
  let t220;
  let code44;
  let t222;
  let t223;
  let li37;
  let t224;
  let code45;
  let t226;
  let t227;
  let h220;
  let t228;
  let em20;
  let t230;
  let ul20;
  let li38;
  let code46;
  let t232;
  let t233;
  let li39;
  let t234;
  let code47;
  let t236;
  let t237;
  let li40;
  let t239;
  let h221;
  let t240;
  let em21;
  let t242;
  let ul21;
  let li41;
  let t243;
  let code48;
  let t245;
  let t246;
  let h222;
  let t247;
  let em22;
  let t249;
  let ul22;
  let li42;
  let t250;
  let code49;
  let t252;
  let t253;
  let h223;
  let t254;
  let em23;
  let t256;
  let ul23;
  let li43;
  let code50;
  let t258;
  let code51;
  let t260;
  let t261;
  let h224;
  let t262;
  let em24;
  let t264;
  let ul24;
  let li44;
  let t265;
  let code52;
  let t267;
  let t268;
  let h225;
  let t269;
  let em25;
  let t271;
  let ul25;
  let li45;
  let t272;
  let code53;
  let t274;
  let code54;
  let t276;
  let code55;
  let t278;
  let code56;
  let t280;
  let t281;
  let li46;
  let t282;
  let code57;
  let t284;
  let code58;
  let t286;
  let t287;
  let li47;
  let t288;
  let code59;
  let t290;
  let code60;
  let t292;
  let t293;
  let li48;
  let t294;
  let code61;
  let t296;
  let t297;
  let li49;
  let t299;
  let h226;
  let t300;
  let em26;
  let t302;
  let ul26;
  let li50;
  let t303;
  let code62;
  let t305;
  let code63;
  let t307;
  let t308;
  let h227;
  let t309;
  let em27;
  let t311;
  let ul27;
  let li51;
  let t312;
  let code64;
  let t314;
  let code65;
  let t316;
  let t317;
  let li52;
  let t318;
  let code66;
  let t320;
  let t321;
  let li53;
  let t322;
  let code67;
  let t324;
  let t325;
  let h228;
  let t326;
  let em28;
  let t328;
  let ul28;
  let li54;
  let strong0;
  let t330;
  let code68;
  let t332;
  let t333;
  let li55;
  let code69;
  let t335;
  let t336;
  let li56;
  let code70;
  let t338;
  let t339;
  let li57;
  let t340;
  let code71;
  let t342;
  let code72;
  let t344;
  let t345;
  let li58;
  let t347;
  let li59;
  let t349;
  let li60;
  let t350;
  let code73;
  let t352;
  let t353;
  let li61;
  let t354;
  let code74;
  let t356;
  let t357;
  let h30;
  let t359;
  let ul29;
  let li62;
  let t360;
  let code75;
  let t362;
  let code76;
  let t364;
  let em29;
  let t366;
  let em30;
  let t368;
  let em31;
  let t370;
  let code77;
  let t372;
  let t373;
  let li63;
  let code78;
  let t375;
  let code79;
  let t377;
  let code80;
  let t379;
  let code81;
  let t381;
  let code82;
  let t383;
  let t384;
  let hr0;
  let t385;
  let h229;
  let t386;
  let em32;
  let t388;
  let ul30;
  let li64;
  let t389;
  let code83;
  let t391;
  let t392;
  let li65;
  let t393;
  let code84;
  let t395;
  let t396;
  let li66;
  let t397;
  let code85;
  let t399;
  let code86;
  let t401;
  let t402;
  let li67;
  let t404;
  let h230;
  let t405;
  let em33;
  let t407;
  let ul31;
  let li68;
  let t408;
  let code87;
  let t410;
  let t411;
  let h231;
  let t412;
  let em34;
  let t414;
  let ul32;
  let li69;
  let strong1;
  let t416;
  let code88;
  let t418;
  let code89;
  let t420;
  let code90;
  let t422;
  let t423;
  let li70;
  let t425;
  let li71;
  let t426;
  let code91;
  let t428;
  let code92;
  let t430;
  let t431;
  let h232;
  let t432;
  let em35;
  let t434;
  let ul33;
  let li72;
  let t435;
  let code93;
  let t437;
  let code94;
  let t439;
  let t440;
  let li73;
  let code95;
  let t442;
  let t443;
  let li74;
  let code96;
  let t445;
  let code97;
  let t447;
  let t448;
  let h233;
  let t449;
  let em36;
  let t451;
  let ul34;
  let li75;
  let t452;
  let code98;
  let t454;
  let t455;
  let li76;
  let t456;
  let code99;
  let t458;
  let code100;
  let t460;
  let code101;
  let t462;
  let code102;
  let t464;
  let code103;
  let t466;
  let t467;
  let li77;
  let t468;
  let code104;
  let t470;
  let t471;
  let li78;
  let code105;
  let t473;
  let code106;
  let t475;
  let t476;
  let li79;
  let t477;
  let code107;
  let t479;
  let t480;
  let li80;
  let t481;
  let code108;
  let t483;
  let t484;
  let li81;
  let t485;
  let code109;
  let t487;
  let t488;
  let h234;
  let t489;
  let em37;
  let t491;
  let ul35;
  let li82;
  let t492;
  let code110;
  let t494;
  let code111;
  let t496;
  let t497;
  let li83;
  let t498;
  let code112;
  let t500;
  let code113;
  let t502;
  let t503;
  let li84;
  let t504;
  let code114;
  let t506;
  let t507;
  let li85;
  let t509;
  let li86;
  let t510;
  let code115;
  let t512;
  let code116;
  let t514;
  let code117;
  let t516;
  let t517;
  let li87;
  let t518;
  let code118;
  let t520;
  let t521;
  let li88;
  let t523;
  let li89;
  let t524;
  let code119;
  let t526;
  let code120;
  let t528;
  let t529;
  let h235;
  let t530;
  let em38;
  let t532;
  let ul36;
  let li90;
  let strong2;
  let t534;
  let code121;
  let t536;
  let code122;
  let t538;
  let t539;
  let li91;
  let t540;
  let code123;
  let t542;
  let t543;
  let h236;
  let t544;
  let em39;
  let t546;
  let ul37;
  let li92;
  let code124;
  let t548;
  let code125;
  let t550;
  let code126;
  let t552;
  let t553;
  let li93;
  let code127;
  let t555;
  let code128;
  let t557;
  let code129;
  let t559;
  let code130;
  let t561;
  let t562;
  let h237;
  let t563;
  let em40;
  let t565;
  let ul38;
  let li94;
  let t566;
  let code131;
  let t568;
  let t569;
  let li95;
  let t571;
  let h238;
  let t572;
  let em41;
  let t574;
  let ul39;
  let li96;
  let code132;
  let t576;
  let t577;
  let li97;
  let t578;
  let code133;
  let t580;
  let t581;
  let li98;
  let t583;
  let li99;
  let t585;
  let li100;
  let t587;
  let li101;
  let t588;
  let code134;
  let t590;
  let t591;
  let h239;
  let t592;
  let em42;
  let t594;
  let ul40;
  let li102;
  let t596;
  let li103;
  let t598;
  let h240;
  let t599;
  let em43;
  let t601;
  let ul41;
  let li104;
  let t602;
  let code135;
  let t604;
  let code136;
  let t606;
  let t607;
  let li105;
  let code137;
  let t609;
  let code138;
  let t611;
  let t612;
  let li106;
  let code139;
  let t614;
  let code140;
  let t616;
  let t617;
  let h241;
  let t618;
  let em44;
  let t620;
  let ul42;
  let li107;
  let strong3;
  let t622;
  let code141;
  let t624;
  let t625;
  let h242;
  let t626;
  let em45;
  let t628;
  let ul43;
  let li108;
  let strong4;
  let t630;
  let code142;
  let t632;
  let code143;
  let t634;
  let code144;
  let t636;
  let t637;
  let li109;
  let t639;
  let li110;
  let t641;
  let h243;
  let t642;
  let em46;
  let t644;
  let ul44;
  let li111;
  let strong5;
  let t646;
  let code145;
  let t648;
  let t649;
  let li112;
  let strong6;
  let t651;
  let code146;
  let t653;
  let code147;
  let t655;
  let t656;
  let li113;
  let strong7;
  let t658;
  let code148;
  let t660;
  let code149;
  let t662;
  let code150;
  let t664;
  let code151;
  let t666;
  let code152;
  let t668;
  let code153;
  let t670;
  let code154;
  let t672;
  let code155;
  let t674;
  let t675;
  let li114;
  let strong8;
  let t677;
  let code156;
  let t679;
  let code157;
  let t681;
  let code158;
  let t683;
  let code159;
  let t685;
  let t686;
  let li115;
  let t687;
  let code160;
  let t689;
  let code161;
  let t691;
  let t692;
  let li116;
  let t693;
  let code162;
  let t695;
  let code163;
  let t697;
  let t698;
  let li117;
  let t699;
  let code164;
  let t701;
  let code165;
  let t703;
  let t704;
  let li118;
  let t705;
  let code166;
  let t707;
  let code167;
  let t709;
  let t710;
  let h31;
  let t712;
  let ul45;
  let li119;
  let t714;
  let li120;
  let code168;
  let t716;
  let code169;
  let t718;
  let t719;
  let li121;
  let code170;
  let t721;
  let code171;
  let t723;
  let t724;
  let li122;
  let code172;
  let t726;
  let code173;
  let t728;
  let t729;
  let li123;
  let code174;
  let t731;
  let code175;
  let t733;
  let code176;
  let t735;
  let li124;
  let code177;
  let t737;
  let code178;
  let t739;
  let code179;
  let t741;
  let li125;
  let code180;
  let t743;
  let code181;
  let t745;
  let code182;
  let t747;
  let li126;
  let code183;
  let t749;
  let code184;
  let t751;
  let t752;
  let li127;
  let t753;
  let code185;
  let t755;
  let code186;
  let t757;
  let code187;
  let t759;
  let code188;
  let t761;
  let code189;
  let t763;
  let code190;
  let t765;
  let code191;
  let t767;
  let h32;
  let t769;
  let ul46;
  let li128;
  let code192;
  let t771;
  let code193;
  let t773;
  let li129;
  let code194;
  let t775;
  let code195;
  let t777;
  let li130;
  let code196;
  let t779;
  let code197;
  let t781;
  let li131;
  let code198;
  let t783;
  let code199;
  let t785;
  let li132;
  let code200;
  let t787;
  let code201;
  let t789;
  let li133;
  let code202;
  let t791;
  let code203;
  let t793;
  let li134;
  let code204;
  let t795;
  let code205;
  let t797;
  let p;
  let t798;
  let code206;
  let t800;
  let code207;
  let t802;
  let t803;
  let hr1;
  let t804;
  let h244;
  let t805;
  let em47;
  let t807;
  let ul47;
  let li135;
  let t808;
  let code208;
  let t810;
  let t811;
  let h245;
  let t812;
  let em48;
  let t814;
  let ul48;
  let li136;
  let t815;
  let code209;
  let t817;
  let t818;
  let h246;
  let t819;
  let em49;
  let t821;
  let ul49;
  let li137;
  let t822;
  let code210;
  let t824;
  let code211;
  let t826;
  let code212;
  let t828;
  let t829;
  let h247;
  let t830;
  let em50;
  let t832;
  let ul50;
  let li138;
  let t833;
  let code213;
  let t835;
  let code214;
  let t837;
  let t838;
  let li139;
  let t840;
  let h248;
  let t841;
  let em51;
  let t843;
  let ul51;
  let li140;
  let code215;
  let t845;
  let code216;
  let t847;
  let code217;
  let t849;
  let code218;
  let t851;
  let t852;
  let li141;
  let t854;
  let h249;
  let t855;
  let em52;
  let t857;
  let ul52;
  let li142;
  let strong9;
  let t859;
  let a0;
  let t861;
  let t862;
  let li143;
  let strong10;
  let t864;
  let a1;
  let t866;
  let a2;
  let t868;
  let a3;
  let t870;
  let t871;
  let li144;
  let strong11;
  let t873;
  let code219;
  let t875;
  let code220;
  let t877;
  let code221;
  let t879;
  let code222;
  let t881;
  let code223;
  let t883;
  let code224;
  let t885;
  let code225;
  let t887;
  let code226;
  let t889;
  let code227;
  let t891;
  let t892;
  let li145;
  let strong12;
  let t894;
  let code228;
  let t896;
  let code229;
  let t898;
  let t899;
  let h33;
  let t901;
  let h40;
  let t903;
  let ul53;
  let li146;
  let t904;
  let code230;
  let t906;
  let code231;
  let t908;
  let li147;
  let code232;
  let t910;
  let code233;
  let t912;
  let code234;
  let t914;
  let h41;
  let t916;
  let ul54;
  let li148;
  let t917;
  let code235;
  let t919;
  let code236;
  let t921;
  let h42;
  let t923;
  let ul55;
  let li149;
  let t924;
  let code237;
  let t926;
  let code238;
  let t928;
  let h43;
  let t930;
  let ul56;
  let li150;
  let t931;
  let code239;
  let t933;
  let code240;
  let t935;
  let h44;
  let t937;
  let ul57;
  let li151;
  let code241;
  let t939;
  let code242;
  let t941;
  let hr2;
  let t942;
  let h250;
  let t943;
  let em53;
  let t945;
  let ul58;
  let li152;
  let t946;
  let code243;
  let t948;
  let t949;
  let li153;
  let t950;
  let code244;
  let t952;
  let t953;
  let h251;
  let t954;
  let em54;
  let t956;
  let ul59;
  let li154;
  let strong13;
  let t958;
  let code245;
  let t960;
  let code246;
  let t962;
  let code247;
  let t964;
  let t965;
  let h252;
  let t966;
  let em55;
  let t968;
  let ul60;
  let li155;
  let t969;
  let code248;
  let t971;
  let t972;
  let h253;
  let t973;
  let em56;
  let t975;
  let ul62;
  let li156;
  let strong14;
  let t977;
  let code249;
  let t979;
  let code250;
  let t981;
  let t982;
  let li157;
  let code251;
  let t984;
  let strong15;
  let t986;
  let t987;
  let li162;
  let code252;
  let t989;
  let ul61;
  let li158;
  let t990;
  let code253;
  let t992;
  let code254;
  let t994;
  let t995;
  let li159;
  let t996;
  let code255;
  let t998;
  let t999;
  let li160;
  let t1000;
  let code256;
  let t1002;
  let code257;
  let t1004;
  let code258;
  let t1006;
  let t1007;
  let li161;
  let t1008;
  let code259;
  let t1010;
  let code260;
  let t1012;
  let t1013;
  let h254;
  let t1014;
  let em57;
  let t1016;
  let ul64;
  let li166;
  let code261;
  let t1018;
  let ul63;
  let li163;
  let code262;
  let t1020;
  let code263;
  let t1022;
  let t1023;
  let li164;
  let t1025;
  let li165;
  let t1026;
  let code264;
  let t1028;
  let code265;
  let t1030;
  let code266;
  let t1032;
  let code267;
  let t1034;
  let t1035;
  let h255;
  let t1036;
  let em58;
  let t1038;
  let ul66;
  let li170;
  let code268;
  let t1040;
  let ul65;
  let li167;
  let t1042;
  let li168;
  let t1043;
  let code269;
  let t1045;
  let t1046;
  let li169;
  let t1048;
  let h256;
  let t1049;
  let em59;
  let t1051;
  let ul67;
  let li171;
  let t1052;
  let code270;
  let t1054;
  let t1055;
  let h257;
  let t1056;
  let em60;
  let t1058;
  let ul68;
  let li172;
  let t1059;
  let code271;
  let t1061;
  let t1062;
  let li173;
  let code272;
  let t1064;
  let t1065;
  let h258;
  let t1066;
  let em61;
  let t1068;
  let ul69;
  let li174;
  let code273;
  let t1070;
  let t1071;
  let li175;
  let code274;
  let t1073;
  let t1074;
  let li176;
  let code275;
  let t1076;
  let code276;
  let t1078;
  let t1079;
  let h259;
  let t1080;
  let em62;
  let t1082;
  let ul70;
  let li177;
  let t1084;
  let li178;
  let t1086;
  let li179;
  let t1088;
  let li180;
  let t1089;
  let code277;
  let t1091;
  let code278;
  let t1093;
  let t1094;
  let h260;
  let t1095;
  let em63;
  let t1097;
  let ul71;
  let li181;
  let t1099;
  let h261;
  let t1100;
  let em64;
  let t1102;
  let ul72;
  let li182;
  let code279;
  let t1104;
  let code280;
  let t1106;
  let code281;
  let t1108;
  let t1109;
  let h262;
  let t1110;
  let em65;
  let t1112;
  let ul73;
  let li183;
  let t1114;
  let li184;
  let t1115;
  let code282;
  let t1117;
  let code283;
  let t1119;
  let code284;
  let t1121;
  let t1122;
  let li185;
  let t1124;
  let h263;
  let t1125;
  let em66;
  let t1127;
  let ul74;
  let li186;
  let t1128;
  let code285;
  let t1130;
  let t1131;
  let li187;
  let code286;
  let t1133;
  let t1134;
  let h264;
  let t1135;
  let em67;
  let t1137;
  let ul75;
  let li188;
  let t1139;
  let li189;
  let t1140;
  let code287;
  let t1142;
  let t1143;
  let li190;
  let t1144;
  let code288;
  let t1146;
  let t1147;
  let h265;
  let t1148;
  let em68;
  let t1150;
  let ul76;
  let li191;
  let t1152;
  let h266;
  let t1153;
  let em69;
  let t1155;
  let ul77;
  let li192;
  let t1156;
  let code289;
  let t1158;
  let code290;
  let t1160;
  let t1161;
  let li193;
  let t1162;
  let code291;
  let t1164;
  let t1165;
  let h267;
  let t1166;
  let em70;
  let t1168;
  let ul78;
  let li194;
  let code292;
  let t1170;
  let t1171;
  let li195;
  let t1172;
  let code293;
  let t1174;
  let t1175;
  let h268;
  let t1176;
  let em71;
  let t1178;
  let ul79;
  let li196;
  let t1180;
  let h269;
  let t1181;
  let em72;
  let t1183;
  let ul80;
  let li197;
  let code294;
  let t1185;
  let t1186;
  let li198;
  let code295;
  let t1188;
  let code296;
  let t1190;
  let t1191;
  let h270;
  let t1192;
  let em73;
  let t1194;
  let ul81;
  let li199;
  let t1196;
  let li200;
  let t1198;
  let li201;
  let t1200;
  let li202;
  let t1201;
  let code297;
  let t1203;
  let code298;
  let t1205;
  let code299;
  let t1207;
  let t1208;
  let li203;
  let t1209;
  let code300;
  let t1211;
  let code301;
  let t1213;
  let t1214;
  let h271;
  let t1215;
  let em74;
  let t1217;
  let ul82;
  let li204;
  let code302;
  let t1219;
  let code303;
  let t1221;
  let t1222;
  let li205;
  let code304;
  let t1224;
  let code305;
  let t1226;
  let code306;
  let t1228;
  let code307;
  let t1230;
  let t1231;
  let h272;
  let t1232;
  let em75;
  let t1234;
  let ul83;
  let li206;
  let code308;
  let t1236;
  let t1237;
  let li207;
  let code309;
  let t1239;
  let t1240;
  let h273;
  let t1241;
  let em76;
  let t1243;
  let ul84;
  let li208;
  let code310;
  let t1245;
  let t1246;
  let h274;
  let t1247;
  let em77;
  let t1249;
  let ul85;
  let li209;
  let t1250;
  let code311;
  let t1252;
  let t1253;
  let h275;
  let t1254;
  let em78;
  let t1256;
  let ul86;
  let li210;
  let t1257;
  let code312;
  let t1259;
  let t1260;
  let h276;
  let t1261;
  let em79;
  let t1263;
  let ul87;
  let li211;
  let t1264;
  let code313;
  let t1266;
  let t1267;
  let h277;
  let t1268;
  let em80;
  let t1270;
  let ul88;
  let li212;
  let t1272;
  let h278;
  let t1273;
  let em81;
  let t1275;
  let ul89;
  let li213;
  let t1276;
  let code314;
  let t1278;
  let t1279;
  let h279;
  let t1280;
  let em82;
  let t1282;
  let ul90;
  let li214;
  let t1283;
  let code315;
  let t1285;
  let code316;
  let t1287;
  let t1288;
  let h280;
  let t1289;
  let em83;
  let t1291;
  let ul91;
  let li215;
  let t1292;
  let a4;
  let t1294;
  let h281;
  let t1295;
  let em84;
  let t1297;
  let ul92;
  let li216;
  let t1298;
  let code317;
  let t1300;
  let t1301;
  let li217;
  let t1302;
  let code318;
  let t1304;
  let code319;
  let t1306;
  let code320;
  let t1308;
  let t1309;
  let h282;
  let t1310;
  let em85;
  let t1312;
  let ul93;
  let li218;
  let t1314;
  let h283;
  let t1315;
  let em86;
  let t1317;
  let ul94;
  let li219;
  let t1319;
  let h284;
  let t1320;
  let em87;
  let t1322;
  let ul95;
  let li220;
  let t1323;
  let code321;
  let t1325;
  let t1326;
  let li221;
  let t1328;
  let li222;
  let t1330;
  let li223;
  let t1332;
  let h285;
  let t1333;
  let em88;
  let t1335;
  let ul96;
  let li224;
  let t1336;
  let code322;
  let t1338;
  let t1339;
  let h286;
  let t1340;
  let em89;
  let t1342;
  let ul97;
  let li225;
  let code323;
  let t1344;
  let t1345;
  let h287;
  let t1346;
  let em90;
  let t1348;
  let ul98;
  let li226;
  let t1349;
  let code324;
  let t1351;
  let code325;
  let t1353;
  let hr3;
  let t1354;
  let h288;
  let t1355;
  let em91;
  let t1357;
  let ul99;
  let li227;
  let t1359;
  let li228;
  let t1361;
  let li229;
  let t1363;
  let h289;
  let t1364;
  let em92;
  let t1366;
  let ul100;
  let li230;
  let t1368;
  let h290;
  let t1369;
  let em93;
  let t1371;
  let ul101;
  let li231;
  let t1373;
  let h291;
  let t1374;
  let em94;
  let t1376;
  let ul102;
  let li232;
  let t1377;
  let code326;
  let t1379;
  let t1380;
  let h292;
  let t1381;
  let em95;
  let t1383;
  let ul103;
  let li233;
  let t1384;
  let code327;
  let t1386;
  let t1387;
  let h293;
  let t1388;
  let em96;
  let t1390;
  let ul104;
  let li234;
  let t1392;
  let li235;
  let t1394;
  let h294;
  let t1395;
  let em97;
  let t1397;
  let ul105;
  let li236;
  let t1399;
  let h295;
  let t1400;
  let em98;
  let t1402;
  let ul106;
  let li237;
  let t1404;
  let li238;
  let t1406;
  let h296;
  let t1407;
  let em99;
  let t1409;
  let ul107;
  let li239;
  let t1410;
  let code328;
  let t1412;
  let t1413;
  let h297;
  let t1414;
  let em100;
  let t1416;
  let ul108;
  let li240;
  let t1417;
  let code329;
  let t1419;
  let code330;
  let t1421;
  let code331;
  let t1423;
  let t1424;
  let li241;
  let t1425;
  let code332;
  let t1427;
  let t1428;
  let li242;
  let t1430;
  let li243;
  let t1432;
  let li244;
  let t1433;
  let code333;
  let t1435;
  let code334;
  let t1437;
  let t1438;
  let hr4;
  let t1439;
  let h298;
  let t1440;
  let em101;
  let t1442;
  let ul109;
  let li245;
  let t1443;
  let code335;
  let t1445;
  let code336;
  let t1447;
  let code337;
  let t1449;
  let code338;
  let t1451;
  let li246;
  let t1453;
  let hr5;
  let t1454;
  let h299;
  let t1455;
  let em102;
  let t1457;
  let ul110;
  let li247;
  let t1458;
  let code339;
  let t1460;
  let code340;
  let t1462;
  let t1463;
  let h2100;
  let t1464;
  let em103;
  let t1466;
  let ul111;
  let li248;
  let t1467;
  let code341;
  let t1469;
  let t1470;
  let li249;
  let t1471;
  let code342;
  let t1473;
  let t1474;
  let h2101;
  let t1475;
  let em104;
  let t1477;
  let ul112;
  let li250;
  let t1478;
  let code343;
  let t1480;
  let code344;
  let t1482;
  let t1483;
  let li251;
  let t1485;
  let li252;
  let t1487;
  let h2102;
  let t1488;
  let em105;
  let t1490;
  let ul113;
  let li253;
  let t1492;
  let h2103;
  let t1493;
  let em106;
  let t1495;
  let ul114;
  let li254;
  let t1496;
  let code345;
  let t1498;
  let code346;
  let t1500;
  let t1501;
  let li255;
  let t1502;
  let code347;
  let t1504;
  let t1505;
  let hr6;
  let t1506;
  let h2104;
  let t1507;
  let em107;
  let t1509;
  let ul115;
  let li256;
  let t1510;
  let code348;
  let t1512;
  let code349;
  let t1514;
  let t1515;
  let hr7;
  let t1516;
  let h2105;
  let t1517;
  let em108;
  const block = {
    c: function create() {
      h1 = element2("h1");
      h1.textContent = "Changelog";
      t1 = space();
      h20 = element2("h2");
      t2 = text("v9.5.3 ");
      em0 = element2("em");
      em0.textContent = "(2024-05-18)";
      t4 = space();
      ul0 = element2("ul");
      li0 = element2("li");
      t5 = text("Fix ");
      code0 = element2("code");
      code0.textContent = "Combobox";
      t7 = text(" issue for some edge cases.");
      t8 = space();
      h21 = element2("h2");
      t9 = text("v9.5.2 ");
      em1 = element2("em");
      em1.textContent = "(2024-05-15)";
      t11 = space();
      ul1 = element2("ul");
      li1 = element2("li");
      t12 = text("Fix ");
      code1 = element2("code");
      code1.textContent = "--ui-shadow-large";
      t14 = text(" in light-mode (was a bit too dark).");
      t15 = space();
      li2 = element2("li");
      li2.textContent = "Animation speed increased from 0.3 to 0.25s.";
      t17 = space();
      li3 = element2("li");
      t18 = text("Fix ");
      code2 = element2("code");
      code2.textContent = "Dialog";
      t20 = text("'s rendering artifacts in Safari.");
      t21 = space();
      h22 = element2("h2");
      t22 = text("v9.5.1, v9.5.0 ");
      em2 = element2("em");
      em2.textContent = "(2024-05-12)";
      t24 = space();
      ul2 = element2("ul");
      li4 = element2("li");
      t25 = text("New property for ");
      code3 = element2("code");
      code3.textContent = "Dialog";
      t27 = text(": ");
      code4 = element2("code");
      code4.textContent = "modal";
      t29 = text(".");
      t30 = space();
      li5 = element2("li");
      li5.textContent = "Fix square radiobuttons bug.";
      t32 = space();
      h23 = element2("h2");
      t33 = text("v9.4.21, v9.4.20 ");
      em3 = element2("em");
      em3.textContent = "(2024-05-11)";
      t35 = space();
      ul3 = element2("ul");
      li6 = element2("li");
      t36 = text("Fix ");
      code5 = element2("code");
      code5.textContent = "MenuItem";
      t38 = text(" descenders were 1px cropped when using some fonts.");
      t39 = space();
      li7 = element2("li");
      t40 = text("Fix active style in ");
      code6 = element2("code");
      code6.textContent = "ButtonToggle";
      t42 = text(" was showing despite the disabled attribute.");
      t43 = space();
      li8 = element2("li");
      li8.textContent = "Improve js & css linting and build process.";
      t45 = space();
      li9 = element2("li");
      li9.textContent = "Upgrade dependencies.";
      t47 = space();
      h24 = element2("h2");
      t48 = text("v9.4.19 ");
      em4 = element2("em");
      em4.textContent = "(2024-05-06)";
      t50 = space();
      ul4 = element2("ul");
      li10 = element2("li");
      t51 = text("Hide error on ");
      code7 = element2("code");
      code7.textContent = "InputPassword";
      t53 = text(" where ");
      code8 = element2("code");
      code8.textContent = "zxcvbn";
      t55 = text(" wasn't loaded.");
      t56 = space();
      li11 = element2("li");
      li11.textContent = "Correct icons' alignment.";
      t58 = space();
      li12 = element2("li");
      t59 = text("Renamed icons: ");
      code9 = element2("code");
      code9.textContent = "pluscircle";
      t61 = text(" to ");
      code10 = element2("code");
      code10.textContent = "plusCircle";
      t63 = text(" and ");
      code11 = element2("code");
      code11.textContent = "minuscircle";
      t65 = text(" to ");
      code12 = element2("code");
      code12.textContent = "minusCircle";
      t67 = text(".");
      t68 = space();
      li13 = element2("li");
      t69 = text("Fix ");
      code13 = element2("code");
      code13.textContent = "chartLine";
      t71 = text(" icon (there was ");
      code14 = element2("code");
      code14.textContent = "/>";
      t73 = text(" showing in the icon).");
      t74 = space();
      li14 = element2("li");
      t75 = text("Fix ");
      code15 = element2("code");
      code15.textContent = "InputPassword";
      t77 = text(" it was focusable when disabled.");
      t78 = space();
      li15 = element2("li");
      t79 = text("Fix ");
      code16 = element2("code");
      code16.textContent = "InputPassword";
      t81 = text(" incorrect layout when ");
      code17 = element2("code");
      code17.textContent = "strength";
      t83 = text(" and ");
      code18 = element2("code");
      code18.textContent = "labelOnTheLeft";
      t85 = text(" was set.");
      t86 = space();
      h25 = element2("h2");
      t87 = text("v9.4.18 ");
      em5 = element2("em");
      em5.textContent = "(2024-05-01)";
      t89 = space();
      ul5 = element2("ul");
      li16 = element2("li");
      t90 = text("Fix icon alignment in ");
      code19 = element2("code");
      code19.textContent = "Menu";
      t92 = text(".");
      t93 = space();
      li17 = element2("li");
      li17.textContent = "Fix tests to work with the latest version of svelte testing library.";
      t95 = space();
      h26 = element2("h2");
      t96 = text("v9.4.17 ");
      em6 = element2("em");
      em6.textContent = "(2024-04-14)";
      t98 = space();
      ul6 = element2("ul");
      li18 = element2("li");
      li18.textContent = "InputDate event handling race-condition fix (when enter was pressed).";
      t100 = space();
      h27 = element2("h2");
      t101 = text("v9.4.16 ");
      em7 = element2("em");
      em7.textContent = "(2024-04-13)";
      t103 = space();
      ul7 = element2("ul");
      li19 = element2("li");
      li19.textContent = "Maintenance release; updating dependencies.";
      t105 = space();
      h28 = element2("h2");
      t106 = text("v9.4.15, v9.4.14 ");
      em8 = element2("em");
      em8.textContent = "(2024-02-03)";
      t108 = space();
      ul8 = element2("ul");
      li20 = element2("li");
      t109 = text("Fix ");
      code20 = element2("code");
      code20.textContent = "InputDate";
      t111 = text("'s value setting on ");
      code21 = element2("code");
      code21.textContent = "Enter";
      t113 = text(", after input was emptied.");
      t114 = space();
      h29 = element2("h2");
      t115 = text("v9.4.13 ");
      em9 = element2("em");
      em9.textContent = "(2024-01-26)";
      t117 = space();
      ul9 = element2("ul");
      li21 = element2("li");
      code22 = element2("code");
      code22.textContent = "Dialog";
      t119 = text("'s backdrop style tweaks (add some effects to the backdrop).");
      t120 = space();
      li22 = element2("li");
      code23 = element2("code");
      code23.textContent = "Popover";
      t122 = text(" tip style tweaks (it's now offset using full pixels, so the tip's border will look consistently all around).");
      t123 = space();
      h210 = element2("h2");
      t124 = text("v9.4.12 ");
      em10 = element2("em");
      em10.textContent = "(2024-01-25)";
      t126 = space();
      ul10 = element2("ul");
      li23 = element2("li");
      t127 = text("Fix ");
      code24 = element2("code");
      code24.textContent = "InputRating";
      t129 = text(" - it would select value on mouse-down. This - where an error message was displayed above the input - would cause the error message to be removed, and input to slide up, which would unselect the value (while mouse was down), and cause the error message to reappear.");
      t130 = space();
      h211 = element2("h2");
      t131 = text("v9.4.11, v9.4.10, v9.4.9 ");
      em11 = element2("em");
      em11.textContent = "(2024-01-20)";
      t133 = space();
      ul11 = element2("ul");
      li24 = element2("li");
      li24.textContent = "Minor style tweaks (label-on-the-left alignment).";
      t135 = space();
      li25 = element2("li");
      t136 = text("Fix tip positioning when popups are not centered on targets (for ");
      code25 = element2("code");
      code25.textContent = "Tooltip";
      t138 = text(" and ");
      code26 = element2("code");
      code26.textContent = "Popover";
      t140 = text(").");
      t141 = space();
      h212 = element2("h2");
      t142 = text("v9.4.8 ");
      em12 = element2("em");
      em12.textContent = "(2024-01-19)";
      t144 = space();
      ul12 = element2("ul");
      li26 = element2("li");
      t145 = text("Style tweak: reduce margin around ");
      code27 = element2("code");
      code27.textContent = "Radio";
      t147 = text(" items.");
      t148 = space();
      h213 = element2("h2");
      t149 = text("v9.4.7 ");
      em13 = element2("em");
      em13.textContent = "(2024-01-17)";
      t151 = space();
      ul13 = element2("ul");
      li27 = element2("li");
      t152 = text("Fix ");
      code28 = element2("code");
      code28.textContent = "Range";
      t154 = text(" - knob alignment in Safari is off.");
      t155 = space();
      li28 = element2("li");
      t156 = text("Fix ");
      code29 = element2("code");
      code29.textContent = "Range";
      t158 = text(" - clicking on ticks should set the value.");
      t159 = space();
      h214 = element2("h2");
      t160 = text("v9.4.6, v9.4.5, v9.4.4, v9.4.3 ");
      em14 = element2("em");
      em14.textContent = "(2024-01-14)";
      t162 = space();
      ul14 = element2("ul");
      li29 = element2("li");
      t163 = text("More bugfixes, tests and some optimisations of the ");
      code30 = element2("code");
      code30.textContent = "Combobox";
      t165 = text(" component.");
      t166 = space();
      li30 = element2("li");
      t167 = text("Fix to allow to clear the value of the ");
      code31 = element2("code");
      code31.textContent = "Combobox";
      t169 = text(" by setting its value to ");
      code32 = element2("code");
      code32.textContent = "null";
      t171 = text(" or ");
      code33 = element2("code");
      code33.textContent = "[]";
      t173 = text(".");
      t174 = space();
      h215 = element2("h2");
      t175 = text("v9.4.2 ");
      em15 = element2("em");
      em15.textContent = "(2024-01-10)";
      t177 = space();
      ul15 = element2("ul");
      li31 = element2("li");
      t178 = text("Minor bugfixes for ");
      code34 = element2("code");
      code34.textContent = "Popover";
      t180 = text(" and ");
      code35 = element2("code");
      code35.textContent = "Combobox";
      t182 = text(".");
      t183 = space();
      h216 = element2("h2");
      t184 = text("v9.4.1 ");
      em16 = element2("em");
      em16.textContent = "(2024-01-07)";
      t186 = space();
      ul16 = element2("ul");
      li32 = element2("li");
      t187 = text("Add ");
      code36 = element2("code");
      code36.textContent = "title";
      t189 = text(" attribute to the multiselect ");
      code37 = element2("code");
      code37.textContent = "Combobox";
      t191 = text(" input, so that when it's too long, the value can be read easily.");
      t192 = space();
      h217 = element2("h2");
      t193 = text("v9.4.0 ");
      em17 = element2("em");
      em17.textContent = "(2024-01-04)";
      t195 = space();
      ul17 = element2("ul");
      li33 = element2("li");
      t196 = text("Add ");
      code38 = element2("code");
      code38.textContent = "multiselect";
      t198 = text(" option to the ");
      code39 = element2("code");
      code39.textContent = "Combobox";
      t200 = text(".");
      t201 = space();
      h218 = element2("h2");
      t202 = text("v9.3.4, v9.3.3 ");
      em18 = element2("em");
      em18.textContent = "(2023-12-25)";
      t204 = space();
      ul18 = element2("ul");
      li34 = element2("li");
      t205 = text("Fix ");
      code40 = element2("code");
      code40.textContent = "InputDate";
      t207 = text(" when picker was not in sync with the input value.");
      t208 = space();
      li35 = element2("li");
      t209 = text("Better dropdown alignment for ");
      code41 = element2("code");
      code41.textContent = "Popover";
      t211 = text(" and ");
      code42 = element2("code");
      code42.textContent = "Menu";
      t213 = text(" onScroll (should work if scrolling other elements beside the ");
      code43 = element2("code");
      code43.textContent = "<body>";
      t215 = text(").");
      t216 = space();
      h219 = element2("h2");
      t217 = text("v9.3.2, v9.3.1 ");
      em19 = element2("em");
      em19.textContent = "(2023-12-17)";
      t219 = space();
      ul19 = element2("ul");
      li36 = element2("li");
      t220 = text("Add ");
      code44 = element2("code");
      code44.textContent = "$$restProps";
      t222 = text(" to some components, to allow passing through custom props.");
      t223 = space();
      li37 = element2("li");
      t224 = text("Fix ");
      code45 = element2("code");
      code45.textContent = "Range";
      t226 = text(" offset issue in chromium browsers.");
      t227 = space();
      h220 = element2("h2");
      t228 = text("v9.3.0, v9.2.4 ");
      em20 = element2("em");
      em20.textContent = "(2023-12-12)";
      t230 = space();
      ul20 = element2("ul");
      li38 = element2("li");
      code46 = element2("code");
      code46.textContent = "Panel";
      t232 = text(" types (color variations).");
      t233 = space();
      li39 = element2("li");
      t234 = text("New icons (");
      code47 = element2("code");
      code47.textContent = "print";
      t236 = text(").");
      t237 = space();
      li40 = element2("li");
      li40.textContent = "Icon optimisations.";
      t239 = space();
      h221 = element2("h2");
      t240 = text("v9.2.3 ");
      em21 = element2("em");
      em21.textContent = "(2023-11-10)";
      t242 = space();
      ul21 = element2("ul");
      li41 = element2("li");
      t243 = text("Fix ");
      code48 = element2("code");
      code48.textContent = "InputTag";
      t245 = text(".");
      t246 = space();
      h222 = element2("h2");
      t247 = text("v9.2.2 ");
      em22 = element2("em");
      em22.textContent = "(2023-10-15)";
      t249 = space();
      ul22 = element2("ul");
      li42 = element2("li");
      t250 = text("Change tooltip to ticks in ");
      code49 = element2("code");
      code49.textContent = "Range";
      t252 = text(" component, for better accessibility.");
      t253 = space();
      h223 = element2("h2");
      t254 = text("v9.2.1 ");
      em23 = element2("em");
      em23.textContent = "(2023-10-14)";
      t256 = space();
      ul23 = element2("ul");
      li43 = element2("li");
      code50 = element2("code");
      code50.textContent = "Tag";
      t258 = text(" should not be clickable (or focusable) by default. It can be made interactive by adding the new ");
      code51 = element2("code");
      code51.textContent = "clickable";
      t260 = text(" attribute.");
      t261 = space();
      h224 = element2("h2");
      t262 = text("v9.2.0 ");
      em24 = element2("em");
      em24.textContent = "(2023-10-13)";
      t264 = space();
      ul24 = element2("ul");
      li44 = element2("li");
      t265 = text("New component: ");
      code52 = element2("code");
      code52.textContent = "Range";
      t267 = text(".");
      t268 = space();
      h225 = element2("h2");
      t269 = text("v9.1.2, v9.1.1, v9.1.0 ");
      em25 = element2("em");
      em25.textContent = "(2023-09-27)";
      t271 = space();
      ul25 = element2("ul");
      li45 = element2("li");
      t272 = text("New components: ");
      code53 = element2("code");
      code53.textContent = "InputRating";
      t274 = text(", ");
      code54 = element2("code");
      code54.textContent = "Tag";
      t276 = text(", ");
      code55 = element2("code");
      code55.textContent = "InputTag";
      t278 = text(", ");
      code56 = element2("code");
      code56.textContent = "InputTime";
      t280 = text(".");
      t281 = space();
      li46 = element2("li");
      t282 = text("Add ");
      code57 = element2("code");
      code57.textContent = "hideTip";
      t284 = text(" and more, to ");
      code58 = element2("code");
      code58.textContent = "Popover";
      t286 = text(".");
      t287 = space();
      li47 = element2("li");
      t288 = text("Add ");
      code59 = element2("code");
      code59.textContent = "useNativeOnMobile";
      t290 = text(" to ");
      code60 = element2("code");
      code60.textContent = "InputDate";
      t292 = text(".");
      t293 = space();
      li48 = element2("li");
      t294 = text("Fix ");
      code61 = element2("code");
      code61.textContent = "Popover";
      t296 = text(" z-index (so that it shows over dialogs)");
      t297 = space();
      li49 = element2("li");
      li49.textContent = "Many other smaller bugfixes and improvements.";
      t299 = space();
      h226 = element2("h2");
      t300 = text("v9.0.5 ");
      em26 = element2("em");
      em26.textContent = "(2023-09-22)";
      t302 = space();
      ul26 = element2("ul");
      li50 = element2("li");
      t303 = text("Reduce ");
      code62 = element2("code");
      code62.textContent = "Dialog's";
      t305 = space();
      code63 = element2("code");
      code63.textContent = "z-index";
      t307 = text(" so that the popups from the dialog show up on top of it.");
      t308 = space();
      h227 = element2("h2");
      t309 = text("v9.0.4, v9.0.3, v9.0.2, v9.0.1 ");
      em27 = element2("em");
      em27.textContent = "(2023-09-16)";
      t311 = space();
      ul27 = element2("ul");
      li51 = element2("li");
      t312 = text("Make ");
      code64 = element2("code");
      code64.textContent = "title";
      t314 = text(" optional for ");
      code65 = element2("code");
      code65.textContent = "Panel";
      t316 = text(".");
      t317 = space();
      li52 = element2("li");
      t318 = text("Add ");
      code66 = element2("code");
      code66.textContent = "ANIMATION_SPEED";
      t320 = text(" to utils/properties.");
      t321 = space();
      li53 = element2("li");
      t322 = text("Correct ");
      code67 = element2("code");
      code67.textContent = "FOCUSABLE_SELECTOR";
      t324 = text(" (it's a constant, not a svelte store).");
      t325 = space();
      h228 = element2("h2");
      t326 = text("v9.0.0 ");
      em28 = element2("em");
      em28.textContent = "(2023-09-09)";
      t328 = space();
      ul28 = element2("ul");
      li54 = element2("li");
      strong0 = element2("strong");
      strong0.textContent = "New";
      t330 = text(": added ");
      code68 = element2("code");
      code68.textContent = "Utils";
      t332 = text(" page in the docs with APIs to the utility functions exposed by the library.");
      t333 = space();
      li55 = element2("li");
      code69 = element2("code");
      code69.textContent = "Tooltip";
      t335 = text(" was simplified and now the positioning ensures that the tooltip is always visible on the screen.");
      t336 = space();
      li56 = element2("li");
      code70 = element2("code");
      code70.textContent = "Popover";
      t338 = text(" will now update its position when the window is resized.");
      t339 = space();
      li57 = element2("li");
      t340 = text("The tip of the ");
      code71 = element2("code");
      code71.textContent = "Tooltip";
      t342 = text(" and ");
      code72 = element2("code");
      code72.textContent = "Popover";
      t344 = text(" will now try to be centered on the target element (if the box was offset from the screen edge).");
      t345 = space();
      li58 = element2("li");
      li58.textContent = "Improved keyboard focus for notifications: when a notification is dismissed from the keyboard (Escape) the focus will be moved to the next available notification.";
      t347 = space();
      li59 = element2("li");
      li59.textContent = "Improved & standardised z-index throughout the components.";
      t349 = space();
      li60 = element2("li");
      t350 = text("Tweaked ");
      code73 = element2("code");
      code73.textContent = "Menu";
      t352 = text(" positioning to update on window resize.");
      t353 = space();
      li61 = element2("li");
      t354 = text("Tweaked ");
      code74 = element2("code");
      code74.textContent = "MenuItem";
      t356 = text(" for responsiveness (e.g. add ellipsis if the text is too long).");
      t357 = space();
      h30 = element2("h3");
      h30.textContent = "Breaking changes";
      t359 = space();
      ul29 = element2("ul");
      li62 = element2("li");
      t360 = text("The ");
      code75 = element2("code");
      code75.textContent = "events";
      t362 = text(" property was dropped from the ");
      code76 = element2("code");
      code76.textContent = "Tooltip";
      t364 = text(", leaving ");
      em29 = element2("em");
      em29.textContent = "hover";
      t366 = text(" and ");
      em30 = element2("em");
      em30.textContent = "focus";
      t368 = text(" events as the default. For use cases when the ");
      em31 = element2("em");
      em31.textContent = "click";
      t370 = text(" was needed, ");
      code77 = element2("code");
      code77.textContent = "Popover";
      t372 = text(" should be used instead.");
      t373 = space();
      li63 = element2("li");
      code78 = element2("code");
      code78.textContent = "z-index";
      t375 = text(" value of the ");
      code79 = element2("code");
      code79.textContent = "Popover";
      t377 = text(" and ");
      code80 = element2("code");
      code80.textContent = "Tooltip";
      t379 = text(" has been reduced from ");
      code81 = element2("code");
      code81.textContent = "9999";
      t381 = text(" to ");
      code82 = element2("code");
      code82.textContent = "99";
      t383 = text(", so that it's closer to the content it describes. Ideally tooltips should slide under some other floating elements of the UI (like toolbars or drawers), while remaining above the content layer. This can be o overriden in the app's own css if needed.");
      t384 = space();
      hr0 = element2("hr");
      t385 = space();
      h229 = element2("h2");
      t386 = text("v8.4.5, v8.4.4 ");
      em32 = element2("em");
      em32.textContent = "(2023-08-26)";
      t388 = space();
      ul30 = element2("ul");
      li64 = element2("li");
      t389 = text("Standardise ");
      code83 = element2("code");
      code83.textContent = "InputSearch";
      t391 = text(" UX: clear button and Escape-to-clear behaviour now works the same in different browsers.");
      t392 = space();
      li65 = element2("li");
      t393 = text("Enhance ");
      code84 = element2("code");
      code84.textContent = "Popover";
      t395 = text(" so that it updates its position after it detects a content change.");
      t396 = space();
      li66 = element2("li");
      t397 = text("Expose ");
      code85 = element2("code");
      code85.textContent = "Popover";
      t399 = text("'s ");
      code86 = element2("code");
      code86.textContent = "updatePosition";
      t401 = text(" function.");
      t402 = space();
      li67 = element2("li");
      li67.textContent = "Tweak the dropdown-align function for popover.";
      t404 = space();
      h230 = element2("h2");
      t405 = text("v8.4.3 ");
      em33 = element2("em");
      em33.textContent = "(2023-08-25)";
      t407 = space();
      ul31 = element2("ul");
      li68 = element2("li");
      t408 = text("Fix ");
      code87 = element2("code");
      code87.textContent = "InputRadio";
      t410 = text(" group block padding.");
      t411 = space();
      h231 = element2("h2");
      t412 = text("v8.4.2, v8.4.1, v8.4.0 ");
      em34 = element2("em");
      em34.textContent = "(2023-08-24)";
      t414 = space();
      ul32 = element2("ul");
      li69 = element2("li");
      strong1 = element2("strong");
      strong1.textContent = "New:";
      t416 = space();
      code88 = element2("code");
      code88.textContent = "Popover";
      t418 = text(" component. If a ");
      code89 = element2("code");
      code89.textContent = "Dialog";
      t420 = text(" and ");
      code90 = element2("code");
      code90.textContent = "Tooltip";
      t422 = text(" had a child - this would be it. It's a container that can be opened like a dialog, but will be attached to the target element (like a tooltip). It's a great way to display additional information or actions for a specific element on the page. It can contain other components (e.g. buttons) and can serve as a free-form menu.");
      t423 = space();
      li70 = element2("li");
      li70.textContent = "Fix popover above the target styling.";
      t425 = space();
      li71 = element2("li");
      t426 = text("Simplify & refactor ");
      code91 = element2("code");
      code91.textContent = "Tooltip";
      t428 = text(" to share more code with ");
      code92 = element2("code");
      code92.textContent = "Popover";
      t430 = text(". Styling and core functionality is now almost the same, while the UX and usage remains a bit different.");
      t431 = space();
      h232 = element2("h2");
      t432 = text("v8.3.3 ");
      em35 = element2("em");
      em35.textContent = "(2023-08-19)";
      t434 = space();
      ul33 = element2("ul");
      li72 = element2("li");
      t435 = text("Inputs with dropdowns (e.g. ");
      code93 = element2("code");
      code93.textContent = "Combobox";
      t437 = text(" and ");
      code94 = element2("code");
      code94.textContent = "InputDate";
      t439 = text(") will not trigger page scroll on focus (in mobile Safari).");
      t440 = space();
      li73 = element2("li");
      code95 = element2("code");
      code95.textContent = "Combobox";
      t442 = text(" dropdown will now auto-adjust its position when the virtual keyboard opens (in mobile Safari).");
      t443 = space();
      li74 = element2("li");
      code96 = element2("code");
      code96.textContent = ":focus";
      t445 = text(" has been updated to ");
      code97 = element2("code");
      code97.textContent = ":focus-visible";
      t447 = text(" for non-input elements, for a better look.");
      t448 = space();
      h233 = element2("h2");
      t449 = text("v8.3.2 ");
      em36 = element2("em");
      em36.textContent = "(2023-08-18)";
      t451 = space();
      ul34 = element2("ul");
      li75 = element2("li");
      t452 = text("Improve ");
      code98 = element2("code");
      code98.textContent = "InputRadio";
      t454 = text(" styling to look more like the rest of the inputs (e.g. checkbox).");
      t455 = space();
      li76 = element2("li");
      t456 = text("Standardise font sizes into css variables: ");
      code99 = element2("code");
      code99.textContent = "--ui-font-xs";
      t458 = text("=14px, ");
      code100 = element2("code");
      code100.textContent = "--ui-font-s";
      t460 = text("=15px, ");
      code101 = element2("code");
      code101.textContent = "--ui-font-m";
      t462 = text("=16px, ");
      code102 = element2("code");
      code102.textContent = "--ui-font-l";
      t464 = text("=17px, ");
      code103 = element2("code");
      code103.textContent = "--ui-font-xl";
      t466 = text("=22px");
      t467 = space();
      li77 = element2("li");
      t468 = text("Correct the symbol for Return (\u23CE) in ");
      code104 = element2("code");
      code104.textContent = "Menu";
      t470 = text(".");
      t471 = space();
      li78 = element2("li");
      code105 = element2("code");
      code105.textContent = "Menu";
      t473 = text(" can now be centered with the target button (using ");
      code106 = element2("code");
      code106.textContent = "align";
      t475 = text(" attribute).");
      t476 = space();
      li79 = element2("li");
      t477 = text("Context ");
      code107 = element2("code");
      code107.textContent = "Menu";
      t479 = text(" will now open above the long-pressed spot on mobile (by default).");
      t480 = space();
      li80 = element2("li");
      t481 = text("Pressing the same letter key, with the ");
      code108 = element2("code");
      code108.textContent = "Menu";
      t483 = text(" open will now cycle through the items starting with that letter.");
      t484 = space();
      li81 = element2("li");
      t485 = text("Pressing space with the ");
      code109 = element2("code");
      code109.textContent = "Menu";
      t487 = text(" open, while typing something quickly, will not trigger the click event on the currently selected item. This allows to type-to-highlight elements that contain space in the text. Pressing space standalone (while not typing), will trigger the click event.");
      t488 = space();
      h234 = element2("h2");
      t489 = text("v8.3.1 ");
      em37 = element2("em");
      em37.textContent = "(2023-08-14)";
      t491 = space();
      ul35 = element2("ul");
      li82 = element2("li");
      t492 = text("Removed ");
      code110 = element2("code");
      code110.textContent = "--ui-margin-xl";
      t494 = text(" and ");
      code111 = element2("code");
      code111.textContent = "--ui-margin-xxl";
      t496 = text(" as they were not used.");
      t497 = space();
      li83 = element2("li");
      t498 = text("Merged ");
      code112 = element2("code");
      code112.textContent = "--ui-border-radius-s";
      t500 = text(" with ");
      code113 = element2("code");
      code113.textContent = "--ui-border-radius";
      t502 = text(" and changed to a rem value that calculates to the whole pixel (so that browsers would render it better).");
      t503 = space();
      li84 = element2("li");
      t504 = text("Fixed the ");
      code114 = element2("code");
      code114.textContent = "NotificationCenter";
      t506 = text(" issue, where toasts would not close if navigated away from the page that initialises the component.");
      t507 = space();
      li85 = element2("li");
      li85.textContent = "Tweaked dialog border-radius to render a bit better (for dialog's header and footer).";
      t509 = space();
      li86 = element2("li");
      t510 = text("Aligned components heights (");
      code115 = element2("code");
      code115.textContent = "Menu";
      t512 = text(", ");
      code116 = element2("code");
      code116.textContent = "Combobox";
      t514 = text(", and ");
      code117 = element2("code");
      code117.textContent = "InputRadio";
      t516 = text(" items).");
      t517 = space();
      li87 = element2("li");
      t518 = text("Fixed ");
      code118 = element2("code");
      code118.textContent = "Menu";
      t520 = text("'s longpress event to not triger when moving the finger (touchmove should stop longpress).");
      t521 = space();
      li88 = element2("li");
      li88.textContent = "Improve navigation swipe event (swiping can now be triggered by any element that is not scrollable and has no scrollable ancestors).";
      t523 = space();
      li89 = element2("li");
      t524 = text("Increased ");
      code119 = element2("code");
      code119.textContent = "Menu";
      t526 = text(" font size slightly, while decreasing it for everything (102% -> 100% on ");
      code120 = element2("code");
      code120.textContent = "body";
      t528 = text(").");
      t529 = space();
      h235 = element2("h2");
      t530 = text("v8.3.0 ");
      em38 = element2("em");
      em38.textContent = "(2023-08-11)";
      t532 = space();
      ul36 = element2("ul");
      li90 = element2("li");
      strong2 = element2("strong");
      strong2.textContent = "New:";
      t534 = space();
      code121 = element2("code");
      code121.textContent = "InputSearch";
      t536 = text(" component. Not much more than ");
      code122 = element2("code");
      code122.textContent = "InputText";
      t538 = text(", except the search icon and (depending on the browser) - the clear button.");
      t539 = space();
      li91 = element2("li");
      t540 = text("Fixed a weird and edge-case issue with ");
      code123 = element2("code");
      code123.textContent = "Menu";
      t542 = text(" on mobile Safari (#119).");
      t543 = space();
      h236 = element2("h2");
      t544 = text("v8.2.0 ");
      em39 = element2("em");
      em39.textContent = "(2023-08-08)";
      t546 = space();
      ul37 = element2("ul");
      li92 = element2("li");
      code124 = element2("code");
      code124.textContent = "data";
      t548 = text(" attribute in ");
      code125 = element2("code");
      code125.textContent = "Combobox";
      t550 = text(" is deprecated. It will be removed in the next major version. Use ");
      code126 = element2("code");
      code126.textContent = "items";
      t552 = text(" instead.");
      t553 = space();
      li93 = element2("li");
      code127 = element2("code");
      code127.textContent = "Combobox";
      t555 = text(" and ");
      code128 = element2("code");
      code128.textContent = "Menu";
      t557 = text(" now use the same align function (for consistency and performance) and there's no need to add ");
      code129 = element2("code");
      code129.textContent = "elevate";
      t559 = text(" attribute to either of them, as both popups are rendered inside the ");
      code130 = element2("code");
      code130.textContent = "body";
      t561 = text(" element and are only added to the DOM, when they are opened (to avoid polluting the DOM with unnecessary elements).");
      t562 = space();
      h237 = element2("h2");
      t563 = text("v8.1.4 ");
      em40 = element2("em");
      em40.textContent = "(2023-07-31)";
      t565 = space();
      ul38 = element2("ul");
      li94 = element2("li");
      t566 = text("Improved ");
      code131 = element2("code");
      code131.textContent = "PushButton";
      t568 = text(" pressed styling.");
      t569 = space();
      li95 = element2("li");
      li95.textContent = "Some buttons should now react faster on mobile (touch-action added to notification buttons and all inputs, selects and textareas).";
      t571 = space();
      h238 = element2("h2");
      t572 = text("v8.1.3 ");
      em41 = element2("em");
      em41.textContent = "(2023-07-30)";
      t574 = space();
      ul39 = element2("ul");
      li96 = element2("li");
      code132 = element2("code");
      code132.textContent = "PushButton";
      t576 = text(" now has better contrast (when pressed).");
      t577 = space();
      li97 = element2("li");
      t578 = text("Fixed ");
      code133 = element2("code");
      code133.textContent = "showMessage";
      t580 = text(" style for long messages on mobile.");
      t581 = space();
      li98 = element2("li");
      li98.textContent = "Fixed password strength popup style.";
      t583 = space();
      li99 = element2("li");
      li99.textContent = "Docs: fancy font should be applied do docs only, not to the components.";
      t585 = space();
      li100 = element2("li");
      li100.textContent = "Docs: try swipeRight on mobile to open sidebar.";
      t587 = space();
      li101 = element2("li");
      t588 = text("Added touch-action: manipulation to ");
      code134 = element2("code");
      code134.textContent = "Label";
      t590 = text(" and some other missing places.");
      t591 = space();
      h239 = element2("h2");
      t592 = text("v8.1.2 ");
      em42 = element2("em");
      em42.textContent = "(2023-07-29)";
      t594 = space();
      ul40 = element2("ul");
      li102 = element2("li");
      li102.textContent = "Small table style tweaks";
      t596 = space();
      li103 = element2("li");
      li103.textContent = "Docs improvements";
      t598 = space();
      h240 = element2("h2");
      t599 = text("v8.1.1 ");
      em43 = element2("em");
      em43.textContent = "(2023-07-28)";
      t601 = space();
      ul41 = element2("ul");
      li104 = element2("li");
      t602 = text("Bring back ");
      code135 = element2("code");
      code135.textContent = "--ui-color-accent-semi";
      t604 = text(" and ");
      code136 = element2("code");
      code136.textContent = "--ui-color-highlight-semi";
      t606 = text(" colors.");
      t607 = space();
      li105 = element2("li");
      code137 = element2("code");
      code137.textContent = "Combobox";
      t609 = text(" and ");
      code138 = element2("code");
      code138.textContent = "InputDate";
      t611 = text(" buttons should not be tabbable.");
      t612 = space();
      li106 = element2("li");
      code139 = element2("code");
      code139.textContent = "Combobox";
      t614 = text(" and ");
      code140 = element2("code");
      code140.textContent = "InputDate";
      t616 = text(" buttons should toggle the dropdown on click.");
      t617 = space();
      h241 = element2("h2");
      t618 = text("v8.1.0 ");
      em44 = element2("em");
      em44.textContent = "(2023-07-28)";
      t620 = space();
      ul42 = element2("ul");
      li107 = element2("li");
      strong3 = element2("strong");
      strong3.textContent = "New:";
      t622 = text(" All inputs have a new attribute ");
      code141 = element2("code");
      code141.textContent = "labelOnTheLeft";
      t624 = text(" which allows to move the label to the left of the input.");
      t625 = space();
      h242 = element2("h2");
      t626 = text("v8.0.1 ");
      em45 = element2("em");
      em45.textContent = "(2023-07-26)";
      t628 = space();
      ul43 = element2("ul");
      li108 = element2("li");
      strong4 = element2("strong");
      strong4.textContent = "New:";
      t630 = text(" Check the platform on load and add a ");
      code142 = element2("code");
      code142.textContent = "mobile";
      t632 = text(" or ");
      code143 = element2("code");
      code143.textContent = "desktop";
      t634 = text(" class to the ");
      code144 = element2("code");
      code144.textContent = "html";
      t636 = text(" element.");
      t637 = space();
      li109 = element2("li");
      li109.textContent = "Fixed: Menu separator is now aligned with menu items.";
      t639 = space();
      li110 = element2("li");
      li110.textContent = 'Fixed: Notifications Archive "Clear all" button is now back to normal.';
      t641 = space();
      h243 = element2("h2");
      t642 = text("v8.0.0 ");
      em46 = element2("em");
      em46.textContent = "(2023-07-25)";
      t644 = space();
      ul44 = element2("ul");
      li111 = element2("li");
      strong5 = element2("strong");
      strong5.textContent = "New:";
      t646 = space();
      code145 = element2("code");
      code145.textContent = "Label";
      t648 = text(" component.");
      t649 = space();
      li112 = element2("li");
      strong6 = element2("strong");
      strong6.textContent = "New icons:";
      t651 = space();
      code146 = element2("code");
      code146.textContent = "sun";
      t653 = text(" and ");
      code147 = element2("code");
      code147.textContent = "moon";
      t655 = text(" for the dark-theme switchers.");
      t656 = space();
      li113 = element2("li");
      strong7 = element2("strong");
      strong7.textContent = "Improvement:";
      t658 = space();
      code148 = element2("code");
      code148.textContent = "info";
      t660 = text(", ");
      code149 = element2("code");
      code149.textContent = "error";
      t662 = text(" and ");
      code150 = element2("code");
      code150.textContent = "label";
      t664 = text(" attributes are now supported on other inputs (");
      code151 = element2("code");
      code151.textContent = "Combobox";
      t666 = text(", ");
      code152 = element2("code");
      code152.textContent = "InputDate";
      t668 = text(", ");
      code153 = element2("code");
      code153.textContent = "Select";
      t670 = text(", ");
      code154 = element2("code");
      code154.textContent = "ButtonToggle";
      t672 = text(", and ");
      code155 = element2("code");
      code155.textContent = "Toggle";
      t674 = text(").");
      t675 = space();
      li114 = element2("li");
      strong8 = element2("strong");
      strong8.textContent = "Improvement:";
      t677 = text(" all components now expose ");
      code156 = element2("code");
      code156.textContent = "element";
      t679 = text(" and ");
      code157 = element2("code");
      code157.textContent = "inputElement";
      t681 = text(" (if there is one (and only one)). The exceptions are ");
      code158 = element2("code");
      code158.textContent = "NotificationCenter";
      t683 = text(" and ");
      code159 = element2("code");
      code159.textContent = "MessageBox";
      t685 = text(", due to their implementation.");
      t686 = space();
      li115 = element2("li");
      t687 = text("Added ");
      code160 = element2("code");
      code160.textContent = "title";
      t689 = text(" attribute to ");
      code161 = element2("code");
      code161.textContent = "ButtonToggle";
      t691 = text(".");
      t692 = space();
      li116 = element2("li");
      t693 = text("Added ");
      code162 = element2("code");
      code162.textContent = "success";
      t695 = text(" type for ");
      code163 = element2("code");
      code163.textContent = "MessageBox";
      t697 = text(".");
      t698 = space();
      li117 = element2("li");
      t699 = text("Fixed ");
      code164 = element2("code");
      code164.textContent = "selectable=false";
      t701 = text(" not working on ");
      code165 = element2("code");
      code165.textContent = "Table";
      t703 = text(".");
      t704 = space();
      li118 = element2("li");
      t705 = text("Improved styling for ");
      code166 = element2("code");
      code166.textContent = "Dialog";
      t707 = text(" and ");
      code167 = element2("code");
      code167.textContent = "MessageBox";
      t709 = text(".");
      t710 = space();
      h31 = element2("h3");
      h31.textContent = "Breaking changes";
      t712 = space();
      ul45 = element2("ul");
      li119 = element2("li");
      li119.textContent = "Color palette has been completely revamped for better accessibility (more contrast), consistency and simplicity (fewer colors and css variables).";
      t714 = space();
      li120 = element2("li");
      code168 = element2("code");
      code168.textContent = "Autocomplete";
      t716 = text(" has been renamed to ");
      code169 = element2("code");
      code169.textContent = "Combobox";
      t718 = text(" as this is what it really is.");
      t719 = space();
      li121 = element2("li");
      code170 = element2("code");
      code170.textContent = "Datepicker";
      t721 = text(" has been renamed to ");
      code171 = element2("code");
      code171.textContent = "InputDate";
      t723 = text(".");
      t724 = space();
      li122 = element2("li");
      code172 = element2("code");
      code172.textContent = "Toaster";
      t726 = text(" component has been removed. Use ");
      code173 = element2("code");
      code173.textContent = "NotificationCenter";
      t728 = text(" instead.");
      t729 = space();
      li123 = element2("li");
      code174 = element2("code");
      code174.textContent = "Select";
      t731 = text(" - HTML structure has changed: ");
      code175 = element2("code");
      code175.textContent = ".select-wrap select";
      t733 = text(" --> ");
      code176 = element2("code");
      code176.textContent = ".select .input-inner .input-row select";
      t735 = space();
      li124 = element2("li");
      code177 = element2("code");
      code177.textContent = "Table";
      t737 = text(" - CSS classes have changed from ");
      code178 = element2("code");
      code178.textContent = ".table-wrapper table.table";
      t739 = text(" --> ");
      code179 = element2("code");
      code179.textContent = ".table table";
      t741 = space();
      li125 = element2("li");
      code180 = element2("code");
      code180.textContent = "Toggle";
      t743 = text(" - HTML structure has changed from ");
      code181 = element2("code");
      code181.textContent = ".toggle .toggle-inner .toggle-scroller input";
      t745 = text(" --> ");
      code182 = element2("code");
      code182.textContent = ".toggle .toggle-inner .toggle-label .toggle-scroller input";
      t747 = space();
      li126 = element2("li");
      code183 = element2("code");
      code183.textContent = "drawBorders";
      t749 = text(" attribute has been removed from ");
      code184 = element2("code");
      code184.textContent = "Dialog";
      t751 = text(", while header and footer styling has been improved for all dialogs.");
      t752 = space();
      li127 = element2("li");
      t753 = text("These components previously exposed ");
      code185 = element2("code");
      code185.textContent = "_this";
      t755 = text(", which is now called ");
      code186 = element2("code");
      code186.textContent = "element";
      t757 = text(": ");
      code187 = element2("code");
      code187.textContent = "Button";
      t759 = text(", ");
      code188 = element2("code");
      code188.textContent = "Checkbox";
      t761 = text(", ");
      code189 = element2("code");
      code189.textContent = "InputMath";
      t763 = text(", ");
      code190 = element2("code");
      code190.textContent = "PushButton";
      t765 = text(", ");
      code191 = element2("code");
      code191.textContent = "Table";
      t767 = space();
      h32 = element2("h3");
      h32.textContent = "Color palette - mapping from v7 to v8 colors:";
      t769 = space();
      ul46 = element2("ul");
      li128 = element2("li");
      code192 = element2("code");
      code192.textContent = "--ui-color-text-dark-1";
      t771 = text(" --> ");
      code193 = element2("code");
      code193.textContent = "--ui-color-text-1";
      t773 = space();
      li129 = element2("li");
      code194 = element2("code");
      code194.textContent = "--ui-color-text-dark-2";
      t775 = text(" --> ");
      code195 = element2("code");
      code195.textContent = "--ui-color-text-2";
      t777 = space();
      li130 = element2("li");
      code196 = element2("code");
      code196.textContent = "--ui-color-border-dark-1";
      t779 = text(" --> ");
      code197 = element2("code");
      code197.textContent = "--ui-color-border-1";
      t781 = space();
      li131 = element2("li");
      code198 = element2("code");
      code198.textContent = "--ui-color-border-dark-2";
      t783 = text(" --> ");
      code199 = element2("code");
      code199.textContent = "--ui-color-border-2";
      t785 = space();
      li132 = element2("li");
      code200 = element2("code");
      code200.textContent = "--ui-color-background-light-2";
      t787 = text(" --> ");
      code201 = element2("code");
      code201.textContent = "--ui-color-background-1";
      t789 = space();
      li133 = element2("li");
      code202 = element2("code");
      code202.textContent = "--ui-color-background-dark-2";
      t791 = text(" --> ");
      code203 = element2("code");
      code203.textContent = "--ui-color-background-2";
      t793 = space();
      li134 = element2("li");
      code204 = element2("code");
      code204.textContent = "--ui-color-highlight-dark-2";
      t795 = text(" --> ");
      code205 = element2("code");
      code205.textContent = "--ui-color-highlight-1";
      t797 = space();
      p = element2("p");
      t798 = text("Other (not mentioned above) color variations, (i.e. ");
      code206 = element2("code");
      code206.textContent = "-light-";
      t800 = text(" and ");
      code207 = element2("code");
      code207.textContent = "-dark-";
      t802 = text(") have been removed.");
      t803 = space();
      hr1 = element2("hr");
      t804 = space();
      h244 = element2("h2");
      t805 = text("v7.1.2 ");
      em47 = element2("em");
      em47.textContent = "(2023-07-05)";
      t807 = space();
      ul47 = element2("ul");
      li135 = element2("li");
      t808 = text("Fix ");
      code208 = element2("code");
      code208.textContent = "Checkbox";
      t810 = text(" label (don't render empty label if no label attribute was passed).");
      t811 = space();
      h245 = element2("h2");
      t812 = text("v7.1.1 ");
      em48 = element2("em");
      em48.textContent = "(2023-07-01)";
      t814 = space();
      ul48 = element2("ul");
      li136 = element2("li");
      t815 = text("Fixed some ");
      code209 = element2("code");
      code209.textContent = "NotificationCenter";
      t817 = text(" bugs.");
      t818 = space();
      h246 = element2("h2");
      t819 = text("v7.1.0 ");
      em49 = element2("em");
      em49.textContent = "(2023-06-30)";
      t821 = space();
      ul49 = element2("ul");
      li137 = element2("li");
      t822 = text("Improve ");
      code210 = element2("code");
      code210.textContent = "Panel";
      t824 = text(" component with new properties: ");
      code211 = element2("code");
      code211.textContent = "collapsible";
      t826 = text(" (it's not collapsible by default), and ");
      code212 = element2("code");
      code212.textContent = "disabled";
      t828 = text(".");
      t829 = space();
      h247 = element2("h2");
      t830 = text("v7.0.2 ");
      em50 = element2("em");
      em50.textContent = "(2023-06-29)";
      t832 = space();
      ul50 = element2("ul");
      li138 = element2("li");
      t833 = text("Add ");
      code213 = element2("code");
      code213.textContent = "success";
      t835 = text(" to the ");
      code214 = element2("code");
      code214.textContent = "InfoBar";
      t837 = text(" component.");
      t838 = space();
      li139 = element2("li");
      li139.textContent = "Behind the scenes refactoring and improvements.";
      t840 = space();
      h248 = element2("h2");
      t841 = text("v7.0.1 ");
      em51 = element2("em");
      em51.textContent = "(2023-06-28)";
      t843 = space();
      ul51 = element2("ul");
      li140 = element2("li");
      code215 = element2("code");
      code215.textContent = "Textarea";
      t845 = text(" component now follows all basic inputs and support ");
      code216 = element2("code");
      code216.textContent = "error";
      t847 = text(", ");
      code217 = element2("code");
      code217.textContent = "info";
      t849 = text(", and ");
      code218 = element2("code");
      code218.textContent = "label";
      t851 = text(" properties.");
      t852 = space();
      li141 = element2("li");
      li141.textContent = "Notifications are now centered on mobile screen sizes.";
      t854 = space();
      h249 = element2("h2");
      t855 = text("v7.0.0 ");
      em52 = element2("em");
      em52.textContent = "(2023-06-28)";
      t857 = space();
      ul52 = element2("ul");
      li142 = element2("li");
      strong9 = element2("strong");
      strong9.textContent = "New:";
      t859 = space();
      a0 = element2("a");
      a0.textContent = "InfoBar";
      t861 = text(" component.");
      t862 = space();
      li143 = element2("li");
      strong10 = element2("strong");
      strong10.textContent = "New:";
      t864 = space();
      a1 = element2("a");
      a1.textContent = "InputText";
      t866 = text(", ");
      a2 = element2("a");
      a2.textContent = "InputNumber";
      t868 = text(", and ");
      a3 = element2("a");
      a3.textContent = "Radio";
      t870 = text(" components.");
      t871 = space();
      li144 = element2("li");
      strong11 = element2("strong");
      strong11.textContent = "New:";
      t873 = space();
      code219 = element2("code");
      code219.textContent = "info";
      t875 = text(", ");
      code220 = element2("code");
      code220.textContent = "error";
      t877 = text(" and ");
      code221 = element2("code");
      code221.textContent = "label";
      t879 = text(" attributes are now supported on all basic inputs (");
      code222 = element2("code");
      code222.textContent = "InputText";
      t881 = text(", ");
      code223 = element2("code");
      code223.textContent = "InputNumber";
      t883 = text(", ");
      code224 = element2("code");
      code224.textContent = "InputMath";
      t885 = text(", ");
      code225 = element2("code");
      code225.textContent = "InputPassword";
      t887 = text(", ");
      code226 = element2("code");
      code226.textContent = "Radio";
      t889 = text(", and ");
      code227 = element2("code");
      code227.textContent = "Checkbox";
      t891 = text(").");
      t892 = space();
      li145 = element2("li");
      strong12 = element2("strong");
      strong12.textContent = "Improved:";
      t894 = space();
      code228 = element2("code");
      code228.textContent = "InputMath";
      t896 = text(" component: support for ");
      code229 = element2("code");
      code229.textContent = "()";
      t898 = text(" characters, to allow for more complex expressions.");
      t899 = space();
      h33 = element2("h3");
      h33.textContent = "Breaking changes";
      t901 = space();
      h40 = element2("h4");
      h40.textContent = "Checkbox";
      t903 = space();
      ul53 = element2("ul");
      li146 = element2("li");
      t904 = text("HTML structure changed ");
      code230 = element2("code");
      code230.textContent = "input";
      t906 = text(" --> ");
      code231 = element2("code");
      code231.textContent = ".checkbox .checkbox-row input";
      t908 = space();
      li147 = element2("li");
      code232 = element2("code");
      code232.textContent = "on:change";
      t910 = text(" is called with a svelte event instead of the native one, so: ");
      code233 = element2("code");
      code233.textContent = "e.target.checked";
      t912 = text(" is now ");
      code234 = element2("code");
      code234.textContent = "e.detail.checked";
      t914 = space();
      h41 = element2("h4");
      h41.textContent = "InputMath";
      t916 = space();
      ul54 = element2("ul");
      li148 = element2("li");
      t917 = text("HTML structure changed ");
      code235 = element2("code");
      code235.textContent = ".input-math-wrapper input";
      t919 = text(" --> ");
      code236 = element2("code");
      code236.textContent = ".input-math .input-inner .input-math-row input";
      t921 = space();
      h42 = element2("h4");
      h42.textContent = "InputNumber:";
      t923 = space();
      ul55 = element2("ul");
      li149 = element2("li");
      t924 = text("HTML structure changed: ");
      code237 = element2("code");
      code237.textContent = "input";
      t926 = text(" --> ");
      code238 = element2("code");
      code238.textContent = ".input-number .input-inner input";
      t928 = space();
      h43 = element2("h4");
      h43.textContent = "InputPassword";
      t930 = space();
      ul56 = element2("ul");
      li150 = element2("li");
      t931 = text("HTML structure changed: ");
      code239 = element2("code");
      code239.textContent = ".input-password-wrapper .input-password-row input";
      t933 = text(" --> ");
      code240 = element2("code");
      code240.textContent = ".input-password .input-inner .input-password-row input";
      t935 = space();
      h44 = element2("h4");
      h44.textContent = "CSS variables changed:";
      t937 = space();
      ul57 = element2("ul");
      li151 = element2("li");
      code241 = element2("code");
      code241.textContent = "--ui-shadow-invalid";
      t939 = text(" --> ");
      code242 = element2("code");
      code242.textContent = "--ui-shadow-danger";
      t941 = space();
      hr2 = element2("hr");
      t942 = space();
      h250 = element2("h2");
      t943 = text("v6.8.2, v6.8.1 ");
      em53 = element2("em");
      em53.textContent = "(2023-06-21)";
      t945 = space();
      ul58 = element2("ul");
      li152 = element2("li");
      t946 = text("Allow HTML in ");
      code243 = element2("code");
      code243.textContent = "MessageBox";
      t948 = text(".");
      t949 = space();
      li153 = element2("li");
      t950 = text("Improve styling for multi-line messages in ");
      code244 = element2("code");
      code244.textContent = "MessageBox";
      t952 = text(".");
      t953 = space();
      h251 = element2("h2");
      t954 = text("v6.8.0 ");
      em54 = element2("em");
      em54.textContent = "(2023-06-17)";
      t956 = space();
      ul59 = element2("ul");
      li154 = element2("li");
      strong13 = element2("strong");
      strong13.textContent = "New:";
      t958 = space();
      code245 = element2("code");
      code245.textContent = "MessageBox";
      t960 = text(" component for displaying quick info/warning/error messages or confirmation dialogs (replacement for browser's native ");
      code246 = element2("code");
      code246.textContent = "alert";
      t962 = text(" and ");
      code247 = element2("code");
      code247.textContent = "confirm";
      t964 = text(").");
      t965 = space();
      h252 = element2("h2");
      t966 = text("v6.7.1 ");
      em55 = element2("em");
      em55.textContent = "(2023-06-13)";
      t968 = space();
      ul60 = element2("ul");
      li155 = element2("li");
      t969 = text("Fix ");
      code248 = element2("code");
      code248.textContent = "Menu";
      t971 = text(" show and hide events and clearing the highlight on mouse out.");
      t972 = space();
      h253 = element2("h2");
      t973 = text("v6.7.0 ");
      em56 = element2("em");
      em56.textContent = "(2023-06-13)";
      t975 = space();
      ul62 = element2("ul");
      li156 = element2("li");
      strong14 = element2("strong");
      strong14.textContent = "New:";
      t977 = space();
      code249 = element2("code");
      code249.textContent = "NotificationCenter";
      t979 = text(" component. This will eventually replace ");
      code250 = element2("code");
      code250.textContent = "Toaster";
      t981 = text(", as it's more accessible and powerful.");
      t982 = space();
      li157 = element2("li");
      code251 = element2("code");
      code251.textContent = "Toaster";
      t984 = text(" component is now ");
      strong15 = element2("strong");
      strong15.textContent = "deprecated";
      t986 = text(" and will be removed in the next major version.");
      t987 = space();
      li162 = element2("li");
      code252 = element2("code");
      code252.textContent = "PushButton";
      t989 = text(" changes:");
      ul61 = element2("ul");
      li158 = element2("li");
      t990 = text("remove ");
      code253 = element2("code");
      code253.textContent = "link";
      t992 = text(" and ");
      code254 = element2("code");
      code254.textContent = "text";
      t994 = text(" types, as they don't make sense (pushed state would not be visible).");
      t995 = space();
      li159 = element2("li");
      t996 = text("fix ");
      code255 = element2("code");
      code255.textContent = "outline";
      t998 = text(" type styling.");
      t999 = space();
      li160 = element2("li");
      t1000 = text("update the event passed to the ");
      code256 = element2("code");
      code256.textContent = "on:change";
      t1002 = text(" callback (rename property from ");
      code257 = element2("code");
      code257.textContent = "event.detail.value";
      t1004 = text(" to ");
      code258 = element2("code");
      code258.textContent = "event.detail.pressed";
      t1006 = text(").");
      t1007 = space();
      li161 = element2("li");
      t1008 = text("fix ");
      code259 = element2("code");
      code259.textContent = "PushButton";
      t1010 = text(" keyboard events (pressing Space or Enter would not trigger the ");
      code260 = element2("code");
      code260.textContent = "on:change";
      t1012 = text(" event).");
      t1013 = space();
      h254 = element2("h2");
      t1014 = text("v6.6.8 ");
      em57 = element2("em");
      em57.textContent = "(2023-06-07)";
      t1016 = space();
      ul64 = element2("ul");
      li166 = element2("li");
      code261 = element2("code");
      code261.textContent = "Menu";
      t1018 = text(" improvements:");
      ul63 = element2("ul");
      li163 = element2("li");
      code262 = element2("code");
      code262.textContent = "aria-expanded";
      t1020 = text(" attribute was incorrectly being added to the ");
      code263 = element2("code");
      code263.textContent = "body";
      t1022 = text(" on menu open (apart from the target button).");
      t1023 = space();
      li164 = element2("li");
      li164.textContent = "Tabbing does not move focus out of the menu anymore (it will cycle through the menu items).";
      t1025 = space();
      li165 = element2("li");
      t1026 = text("simplify html structure (");
      code264 = element2("code");
      code264.textContent = "ul";
      t1028 = text(" -> ");
      code265 = element2("code");
      code265.textContent = "menu";
      t1030 = text(", ");
      code266 = element2("code");
      code266.textContent = "li/button";
      t1032 = text(" -> ");
      code267 = element2("code");
      code267.textContent = "button";
      t1034 = text(")");
      t1035 = space();
      h255 = element2("h2");
      t1036 = text("v6.6.7 ");
      em58 = element2("em");
      em58.textContent = "(2023-06-01)";
      t1038 = space();
      ul66 = element2("ul");
      li170 = element2("li");
      code268 = element2("code");
      code268.textContent = "Toaster";
      t1040 = text(" enhancements:");
      ul65 = element2("ul");
      li167 = element2("li");
      li167.textContent = "Improve contrast (reduce the transparency).";
      t1042 = space();
      li168 = element2("li");
      t1043 = text("Make toasts focusable (so that they can be closed with ");
      code269 = element2("code");
      code269.textContent = "Escape";
      t1045 = text(").");
      t1046 = space();
      li169 = element2("li");
      li169.textContent = "When toasts are focused or mouse is over them, the auto-close progress will pause.";
      t1048 = space();
      h256 = element2("h2");
      t1049 = text("v6.6.6 ");
      em59 = element2("em");
      em59.textContent = "(2023-05-31)";
      t1051 = space();
      ul67 = element2("ul");
      li171 = element2("li");
      t1052 = text("Fix ");
      code270 = element2("code");
      code270.textContent = "button-toggle";
      t1054 = text(" not working on mobile.");
      t1055 = space();
      h257 = element2("h2");
      t1056 = text("v6.6.4, v6.6.5 ");
      em60 = element2("em");
      em60.textContent = "(2023-05-12)";
      t1058 = space();
      ul68 = element2("ul");
      li172 = element2("li");
      t1059 = text("Bring back ");
      code271 = element2("code");
      code271.textContent = "--ui-shadow-small";
      t1061 = text(" property.");
      t1062 = space();
      li173 = element2("li");
      code272 = element2("code");
      code272.textContent = "Menu";
      t1064 = text(" performance improvements: menu will not be rendered until it's opened.");
      t1065 = space();
      h258 = element2("h2");
      t1066 = text("v6.6.3, v6.6.2, v6.6.1, v6.6.0,  ");
      em61 = element2("em");
      em61.textContent = "(2023-05-11)";
      t1068 = space();
      ul69 = element2("ul");
      li174 = element2("li");
      code273 = element2("code");
      code273.textContent = "Select";
      t1070 = text(" now also accepts an array of strings for items.");
      t1071 = space();
      li175 = element2("li");
      code274 = element2("code");
      code274.textContent = "ButtonToggle";
      t1073 = text(" now also accepts an array of strings for items.");
      t1074 = space();
      li176 = element2("li");
      code275 = element2("code");
      code275.textContent = "em";
      t1076 = text(" to ");
      code276 = element2("code");
      code276.textContent = "rem";
      t1078 = text(", as it's more consistent and predictable.");
      t1079 = space();
      h259 = element2("h2");
      t1080 = text("v6.5.5, v6.5.4, v6.5.3 ");
      em62 = element2("em");
      em62.textContent = "(2023-05-09)";
      t1082 = space();
      ul70 = element2("ul");
      li177 = element2("li");
      li177.textContent = "Standardise button height to match all the other controls.";
      t1084 = space();
      li178 = element2("li");
      li178.textContent = "Standardise placeholder and input-icon colours.";
      t1086 = space();
      li179 = element2("li");
      li179.textContent = "Enhance Autocomplete's and DatePicker's input-icon click experience.";
      t1088 = space();
      li180 = element2("li");
      t1089 = text("Size the icons in ");
      code277 = element2("code");
      code277.textContent = "em";
      t1091 = text(" not ");
      code278 = element2("code");
      code278.textContent = "px";
      t1093 = text(".");
      t1094 = space();
      h260 = element2("h2");
      t1095 = text("v6.5.2 ");
      em63 = element2("em");
      em63.textContent = "(2023-05-08)";
      t1097 = space();
      ul71 = element2("ul");
      li181 = element2("li");
      li181.textContent = "Maintenance update: upgrade dependencies, remove yet another useless a11y warning from svelte zealots.";
      t1099 = space();
      h261 = element2("h2");
      t1100 = text("v6.5.1 ");
      em64 = element2("em");
      em64.textContent = "(2023-05-07)";
      t1102 = space();
      ul72 = element2("ul");
      li182 = element2("li");
      code279 = element2("code");
      code279.textContent = "Menu";
      t1104 = text(" highlighting upgrade: ");
      code280 = element2("code");
      code280.textContent = "ArrowDown";
      t1106 = text(" on the last item will highlight the first item, ");
      code281 = element2("code");
      code281.textContent = "ArrowUp";
      t1108 = text(" on the first item will highlight the last item.");
      t1109 = space();
      h262 = element2("h2");
      t1110 = text("v6.5.0 ");
      em65 = element2("em");
      em65.textContent = "(2023-04-28)";
      t1112 = space();
      ul73 = element2("ul");
      li183 = element2("li");
      li183.textContent = "Change the default color for a secondary button.";
      t1114 = space();
      li184 = element2("li");
      t1115 = text("Add ");
      code282 = element2("code");
      code282.textContent = "info";
      t1117 = text(" type to ");
      code283 = element2("code");
      code283.textContent = "Button";
      t1119 = text(" component (that takes the colour of the previous ");
      code284 = element2("code");
      code284.textContent = "default";
      t1121 = text(").");
      t1122 = space();
      li185 = element2("li");
      li185.textContent = "Fix round button (with text) aspect-ratio lock.";
      t1124 = space();
      h263 = element2("h2");
      t1125 = text("v6.4.3 ");
      em66 = element2("em");
      em66.textContent = "(2023-04-27)";
      t1127 = space();
      ul74 = element2("ul");
      li186 = element2("li");
      t1128 = text("Improve ");
      code285 = element2("code");
      code285.textContent = "<InputPassword/>";
      t1130 = text(" component: don't rerender when eye button is clicked, minor alignment style tweak.");
      t1131 = space();
      li187 = element2("li");
      code286 = element2("code");
      code286.textContent = "Autocomplete";
      t1133 = text(" keyboard scrolling alignment fix (highlighted item was partially cropped).");
      t1134 = space();
      h264 = element2("h2");
      t1135 = text("v6.4.2, v6.4.1 ");
      em67 = element2("em");
      em67.textContent = "(2023-04-22)";
      t1137 = space();
      ul75 = element2("ul");
      li188 = element2("li");
      li188.textContent = "Remove the need to inline svg icons in the consumer's build.";
      t1139 = space();
      li189 = element2("li");
      t1140 = text("Add ");
      code287 = element2("code");
      code287.textContent = "addIcon";
      t1142 = text(" function to allow adding custom icons.");
      t1143 = space();
      li190 = element2("li");
      t1144 = text("Fix ");
      code288 = element2("code");
      code288.textContent = "menu.open";
      t1146 = text(" issue when event was not passed.");
      t1147 = space();
      h265 = element2("h2");
      t1148 = text("v6.4.0 ");
      em68 = element2("em");
      em68.textContent = "(2023-04-20)";
      t1150 = space();
      ul76 = element2("ul");
      li191 = element2("li");
      li191.textContent = "Tweaks to allow it to be used with SvelteKit.";
      t1152 = space();
      h266 = element2("h2");
      t1153 = text("v6.3.16, v6.3.15 ");
      em69 = element2("em");
      em69.textContent = "(2023-04-15)";
      t1155 = space();
      ul77 = element2("ul");
      li192 = element2("li");
      t1156 = text("New icons: ");
      code289 = element2("code");
      code289.textContent = "undo";
      t1158 = text(" and ");
      code290 = element2("code");
      code290.textContent = "redo";
      t1160 = text(".");
      t1161 = space();
      li193 = element2("li");
      t1162 = text("Fix ");
      code291 = element2("code");
      code291.textContent = "ButtonGroup";
      t1164 = text(" styling for other button types.");
      t1165 = space();
      h267 = element2("h2");
      t1166 = text("v6.3.14, v6.3.13 ");
      em70 = element2("em");
      em70.textContent = "(2023-04-12)";
      t1168 = space();
      ul78 = element2("ul");
      li194 = element2("li");
      code292 = element2("code");
      code292.textContent = "Tooltip";
      t1170 = text(" style tweaks, so it's finally perfect.");
      t1171 = space();
      li195 = element2("li");
      t1172 = text("Minor fix in ");
      code293 = element2("code");
      code293.textContent = "Tooltip";
      t1174 = text(".");
      t1175 = space();
      h268 = element2("h2");
      t1176 = text("v6.3.12 ");
      em71 = element2("em");
      em71.textContent = "(2023-04-09)";
      t1178 = space();
      ul79 = element2("ul");
      li196 = element2("li");
      li196.textContent = "Cleanup.";
      t1180 = space();
      h269 = element2("h2");
      t1181 = text("v6.3.12, v6.3.11, v6.3.10, v6.3.9 ");
      em72 = element2("em");
      em72.textContent = "(2023-04-07)";
      t1183 = space();
      ul80 = element2("ul");
      li197 = element2("li");
      code294 = element2("code");
      code294.textContent = "Menu";
      t1185 = text(" on-close should resolve instantly, when the menu is already closed.");
      t1186 = space();
      li198 = element2("li");
      code295 = element2("code");
      code295.textContent = "Menu";
      t1188 = text(" new attribute ");
      code296 = element2("code");
      code296.textContent = "align";
      t1190 = text(" allows to align the menu to the right with the target.");
      t1191 = space();
      h270 = element2("h2");
      t1192 = text("v6.3.8, v6.3.7, v6.3.6, v6.3.5, v6.3.4 ");
      em73 = element2("em");
      em73.textContent = "(2023-04-06)";
      t1194 = space();
      ul81 = element2("ul");
      li199 = element2("li");
      li199.textContent = "Handle svelte's newest a11y warnings.";
      t1196 = space();
      li200 = element2("li");
      li200.textContent = "Tweak media query notation.";
      t1198 = space();
      li201 = element2("li");
      li201.textContent = "Remove menu of type='input'.";
      t1200 = space();
      li202 = element2("li");
      t1201 = text("Allow ");
      code297 = element2("code");
      code297.textContent = "data-";
      t1203 = text(" attributes on ");
      code298 = element2("code");
      code298.textContent = "Button";
      t1205 = text(" and ");
      code299 = element2("code");
      code299.textContent = "MenuItem";
      t1207 = text(".");
      t1208 = space();
      li203 = element2("li");
      t1209 = text("Fix Menu target button's ");
      code300 = element2("code");
      code300.textContent = "aria-expanded";
      t1211 = text(" attribute (wasn't set to ");
      code301 = element2("code");
      code301.textContent = "false";
      t1213 = text(" on menu close).");
      t1214 = space();
      h271 = element2("h2");
      t1215 = text("v6.3.3 ");
      em74 = element2("em");
      em74.textContent = "(2023-04-05)";
      t1217 = space();
      ul82 = element2("ul");
      li204 = element2("li");
      code302 = element2("code");
      code302.textContent = "Tooltip";
      t1219 = text(" tip was upgraded to take advantage of the new ");
      code303 = element2("code");
      code303.textContent = "clip-path";
      t1221 = text(" property.");
      t1222 = space();
      li205 = element2("li");
      code304 = element2("code");
      code304.textContent = "Tooltip";
      t1224 = text(" tip was enhanced with color variations: ");
      code305 = element2("code");
      code305.textContent = "success";
      t1226 = text(", ");
      code306 = element2("code");
      code306.textContent = "warning";
      t1228 = text(" and ");
      code307 = element2("code");
      code307.textContent = "danger";
      t1230 = text(".");
      t1231 = space();
      h272 = element2("h2");
      t1232 = text("v6.3.2 ");
      em75 = element2("em");
      em75.textContent = "(2023-03-30)";
      t1234 = space();
      ul83 = element2("ul");
      li206 = element2("li");
      code308 = element2("code");
      code308.textContent = "Table";
      t1236 = text(" will not listen to events when it's not the target.");
      t1237 = space();
      li207 = element2("li");
      code309 = element2("code");
      code309.textContent = "Dialog";
      t1239 = text(" buttons can now be navigated with left & right arrow keys for convenience.");
      t1240 = space();
      h273 = element2("h2");
      t1241 = text("v6.3.1 ");
      em76 = element2("em");
      em76.textContent = "(2023-03-26)";
      t1243 = space();
      ul84 = element2("ul");
      li208 = element2("li");
      code310 = element2("code");
      code310.textContent = "ButtonGroup";
      t1245 = text(" styling tweaks (edge buttons padding alignment)");
      t1246 = space();
      h274 = element2("h2");
      t1247 = text("v6.3.0 ");
      em77 = element2("em");
      em77.textContent = "(2023-03-26)";
      t1249 = space();
      ul85 = element2("ul");
      li209 = element2("li");
      t1250 = text("enhance ");
      code311 = element2("code");
      code311.textContent = "MenuItem";
      t1252 = text(" component (add props: class, disabled, icon, success, warning, danger)");
      t1253 = space();
      h275 = element2("h2");
      t1254 = text("v6.2.10 ");
      em78 = element2("em");
      em78.textContent = "(2023-03-25)";
      t1256 = space();
      ul86 = element2("ul");
      li210 = element2("li");
      t1257 = text("Also pass event target in menu ");
      code312 = element2("code");
      code312.textContent = "on:close";
      t1259 = text(" event.");
      t1260 = space();
      h276 = element2("h2");
      t1261 = text("v6.2.9 ");
      em79 = element2("em");
      em79.textContent = "(2023-03-25)";
      t1263 = space();
      ul87 = element2("ul");
      li211 = element2("li");
      t1264 = text("Fix: menu ");
      code313 = element2("code");
      code313.textContent = "on:open";
      t1266 = text(" event was missing.");
      t1267 = space();
      h277 = element2("h2");
      t1268 = text("v6.2.8 ");
      em80 = element2("em");
      em80.textContent = "(2023-03-24)";
      t1270 = space();
      ul88 = element2("ul");
      li212 = element2("li");
      li212.textContent = "move tooltip custom class attribute to the tooltip itself, not the content (so that it can easily overwrite the background color).";
      t1272 = space();
      h278 = element2("h2");
      t1273 = text("v6.2.7 ");
      em81 = element2("em");
      em81.textContent = "(2023-03-24)";
      t1275 = space();
      ul89 = element2("ul");
      li213 = element2("li");
      t1276 = text("revert some tooltip changes (");
      code314 = element2("code");
      code314.textContent = "events";
      t1278 = text(" prop is actually useful)");
      t1279 = space();
      h279 = element2("h2");
      t1280 = text("v6.2.6 ");
      em82 = element2("em");
      em82.textContent = "(2023-03-24)";
      t1282 = space();
      ul90 = element2("ul");
      li214 = element2("li");
      t1283 = text("simplify tooltip (change bg color to ");
      code315 = element2("code");
      code315.textContent = "accent";
      t1285 = text(", drop ");
      code316 = element2("code");
      code316.textContent = "events";
      t1287 = text(" prop and default to focus + hover)");
      t1288 = space();
      h280 = element2("h2");
      t1289 = text("v6.2.5 ");
      em83 = element2("em");
      em83.textContent = "(2023-03-24)";
      t1291 = space();
      ul91 = element2("ul");
      li215 = element2("li");
      t1292 = text("disable svelte false-positive a11y warnings. See ");
      a4 = element2("a");
      a4.textContent = "svelte#8402";
      t1294 = space();
      h281 = element2("h2");
      t1295 = text("v6.2.4 ");
      em84 = element2("em");
      em84.textContent = "(2023-03-24)";
      t1297 = space();
      ul92 = element2("ul");
      li216 = element2("li");
      t1298 = text("update table docs (missing ");
      code317 = element2("code");
      code317.textContent = "data";
      t1300 = text(" prop)");
      t1301 = space();
      li217 = element2("li");
      t1302 = text("change button's ");
      code318 = element2("code");
      code318.textContent = "active";
      t1304 = text(" class to ");
      code319 = element2("code");
      code319.textContent = "touching";
      t1306 = text(" for touch events (to not conflict with popular ");
      code320 = element2("code");
      code320.textContent = "active";
      t1308 = text(" class name that may be used by consumers)");
      t1309 = space();
      h282 = element2("h2");
      t1310 = text("v6.2.3, v6.2.2 ");
      em85 = element2("em");
      em85.textContent = "(2023-03-24)";
      t1312 = space();
      ul93 = element2("ul");
      li218 = element2("li");
      li218.textContent = "Fix issue where a selectable table would become non-selectable if another table on the same page was destroyed.";
      t1314 = space();
      h283 = element2("h2");
      t1315 = text("v6.2.1 ");
      em86 = element2("em");
      em86.textContent = "(2023-03-23)";
      t1317 = space();
      ul94 = element2("ul");
      li219 = element2("li");
      li219.textContent = "Datepicker should stopPropagation on Escape, when the calendar is open.";
      t1319 = space();
      h284 = element2("h2");
      t1320 = text("v6.2.0 ");
      em87 = element2("em");
      em87.textContent = "(2023-03-20)";
      t1322 = space();
      ul95 = element2("ul");
      li220 = element2("li");
      t1323 = text("Review accessibility of all components (added ");
      code321 = element2("code");
      code321.textContent = "aria-";
      t1325 = text(" roles and attributes where necessary).");
      t1326 = space();
      li221 = element2("li");
      li221.textContent = "Tweaked some components (e.g. close Tooltip on Escape)";
      t1328 = space();
      li222 = element2("li");
      li222.textContent = "Added unit tests for all components.";
      t1330 = space();
      li223 = element2("li");
      li223.textContent = "Docs pages style tweaks (e.g. color palette)";
      t1332 = space();
      h285 = element2("h2");
      t1333 = text("v6.1.1 ");
      em88 = element2("em");
      em88.textContent = "(2023-03-15)";
      t1335 = space();
      ul96 = element2("ul");
      li224 = element2("li");
      t1336 = text("Remove ");
      code322 = element2("code");
      code322.textContent = "coverage";
      t1338 = text(" folder from the npm package.");
      t1339 = space();
      h286 = element2("h2");
      t1340 = text("v6.1.0 ");
      em89 = element2("em");
      em89.textContent = "(2023-03-15)";
      t1342 = space();
      ul97 = element2("ul");
      li225 = element2("li");
      code323 = element2("code");
      code323.textContent = "Toggle";
      t1344 = text(" component has been completely rewritten to make it more flexible and perfect.");
      t1345 = space();
      h287 = element2("h2");
      t1346 = text("v6.0.2, v6.0.1, v6.0.0 ");
      em90 = element2("em");
      em90.textContent = "(2023-03-13)";
      t1348 = space();
      ul98 = element2("ul");
      li226 = element2("li");
      t1349 = text("rebrand ");
      code324 = element2("code");
      code324.textContent = "simple-ui-components-in-svelte";
      t1351 = text(" to ");
      code325 = element2("code");
      code325.textContent = "@perfectthings/ui";
      t1353 = space();
      hr3 = element2("hr");
      t1354 = space();
      h288 = element2("h2");
      t1355 = text("v5.1.0 ");
      em91 = element2("em");
      em91.textContent = "(2023-03-12)";
      t1357 = space();
      ul99 = element2("ul");
      li227 = element2("li");
      li227.textContent = "Better Menu highlighting (doesn't hl first item on open, mouseout removes the highlighting), inline with how native menus work on MacOS";
      t1359 = space();
      li228 = element2("li");
      li228.textContent = "Mobile friendlier buttons (touchstart invokes :active styling)";
      t1361 = space();
      li229 = element2("li");
      li229.textContent = "unit tests for some components";
      t1363 = space();
      h289 = element2("h2");
      t1364 = text("v5.0.8 ");
      em92 = element2("em");
      em92.textContent = "(2023-03-03)";
      t1366 = space();
      ul100 = element2("ul");
      li230 = element2("li");
      li230.textContent = "Tooltip offset parameter";
      t1368 = space();
      h290 = element2("h2");
      t1369 = text("v5.0.7 ");
      em93 = element2("em");
      em93.textContent = "(2023-03-03)";
      t1371 = space();
      ul101 = element2("ul");
      li231 = element2("li");
      li231.textContent = "PushButton fix (pushed class was not applied)";
      t1373 = space();
      h291 = element2("h2");
      t1374 = text("v5.0.6 ");
      em94 = element2("em");
      em94.textContent = "(2023-03-02)";
      t1376 = space();
      ul102 = element2("ul");
      li232 = element2("li");
      t1377 = text("Add back ");
      code326 = element2("code");
      code326.textContent = "form";
      t1379 = text(" property to a button");
      t1380 = space();
      h292 = element2("h2");
      t1381 = text("v5.0.5 ");
      em95 = element2("em");
      em95.textContent = "(2023-03-02)";
      t1383 = space();
      ul103 = element2("ul");
      li233 = element2("li");
      t1384 = text("Reduce memory footprint (removed some of the ");
      code327 = element2("code");
      code327.textContent = "transform";
      t1386 = text(" props that were no longer necessary)");
      t1387 = space();
      h293 = element2("h2");
      t1388 = text("v5.0.4 ");
      em96 = element2("em");
      em96.textContent = "(2023-03-02)";
      t1390 = space();
      ul104 = element2("ul");
      li234 = element2("li");
      li234.textContent = "esbuild replaced rollup for speed and simplicity";
      t1392 = space();
      li235 = element2("li");
      li235.textContent = "cleanup & refactoring";
      t1394 = space();
      h294 = element2("h2");
      t1395 = text("v5.0.3 ");
      em97 = element2("em");
      em97.textContent = "(2023-03-01)";
      t1397 = space();
      ul105 = element2("ul");
      li236 = element2("li");
      li236.textContent = "Tooltip hiding fix (wasn't hiding when hovering target)";
      t1399 = space();
      h295 = element2("h2");
      t1400 = text("v5.0.2 ");
      em98 = element2("em");
      em98.textContent = "(2023-03-01)";
      t1402 = space();
      ul106 = element2("ul");
      li237 = element2("li");
      li237.textContent = "Toaster import fix";
      t1404 = space();
      li238 = element2("li");
      li238.textContent = "Tooltip fix (some console errors were popping up)";
      t1406 = space();
      h296 = element2("h2");
      t1407 = text("v5.0.1 ");
      em99 = element2("em");
      em99.textContent = "(2023-02-28)";
      t1409 = space();
      ul107 = element2("ul");
      li239 = element2("li");
      t1410 = text("Bring back ");
      code328 = element2("code");
      code328.textContent = "button-outline.css";
      t1412 = text(" (it was accidentally deleted in v5.0.0)");
      t1413 = space();
      h297 = element2("h2");
      t1414 = text("v5.0.0 ");
      em100 = element2("em");
      em100.textContent = "(2023-02-28)";
      t1416 = space();
      ul108 = element2("ul");
      li240 = element2("li");
      t1417 = text("Breaking change: renamed props for all components: ");
      code329 = element2("code");
      code329.textContent = "className";
      t1419 = text(" -> ");
      code330 = element2("code");
      code330.textContent = "class";
      t1421 = text(" (as it turns out it is possible to use ");
      code331 = element2("code");
      code331.textContent = "class";
      t1423 = text(" as a prop name in svelte)");
      t1424 = space();
      li241 = element2("li");
      t1425 = text("Almost all components now have a ");
      code332 = element2("code");
      code332.textContent = "class";
      t1427 = text(" prop, which can be used to add custom classes to the component");
      t1428 = space();
      li242 = element2("li");
      li242.textContent = "Updated docs to reflect the above changes";
      t1430 = space();
      li243 = element2("li");
      li243.textContent = "Docs API table is now alphabetically sorted";
      t1432 = space();
      li244 = element2("li");
      t1433 = text("Components don't use ");
      code333 = element2("code");
      code333.textContent = "$$props";
      t1435 = text(" anymore, as it was causing issues with the ");
      code334 = element2("code");
      code334.textContent = "class";
      t1437 = text(" prop. Instead, the props are now explicitly passed down to the component. This is a good thing to do, as it makes the components more explicit and easier to understand.");
      t1438 = space();
      hr4 = element2("hr");
      t1439 = space();
      h298 = element2("h2");
      t1440 = text("v4.0.0 ");
      em101 = element2("em");
      em101.textContent = "(2023-02-28)";
      t1442 = space();
      ul109 = element2("ul");
      li245 = element2("li");
      t1443 = text("Breaking change: renamed components: ");
      code335 = element2("code");
      code335.textContent = "Item";
      t1445 = text(" -> ");
      code336 = element2("code");
      code336.textContent = "MenuItem";
      t1447 = text(", ");
      code337 = element2("code");
      code337.textContent = "Separator";
      t1449 = text(" -> ");
      code338 = element2("code");
      code338.textContent = "MenuSeparator";
      t1451 = space();
      li246 = element2("li");
      li246.textContent = "Refactored the folder structure";
      t1453 = space();
      hr5 = element2("hr");
      t1454 = space();
      h299 = element2("h2");
      t1455 = text("v3.1.2 ");
      em102 = element2("em");
      em102.textContent = "(2023-01-04)";
      t1457 = space();
      ul110 = element2("ul");
      li247 = element2("li");
      t1458 = text("Toggle's ");
      code339 = element2("code");
      code339.textContent = "innerWidth";
      t1460 = text(" function was somehow overwriting ");
      code340 = element2("code");
      code340.textContent = "window.innerWidth";
      t1462 = text(" property (maybe a compiler issue?)");
      t1463 = space();
      h2100 = element2("h2");
      t1464 = text("v3.1.1 ");
      em103 = element2("em");
      em103.textContent = "(2023-01-04)";
      t1466 = space();
      ul111 = element2("ul");
      li248 = element2("li");
      t1467 = text("Fix ");
      code341 = element2("code");
      code341.textContent = "input-number";
      t1469 = text(" (could not enter decimals)");
      t1470 = space();
      li249 = element2("li");
      t1471 = text("Fix ");
      code342 = element2("code");
      code342.textContent = "input-math";
      t1473 = text(" (math didn't work)");
      t1474 = space();
      h2101 = element2("h2");
      t1475 = text("v3.1.0 ");
      em104 = element2("em");
      em104.textContent = "(2023-01-03)";
      t1477 = space();
      ul112 = element2("ul");
      li250 = element2("li");
      t1478 = text("UX change: autocomplete will not close on scroll or resize events from now on (it can be changed using new properties ");
      code343 = element2("code");
      code343.textContent = "hideOnScroll";
      t1480 = text(" and ");
      code344 = element2("code");
      code344.textContent = "hideOnResize";
      t1482 = text(").");
      t1483 = space();
      li251 = element2("li");
      li251.textContent = "fixed: autocomplete issue, where clicking on a filtered list would not select.";
      t1485 = space();
      li252 = element2("li");
      li252.textContent = 'tweak: autocomplete will now show "create new item" always (when enabled), not only when the query did not match anything. Except when the query matches an item exactly.';
      t1487 = space();
      h2102 = element2("h2");
      t1488 = text("v3.0.1 ");
      em105 = element2("em");
      em105.textContent = "(2022-12-30)";
      t1490 = space();
      ul113 = element2("ul");
      li253 = element2("li");
      li253.textContent = "autocomplete should revert when entered value is not on the list";
      t1492 = space();
      h2103 = element2("h2");
      t1493 = text("v3.0.0 ");
      em106 = element2("em");
      em106.textContent = "(2022-12-28)";
      t1495 = space();
      ul114 = element2("ul");
      li254 = element2("li");
      t1496 = text("breaking change: ");
      code345 = element2("code");
      code345.textContent = "cssClass";
      t1498 = text(" property available on some components has been renamed to ");
      code346 = element2("code");
      code346.textContent = "className";
      t1500 = text(" (to be more aligned with the standard workaround in other libs/frameworks).");
      t1501 = space();
      li255 = element2("li");
      t1502 = text("some components (where possible) are now using ");
      code347 = element2("code");
      code347.textContent = "$$props";
      t1504 = text(" to pass-through the properties of the instance down to the component.");
      t1505 = space();
      hr6 = element2("hr");
      t1506 = space();
      h2104 = element2("h2");
      t1507 = text("v2.1.1 ");
      em107 = element2("em");
      em107.textContent = "(2022-12-24)";
      t1509 = space();
      ul115 = element2("ul");
      li256 = element2("li");
      t1510 = text("breaking change: ");
      code348 = element2("code");
      code348.textContent = "dist";
      t1512 = text(" folder has been renamed to ");
      code349 = element2("code");
      code349.textContent = "docs";
      t1514 = text(", as this is the only allowed name for a GH pages folder so that the GH pages is published automatically (without writing a GH action specifically for this).");
      t1515 = space();
      hr7 = element2("hr");
      t1516 = space();
      h2105 = element2("h2");
      t1517 = text("v1.7.12 ");
      em108 = element2("em");
      em108.textContent = "(2022)";
      add_location(h1, file46, 0, 0, 0);
      add_location(em0, file46, 1, 11, 30);
      add_location(h20, file46, 1, 0, 19);
      add_location(code0, file46, 3, 8, 70);
      add_location(li0, file46, 3, 0, 62);
      add_location(ul0, file46, 2, 0, 57);
      add_location(em1, file46, 5, 11, 141);
      add_location(h21, file46, 5, 0, 130);
      add_location(code1, file46, 7, 8, 181);
      add_location(li1, file46, 7, 0, 173);
      add_location(li2, file46, 8, 0, 253);
      add_location(code2, file46, 9, 8, 315);
      add_location(li3, file46, 9, 0, 307);
      add_location(ul1, file46, 6, 0, 168);
      add_location(em2, file46, 11, 19, 402);
      add_location(h22, file46, 11, 0, 383);
      add_location(code3, file46, 13, 21, 455);
      add_location(code4, file46, 13, 42, 476);
      add_location(li4, file46, 13, 0, 434);
      add_location(li5, file46, 14, 0, 501);
      add_location(ul2, file46, 12, 0, 429);
      add_location(em3, file46, 16, 21, 566);
      add_location(h23, file46, 16, 0, 545);
      add_location(code5, file46, 18, 8, 606);
      add_location(li6, file46, 18, 0, 598);
      add_location(code6, file46, 19, 24, 708);
      add_location(li7, file46, 19, 0, 684);
      add_location(li8, file46, 20, 0, 783);
      add_location(li9, file46, 21, 0, 840);
      add_location(ul3, file46, 17, 0, 593);
      add_location(em4, file46, 23, 12, 889);
      add_location(h24, file46, 23, 0, 877);
      add_location(code7, file46, 25, 18, 939);
      add_location(code8, file46, 25, 51, 972);
      add_location(li10, file46, 25, 0, 921);
      add_location(li11, file46, 26, 0, 1016);
      add_location(code9, file46, 27, 19, 1074);
      add_location(code10, file46, 27, 46, 1101);
      add_location(code11, file46, 27, 74, 1129);
      add_location(code12, file46, 27, 102, 1157);
      add_location(li12, file46, 27, 0, 1055);
      add_location(code13, file46, 28, 8, 1196);
      add_location(code14, file46, 28, 47, 1235);
      add_location(li13, file46, 28, 0, 1188);
      add_location(code15, file46, 29, 8, 1289);
      add_location(li14, file46, 29, 0, 1281);
      add_location(code16, file46, 30, 8, 1361);
      add_location(code17, file46, 30, 57, 1410);
      add_location(code18, file46, 30, 83, 1436);
      add_location(li15, file46, 30, 0, 1353);
      add_location(ul4, file46, 24, 0, 916);
      add_location(em5, file46, 32, 12, 1496);
      add_location(h25, file46, 32, 0, 1484);
      add_location(code19, file46, 34, 26, 1554);
      add_location(li16, file46, 34, 0, 1528);
      add_location(li17, file46, 35, 0, 1578);
      add_location(ul5, file46, 33, 0, 1523);
      add_location(em6, file46, 37, 12, 1674);
      add_location(h26, file46, 37, 0, 1662);
      add_location(li18, file46, 39, 0, 1706);
      add_location(ul6, file46, 38, 0, 1701);
      add_location(em7, file46, 41, 12, 1803);
      add_location(h27, file46, 41, 0, 1791);
      add_location(li19, file46, 43, 0, 1835);
      add_location(ul7, file46, 42, 0, 1830);
      add_location(em8, file46, 45, 21, 1915);
      add_location(h28, file46, 45, 0, 1894);
      add_location(code20, file46, 47, 8, 1955);
      add_location(code21, file46, 47, 54, 2001);
      add_location(li20, file46, 47, 0, 1947);
      add_location(ul8, file46, 46, 0, 1942);
      add_location(em9, file46, 49, 12, 2069);
      add_location(h29, file46, 49, 0, 2057);
      add_location(code22, file46, 51, 4, 2105);
      add_location(li21, file46, 51, 0, 2101);
      add_location(code23, file46, 52, 4, 2198);
      add_location(li22, file46, 52, 0, 2194);
      add_location(ul9, file46, 50, 0, 2096);
      add_location(em10, file46, 54, 12, 2359);
      add_location(h210, file46, 54, 0, 2347);
      add_location(code24, file46, 56, 8, 2399);
      add_location(li23, file46, 56, 0, 2391);
      add_location(ul10, file46, 55, 0, 2386);
      add_location(em11, file46, 58, 29, 2729);
      add_location(h211, file46, 58, 0, 2700);
      add_location(li24, file46, 60, 0, 2761);
      add_location(code25, file46, 61, 69, 2889);
      add_location(code26, file46, 61, 94, 2914);
      add_location(li25, file46, 61, 0, 2820);
      add_location(ul11, file46, 59, 0, 2756);
      add_location(em12, file46, 63, 11, 2959);
      add_location(h212, file46, 63, 0, 2948);
      add_location(code27, file46, 65, 38, 3029);
      add_location(li26, file46, 65, 0, 2991);
      add_location(ul12, file46, 64, 0, 2986);
      add_location(em13, file46, 67, 11, 3077);
      add_location(h213, file46, 67, 0, 3066);
      add_location(code28, file46, 69, 8, 3117);
      add_location(li27, file46, 69, 0, 3109);
      add_location(code29, file46, 70, 8, 3184);
      add_location(li28, file46, 70, 0, 3176);
      add_location(ul13, file46, 68, 0, 3104);
      add_location(em14, file46, 72, 35, 3291);
      add_location(h214, file46, 72, 0, 3256);
      add_location(code30, file46, 74, 55, 3378);
      add_location(li29, file46, 74, 0, 3323);
      add_location(code31, file46, 75, 43, 3459);
      add_location(code32, file46, 75, 89, 3505);
      add_location(code33, file46, 75, 110, 3526);
      add_location(li30, file46, 75, 0, 3416);
      add_location(ul14, file46, 73, 0, 3318);
      add_location(em15, file46, 77, 11, 3565);
      add_location(h215, file46, 77, 0, 3554);
      add_location(code34, file46, 79, 23, 3620);
      add_location(code35, file46, 79, 48, 3645);
      add_location(li31, file46, 79, 0, 3597);
      add_location(ul15, file46, 78, 0, 3592);
      add_location(em16, file46, 81, 11, 3690);
      add_location(h216, file46, 81, 0, 3679);
      add_location(code36, file46, 83, 8, 3730);
      add_location(code37, file46, 83, 56, 3778);
      add_location(li32, file46, 83, 0, 3722);
      add_location(ul16, file46, 82, 0, 3717);
      add_location(em17, file46, 85, 11, 3891);
      add_location(h217, file46, 85, 0, 3880);
      add_location(code38, file46, 87, 8, 3931);
      add_location(code39, file46, 87, 47, 3970);
      add_location(li33, file46, 87, 0, 3923);
      add_location(ul17, file46, 86, 0, 3918);
      add_location(em18, file46, 89, 19, 4023);
      add_location(h218, file46, 89, 0, 4004);
      add_location(code40, file46, 91, 8, 4063);
      add_location(li34, file46, 91, 0, 4055);
      add_location(code41, file46, 92, 34, 4175);
      add_location(code42, file46, 92, 59, 4200);
      add_location(code43, file46, 92, 138, 4279);
      add_location(li35, file46, 92, 0, 4141);
      add_location(ul18, file46, 90, 0, 4050);
      add_location(em19, file46, 94, 19, 4337);
      add_location(h219, file46, 94, 0, 4318);
      add_location(code44, file46, 96, 8, 4377);
      add_location(li36, file46, 96, 0, 4369);
      add_location(code45, file46, 97, 8, 4474);
      add_location(li37, file46, 97, 0, 4466);
      add_location(ul19, file46, 95, 0, 4364);
      add_location(em20, file46, 99, 19, 4558);
      add_location(h220, file46, 99, 0, 4539);
      add_location(code46, file46, 101, 4, 4594);
      add_location(li38, file46, 101, 0, 4590);
      add_location(code47, file46, 102, 15, 4659);
      add_location(li39, file46, 102, 0, 4644);
      add_location(li40, file46, 103, 0, 4685);
      add_location(ul20, file46, 100, 0, 4585);
      add_location(em21, file46, 105, 11, 4731);
      add_location(h221, file46, 105, 0, 4720);
      add_location(code48, file46, 107, 8, 4771);
      add_location(li41, file46, 107, 0, 4763);
      add_location(ul21, file46, 106, 0, 4758);
      add_location(em22, file46, 109, 11, 4816);
      add_location(h222, file46, 109, 0, 4805);
      add_location(code49, file46, 111, 31, 4879);
      add_location(li42, file46, 111, 0, 4848);
      add_location(ul22, file46, 110, 0, 4843);
      add_location(em23, file46, 113, 11, 4957);
      add_location(h223, file46, 113, 0, 4946);
      add_location(code50, file46, 115, 4, 4993);
      add_location(code51, file46, 115, 117, 5106);
      add_location(li43, file46, 115, 0, 4989);
      add_location(ul23, file46, 114, 0, 4984);
      add_location(em24, file46, 117, 11, 5162);
      add_location(h224, file46, 117, 0, 5151);
      add_location(code52, file46, 119, 19, 5213);
      add_location(li44, file46, 119, 0, 5194);
      add_location(ul24, file46, 118, 0, 5189);
      add_location(em25, file46, 121, 27, 5271);
      add_location(h225, file46, 121, 0, 5244);
      add_location(code53, file46, 123, 20, 5323);
      add_location(code54, file46, 123, 46, 5349);
      add_location(code55, file46, 123, 64, 5367);
      add_location(code56, file46, 123, 87, 5390);
      add_location(li45, file46, 123, 0, 5303);
      add_location(code57, file46, 124, 8, 5427);
      add_location(code58, file46, 124, 42, 5461);
      add_location(li46, file46, 124, 0, 5419);
      add_location(code59, file46, 125, 8, 5496);
      add_location(code60, file46, 125, 42, 5530);
      add_location(li47, file46, 125, 0, 5488);
      add_location(code61, file46, 126, 8, 5567);
      add_location(li48, file46, 126, 0, 5559);
      add_location(li49, file46, 127, 0, 5633);
      add_location(ul25, file46, 122, 0, 5298);
      add_location(em26, file46, 129, 11, 5705);
      add_location(h226, file46, 129, 0, 5694);
      add_location(code62, file46, 131, 11, 5748);
      add_location(code63, file46, 131, 37, 5774);
      add_location(li50, file46, 131, 0, 5737);
      add_location(ul26, file46, 130, 0, 5732);
      add_location(em27, file46, 133, 35, 5898);
      add_location(h227, file46, 133, 0, 5863);
      add_location(code64, file46, 135, 9, 5939);
      add_location(code65, file46, 135, 41, 5971);
      add_location(li51, file46, 135, 0, 5930);
      add_location(code66, file46, 136, 8, 6004);
      add_location(li52, file46, 136, 0, 5996);
      add_location(code67, file46, 137, 12, 6071);
      add_location(li53, file46, 137, 0, 6059);
      add_location(ul27, file46, 134, 0, 5925);
      add_location(em28, file46, 139, 11, 6168);
      add_location(h228, file46, 139, 0, 6157);
      add_location(strong0, file46, 141, 4, 6204);
      add_location(code68, file46, 141, 32, 6232);
      add_location(li54, file46, 141, 0, 6200);
      add_location(code69, file46, 142, 4, 6336);
      add_location(li55, file46, 142, 0, 6332);
      add_location(code70, file46, 143, 4, 6463);
      add_location(li56, file46, 143, 0, 6459);
      add_location(code71, file46, 144, 19, 6565);
      add_location(code72, file46, 144, 44, 6590);
      add_location(li57, file46, 144, 0, 6546);
      add_location(li58, file46, 145, 0, 6712);
      add_location(li59, file46, 146, 0, 6884);
      add_location(code73, file46, 147, 12, 6968);
      add_location(li60, file46, 147, 0, 6956);
      add_location(code74, file46, 148, 12, 7043);
      add_location(li61, file46, 148, 0, 7031);
      add_location(ul28, file46, 140, 0, 6195);
      add_location(h30, file46, 150, 0, 7140);
      add_location(code75, file46, 152, 8, 7179);
      add_location(code76, file46, 152, 58, 7229);
      add_location(em29, file46, 152, 88, 7259);
      add_location(em30, file46, 152, 107, 7278);
      add_location(em31, file46, 152, 168, 7339);
      add_location(code77, file46, 152, 195, 7366);
      add_location(li62, file46, 152, 0, 7171);
      add_location(code78, file46, 153, 4, 7420);
      add_location(code79, file46, 153, 38, 7454);
      add_location(code80, file46, 153, 63, 7479);
      add_location(code81, file46, 153, 106, 7522);
      add_location(code82, file46, 153, 127, 7543);
      add_location(li63, file46, 153, 0, 7416);
      add_location(ul29, file46, 151, 0, 7166);
      add_location(hr0, file46, 155, 0, 7828);
      add_location(em32, file46, 156, 19, 7852);
      add_location(h229, file46, 156, 0, 7833);
      add_location(code83, file46, 158, 16, 7900);
      add_location(li64, file46, 158, 0, 7884);
      add_location(code84, file46, 159, 12, 8031);
      add_location(li65, file46, 159, 0, 8019);
      add_location(code85, file46, 160, 11, 8135);
      add_location(code86, file46, 160, 38, 8162);
      add_location(li66, file46, 160, 0, 8124);
      add_location(li67, file46, 161, 0, 8205);
      add_location(ul30, file46, 157, 0, 7879);
      add_location(em33, file46, 163, 11, 8278);
      add_location(h230, file46, 163, 0, 8267);
      add_location(code87, file46, 165, 8, 8318);
      add_location(li68, file46, 165, 0, 8310);
      add_location(ul31, file46, 164, 0, 8305);
      add_location(em34, file46, 167, 27, 8401);
      add_location(h231, file46, 167, 0, 8374);
      add_location(strong1, file46, 169, 4, 8437);
      add_location(code88, file46, 169, 26, 8459);
      add_location(code89, file46, 169, 63, 8496);
      add_location(code90, file46, 169, 87, 8520);
      add_location(li69, file46, 169, 0, 8433);
      add_location(li70, file46, 170, 0, 8878);
      add_location(code91, file46, 171, 28, 8953);
      add_location(code92, file46, 171, 73, 8998);
      add_location(li71, file46, 171, 0, 8925);
      add_location(ul32, file46, 168, 0, 8428);
      add_location(em35, file46, 173, 11, 9145);
      add_location(h232, file46, 173, 0, 9134);
      add_location(code93, file46, 175, 32, 9209);
      add_location(code94, file46, 175, 58, 9235);
      add_location(li72, file46, 175, 0, 9177);
      add_location(code95, file46, 176, 4, 9326);
      add_location(li73, file46, 176, 0, 9322);
      add_location(code96, file46, 177, 4, 9452);
      add_location(code97, file46, 177, 44, 9492);
      add_location(li74, file46, 177, 0, 9448);
      add_location(ul33, file46, 174, 0, 9172);
      add_location(em36, file46, 179, 11, 9585);
      add_location(h233, file46, 179, 0, 9574);
      add_location(code98, file46, 181, 12, 9629);
      add_location(li75, file46, 181, 0, 9617);
      add_location(code99, file46, 182, 47, 9771);
      add_location(code100, file46, 182, 79, 9803);
      add_location(code101, file46, 182, 110, 9834);
      add_location(code102, file46, 182, 141, 9865);
      add_location(code103, file46, 182, 172, 9896);
      add_location(li76, file46, 182, 0, 9724);
      add_location(code104, file46, 183, 41, 9973);
      add_location(li77, file46, 183, 0, 9932);
      add_location(code105, file46, 184, 4, 10001);
      add_location(code106, file46, 184, 72, 10069);
      add_location(li78, file46, 184, 0, 9997);
      add_location(code107, file46, 185, 12, 10117);
      add_location(li79, file46, 185, 0, 10105);
      add_location(code108, file46, 186, 43, 10249);
      add_location(li80, file46, 186, 0, 10206);
      add_location(code109, file46, 187, 28, 10365);
      add_location(li81, file46, 187, 0, 10337);
      add_location(ul34, file46, 180, 0, 9612);
      add_location(em37, file46, 189, 11, 10658);
      add_location(h234, file46, 189, 0, 10647);
      add_location(code110, file46, 191, 12, 10702);
      add_location(code111, file46, 191, 44, 10734);
      add_location(li82, file46, 191, 0, 10690);
      add_location(code112, file46, 192, 11, 10802);
      add_location(code113, file46, 192, 50, 10841);
      add_location(li83, file46, 192, 0, 10791);
      add_location(code114, file46, 193, 14, 10997);
      add_location(li84, file46, 193, 0, 10983);
      add_location(li85, file46, 194, 0, 11134);
      add_location(code115, file46, 195, 32, 11265);
      add_location(code116, file46, 195, 51, 11284);
      add_location(code117, file46, 195, 78, 11311);
      add_location(li86, file46, 195, 0, 11233);
      add_location(code118, file46, 196, 10, 11358);
      add_location(li87, file46, 196, 0, 11348);
      add_location(li88, file46, 197, 0, 11475);
      add_location(code119, file46, 198, 14, 11631);
      add_location(code120, file46, 198, 107, 11724);
      add_location(li89, file46, 198, 0, 11617);
      add_location(ul35, file46, 190, 0, 10685);
      add_location(em38, file46, 200, 11, 11766);
      add_location(h235, file46, 200, 0, 11755);
      add_location(strong2, file46, 202, 4, 11802);
      add_location(code121, file46, 202, 26, 11824);
      add_location(code122, file46, 202, 81, 11879);
      add_location(li90, file46, 202, 0, 11798);
      add_location(code123, file46, 203, 43, 12025);
      add_location(li91, file46, 203, 0, 11982);
      add_location(ul36, file46, 201, 0, 11793);
      add_location(em39, file46, 205, 11, 12090);
      add_location(h236, file46, 205, 0, 12079);
      add_location(code124, file46, 207, 4, 12126);
      add_location(code125, file46, 207, 35, 12157);
      add_location(code126, file46, 207, 122, 12244);
      add_location(li92, file46, 207, 0, 12122);
      add_location(code127, file46, 208, 4, 12281);
      add_location(code128, file46, 208, 30, 12307);
      add_location(code129, file46, 208, 145, 12422);
      add_location(code130, file46, 208, 234, 12511);
      add_location(li93, file46, 208, 0, 12277);
      add_location(ul37, file46, 206, 0, 12117);
      add_location(em40, file46, 210, 11, 12667);
      add_location(h237, file46, 210, 0, 12656);
      add_location(code131, file46, 212, 13, 12712);
      add_location(li94, file46, 212, 0, 12699);
      add_location(li95, file46, 213, 0, 12758);
      add_location(ul38, file46, 211, 0, 12694);
      add_location(em41, file46, 215, 11, 12915);
      add_location(h238, file46, 215, 0, 12904);
      add_location(code132, file46, 217, 4, 12951);
      add_location(li96, file46, 217, 0, 12947);
      add_location(code133, file46, 218, 10, 13030);
      add_location(li97, file46, 218, 0, 13020);
      add_location(li98, file46, 219, 0, 13095);
      add_location(li99, file46, 220, 0, 13141);
      add_location(li100, file46, 221, 0, 13222);
      add_location(code134, file46, 222, 40, 13319);
      add_location(li101, file46, 222, 0, 13279);
      add_location(ul39, file46, 216, 0, 12942);
      add_location(em42, file46, 224, 11, 13391);
      add_location(h239, file46, 224, 0, 13380);
      add_location(li102, file46, 226, 0, 13423);
      add_location(li103, file46, 227, 0, 13457);
      add_location(ul40, file46, 225, 0, 13418);
      add_location(em43, file46, 229, 11, 13501);
      add_location(h240, file46, 229, 0, 13490);
      add_location(code135, file46, 231, 15, 13548);
      add_location(code136, file46, 231, 55, 13588);
      add_location(li104, file46, 231, 0, 13533);
      add_location(code137, file46, 232, 4, 13644);
      add_location(code138, file46, 232, 30, 13670);
      add_location(li105, file46, 232, 0, 13640);
      add_location(code139, file46, 233, 4, 13734);
      add_location(code140, file46, 233, 30, 13760);
      add_location(li106, file46, 233, 0, 13730);
      add_location(ul41, file46, 230, 0, 13528);
      add_location(em44, file46, 235, 11, 13850);
      add_location(h241, file46, 235, 0, 13839);
      add_location(strong3, file46, 237, 4, 13886);
      add_location(code141, file46, 237, 58, 13940);
      add_location(li107, file46, 237, 0, 13882);
      add_location(ul42, file46, 236, 0, 13877);
      add_location(em45, file46, 239, 11, 14047);
      add_location(h242, file46, 239, 0, 14036);
      add_location(strong4, file46, 241, 4, 14083);
      add_location(code142, file46, 241, 63, 14142);
      add_location(code143, file46, 241, 86, 14165);
      add_location(code144, file46, 241, 120, 14199);
      add_location(li108, file46, 241, 0, 14079);
      add_location(li109, file46, 242, 0, 14231);
      add_location(li110, file46, 243, 0, 14294);
      add_location(ul43, file46, 240, 0, 14074);
      add_location(em46, file46, 245, 11, 14401);
      add_location(h243, file46, 245, 0, 14390);
      add_location(strong5, file46, 247, 4, 14437);
      add_location(code145, file46, 247, 26, 14459);
      add_location(li111, file46, 247, 0, 14433);
      add_location(strong6, file46, 248, 4, 14498);
      add_location(code146, file46, 248, 32, 14526);
      add_location(code147, file46, 248, 53, 14547);
      add_location(li112, file46, 248, 0, 14494);
      add_location(strong7, file46, 249, 4, 14604);
      add_location(code148, file46, 249, 34, 14634);
      add_location(code149, file46, 249, 53, 14653);
      add_location(code150, file46, 249, 76, 14676);
      add_location(code151, file46, 249, 141, 14741);
      add_location(code152, file46, 249, 164, 14764);
      add_location(code153, file46, 249, 188, 14788);
      add_location(code154, file46, 249, 209, 14809);
      add_location(code155, file46, 249, 240, 14840);
      add_location(li113, file46, 249, 0, 14600);
      add_location(strong8, file46, 250, 4, 14871);
      add_location(code156, file46, 250, 60, 14927);
      add_location(code157, file46, 250, 85, 14952);
      add_location(code158, file46, 250, 164, 15031);
      add_location(code159, file46, 250, 200, 15067);
      add_location(li114, file46, 250, 0, 14867);
      add_location(code160, file46, 251, 10, 15136);
      add_location(code161, file46, 251, 42, 15168);
      add_location(li115, file46, 251, 0, 15126);
      add_location(code162, file46, 252, 10, 15210);
      add_location(code163, file46, 252, 40, 15240);
      add_location(li116, file46, 252, 0, 15200);
      add_location(code164, file46, 253, 10, 15280);
      add_location(code165, file46, 253, 55, 15325);
      add_location(li117, file46, 253, 0, 15270);
      add_location(code166, file46, 254, 25, 15375);
      add_location(code167, file46, 254, 49, 15399);
      add_location(li118, file46, 254, 0, 15350);
      add_location(ul44, file46, 246, 0, 14428);
      add_location(h31, file46, 256, 0, 15435);
      add_location(li119, file46, 258, 0, 15466);
      add_location(code168, file46, 259, 4, 15625);
      add_location(code169, file46, 259, 50, 15671);
      add_location(li120, file46, 259, 0, 15621);
      add_location(code170, file46, 260, 4, 15732);
      add_location(code171, file46, 260, 48, 15776);
      add_location(li121, file46, 260, 0, 15728);
      add_location(code172, file46, 261, 4, 15809);
      add_location(code173, file46, 261, 57, 15862);
      add_location(li122, file46, 261, 0, 15805);
      add_location(code174, file46, 262, 4, 15912);
      add_location(code175, file46, 262, 54, 15962);
      add_location(code176, file46, 262, 94, 16002);
      add_location(li123, file46, 262, 0, 15908);
      add_location(code177, file46, 263, 4, 16063);
      add_location(code178, file46, 263, 55, 16114);
      add_location(code179, file46, 263, 102, 16161);
      add_location(li124, file46, 263, 0, 16059);
      add_location(code180, file46, 264, 4, 16196);
      add_location(code181, file46, 264, 58, 16250);
      add_location(code182, file46, 264, 123, 16315);
      add_location(li125, file46, 264, 0, 16192);
      add_location(code183, file46, 265, 4, 16396);
      add_location(code184, file46, 265, 61, 16453);
      add_location(li126, file46, 265, 0, 16392);
      add_location(code185, file46, 266, 40, 16586);
      add_location(code186, file46, 266, 80, 16626);
      add_location(code187, file46, 266, 102, 16648);
      add_location(code188, file46, 266, 123, 16669);
      add_location(code189, file46, 266, 146, 16692);
      add_location(code190, file46, 266, 170, 16716);
      add_location(code191, file46, 266, 195, 16741);
      add_location(li127, file46, 266, 0, 16546);
      add_location(ul45, file46, 257, 0, 15461);
      add_location(h32, file46, 268, 0, 16771);
      add_location(code192, file46, 270, 4, 16835);
      add_location(code193, file46, 270, 47, 16878);
      add_location(li128, file46, 270, 0, 16831);
      add_location(code194, file46, 271, 4, 16918);
      add_location(code195, file46, 271, 47, 16961);
      add_location(li129, file46, 271, 0, 16914);
      add_location(code196, file46, 272, 4, 17001);
      add_location(code197, file46, 272, 49, 17046);
      add_location(li130, file46, 272, 0, 16997);
      add_location(code198, file46, 273, 4, 17088);
      add_location(code199, file46, 273, 49, 17133);
      add_location(li131, file46, 273, 0, 17084);
      add_location(code200, file46, 274, 4, 17175);
      add_location(code201, file46, 274, 54, 17225);
      add_location(li132, file46, 274, 0, 17171);
      add_location(code202, file46, 275, 4, 17271);
      add_location(code203, file46, 275, 53, 17320);
      add_location(li133, file46, 275, 0, 17267);
      add_location(code204, file46, 276, 4, 17366);
      add_location(code205, file46, 276, 52, 17414);
      add_location(li134, file46, 276, 0, 17362);
      add_location(ul46, file46, 269, 0, 16826);
      add_location(code206, file46, 278, 55, 17516);
      add_location(code207, file46, 278, 80, 17541);
      add_location(p, file46, 278, 0, 17461);
      add_location(hr1, file46, 279, 0, 17585);
      add_location(em47, file46, 280, 11, 17601);
      add_location(h244, file46, 280, 0, 17590);
      add_location(code208, file46, 282, 8, 17641);
      add_location(li135, file46, 282, 0, 17633);
      add_location(ul47, file46, 281, 0, 17628);
      add_location(em48, file46, 284, 11, 17756);
      add_location(h245, file46, 284, 0, 17745);
      add_location(code209, file46, 286, 15, 17803);
      add_location(li136, file46, 286, 0, 17788);
      add_location(ul48, file46, 285, 0, 17783);
      add_location(em49, file46, 288, 11, 17863);
      add_location(h246, file46, 288, 0, 17852);
      add_location(code210, file46, 290, 12, 17907);
      add_location(code211, file46, 290, 62, 17957);
      add_location(code212, file46, 290, 130, 18025);
      add_location(li137, file46, 290, 0, 17895);
      add_location(ul49, file46, 289, 0, 17890);
      add_location(em50, file46, 292, 11, 18070);
      add_location(h247, file46, 292, 0, 18059);
      add_location(code213, file46, 294, 8, 18110);
      add_location(code214, file46, 294, 36, 18138);
      add_location(li138, file46, 294, 0, 18102);
      add_location(li139, file46, 295, 0, 18175);
      add_location(ul50, file46, 293, 0, 18097);
      add_location(em51, file46, 297, 11, 18249);
      add_location(h248, file46, 297, 0, 18238);
      add_location(code215, file46, 299, 4, 18285);
      add_location(code216, file46, 299, 77, 18358);
      add_location(code217, file46, 299, 97, 18378);
      add_location(code218, file46, 299, 120, 18401);
      add_location(li140, file46, 299, 0, 18281);
      add_location(li141, file46, 300, 0, 18437);
      add_location(ul51, file46, 298, 0, 18276);
      add_location(em52, file46, 302, 11, 18518);
      add_location(h249, file46, 302, 0, 18507);
      add_location(strong9, file46, 304, 4, 18554);
      attr_dev(a0, "href", "#InfoBar");
      add_location(a0, file46, 304, 26, 18576);
      add_location(li142, file46, 304, 0, 18550);
      add_location(strong10, file46, 305, 4, 18627);
      attr_dev(a1, "href", "#InputText");
      add_location(a1, file46, 305, 26, 18649);
      attr_dev(a2, "href", "#InputNumber");
      add_location(a2, file46, 305, 62, 18685);
      attr_dev(a3, "href", "#Radio");
      add_location(a3, file46, 305, 106, 18729);
      add_location(li143, file46, 305, 0, 18623);
      add_location(strong11, file46, 306, 4, 18777);
      add_location(code219, file46, 306, 26, 18799);
      add_location(code220, file46, 306, 45, 18818);
      add_location(code221, file46, 306, 68, 18841);
      add_location(code222, file46, 306, 137, 18910);
      add_location(code223, file46, 306, 161, 18934);
      add_location(code224, file46, 306, 187, 18960);
      add_location(code225, file46, 306, 211, 18984);
      add_location(code226, file46, 306, 239, 19012);
      add_location(code227, file46, 306, 263, 19036);
      add_location(li144, file46, 306, 0, 18773);
      add_location(strong12, file46, 307, 4, 19069);
      add_location(code228, file46, 307, 31, 19096);
      add_location(code229, file46, 307, 77, 19142);
      add_location(li145, file46, 307, 0, 19065);
      add_location(ul52, file46, 303, 0, 18545);
      add_location(h33, file46, 309, 0, 19220);
      add_location(h40, file46, 310, 0, 19246);
      add_location(code230, file46, 312, 27, 19296);
      add_location(code231, file46, 312, 53, 19322);
      add_location(li146, file46, 312, 0, 19269);
      add_location(code232, file46, 313, 4, 19374);
      add_location(code233, file46, 313, 88, 19458);
      add_location(code234, file46, 313, 125, 19495);
      add_location(li147, file46, 313, 0, 19370);
      add_location(ul53, file46, 311, 0, 19264);
      add_location(h41, file46, 315, 0, 19536);
      add_location(code235, file46, 317, 27, 19587);
      add_location(code236, file46, 317, 73, 19633);
      add_location(li148, file46, 317, 0, 19560);
      add_location(ul54, file46, 316, 0, 19555);
      add_location(h42, file46, 319, 0, 19704);
      add_location(code237, file46, 321, 28, 19759);
      add_location(code238, file46, 321, 54, 19785);
      add_location(li149, file46, 321, 0, 19731);
      add_location(ul55, file46, 320, 0, 19726);
      add_location(h43, file46, 323, 0, 19842);
      add_location(code239, file46, 325, 28, 19898);
      add_location(code240, file46, 325, 98, 19968);
      add_location(li150, file46, 325, 0, 19870);
      add_location(ul56, file46, 324, 0, 19865);
      add_location(h44, file46, 327, 0, 20047);
      add_location(code241, file46, 329, 4, 20088);
      add_location(code242, file46, 329, 44, 20128);
      add_location(li151, file46, 329, 0, 20084);
      add_location(ul57, file46, 328, 0, 20079);
      add_location(hr2, file46, 331, 0, 20171);
      add_location(em53, file46, 332, 19, 20195);
      add_location(h250, file46, 332, 0, 20176);
      add_location(code243, file46, 334, 18, 20245);
      add_location(li152, file46, 334, 0, 20227);
      add_location(code244, file46, 335, 47, 20322);
      add_location(li153, file46, 335, 0, 20275);
      add_location(ul58, file46, 333, 0, 20222);
      add_location(em54, file46, 337, 11, 20369);
      add_location(h251, file46, 337, 0, 20358);
      add_location(strong13, file46, 339, 4, 20405);
      add_location(code245, file46, 339, 26, 20427);
      add_location(code246, file46, 339, 171, 20572);
      add_location(code247, file46, 339, 194, 20595);
      add_location(li154, file46, 339, 0, 20401);
      add_location(ul59, file46, 338, 0, 20396);
      add_location(em55, file46, 341, 11, 20640);
      add_location(h252, file46, 341, 0, 20629);
      add_location(code248, file46, 343, 8, 20680);
      add_location(li155, file46, 343, 0, 20672);
      add_location(ul60, file46, 342, 0, 20667);
      add_location(em56, file46, 345, 11, 20782);
      add_location(h253, file46, 345, 0, 20771);
      add_location(strong14, file46, 347, 4, 20818);
      add_location(code249, file46, 347, 26, 20840);
      add_location(code250, file46, 347, 98, 20912);
      add_location(li156, file46, 347, 0, 20814);
      add_location(code251, file46, 348, 4, 20985);
      add_location(strong15, file46, 348, 42, 21023);
      add_location(li157, file46, 348, 0, 20981);
      add_location(code252, file46, 349, 4, 21107);
      add_location(code253, file46, 350, 11, 21155);
      add_location(code254, file46, 350, 33, 21177);
      add_location(li158, file46, 350, 0, 21144);
      add_location(code255, file46, 351, 8, 21281);
      add_location(li159, file46, 351, 0, 21273);
      add_location(code256, file46, 352, 35, 21356);
      add_location(code257, file46, 352, 89, 21410);
      add_location(code258, file46, 352, 124, 21445);
      add_location(li160, file46, 352, 0, 21321);
      add_location(code259, file46, 353, 8, 21494);
      add_location(code260, file46, 353, 95, 21581);
      add_location(li161, file46, 353, 0, 21486);
      add_location(ul61, file46, 349, 36, 21139);
      add_location(li162, file46, 349, 0, 21103);
      add_location(ul62, file46, 346, 0, 20809);
      add_location(em57, file46, 357, 11, 21646);
      add_location(h254, file46, 357, 0, 21635);
      add_location(code261, file46, 359, 4, 21682);
      add_location(code262, file46, 360, 4, 21722);
      add_location(code263, file46, 360, 76, 21794);
      add_location(li163, file46, 360, 0, 21718);
      add_location(li164, file46, 361, 0, 21862);
      add_location(code264, file46, 362, 29, 21992);
      add_location(code265, file46, 362, 51, 22014);
      add_location(code266, file46, 362, 70, 22033);
      add_location(code267, file46, 362, 99, 22062);
      add_location(li165, file46, 362, 0, 21963);
      add_location(ul63, file46, 359, 35, 21713);
      add_location(li166, file46, 359, 0, 21678);
      add_location(ul64, file46, 358, 0, 21673);
      add_location(em58, file46, 366, 11, 22117);
      add_location(h255, file46, 366, 0, 22106);
      add_location(code268, file46, 368, 4, 22153);
      add_location(li167, file46, 369, 0, 22192);
      add_location(code269, file46, 370, 59, 22304);
      add_location(li168, file46, 370, 0, 22245);
      add_location(li169, file46, 371, 0, 22331);
      add_location(ul65, file46, 368, 38, 22187);
      add_location(li170, file46, 368, 0, 22149);
      add_location(ul66, file46, 367, 0, 22144);
      add_location(em59, file46, 375, 11, 22452);
      add_location(h256, file46, 375, 0, 22441);
      add_location(code270, file46, 377, 8, 22492);
      add_location(li171, file46, 377, 0, 22484);
      add_location(ul67, file46, 376, 0, 22479);
      add_location(em60, file46, 379, 19, 22572);
      add_location(h257, file46, 379, 0, 22553);
      add_location(code271, file46, 381, 15, 22619);
      add_location(li172, file46, 381, 0, 22604);
      add_location(code272, file46, 382, 4, 22669);
      add_location(li173, file46, 382, 0, 22665);
      add_location(ul68, file46, 380, 0, 22599);
      add_location(em61, file46, 384, 37, 22810);
      add_location(h258, file46, 384, 0, 22773);
      add_location(code273, file46, 386, 4, 22846);
      add_location(li174, file46, 386, 0, 22842);
      add_location(code274, file46, 387, 4, 22923);
      add_location(li175, file46, 387, 0, 22919);
      add_location(code275, file46, 388, 4, 23006);
      add_location(code276, file46, 388, 23, 23025);
      add_location(li176, file46, 388, 0, 23002);
      add_location(ul69, file46, 385, 0, 22837);
      add_location(em62, file46, 390, 27, 23126);
      add_location(h259, file46, 390, 0, 23099);
      add_location(li177, file46, 392, 0, 23158);
      add_location(li178, file46, 393, 0, 23226);
      add_location(li179, file46, 394, 0, 23283);
      add_location(code277, file46, 395, 22, 23391);
      add_location(code278, file46, 395, 42, 23411);
      add_location(li180, file46, 395, 0, 23369);
      add_location(ul70, file46, 391, 0, 23153);
      add_location(em63, file46, 397, 11, 23450);
      add_location(h260, file46, 397, 0, 23439);
      add_location(li181, file46, 399, 0, 23482);
      add_location(ul71, file46, 398, 0, 23477);
      add_location(em64, file46, 401, 11, 23611);
      add_location(h261, file46, 401, 0, 23600);
      add_location(code279, file46, 403, 4, 23647);
      add_location(code280, file46, 403, 44, 23687);
      add_location(code281, file46, 403, 115, 23758);
      add_location(li182, file46, 403, 0, 23643);
      add_location(ul72, file46, 402, 0, 23638);
      add_location(em65, file46, 405, 11, 23849);
      add_location(h262, file46, 405, 0, 23838);
      add_location(li183, file46, 407, 0, 23881);
      add_location(code282, file46, 408, 8, 23947);
      add_location(code283, file46, 408, 34, 23973);
      add_location(code284, file46, 408, 103, 24042);
      add_location(li184, file46, 408, 0, 23939);
      add_location(li185, file46, 409, 0, 24070);
      add_location(ul73, file46, 406, 0, 23876);
      add_location(em66, file46, 411, 11, 24144);
      add_location(h263, file46, 411, 0, 24133);
      add_location(code285, file46, 413, 12, 24188);
      add_location(li186, file46, 413, 0, 24176);
      add_location(code286, file46, 414, 4, 24320);
      add_location(li187, file46, 414, 0, 24316);
      add_location(ul74, file46, 412, 0, 24171);
      add_location(em67, file46, 416, 19, 24451);
      add_location(h264, file46, 416, 0, 24432);
      add_location(li188, file46, 418, 0, 24483);
      add_location(code287, file46, 419, 8, 24565);
      add_location(li189, file46, 419, 0, 24557);
      add_location(code288, file46, 420, 8, 24638);
      add_location(li190, file46, 420, 0, 24630);
      add_location(ul75, file46, 417, 0, 24478);
      add_location(em68, file46, 422, 11, 24716);
      add_location(h265, file46, 422, 0, 24705);
      add_location(li191, file46, 424, 0, 24748);
      add_location(ul76, file46, 423, 0, 24743);
      add_location(em69, file46, 426, 21, 24830);
      add_location(h266, file46, 426, 0, 24809);
      add_location(code289, file46, 428, 15, 24877);
      add_location(code290, file46, 428, 37, 24899);
      add_location(li192, file46, 428, 0, 24862);
      add_location(code291, file46, 429, 8, 24931);
      add_location(li193, file46, 429, 0, 24923);
      add_location(ul77, file46, 427, 0, 24857);
      add_location(em70, file46, 431, 21, 25020);
      add_location(h267, file46, 431, 0, 24999);
      add_location(code292, file46, 433, 4, 25056);
      add_location(li194, file46, 433, 0, 25052);
      add_location(code293, file46, 434, 17, 25142);
      add_location(li195, file46, 434, 0, 25125);
      add_location(ul78, file46, 432, 0, 25047);
      add_location(em71, file46, 436, 12, 25187);
      add_location(h268, file46, 436, 0, 25175);
      add_location(li196, file46, 438, 0, 25219);
      add_location(ul79, file46, 437, 0, 25214);
      add_location(em72, file46, 440, 38, 25281);
      add_location(h269, file46, 440, 0, 25243);
      add_location(code294, file46, 442, 4, 25317);
      add_location(li197, file46, 442, 0, 25313);
      add_location(code295, file46, 443, 4, 25412);
      add_location(code296, file46, 443, 36, 25444);
      add_location(li198, file46, 443, 0, 25408);
      add_location(ul80, file46, 441, 0, 25308);
      add_location(em73, file46, 445, 43, 25572);
      add_location(h270, file46, 445, 0, 25529);
      add_location(li199, file46, 447, 0, 25604);
      add_location(li200, file46, 448, 0, 25655);
      add_location(li201, file46, 449, 0, 25692);
      add_location(code297, file46, 450, 10, 25748);
      add_location(code298, file46, 450, 43, 25781);
      add_location(code299, file46, 450, 67, 25805);
      add_location(li202, file46, 450, 0, 25738);
      add_location(code300, file46, 451, 33, 25866);
      add_location(code301, file46, 451, 89, 25922);
      add_location(li203, file46, 451, 0, 25833);
      add_location(ul81, file46, 446, 0, 25599);
      add_location(em74, file46, 453, 11, 25979);
      add_location(h271, file46, 453, 0, 25968);
      add_location(code302, file46, 455, 4, 26015);
      add_location(code303, file46, 455, 71, 26082);
      add_location(li204, file46, 455, 0, 26011);
      add_location(code304, file46, 456, 4, 26124);
      add_location(code305, file46, 456, 65, 26185);
      add_location(code306, file46, 456, 87, 26207);
      add_location(code307, file46, 456, 112, 26232);
      add_location(li205, file46, 456, 0, 26120);
      add_location(ul82, file46, 454, 0, 26006);
      add_location(em75, file46, 458, 11, 26275);
      add_location(h272, file46, 458, 0, 26264);
      add_location(code308, file46, 460, 4, 26311);
      add_location(li206, file46, 460, 0, 26307);
      add_location(code309, file46, 461, 4, 26395);
      add_location(li207, file46, 461, 0, 26391);
      add_location(ul83, file46, 459, 0, 26302);
      add_location(em76, file46, 463, 11, 26516);
      add_location(h273, file46, 463, 0, 26505);
      add_location(code310, file46, 465, 4, 26552);
      add_location(li208, file46, 465, 0, 26548);
      add_location(ul84, file46, 464, 0, 26543);
      add_location(em77, file46, 467, 11, 26647);
      add_location(h274, file46, 467, 0, 26636);
      add_location(code311, file46, 469, 12, 26691);
      add_location(li209, file46, 469, 0, 26679);
      add_location(ul85, file46, 468, 0, 26674);
      add_location(em78, file46, 471, 12, 26807);
      add_location(h275, file46, 471, 0, 26795);
      add_location(code312, file46, 473, 35, 26874);
      add_location(li210, file46, 473, 0, 26839);
      add_location(ul86, file46, 472, 0, 26834);
      add_location(em79, file46, 475, 11, 26925);
      add_location(h276, file46, 475, 0, 26914);
      add_location(code313, file46, 477, 14, 26971);
      add_location(li211, file46, 477, 0, 26957);
      add_location(ul87, file46, 476, 0, 26952);
      add_location(em80, file46, 479, 11, 27033);
      add_location(h277, file46, 479, 0, 27022);
      add_location(li212, file46, 481, 0, 27065);
      add_location(ul88, file46, 480, 0, 27060);
      add_location(em81, file46, 483, 11, 27222);
      add_location(h278, file46, 483, 0, 27211);
      add_location(code314, file46, 485, 33, 27287);
      add_location(li213, file46, 485, 0, 27254);
      add_location(ul89, file46, 484, 0, 27249);
      add_location(em82, file46, 487, 11, 27354);
      add_location(h279, file46, 487, 0, 27343);
      add_location(code315, file46, 489, 41, 27427);
      add_location(code316, file46, 489, 67, 27453);
      add_location(li214, file46, 489, 0, 27386);
      add_location(ul90, file46, 488, 0, 27381);
      add_location(em83, file46, 491, 11, 27530);
      add_location(h280, file46, 491, 0, 27519);
      attr_dev(a4, "href", "https://github.com/sveltejs/svelte/pull/8402");
      add_location(a4, file46, 493, 53, 27615);
      add_location(li215, file46, 493, 0, 27562);
      add_location(ul91, file46, 492, 0, 27557);
      add_location(em84, file46, 495, 11, 27708);
      add_location(h281, file46, 495, 0, 27697);
      add_location(code317, file46, 497, 31, 27771);
      add_location(li216, file46, 497, 0, 27740);
      add_location(code318, file46, 498, 24, 27824);
      add_location(code319, file46, 498, 53, 27853);
      add_location(code320, file46, 498, 122, 27922);
      add_location(li217, file46, 498, 0, 27800);
      add_location(ul92, file46, 496, 0, 27735);
      add_location(em85, file46, 500, 19, 28014);
      add_location(h282, file46, 500, 0, 27995);
      add_location(li218, file46, 502, 0, 28046);
      add_location(ul93, file46, 501, 0, 28041);
      add_location(em86, file46, 504, 11, 28184);
      add_location(h283, file46, 504, 0, 28173);
      add_location(li219, file46, 506, 0, 28216);
      add_location(ul94, file46, 505, 0, 28211);
      add_location(em87, file46, 508, 11, 28314);
      add_location(h284, file46, 508, 0, 28303);
      add_location(code321, file46, 510, 50, 28396);
      add_location(li220, file46, 510, 0, 28346);
      add_location(li221, file46, 511, 0, 28459);
      add_location(li222, file46, 512, 0, 28523);
      add_location(li223, file46, 513, 0, 28569);
      add_location(ul95, file46, 509, 0, 28341);
      add_location(em88, file46, 515, 11, 28640);
      add_location(h285, file46, 515, 0, 28629);
      add_location(code322, file46, 517, 11, 28683);
      add_location(li224, file46, 517, 0, 28672);
      add_location(ul96, file46, 516, 0, 28667);
      add_location(em89, file46, 519, 11, 28756);
      add_location(h286, file46, 519, 0, 28745);
      add_location(code323, file46, 521, 4, 28792);
      add_location(li225, file46, 521, 0, 28788);
      add_location(ul97, file46, 520, 0, 28783);
      add_location(em90, file46, 523, 27, 28928);
      add_location(h287, file46, 523, 0, 28901);
      add_location(code324, file46, 525, 12, 28972);
      add_location(code325, file46, 525, 59, 29019);
      add_location(li226, file46, 525, 0, 28960);
      add_location(ul98, file46, 524, 0, 28955);
      add_location(hr3, file46, 527, 0, 29061);
      add_location(em91, file46, 528, 11, 29077);
      add_location(h288, file46, 528, 0, 29066);
      add_location(li227, file46, 530, 0, 29109);
      add_location(li228, file46, 531, 0, 29258);
      add_location(li229, file46, 532, 0, 29330);
      add_location(ul99, file46, 529, 0, 29104);
      add_location(em92, file46, 534, 11, 29387);
      add_location(h289, file46, 534, 0, 29376);
      add_location(li230, file46, 536, 0, 29419);
      add_location(ul100, file46, 535, 0, 29414);
      add_location(em93, file46, 538, 11, 29470);
      add_location(h290, file46, 538, 0, 29459);
      add_location(li231, file46, 540, 0, 29502);
      add_location(ul101, file46, 539, 0, 29497);
      add_location(em94, file46, 542, 11, 29574);
      add_location(h291, file46, 542, 0, 29563);
      add_location(code326, file46, 544, 13, 29619);
      add_location(li232, file46, 544, 0, 29606);
      add_location(ul102, file46, 543, 0, 29601);
      add_location(em95, file46, 546, 11, 29680);
      add_location(h292, file46, 546, 0, 29669);
      add_location(code327, file46, 548, 49, 29761);
      add_location(li233, file46, 548, 0, 29712);
      add_location(ul103, file46, 547, 0, 29707);
      add_location(em96, file46, 550, 11, 29843);
      add_location(h293, file46, 550, 0, 29832);
      add_location(li234, file46, 552, 0, 29875);
      add_location(li235, file46, 553, 0, 29933);
      add_location(ul104, file46, 551, 0, 29870);
      add_location(em97, file46, 555, 11, 29985);
      add_location(h294, file46, 555, 0, 29974);
      add_location(li236, file46, 557, 0, 30017);
      add_location(ul105, file46, 556, 0, 30012);
      add_location(em98, file46, 559, 11, 30103);
      add_location(h295, file46, 559, 0, 30092);
      add_location(li237, file46, 561, 0, 30135);
      add_location(li238, file46, 562, 0, 30163);
      add_location(ul106, file46, 560, 0, 30130);
      add_location(em99, file46, 564, 11, 30239);
      add_location(h296, file46, 564, 0, 30228);
      add_location(code328, file46, 566, 15, 30286);
      add_location(li239, file46, 566, 0, 30271);
      add_location(ul107, file46, 565, 0, 30266);
      add_location(em100, file46, 568, 11, 30380);
      add_location(h297, file46, 568, 0, 30369);
      add_location(code329, file46, 570, 55, 30467);
      add_location(code330, file46, 570, 84, 30496);
      add_location(code331, file46, 570, 142, 30554);
      add_location(li240, file46, 570, 0, 30412);
      add_location(code332, file46, 571, 37, 30641);
      add_location(li241, file46, 571, 0, 30604);
      add_location(li242, file46, 572, 0, 30728);
      add_location(li243, file46, 573, 0, 30779);
      add_location(code333, file46, 574, 29, 30861);
      add_location(code334, file46, 574, 93, 30925);
      add_location(li244, file46, 574, 0, 30832);
      add_location(ul108, file46, 569, 0, 30407);
      add_location(hr4, file46, 576, 0, 31124);
      add_location(em101, file46, 577, 11, 31140);
      add_location(h298, file46, 577, 0, 31129);
      add_location(code335, file46, 579, 41, 31213);
      add_location(code336, file46, 579, 65, 31237);
      add_location(code337, file46, 579, 88, 31260);
      add_location(code338, file46, 579, 117, 31289);
      add_location(li245, file46, 579, 0, 31172);
      add_location(li246, file46, 580, 0, 31321);
      add_location(ul109, file46, 578, 0, 31167);
      add_location(hr5, file46, 582, 0, 31368);
      add_location(em102, file46, 583, 11, 31384);
      add_location(h299, file46, 583, 0, 31373);
      add_location(code339, file46, 585, 17, 31433);
      add_location(code340, file46, 585, 74, 31490);
      add_location(li247, file46, 585, 0, 31416);
      add_location(ul110, file46, 584, 0, 31411);
      add_location(em103, file46, 587, 11, 31578);
      add_location(h2100, file46, 587, 0, 31567);
      add_location(code341, file46, 589, 8, 31618);
      add_location(li248, file46, 589, 0, 31610);
      add_location(code342, file46, 590, 8, 31684);
      add_location(li249, file46, 590, 0, 31676);
      add_location(ul111, file46, 588, 0, 31605);
      add_location(em104, file46, 592, 11, 31753);
      add_location(h2101, file46, 592, 0, 31742);
      add_location(code343, file46, 594, 122, 31907);
      add_location(code344, file46, 594, 152, 31937);
      add_location(li250, file46, 594, 0, 31785);
      add_location(li251, file46, 595, 0, 31970);
      add_location(li252, file46, 596, 0, 32058);
      add_location(ul112, file46, 593, 0, 31780);
      add_location(em105, file46, 598, 11, 32264);
      add_location(h2102, file46, 598, 0, 32253);
      add_location(li253, file46, 600, 0, 32296);
      add_location(ul113, file46, 599, 0, 32291);
      add_location(em106, file46, 602, 11, 32387);
      add_location(h2103, file46, 602, 0, 32376);
      add_location(code345, file46, 604, 21, 32440);
      add_location(code346, file46, 604, 101, 32520);
      add_location(li254, file46, 604, 0, 32419);
      add_location(code347, file46, 605, 51, 32675);
      add_location(li255, file46, 605, 0, 32624);
      add_location(ul114, file46, 603, 0, 32414);
      add_location(hr6, file46, 607, 0, 32777);
      add_location(em107, file46, 608, 11, 32793);
      add_location(h2104, file46, 608, 0, 32782);
      add_location(code348, file46, 610, 21, 32846);
      add_location(code349, file46, 610, 66, 32891);
      add_location(li256, file46, 610, 0, 32825);
      add_location(ul115, file46, 609, 0, 32820);
      add_location(hr7, file46, 612, 0, 33077);
      add_location(em108, file46, 613, 12, 33094);
      add_location(h2105, file46, 613, 0, 33082);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h1, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h20, anchor);
      append_dev(h20, t2);
      append_dev(h20, em0);
      insert_dev(target, t4, anchor);
      insert_dev(target, ul0, anchor);
      append_dev(ul0, li0);
      append_dev(li0, t5);
      append_dev(li0, code0);
      append_dev(li0, t7);
      insert_dev(target, t8, anchor);
      insert_dev(target, h21, anchor);
      append_dev(h21, t9);
      append_dev(h21, em1);
      insert_dev(target, t11, anchor);
      insert_dev(target, ul1, anchor);
      append_dev(ul1, li1);
      append_dev(li1, t12);
      append_dev(li1, code1);
      append_dev(li1, t14);
      append_dev(ul1, t15);
      append_dev(ul1, li2);
      append_dev(ul1, t17);
      append_dev(ul1, li3);
      append_dev(li3, t18);
      append_dev(li3, code2);
      append_dev(li3, t20);
      insert_dev(target, t21, anchor);
      insert_dev(target, h22, anchor);
      append_dev(h22, t22);
      append_dev(h22, em2);
      insert_dev(target, t24, anchor);
      insert_dev(target, ul2, anchor);
      append_dev(ul2, li4);
      append_dev(li4, t25);
      append_dev(li4, code3);
      append_dev(li4, t27);
      append_dev(li4, code4);
      append_dev(li4, t29);
      append_dev(ul2, t30);
      append_dev(ul2, li5);
      insert_dev(target, t32, anchor);
      insert_dev(target, h23, anchor);
      append_dev(h23, t33);
      append_dev(h23, em3);
      insert_dev(target, t35, anchor);
      insert_dev(target, ul3, anchor);
      append_dev(ul3, li6);
      append_dev(li6, t36);
      append_dev(li6, code5);
      append_dev(li6, t38);
      append_dev(ul3, t39);
      append_dev(ul3, li7);
      append_dev(li7, t40);
      append_dev(li7, code6);
      append_dev(li7, t42);
      append_dev(ul3, t43);
      append_dev(ul3, li8);
      append_dev(ul3, t45);
      append_dev(ul3, li9);
      insert_dev(target, t47, anchor);
      insert_dev(target, h24, anchor);
      append_dev(h24, t48);
      append_dev(h24, em4);
      insert_dev(target, t50, anchor);
      insert_dev(target, ul4, anchor);
      append_dev(ul4, li10);
      append_dev(li10, t51);
      append_dev(li10, code7);
      append_dev(li10, t53);
      append_dev(li10, code8);
      append_dev(li10, t55);
      append_dev(ul4, t56);
      append_dev(ul4, li11);
      append_dev(ul4, t58);
      append_dev(ul4, li12);
      append_dev(li12, t59);
      append_dev(li12, code9);
      append_dev(li12, t61);
      append_dev(li12, code10);
      append_dev(li12, t63);
      append_dev(li12, code11);
      append_dev(li12, t65);
      append_dev(li12, code12);
      append_dev(li12, t67);
      append_dev(ul4, t68);
      append_dev(ul4, li13);
      append_dev(li13, t69);
      append_dev(li13, code13);
      append_dev(li13, t71);
      append_dev(li13, code14);
      append_dev(li13, t73);
      append_dev(ul4, t74);
      append_dev(ul4, li14);
      append_dev(li14, t75);
      append_dev(li14, code15);
      append_dev(li14, t77);
      append_dev(ul4, t78);
      append_dev(ul4, li15);
      append_dev(li15, t79);
      append_dev(li15, code16);
      append_dev(li15, t81);
      append_dev(li15, code17);
      append_dev(li15, t83);
      append_dev(li15, code18);
      append_dev(li15, t85);
      insert_dev(target, t86, anchor);
      insert_dev(target, h25, anchor);
      append_dev(h25, t87);
      append_dev(h25, em5);
      insert_dev(target, t89, anchor);
      insert_dev(target, ul5, anchor);
      append_dev(ul5, li16);
      append_dev(li16, t90);
      append_dev(li16, code19);
      append_dev(li16, t92);
      append_dev(ul5, t93);
      append_dev(ul5, li17);
      insert_dev(target, t95, anchor);
      insert_dev(target, h26, anchor);
      append_dev(h26, t96);
      append_dev(h26, em6);
      insert_dev(target, t98, anchor);
      insert_dev(target, ul6, anchor);
      append_dev(ul6, li18);
      insert_dev(target, t100, anchor);
      insert_dev(target, h27, anchor);
      append_dev(h27, t101);
      append_dev(h27, em7);
      insert_dev(target, t103, anchor);
      insert_dev(target, ul7, anchor);
      append_dev(ul7, li19);
      insert_dev(target, t105, anchor);
      insert_dev(target, h28, anchor);
      append_dev(h28, t106);
      append_dev(h28, em8);
      insert_dev(target, t108, anchor);
      insert_dev(target, ul8, anchor);
      append_dev(ul8, li20);
      append_dev(li20, t109);
      append_dev(li20, code20);
      append_dev(li20, t111);
      append_dev(li20, code21);
      append_dev(li20, t113);
      insert_dev(target, t114, anchor);
      insert_dev(target, h29, anchor);
      append_dev(h29, t115);
      append_dev(h29, em9);
      insert_dev(target, t117, anchor);
      insert_dev(target, ul9, anchor);
      append_dev(ul9, li21);
      append_dev(li21, code22);
      append_dev(li21, t119);
      append_dev(ul9, t120);
      append_dev(ul9, li22);
      append_dev(li22, code23);
      append_dev(li22, t122);
      insert_dev(target, t123, anchor);
      insert_dev(target, h210, anchor);
      append_dev(h210, t124);
      append_dev(h210, em10);
      insert_dev(target, t126, anchor);
      insert_dev(target, ul10, anchor);
      append_dev(ul10, li23);
      append_dev(li23, t127);
      append_dev(li23, code24);
      append_dev(li23, t129);
      insert_dev(target, t130, anchor);
      insert_dev(target, h211, anchor);
      append_dev(h211, t131);
      append_dev(h211, em11);
      insert_dev(target, t133, anchor);
      insert_dev(target, ul11, anchor);
      append_dev(ul11, li24);
      append_dev(ul11, t135);
      append_dev(ul11, li25);
      append_dev(li25, t136);
      append_dev(li25, code25);
      append_dev(li25, t138);
      append_dev(li25, code26);
      append_dev(li25, t140);
      insert_dev(target, t141, anchor);
      insert_dev(target, h212, anchor);
      append_dev(h212, t142);
      append_dev(h212, em12);
      insert_dev(target, t144, anchor);
      insert_dev(target, ul12, anchor);
      append_dev(ul12, li26);
      append_dev(li26, t145);
      append_dev(li26, code27);
      append_dev(li26, t147);
      insert_dev(target, t148, anchor);
      insert_dev(target, h213, anchor);
      append_dev(h213, t149);
      append_dev(h213, em13);
      insert_dev(target, t151, anchor);
      insert_dev(target, ul13, anchor);
      append_dev(ul13, li27);
      append_dev(li27, t152);
      append_dev(li27, code28);
      append_dev(li27, t154);
      append_dev(ul13, t155);
      append_dev(ul13, li28);
      append_dev(li28, t156);
      append_dev(li28, code29);
      append_dev(li28, t158);
      insert_dev(target, t159, anchor);
      insert_dev(target, h214, anchor);
      append_dev(h214, t160);
      append_dev(h214, em14);
      insert_dev(target, t162, anchor);
      insert_dev(target, ul14, anchor);
      append_dev(ul14, li29);
      append_dev(li29, t163);
      append_dev(li29, code30);
      append_dev(li29, t165);
      append_dev(ul14, t166);
      append_dev(ul14, li30);
      append_dev(li30, t167);
      append_dev(li30, code31);
      append_dev(li30, t169);
      append_dev(li30, code32);
      append_dev(li30, t171);
      append_dev(li30, code33);
      append_dev(li30, t173);
      insert_dev(target, t174, anchor);
      insert_dev(target, h215, anchor);
      append_dev(h215, t175);
      append_dev(h215, em15);
      insert_dev(target, t177, anchor);
      insert_dev(target, ul15, anchor);
      append_dev(ul15, li31);
      append_dev(li31, t178);
      append_dev(li31, code34);
      append_dev(li31, t180);
      append_dev(li31, code35);
      append_dev(li31, t182);
      insert_dev(target, t183, anchor);
      insert_dev(target, h216, anchor);
      append_dev(h216, t184);
      append_dev(h216, em16);
      insert_dev(target, t186, anchor);
      insert_dev(target, ul16, anchor);
      append_dev(ul16, li32);
      append_dev(li32, t187);
      append_dev(li32, code36);
      append_dev(li32, t189);
      append_dev(li32, code37);
      append_dev(li32, t191);
      insert_dev(target, t192, anchor);
      insert_dev(target, h217, anchor);
      append_dev(h217, t193);
      append_dev(h217, em17);
      insert_dev(target, t195, anchor);
      insert_dev(target, ul17, anchor);
      append_dev(ul17, li33);
      append_dev(li33, t196);
      append_dev(li33, code38);
      append_dev(li33, t198);
      append_dev(li33, code39);
      append_dev(li33, t200);
      insert_dev(target, t201, anchor);
      insert_dev(target, h218, anchor);
      append_dev(h218, t202);
      append_dev(h218, em18);
      insert_dev(target, t204, anchor);
      insert_dev(target, ul18, anchor);
      append_dev(ul18, li34);
      append_dev(li34, t205);
      append_dev(li34, code40);
      append_dev(li34, t207);
      append_dev(ul18, t208);
      append_dev(ul18, li35);
      append_dev(li35, t209);
      append_dev(li35, code41);
      append_dev(li35, t211);
      append_dev(li35, code42);
      append_dev(li35, t213);
      append_dev(li35, code43);
      append_dev(li35, t215);
      insert_dev(target, t216, anchor);
      insert_dev(target, h219, anchor);
      append_dev(h219, t217);
      append_dev(h219, em19);
      insert_dev(target, t219, anchor);
      insert_dev(target, ul19, anchor);
      append_dev(ul19, li36);
      append_dev(li36, t220);
      append_dev(li36, code44);
      append_dev(li36, t222);
      append_dev(ul19, t223);
      append_dev(ul19, li37);
      append_dev(li37, t224);
      append_dev(li37, code45);
      append_dev(li37, t226);
      insert_dev(target, t227, anchor);
      insert_dev(target, h220, anchor);
      append_dev(h220, t228);
      append_dev(h220, em20);
      insert_dev(target, t230, anchor);
      insert_dev(target, ul20, anchor);
      append_dev(ul20, li38);
      append_dev(li38, code46);
      append_dev(li38, t232);
      append_dev(ul20, t233);
      append_dev(ul20, li39);
      append_dev(li39, t234);
      append_dev(li39, code47);
      append_dev(li39, t236);
      append_dev(ul20, t237);
      append_dev(ul20, li40);
      insert_dev(target, t239, anchor);
      insert_dev(target, h221, anchor);
      append_dev(h221, t240);
      append_dev(h221, em21);
      insert_dev(target, t242, anchor);
      insert_dev(target, ul21, anchor);
      append_dev(ul21, li41);
      append_dev(li41, t243);
      append_dev(li41, code48);
      append_dev(li41, t245);
      insert_dev(target, t246, anchor);
      insert_dev(target, h222, anchor);
      append_dev(h222, t247);
      append_dev(h222, em22);
      insert_dev(target, t249, anchor);
      insert_dev(target, ul22, anchor);
      append_dev(ul22, li42);
      append_dev(li42, t250);
      append_dev(li42, code49);
      append_dev(li42, t252);
      insert_dev(target, t253, anchor);
      insert_dev(target, h223, anchor);
      append_dev(h223, t254);
      append_dev(h223, em23);
      insert_dev(target, t256, anchor);
      insert_dev(target, ul23, anchor);
      append_dev(ul23, li43);
      append_dev(li43, code50);
      append_dev(li43, t258);
      append_dev(li43, code51);
      append_dev(li43, t260);
      insert_dev(target, t261, anchor);
      insert_dev(target, h224, anchor);
      append_dev(h224, t262);
      append_dev(h224, em24);
      insert_dev(target, t264, anchor);
      insert_dev(target, ul24, anchor);
      append_dev(ul24, li44);
      append_dev(li44, t265);
      append_dev(li44, code52);
      append_dev(li44, t267);
      insert_dev(target, t268, anchor);
      insert_dev(target, h225, anchor);
      append_dev(h225, t269);
      append_dev(h225, em25);
      insert_dev(target, t271, anchor);
      insert_dev(target, ul25, anchor);
      append_dev(ul25, li45);
      append_dev(li45, t272);
      append_dev(li45, code53);
      append_dev(li45, t274);
      append_dev(li45, code54);
      append_dev(li45, t276);
      append_dev(li45, code55);
      append_dev(li45, t278);
      append_dev(li45, code56);
      append_dev(li45, t280);
      append_dev(ul25, t281);
      append_dev(ul25, li46);
      append_dev(li46, t282);
      append_dev(li46, code57);
      append_dev(li46, t284);
      append_dev(li46, code58);
      append_dev(li46, t286);
      append_dev(ul25, t287);
      append_dev(ul25, li47);
      append_dev(li47, t288);
      append_dev(li47, code59);
      append_dev(li47, t290);
      append_dev(li47, code60);
      append_dev(li47, t292);
      append_dev(ul25, t293);
      append_dev(ul25, li48);
      append_dev(li48, t294);
      append_dev(li48, code61);
      append_dev(li48, t296);
      append_dev(ul25, t297);
      append_dev(ul25, li49);
      insert_dev(target, t299, anchor);
      insert_dev(target, h226, anchor);
      append_dev(h226, t300);
      append_dev(h226, em26);
      insert_dev(target, t302, anchor);
      insert_dev(target, ul26, anchor);
      append_dev(ul26, li50);
      append_dev(li50, t303);
      append_dev(li50, code62);
      append_dev(li50, t305);
      append_dev(li50, code63);
      append_dev(li50, t307);
      insert_dev(target, t308, anchor);
      insert_dev(target, h227, anchor);
      append_dev(h227, t309);
      append_dev(h227, em27);
      insert_dev(target, t311, anchor);
      insert_dev(target, ul27, anchor);
      append_dev(ul27, li51);
      append_dev(li51, t312);
      append_dev(li51, code64);
      append_dev(li51, t314);
      append_dev(li51, code65);
      append_dev(li51, t316);
      append_dev(ul27, t317);
      append_dev(ul27, li52);
      append_dev(li52, t318);
      append_dev(li52, code66);
      append_dev(li52, t320);
      append_dev(ul27, t321);
      append_dev(ul27, li53);
      append_dev(li53, t322);
      append_dev(li53, code67);
      append_dev(li53, t324);
      insert_dev(target, t325, anchor);
      insert_dev(target, h228, anchor);
      append_dev(h228, t326);
      append_dev(h228, em28);
      insert_dev(target, t328, anchor);
      insert_dev(target, ul28, anchor);
      append_dev(ul28, li54);
      append_dev(li54, strong0);
      append_dev(li54, t330);
      append_dev(li54, code68);
      append_dev(li54, t332);
      append_dev(ul28, t333);
      append_dev(ul28, li55);
      append_dev(li55, code69);
      append_dev(li55, t335);
      append_dev(ul28, t336);
      append_dev(ul28, li56);
      append_dev(li56, code70);
      append_dev(li56, t338);
      append_dev(ul28, t339);
      append_dev(ul28, li57);
      append_dev(li57, t340);
      append_dev(li57, code71);
      append_dev(li57, t342);
      append_dev(li57, code72);
      append_dev(li57, t344);
      append_dev(ul28, t345);
      append_dev(ul28, li58);
      append_dev(ul28, t347);
      append_dev(ul28, li59);
      append_dev(ul28, t349);
      append_dev(ul28, li60);
      append_dev(li60, t350);
      append_dev(li60, code73);
      append_dev(li60, t352);
      append_dev(ul28, t353);
      append_dev(ul28, li61);
      append_dev(li61, t354);
      append_dev(li61, code74);
      append_dev(li61, t356);
      insert_dev(target, t357, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t359, anchor);
      insert_dev(target, ul29, anchor);
      append_dev(ul29, li62);
      append_dev(li62, t360);
      append_dev(li62, code75);
      append_dev(li62, t362);
      append_dev(li62, code76);
      append_dev(li62, t364);
      append_dev(li62, em29);
      append_dev(li62, t366);
      append_dev(li62, em30);
      append_dev(li62, t368);
      append_dev(li62, em31);
      append_dev(li62, t370);
      append_dev(li62, code77);
      append_dev(li62, t372);
      append_dev(ul29, t373);
      append_dev(ul29, li63);
      append_dev(li63, code78);
      append_dev(li63, t375);
      append_dev(li63, code79);
      append_dev(li63, t377);
      append_dev(li63, code80);
      append_dev(li63, t379);
      append_dev(li63, code81);
      append_dev(li63, t381);
      append_dev(li63, code82);
      append_dev(li63, t383);
      insert_dev(target, t384, anchor);
      insert_dev(target, hr0, anchor);
      insert_dev(target, t385, anchor);
      insert_dev(target, h229, anchor);
      append_dev(h229, t386);
      append_dev(h229, em32);
      insert_dev(target, t388, anchor);
      insert_dev(target, ul30, anchor);
      append_dev(ul30, li64);
      append_dev(li64, t389);
      append_dev(li64, code83);
      append_dev(li64, t391);
      append_dev(ul30, t392);
      append_dev(ul30, li65);
      append_dev(li65, t393);
      append_dev(li65, code84);
      append_dev(li65, t395);
      append_dev(ul30, t396);
      append_dev(ul30, li66);
      append_dev(li66, t397);
      append_dev(li66, code85);
      append_dev(li66, t399);
      append_dev(li66, code86);
      append_dev(li66, t401);
      append_dev(ul30, t402);
      append_dev(ul30, li67);
      insert_dev(target, t404, anchor);
      insert_dev(target, h230, anchor);
      append_dev(h230, t405);
      append_dev(h230, em33);
      insert_dev(target, t407, anchor);
      insert_dev(target, ul31, anchor);
      append_dev(ul31, li68);
      append_dev(li68, t408);
      append_dev(li68, code87);
      append_dev(li68, t410);
      insert_dev(target, t411, anchor);
      insert_dev(target, h231, anchor);
      append_dev(h231, t412);
      append_dev(h231, em34);
      insert_dev(target, t414, anchor);
      insert_dev(target, ul32, anchor);
      append_dev(ul32, li69);
      append_dev(li69, strong1);
      append_dev(li69, t416);
      append_dev(li69, code88);
      append_dev(li69, t418);
      append_dev(li69, code89);
      append_dev(li69, t420);
      append_dev(li69, code90);
      append_dev(li69, t422);
      append_dev(ul32, t423);
      append_dev(ul32, li70);
      append_dev(ul32, t425);
      append_dev(ul32, li71);
      append_dev(li71, t426);
      append_dev(li71, code91);
      append_dev(li71, t428);
      append_dev(li71, code92);
      append_dev(li71, t430);
      insert_dev(target, t431, anchor);
      insert_dev(target, h232, anchor);
      append_dev(h232, t432);
      append_dev(h232, em35);
      insert_dev(target, t434, anchor);
      insert_dev(target, ul33, anchor);
      append_dev(ul33, li72);
      append_dev(li72, t435);
      append_dev(li72, code93);
      append_dev(li72, t437);
      append_dev(li72, code94);
      append_dev(li72, t439);
      append_dev(ul33, t440);
      append_dev(ul33, li73);
      append_dev(li73, code95);
      append_dev(li73, t442);
      append_dev(ul33, t443);
      append_dev(ul33, li74);
      append_dev(li74, code96);
      append_dev(li74, t445);
      append_dev(li74, code97);
      append_dev(li74, t447);
      insert_dev(target, t448, anchor);
      insert_dev(target, h233, anchor);
      append_dev(h233, t449);
      append_dev(h233, em36);
      insert_dev(target, t451, anchor);
      insert_dev(target, ul34, anchor);
      append_dev(ul34, li75);
      append_dev(li75, t452);
      append_dev(li75, code98);
      append_dev(li75, t454);
      append_dev(ul34, t455);
      append_dev(ul34, li76);
      append_dev(li76, t456);
      append_dev(li76, code99);
      append_dev(li76, t458);
      append_dev(li76, code100);
      append_dev(li76, t460);
      append_dev(li76, code101);
      append_dev(li76, t462);
      append_dev(li76, code102);
      append_dev(li76, t464);
      append_dev(li76, code103);
      append_dev(li76, t466);
      append_dev(ul34, t467);
      append_dev(ul34, li77);
      append_dev(li77, t468);
      append_dev(li77, code104);
      append_dev(li77, t470);
      append_dev(ul34, t471);
      append_dev(ul34, li78);
      append_dev(li78, code105);
      append_dev(li78, t473);
      append_dev(li78, code106);
      append_dev(li78, t475);
      append_dev(ul34, t476);
      append_dev(ul34, li79);
      append_dev(li79, t477);
      append_dev(li79, code107);
      append_dev(li79, t479);
      append_dev(ul34, t480);
      append_dev(ul34, li80);
      append_dev(li80, t481);
      append_dev(li80, code108);
      append_dev(li80, t483);
      append_dev(ul34, t484);
      append_dev(ul34, li81);
      append_dev(li81, t485);
      append_dev(li81, code109);
      append_dev(li81, t487);
      insert_dev(target, t488, anchor);
      insert_dev(target, h234, anchor);
      append_dev(h234, t489);
      append_dev(h234, em37);
      insert_dev(target, t491, anchor);
      insert_dev(target, ul35, anchor);
      append_dev(ul35, li82);
      append_dev(li82, t492);
      append_dev(li82, code110);
      append_dev(li82, t494);
      append_dev(li82, code111);
      append_dev(li82, t496);
      append_dev(ul35, t497);
      append_dev(ul35, li83);
      append_dev(li83, t498);
      append_dev(li83, code112);
      append_dev(li83, t500);
      append_dev(li83, code113);
      append_dev(li83, t502);
      append_dev(ul35, t503);
      append_dev(ul35, li84);
      append_dev(li84, t504);
      append_dev(li84, code114);
      append_dev(li84, t506);
      append_dev(ul35, t507);
      append_dev(ul35, li85);
      append_dev(ul35, t509);
      append_dev(ul35, li86);
      append_dev(li86, t510);
      append_dev(li86, code115);
      append_dev(li86, t512);
      append_dev(li86, code116);
      append_dev(li86, t514);
      append_dev(li86, code117);
      append_dev(li86, t516);
      append_dev(ul35, t517);
      append_dev(ul35, li87);
      append_dev(li87, t518);
      append_dev(li87, code118);
      append_dev(li87, t520);
      append_dev(ul35, t521);
      append_dev(ul35, li88);
      append_dev(ul35, t523);
      append_dev(ul35, li89);
      append_dev(li89, t524);
      append_dev(li89, code119);
      append_dev(li89, t526);
      append_dev(li89, code120);
      append_dev(li89, t528);
      insert_dev(target, t529, anchor);
      insert_dev(target, h235, anchor);
      append_dev(h235, t530);
      append_dev(h235, em38);
      insert_dev(target, t532, anchor);
      insert_dev(target, ul36, anchor);
      append_dev(ul36, li90);
      append_dev(li90, strong2);
      append_dev(li90, t534);
      append_dev(li90, code121);
      append_dev(li90, t536);
      append_dev(li90, code122);
      append_dev(li90, t538);
      append_dev(ul36, t539);
      append_dev(ul36, li91);
      append_dev(li91, t540);
      append_dev(li91, code123);
      append_dev(li91, t542);
      insert_dev(target, t543, anchor);
      insert_dev(target, h236, anchor);
      append_dev(h236, t544);
      append_dev(h236, em39);
      insert_dev(target, t546, anchor);
      insert_dev(target, ul37, anchor);
      append_dev(ul37, li92);
      append_dev(li92, code124);
      append_dev(li92, t548);
      append_dev(li92, code125);
      append_dev(li92, t550);
      append_dev(li92, code126);
      append_dev(li92, t552);
      append_dev(ul37, t553);
      append_dev(ul37, li93);
      append_dev(li93, code127);
      append_dev(li93, t555);
      append_dev(li93, code128);
      append_dev(li93, t557);
      append_dev(li93, code129);
      append_dev(li93, t559);
      append_dev(li93, code130);
      append_dev(li93, t561);
      insert_dev(target, t562, anchor);
      insert_dev(target, h237, anchor);
      append_dev(h237, t563);
      append_dev(h237, em40);
      insert_dev(target, t565, anchor);
      insert_dev(target, ul38, anchor);
      append_dev(ul38, li94);
      append_dev(li94, t566);
      append_dev(li94, code131);
      append_dev(li94, t568);
      append_dev(ul38, t569);
      append_dev(ul38, li95);
      insert_dev(target, t571, anchor);
      insert_dev(target, h238, anchor);
      append_dev(h238, t572);
      append_dev(h238, em41);
      insert_dev(target, t574, anchor);
      insert_dev(target, ul39, anchor);
      append_dev(ul39, li96);
      append_dev(li96, code132);
      append_dev(li96, t576);
      append_dev(ul39, t577);
      append_dev(ul39, li97);
      append_dev(li97, t578);
      append_dev(li97, code133);
      append_dev(li97, t580);
      append_dev(ul39, t581);
      append_dev(ul39, li98);
      append_dev(ul39, t583);
      append_dev(ul39, li99);
      append_dev(ul39, t585);
      append_dev(ul39, li100);
      append_dev(ul39, t587);
      append_dev(ul39, li101);
      append_dev(li101, t588);
      append_dev(li101, code134);
      append_dev(li101, t590);
      insert_dev(target, t591, anchor);
      insert_dev(target, h239, anchor);
      append_dev(h239, t592);
      append_dev(h239, em42);
      insert_dev(target, t594, anchor);
      insert_dev(target, ul40, anchor);
      append_dev(ul40, li102);
      append_dev(ul40, t596);
      append_dev(ul40, li103);
      insert_dev(target, t598, anchor);
      insert_dev(target, h240, anchor);
      append_dev(h240, t599);
      append_dev(h240, em43);
      insert_dev(target, t601, anchor);
      insert_dev(target, ul41, anchor);
      append_dev(ul41, li104);
      append_dev(li104, t602);
      append_dev(li104, code135);
      append_dev(li104, t604);
      append_dev(li104, code136);
      append_dev(li104, t606);
      append_dev(ul41, t607);
      append_dev(ul41, li105);
      append_dev(li105, code137);
      append_dev(li105, t609);
      append_dev(li105, code138);
      append_dev(li105, t611);
      append_dev(ul41, t612);
      append_dev(ul41, li106);
      append_dev(li106, code139);
      append_dev(li106, t614);
      append_dev(li106, code140);
      append_dev(li106, t616);
      insert_dev(target, t617, anchor);
      insert_dev(target, h241, anchor);
      append_dev(h241, t618);
      append_dev(h241, em44);
      insert_dev(target, t620, anchor);
      insert_dev(target, ul42, anchor);
      append_dev(ul42, li107);
      append_dev(li107, strong3);
      append_dev(li107, t622);
      append_dev(li107, code141);
      append_dev(li107, t624);
      insert_dev(target, t625, anchor);
      insert_dev(target, h242, anchor);
      append_dev(h242, t626);
      append_dev(h242, em45);
      insert_dev(target, t628, anchor);
      insert_dev(target, ul43, anchor);
      append_dev(ul43, li108);
      append_dev(li108, strong4);
      append_dev(li108, t630);
      append_dev(li108, code142);
      append_dev(li108, t632);
      append_dev(li108, code143);
      append_dev(li108, t634);
      append_dev(li108, code144);
      append_dev(li108, t636);
      append_dev(ul43, t637);
      append_dev(ul43, li109);
      append_dev(ul43, t639);
      append_dev(ul43, li110);
      insert_dev(target, t641, anchor);
      insert_dev(target, h243, anchor);
      append_dev(h243, t642);
      append_dev(h243, em46);
      insert_dev(target, t644, anchor);
      insert_dev(target, ul44, anchor);
      append_dev(ul44, li111);
      append_dev(li111, strong5);
      append_dev(li111, t646);
      append_dev(li111, code145);
      append_dev(li111, t648);
      append_dev(ul44, t649);
      append_dev(ul44, li112);
      append_dev(li112, strong6);
      append_dev(li112, t651);
      append_dev(li112, code146);
      append_dev(li112, t653);
      append_dev(li112, code147);
      append_dev(li112, t655);
      append_dev(ul44, t656);
      append_dev(ul44, li113);
      append_dev(li113, strong7);
      append_dev(li113, t658);
      append_dev(li113, code148);
      append_dev(li113, t660);
      append_dev(li113, code149);
      append_dev(li113, t662);
      append_dev(li113, code150);
      append_dev(li113, t664);
      append_dev(li113, code151);
      append_dev(li113, t666);
      append_dev(li113, code152);
      append_dev(li113, t668);
      append_dev(li113, code153);
      append_dev(li113, t670);
      append_dev(li113, code154);
      append_dev(li113, t672);
      append_dev(li113, code155);
      append_dev(li113, t674);
      append_dev(ul44, t675);
      append_dev(ul44, li114);
      append_dev(li114, strong8);
      append_dev(li114, t677);
      append_dev(li114, code156);
      append_dev(li114, t679);
      append_dev(li114, code157);
      append_dev(li114, t681);
      append_dev(li114, code158);
      append_dev(li114, t683);
      append_dev(li114, code159);
      append_dev(li114, t685);
      append_dev(ul44, t686);
      append_dev(ul44, li115);
      append_dev(li115, t687);
      append_dev(li115, code160);
      append_dev(li115, t689);
      append_dev(li115, code161);
      append_dev(li115, t691);
      append_dev(ul44, t692);
      append_dev(ul44, li116);
      append_dev(li116, t693);
      append_dev(li116, code162);
      append_dev(li116, t695);
      append_dev(li116, code163);
      append_dev(li116, t697);
      append_dev(ul44, t698);
      append_dev(ul44, li117);
      append_dev(li117, t699);
      append_dev(li117, code164);
      append_dev(li117, t701);
      append_dev(li117, code165);
      append_dev(li117, t703);
      append_dev(ul44, t704);
      append_dev(ul44, li118);
      append_dev(li118, t705);
      append_dev(li118, code166);
      append_dev(li118, t707);
      append_dev(li118, code167);
      append_dev(li118, t709);
      insert_dev(target, t710, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t712, anchor);
      insert_dev(target, ul45, anchor);
      append_dev(ul45, li119);
      append_dev(ul45, t714);
      append_dev(ul45, li120);
      append_dev(li120, code168);
      append_dev(li120, t716);
      append_dev(li120, code169);
      append_dev(li120, t718);
      append_dev(ul45, t719);
      append_dev(ul45, li121);
      append_dev(li121, code170);
      append_dev(li121, t721);
      append_dev(li121, code171);
      append_dev(li121, t723);
      append_dev(ul45, t724);
      append_dev(ul45, li122);
      append_dev(li122, code172);
      append_dev(li122, t726);
      append_dev(li122, code173);
      append_dev(li122, t728);
      append_dev(ul45, t729);
      append_dev(ul45, li123);
      append_dev(li123, code174);
      append_dev(li123, t731);
      append_dev(li123, code175);
      append_dev(li123, t733);
      append_dev(li123, code176);
      append_dev(ul45, t735);
      append_dev(ul45, li124);
      append_dev(li124, code177);
      append_dev(li124, t737);
      append_dev(li124, code178);
      append_dev(li124, t739);
      append_dev(li124, code179);
      append_dev(ul45, t741);
      append_dev(ul45, li125);
      append_dev(li125, code180);
      append_dev(li125, t743);
      append_dev(li125, code181);
      append_dev(li125, t745);
      append_dev(li125, code182);
      append_dev(ul45, t747);
      append_dev(ul45, li126);
      append_dev(li126, code183);
      append_dev(li126, t749);
      append_dev(li126, code184);
      append_dev(li126, t751);
      append_dev(ul45, t752);
      append_dev(ul45, li127);
      append_dev(li127, t753);
      append_dev(li127, code185);
      append_dev(li127, t755);
      append_dev(li127, code186);
      append_dev(li127, t757);
      append_dev(li127, code187);
      append_dev(li127, t759);
      append_dev(li127, code188);
      append_dev(li127, t761);
      append_dev(li127, code189);
      append_dev(li127, t763);
      append_dev(li127, code190);
      append_dev(li127, t765);
      append_dev(li127, code191);
      insert_dev(target, t767, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t769, anchor);
      insert_dev(target, ul46, anchor);
      append_dev(ul46, li128);
      append_dev(li128, code192);
      append_dev(li128, t771);
      append_dev(li128, code193);
      append_dev(ul46, t773);
      append_dev(ul46, li129);
      append_dev(li129, code194);
      append_dev(li129, t775);
      append_dev(li129, code195);
      append_dev(ul46, t777);
      append_dev(ul46, li130);
      append_dev(li130, code196);
      append_dev(li130, t779);
      append_dev(li130, code197);
      append_dev(ul46, t781);
      append_dev(ul46, li131);
      append_dev(li131, code198);
      append_dev(li131, t783);
      append_dev(li131, code199);
      append_dev(ul46, t785);
      append_dev(ul46, li132);
      append_dev(li132, code200);
      append_dev(li132, t787);
      append_dev(li132, code201);
      append_dev(ul46, t789);
      append_dev(ul46, li133);
      append_dev(li133, code202);
      append_dev(li133, t791);
      append_dev(li133, code203);
      append_dev(ul46, t793);
      append_dev(ul46, li134);
      append_dev(li134, code204);
      append_dev(li134, t795);
      append_dev(li134, code205);
      insert_dev(target, t797, anchor);
      insert_dev(target, p, anchor);
      append_dev(p, t798);
      append_dev(p, code206);
      append_dev(p, t800);
      append_dev(p, code207);
      append_dev(p, t802);
      insert_dev(target, t803, anchor);
      insert_dev(target, hr1, anchor);
      insert_dev(target, t804, anchor);
      insert_dev(target, h244, anchor);
      append_dev(h244, t805);
      append_dev(h244, em47);
      insert_dev(target, t807, anchor);
      insert_dev(target, ul47, anchor);
      append_dev(ul47, li135);
      append_dev(li135, t808);
      append_dev(li135, code208);
      append_dev(li135, t810);
      insert_dev(target, t811, anchor);
      insert_dev(target, h245, anchor);
      append_dev(h245, t812);
      append_dev(h245, em48);
      insert_dev(target, t814, anchor);
      insert_dev(target, ul48, anchor);
      append_dev(ul48, li136);
      append_dev(li136, t815);
      append_dev(li136, code209);
      append_dev(li136, t817);
      insert_dev(target, t818, anchor);
      insert_dev(target, h246, anchor);
      append_dev(h246, t819);
      append_dev(h246, em49);
      insert_dev(target, t821, anchor);
      insert_dev(target, ul49, anchor);
      append_dev(ul49, li137);
      append_dev(li137, t822);
      append_dev(li137, code210);
      append_dev(li137, t824);
      append_dev(li137, code211);
      append_dev(li137, t826);
      append_dev(li137, code212);
      append_dev(li137, t828);
      insert_dev(target, t829, anchor);
      insert_dev(target, h247, anchor);
      append_dev(h247, t830);
      append_dev(h247, em50);
      insert_dev(target, t832, anchor);
      insert_dev(target, ul50, anchor);
      append_dev(ul50, li138);
      append_dev(li138, t833);
      append_dev(li138, code213);
      append_dev(li138, t835);
      append_dev(li138, code214);
      append_dev(li138, t837);
      append_dev(ul50, t838);
      append_dev(ul50, li139);
      insert_dev(target, t840, anchor);
      insert_dev(target, h248, anchor);
      append_dev(h248, t841);
      append_dev(h248, em51);
      insert_dev(target, t843, anchor);
      insert_dev(target, ul51, anchor);
      append_dev(ul51, li140);
      append_dev(li140, code215);
      append_dev(li140, t845);
      append_dev(li140, code216);
      append_dev(li140, t847);
      append_dev(li140, code217);
      append_dev(li140, t849);
      append_dev(li140, code218);
      append_dev(li140, t851);
      append_dev(ul51, t852);
      append_dev(ul51, li141);
      insert_dev(target, t854, anchor);
      insert_dev(target, h249, anchor);
      append_dev(h249, t855);
      append_dev(h249, em52);
      insert_dev(target, t857, anchor);
      insert_dev(target, ul52, anchor);
      append_dev(ul52, li142);
      append_dev(li142, strong9);
      append_dev(li142, t859);
      append_dev(li142, a0);
      append_dev(li142, t861);
      append_dev(ul52, t862);
      append_dev(ul52, li143);
      append_dev(li143, strong10);
      append_dev(li143, t864);
      append_dev(li143, a1);
      append_dev(li143, t866);
      append_dev(li143, a2);
      append_dev(li143, t868);
      append_dev(li143, a3);
      append_dev(li143, t870);
      append_dev(ul52, t871);
      append_dev(ul52, li144);
      append_dev(li144, strong11);
      append_dev(li144, t873);
      append_dev(li144, code219);
      append_dev(li144, t875);
      append_dev(li144, code220);
      append_dev(li144, t877);
      append_dev(li144, code221);
      append_dev(li144, t879);
      append_dev(li144, code222);
      append_dev(li144, t881);
      append_dev(li144, code223);
      append_dev(li144, t883);
      append_dev(li144, code224);
      append_dev(li144, t885);
      append_dev(li144, code225);
      append_dev(li144, t887);
      append_dev(li144, code226);
      append_dev(li144, t889);
      append_dev(li144, code227);
      append_dev(li144, t891);
      append_dev(ul52, t892);
      append_dev(ul52, li145);
      append_dev(li145, strong12);
      append_dev(li145, t894);
      append_dev(li145, code228);
      append_dev(li145, t896);
      append_dev(li145, code229);
      append_dev(li145, t898);
      insert_dev(target, t899, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t901, anchor);
      insert_dev(target, h40, anchor);
      insert_dev(target, t903, anchor);
      insert_dev(target, ul53, anchor);
      append_dev(ul53, li146);
      append_dev(li146, t904);
      append_dev(li146, code230);
      append_dev(li146, t906);
      append_dev(li146, code231);
      append_dev(ul53, t908);
      append_dev(ul53, li147);
      append_dev(li147, code232);
      append_dev(li147, t910);
      append_dev(li147, code233);
      append_dev(li147, t912);
      append_dev(li147, code234);
      insert_dev(target, t914, anchor);
      insert_dev(target, h41, anchor);
      insert_dev(target, t916, anchor);
      insert_dev(target, ul54, anchor);
      append_dev(ul54, li148);
      append_dev(li148, t917);
      append_dev(li148, code235);
      append_dev(li148, t919);
      append_dev(li148, code236);
      insert_dev(target, t921, anchor);
      insert_dev(target, h42, anchor);
      insert_dev(target, t923, anchor);
      insert_dev(target, ul55, anchor);
      append_dev(ul55, li149);
      append_dev(li149, t924);
      append_dev(li149, code237);
      append_dev(li149, t926);
      append_dev(li149, code238);
      insert_dev(target, t928, anchor);
      insert_dev(target, h43, anchor);
      insert_dev(target, t930, anchor);
      insert_dev(target, ul56, anchor);
      append_dev(ul56, li150);
      append_dev(li150, t931);
      append_dev(li150, code239);
      append_dev(li150, t933);
      append_dev(li150, code240);
      insert_dev(target, t935, anchor);
      insert_dev(target, h44, anchor);
      insert_dev(target, t937, anchor);
      insert_dev(target, ul57, anchor);
      append_dev(ul57, li151);
      append_dev(li151, code241);
      append_dev(li151, t939);
      append_dev(li151, code242);
      insert_dev(target, t941, anchor);
      insert_dev(target, hr2, anchor);
      insert_dev(target, t942, anchor);
      insert_dev(target, h250, anchor);
      append_dev(h250, t943);
      append_dev(h250, em53);
      insert_dev(target, t945, anchor);
      insert_dev(target, ul58, anchor);
      append_dev(ul58, li152);
      append_dev(li152, t946);
      append_dev(li152, code243);
      append_dev(li152, t948);
      append_dev(ul58, t949);
      append_dev(ul58, li153);
      append_dev(li153, t950);
      append_dev(li153, code244);
      append_dev(li153, t952);
      insert_dev(target, t953, anchor);
      insert_dev(target, h251, anchor);
      append_dev(h251, t954);
      append_dev(h251, em54);
      insert_dev(target, t956, anchor);
      insert_dev(target, ul59, anchor);
      append_dev(ul59, li154);
      append_dev(li154, strong13);
      append_dev(li154, t958);
      append_dev(li154, code245);
      append_dev(li154, t960);
      append_dev(li154, code246);
      append_dev(li154, t962);
      append_dev(li154, code247);
      append_dev(li154, t964);
      insert_dev(target, t965, anchor);
      insert_dev(target, h252, anchor);
      append_dev(h252, t966);
      append_dev(h252, em55);
      insert_dev(target, t968, anchor);
      insert_dev(target, ul60, anchor);
      append_dev(ul60, li155);
      append_dev(li155, t969);
      append_dev(li155, code248);
      append_dev(li155, t971);
      insert_dev(target, t972, anchor);
      insert_dev(target, h253, anchor);
      append_dev(h253, t973);
      append_dev(h253, em56);
      insert_dev(target, t975, anchor);
      insert_dev(target, ul62, anchor);
      append_dev(ul62, li156);
      append_dev(li156, strong14);
      append_dev(li156, t977);
      append_dev(li156, code249);
      append_dev(li156, t979);
      append_dev(li156, code250);
      append_dev(li156, t981);
      append_dev(ul62, t982);
      append_dev(ul62, li157);
      append_dev(li157, code251);
      append_dev(li157, t984);
      append_dev(li157, strong15);
      append_dev(li157, t986);
      append_dev(ul62, t987);
      append_dev(ul62, li162);
      append_dev(li162, code252);
      append_dev(li162, t989);
      append_dev(li162, ul61);
      append_dev(ul61, li158);
      append_dev(li158, t990);
      append_dev(li158, code253);
      append_dev(li158, t992);
      append_dev(li158, code254);
      append_dev(li158, t994);
      append_dev(ul61, t995);
      append_dev(ul61, li159);
      append_dev(li159, t996);
      append_dev(li159, code255);
      append_dev(li159, t998);
      append_dev(ul61, t999);
      append_dev(ul61, li160);
      append_dev(li160, t1000);
      append_dev(li160, code256);
      append_dev(li160, t1002);
      append_dev(li160, code257);
      append_dev(li160, t1004);
      append_dev(li160, code258);
      append_dev(li160, t1006);
      append_dev(ul61, t1007);
      append_dev(ul61, li161);
      append_dev(li161, t1008);
      append_dev(li161, code259);
      append_dev(li161, t1010);
      append_dev(li161, code260);
      append_dev(li161, t1012);
      insert_dev(target, t1013, anchor);
      insert_dev(target, h254, anchor);
      append_dev(h254, t1014);
      append_dev(h254, em57);
      insert_dev(target, t1016, anchor);
      insert_dev(target, ul64, anchor);
      append_dev(ul64, li166);
      append_dev(li166, code261);
      append_dev(li166, t1018);
      append_dev(li166, ul63);
      append_dev(ul63, li163);
      append_dev(li163, code262);
      append_dev(li163, t1020);
      append_dev(li163, code263);
      append_dev(li163, t1022);
      append_dev(ul63, t1023);
      append_dev(ul63, li164);
      append_dev(ul63, t1025);
      append_dev(ul63, li165);
      append_dev(li165, t1026);
      append_dev(li165, code264);
      append_dev(li165, t1028);
      append_dev(li165, code265);
      append_dev(li165, t1030);
      append_dev(li165, code266);
      append_dev(li165, t1032);
      append_dev(li165, code267);
      append_dev(li165, t1034);
      insert_dev(target, t1035, anchor);
      insert_dev(target, h255, anchor);
      append_dev(h255, t1036);
      append_dev(h255, em58);
      insert_dev(target, t1038, anchor);
      insert_dev(target, ul66, anchor);
      append_dev(ul66, li170);
      append_dev(li170, code268);
      append_dev(li170, t1040);
      append_dev(li170, ul65);
      append_dev(ul65, li167);
      append_dev(ul65, t1042);
      append_dev(ul65, li168);
      append_dev(li168, t1043);
      append_dev(li168, code269);
      append_dev(li168, t1045);
      append_dev(ul65, t1046);
      append_dev(ul65, li169);
      insert_dev(target, t1048, anchor);
      insert_dev(target, h256, anchor);
      append_dev(h256, t1049);
      append_dev(h256, em59);
      insert_dev(target, t1051, anchor);
      insert_dev(target, ul67, anchor);
      append_dev(ul67, li171);
      append_dev(li171, t1052);
      append_dev(li171, code270);
      append_dev(li171, t1054);
      insert_dev(target, t1055, anchor);
      insert_dev(target, h257, anchor);
      append_dev(h257, t1056);
      append_dev(h257, em60);
      insert_dev(target, t1058, anchor);
      insert_dev(target, ul68, anchor);
      append_dev(ul68, li172);
      append_dev(li172, t1059);
      append_dev(li172, code271);
      append_dev(li172, t1061);
      append_dev(ul68, t1062);
      append_dev(ul68, li173);
      append_dev(li173, code272);
      append_dev(li173, t1064);
      insert_dev(target, t1065, anchor);
      insert_dev(target, h258, anchor);
      append_dev(h258, t1066);
      append_dev(h258, em61);
      insert_dev(target, t1068, anchor);
      insert_dev(target, ul69, anchor);
      append_dev(ul69, li174);
      append_dev(li174, code273);
      append_dev(li174, t1070);
      append_dev(ul69, t1071);
      append_dev(ul69, li175);
      append_dev(li175, code274);
      append_dev(li175, t1073);
      append_dev(ul69, t1074);
      append_dev(ul69, li176);
      append_dev(li176, code275);
      append_dev(li176, t1076);
      append_dev(li176, code276);
      append_dev(li176, t1078);
      insert_dev(target, t1079, anchor);
      insert_dev(target, h259, anchor);
      append_dev(h259, t1080);
      append_dev(h259, em62);
      insert_dev(target, t1082, anchor);
      insert_dev(target, ul70, anchor);
      append_dev(ul70, li177);
      append_dev(ul70, t1084);
      append_dev(ul70, li178);
      append_dev(ul70, t1086);
      append_dev(ul70, li179);
      append_dev(ul70, t1088);
      append_dev(ul70, li180);
      append_dev(li180, t1089);
      append_dev(li180, code277);
      append_dev(li180, t1091);
      append_dev(li180, code278);
      append_dev(li180, t1093);
      insert_dev(target, t1094, anchor);
      insert_dev(target, h260, anchor);
      append_dev(h260, t1095);
      append_dev(h260, em63);
      insert_dev(target, t1097, anchor);
      insert_dev(target, ul71, anchor);
      append_dev(ul71, li181);
      insert_dev(target, t1099, anchor);
      insert_dev(target, h261, anchor);
      append_dev(h261, t1100);
      append_dev(h261, em64);
      insert_dev(target, t1102, anchor);
      insert_dev(target, ul72, anchor);
      append_dev(ul72, li182);
      append_dev(li182, code279);
      append_dev(li182, t1104);
      append_dev(li182, code280);
      append_dev(li182, t1106);
      append_dev(li182, code281);
      append_dev(li182, t1108);
      insert_dev(target, t1109, anchor);
      insert_dev(target, h262, anchor);
      append_dev(h262, t1110);
      append_dev(h262, em65);
      insert_dev(target, t1112, anchor);
      insert_dev(target, ul73, anchor);
      append_dev(ul73, li183);
      append_dev(ul73, t1114);
      append_dev(ul73, li184);
      append_dev(li184, t1115);
      append_dev(li184, code282);
      append_dev(li184, t1117);
      append_dev(li184, code283);
      append_dev(li184, t1119);
      append_dev(li184, code284);
      append_dev(li184, t1121);
      append_dev(ul73, t1122);
      append_dev(ul73, li185);
      insert_dev(target, t1124, anchor);
      insert_dev(target, h263, anchor);
      append_dev(h263, t1125);
      append_dev(h263, em66);
      insert_dev(target, t1127, anchor);
      insert_dev(target, ul74, anchor);
      append_dev(ul74, li186);
      append_dev(li186, t1128);
      append_dev(li186, code285);
      append_dev(li186, t1130);
      append_dev(ul74, t1131);
      append_dev(ul74, li187);
      append_dev(li187, code286);
      append_dev(li187, t1133);
      insert_dev(target, t1134, anchor);
      insert_dev(target, h264, anchor);
      append_dev(h264, t1135);
      append_dev(h264, em67);
      insert_dev(target, t1137, anchor);
      insert_dev(target, ul75, anchor);
      append_dev(ul75, li188);
      append_dev(ul75, t1139);
      append_dev(ul75, li189);
      append_dev(li189, t1140);
      append_dev(li189, code287);
      append_dev(li189, t1142);
      append_dev(ul75, t1143);
      append_dev(ul75, li190);
      append_dev(li190, t1144);
      append_dev(li190, code288);
      append_dev(li190, t1146);
      insert_dev(target, t1147, anchor);
      insert_dev(target, h265, anchor);
      append_dev(h265, t1148);
      append_dev(h265, em68);
      insert_dev(target, t1150, anchor);
      insert_dev(target, ul76, anchor);
      append_dev(ul76, li191);
      insert_dev(target, t1152, anchor);
      insert_dev(target, h266, anchor);
      append_dev(h266, t1153);
      append_dev(h266, em69);
      insert_dev(target, t1155, anchor);
      insert_dev(target, ul77, anchor);
      append_dev(ul77, li192);
      append_dev(li192, t1156);
      append_dev(li192, code289);
      append_dev(li192, t1158);
      append_dev(li192, code290);
      append_dev(li192, t1160);
      append_dev(ul77, t1161);
      append_dev(ul77, li193);
      append_dev(li193, t1162);
      append_dev(li193, code291);
      append_dev(li193, t1164);
      insert_dev(target, t1165, anchor);
      insert_dev(target, h267, anchor);
      append_dev(h267, t1166);
      append_dev(h267, em70);
      insert_dev(target, t1168, anchor);
      insert_dev(target, ul78, anchor);
      append_dev(ul78, li194);
      append_dev(li194, code292);
      append_dev(li194, t1170);
      append_dev(ul78, t1171);
      append_dev(ul78, li195);
      append_dev(li195, t1172);
      append_dev(li195, code293);
      append_dev(li195, t1174);
      insert_dev(target, t1175, anchor);
      insert_dev(target, h268, anchor);
      append_dev(h268, t1176);
      append_dev(h268, em71);
      insert_dev(target, t1178, anchor);
      insert_dev(target, ul79, anchor);
      append_dev(ul79, li196);
      insert_dev(target, t1180, anchor);
      insert_dev(target, h269, anchor);
      append_dev(h269, t1181);
      append_dev(h269, em72);
      insert_dev(target, t1183, anchor);
      insert_dev(target, ul80, anchor);
      append_dev(ul80, li197);
      append_dev(li197, code294);
      append_dev(li197, t1185);
      append_dev(ul80, t1186);
      append_dev(ul80, li198);
      append_dev(li198, code295);
      append_dev(li198, t1188);
      append_dev(li198, code296);
      append_dev(li198, t1190);
      insert_dev(target, t1191, anchor);
      insert_dev(target, h270, anchor);
      append_dev(h270, t1192);
      append_dev(h270, em73);
      insert_dev(target, t1194, anchor);
      insert_dev(target, ul81, anchor);
      append_dev(ul81, li199);
      append_dev(ul81, t1196);
      append_dev(ul81, li200);
      append_dev(ul81, t1198);
      append_dev(ul81, li201);
      append_dev(ul81, t1200);
      append_dev(ul81, li202);
      append_dev(li202, t1201);
      append_dev(li202, code297);
      append_dev(li202, t1203);
      append_dev(li202, code298);
      append_dev(li202, t1205);
      append_dev(li202, code299);
      append_dev(li202, t1207);
      append_dev(ul81, t1208);
      append_dev(ul81, li203);
      append_dev(li203, t1209);
      append_dev(li203, code300);
      append_dev(li203, t1211);
      append_dev(li203, code301);
      append_dev(li203, t1213);
      insert_dev(target, t1214, anchor);
      insert_dev(target, h271, anchor);
      append_dev(h271, t1215);
      append_dev(h271, em74);
      insert_dev(target, t1217, anchor);
      insert_dev(target, ul82, anchor);
      append_dev(ul82, li204);
      append_dev(li204, code302);
      append_dev(li204, t1219);
      append_dev(li204, code303);
      append_dev(li204, t1221);
      append_dev(ul82, t1222);
      append_dev(ul82, li205);
      append_dev(li205, code304);
      append_dev(li205, t1224);
      append_dev(li205, code305);
      append_dev(li205, t1226);
      append_dev(li205, code306);
      append_dev(li205, t1228);
      append_dev(li205, code307);
      append_dev(li205, t1230);
      insert_dev(target, t1231, anchor);
      insert_dev(target, h272, anchor);
      append_dev(h272, t1232);
      append_dev(h272, em75);
      insert_dev(target, t1234, anchor);
      insert_dev(target, ul83, anchor);
      append_dev(ul83, li206);
      append_dev(li206, code308);
      append_dev(li206, t1236);
      append_dev(ul83, t1237);
      append_dev(ul83, li207);
      append_dev(li207, code309);
      append_dev(li207, t1239);
      insert_dev(target, t1240, anchor);
      insert_dev(target, h273, anchor);
      append_dev(h273, t1241);
      append_dev(h273, em76);
      insert_dev(target, t1243, anchor);
      insert_dev(target, ul84, anchor);
      append_dev(ul84, li208);
      append_dev(li208, code310);
      append_dev(li208, t1245);
      insert_dev(target, t1246, anchor);
      insert_dev(target, h274, anchor);
      append_dev(h274, t1247);
      append_dev(h274, em77);
      insert_dev(target, t1249, anchor);
      insert_dev(target, ul85, anchor);
      append_dev(ul85, li209);
      append_dev(li209, t1250);
      append_dev(li209, code311);
      append_dev(li209, t1252);
      insert_dev(target, t1253, anchor);
      insert_dev(target, h275, anchor);
      append_dev(h275, t1254);
      append_dev(h275, em78);
      insert_dev(target, t1256, anchor);
      insert_dev(target, ul86, anchor);
      append_dev(ul86, li210);
      append_dev(li210, t1257);
      append_dev(li210, code312);
      append_dev(li210, t1259);
      insert_dev(target, t1260, anchor);
      insert_dev(target, h276, anchor);
      append_dev(h276, t1261);
      append_dev(h276, em79);
      insert_dev(target, t1263, anchor);
      insert_dev(target, ul87, anchor);
      append_dev(ul87, li211);
      append_dev(li211, t1264);
      append_dev(li211, code313);
      append_dev(li211, t1266);
      insert_dev(target, t1267, anchor);
      insert_dev(target, h277, anchor);
      append_dev(h277, t1268);
      append_dev(h277, em80);
      insert_dev(target, t1270, anchor);
      insert_dev(target, ul88, anchor);
      append_dev(ul88, li212);
      insert_dev(target, t1272, anchor);
      insert_dev(target, h278, anchor);
      append_dev(h278, t1273);
      append_dev(h278, em81);
      insert_dev(target, t1275, anchor);
      insert_dev(target, ul89, anchor);
      append_dev(ul89, li213);
      append_dev(li213, t1276);
      append_dev(li213, code314);
      append_dev(li213, t1278);
      insert_dev(target, t1279, anchor);
      insert_dev(target, h279, anchor);
      append_dev(h279, t1280);
      append_dev(h279, em82);
      insert_dev(target, t1282, anchor);
      insert_dev(target, ul90, anchor);
      append_dev(ul90, li214);
      append_dev(li214, t1283);
      append_dev(li214, code315);
      append_dev(li214, t1285);
      append_dev(li214, code316);
      append_dev(li214, t1287);
      insert_dev(target, t1288, anchor);
      insert_dev(target, h280, anchor);
      append_dev(h280, t1289);
      append_dev(h280, em83);
      insert_dev(target, t1291, anchor);
      insert_dev(target, ul91, anchor);
      append_dev(ul91, li215);
      append_dev(li215, t1292);
      append_dev(li215, a4);
      insert_dev(target, t1294, anchor);
      insert_dev(target, h281, anchor);
      append_dev(h281, t1295);
      append_dev(h281, em84);
      insert_dev(target, t1297, anchor);
      insert_dev(target, ul92, anchor);
      append_dev(ul92, li216);
      append_dev(li216, t1298);
      append_dev(li216, code317);
      append_dev(li216, t1300);
      append_dev(ul92, t1301);
      append_dev(ul92, li217);
      append_dev(li217, t1302);
      append_dev(li217, code318);
      append_dev(li217, t1304);
      append_dev(li217, code319);
      append_dev(li217, t1306);
      append_dev(li217, code320);
      append_dev(li217, t1308);
      insert_dev(target, t1309, anchor);
      insert_dev(target, h282, anchor);
      append_dev(h282, t1310);
      append_dev(h282, em85);
      insert_dev(target, t1312, anchor);
      insert_dev(target, ul93, anchor);
      append_dev(ul93, li218);
      insert_dev(target, t1314, anchor);
      insert_dev(target, h283, anchor);
      append_dev(h283, t1315);
      append_dev(h283, em86);
      insert_dev(target, t1317, anchor);
      insert_dev(target, ul94, anchor);
      append_dev(ul94, li219);
      insert_dev(target, t1319, anchor);
      insert_dev(target, h284, anchor);
      append_dev(h284, t1320);
      append_dev(h284, em87);
      insert_dev(target, t1322, anchor);
      insert_dev(target, ul95, anchor);
      append_dev(ul95, li220);
      append_dev(li220, t1323);
      append_dev(li220, code321);
      append_dev(li220, t1325);
      append_dev(ul95, t1326);
      append_dev(ul95, li221);
      append_dev(ul95, t1328);
      append_dev(ul95, li222);
      append_dev(ul95, t1330);
      append_dev(ul95, li223);
      insert_dev(target, t1332, anchor);
      insert_dev(target, h285, anchor);
      append_dev(h285, t1333);
      append_dev(h285, em88);
      insert_dev(target, t1335, anchor);
      insert_dev(target, ul96, anchor);
      append_dev(ul96, li224);
      append_dev(li224, t1336);
      append_dev(li224, code322);
      append_dev(li224, t1338);
      insert_dev(target, t1339, anchor);
      insert_dev(target, h286, anchor);
      append_dev(h286, t1340);
      append_dev(h286, em89);
      insert_dev(target, t1342, anchor);
      insert_dev(target, ul97, anchor);
      append_dev(ul97, li225);
      append_dev(li225, code323);
      append_dev(li225, t1344);
      insert_dev(target, t1345, anchor);
      insert_dev(target, h287, anchor);
      append_dev(h287, t1346);
      append_dev(h287, em90);
      insert_dev(target, t1348, anchor);
      insert_dev(target, ul98, anchor);
      append_dev(ul98, li226);
      append_dev(li226, t1349);
      append_dev(li226, code324);
      append_dev(li226, t1351);
      append_dev(li226, code325);
      insert_dev(target, t1353, anchor);
      insert_dev(target, hr3, anchor);
      insert_dev(target, t1354, anchor);
      insert_dev(target, h288, anchor);
      append_dev(h288, t1355);
      append_dev(h288, em91);
      insert_dev(target, t1357, anchor);
      insert_dev(target, ul99, anchor);
      append_dev(ul99, li227);
      append_dev(ul99, t1359);
      append_dev(ul99, li228);
      append_dev(ul99, t1361);
      append_dev(ul99, li229);
      insert_dev(target, t1363, anchor);
      insert_dev(target, h289, anchor);
      append_dev(h289, t1364);
      append_dev(h289, em92);
      insert_dev(target, t1366, anchor);
      insert_dev(target, ul100, anchor);
      append_dev(ul100, li230);
      insert_dev(target, t1368, anchor);
      insert_dev(target, h290, anchor);
      append_dev(h290, t1369);
      append_dev(h290, em93);
      insert_dev(target, t1371, anchor);
      insert_dev(target, ul101, anchor);
      append_dev(ul101, li231);
      insert_dev(target, t1373, anchor);
      insert_dev(target, h291, anchor);
      append_dev(h291, t1374);
      append_dev(h291, em94);
      insert_dev(target, t1376, anchor);
      insert_dev(target, ul102, anchor);
      append_dev(ul102, li232);
      append_dev(li232, t1377);
      append_dev(li232, code326);
      append_dev(li232, t1379);
      insert_dev(target, t1380, anchor);
      insert_dev(target, h292, anchor);
      append_dev(h292, t1381);
      append_dev(h292, em95);
      insert_dev(target, t1383, anchor);
      insert_dev(target, ul103, anchor);
      append_dev(ul103, li233);
      append_dev(li233, t1384);
      append_dev(li233, code327);
      append_dev(li233, t1386);
      insert_dev(target, t1387, anchor);
      insert_dev(target, h293, anchor);
      append_dev(h293, t1388);
      append_dev(h293, em96);
      insert_dev(target, t1390, anchor);
      insert_dev(target, ul104, anchor);
      append_dev(ul104, li234);
      append_dev(ul104, t1392);
      append_dev(ul104, li235);
      insert_dev(target, t1394, anchor);
      insert_dev(target, h294, anchor);
      append_dev(h294, t1395);
      append_dev(h294, em97);
      insert_dev(target, t1397, anchor);
      insert_dev(target, ul105, anchor);
      append_dev(ul105, li236);
      insert_dev(target, t1399, anchor);
      insert_dev(target, h295, anchor);
      append_dev(h295, t1400);
      append_dev(h295, em98);
      insert_dev(target, t1402, anchor);
      insert_dev(target, ul106, anchor);
      append_dev(ul106, li237);
      append_dev(ul106, t1404);
      append_dev(ul106, li238);
      insert_dev(target, t1406, anchor);
      insert_dev(target, h296, anchor);
      append_dev(h296, t1407);
      append_dev(h296, em99);
      insert_dev(target, t1409, anchor);
      insert_dev(target, ul107, anchor);
      append_dev(ul107, li239);
      append_dev(li239, t1410);
      append_dev(li239, code328);
      append_dev(li239, t1412);
      insert_dev(target, t1413, anchor);
      insert_dev(target, h297, anchor);
      append_dev(h297, t1414);
      append_dev(h297, em100);
      insert_dev(target, t1416, anchor);
      insert_dev(target, ul108, anchor);
      append_dev(ul108, li240);
      append_dev(li240, t1417);
      append_dev(li240, code329);
      append_dev(li240, t1419);
      append_dev(li240, code330);
      append_dev(li240, t1421);
      append_dev(li240, code331);
      append_dev(li240, t1423);
      append_dev(ul108, t1424);
      append_dev(ul108, li241);
      append_dev(li241, t1425);
      append_dev(li241, code332);
      append_dev(li241, t1427);
      append_dev(ul108, t1428);
      append_dev(ul108, li242);
      append_dev(ul108, t1430);
      append_dev(ul108, li243);
      append_dev(ul108, t1432);
      append_dev(ul108, li244);
      append_dev(li244, t1433);
      append_dev(li244, code333);
      append_dev(li244, t1435);
      append_dev(li244, code334);
      append_dev(li244, t1437);
      insert_dev(target, t1438, anchor);
      insert_dev(target, hr4, anchor);
      insert_dev(target, t1439, anchor);
      insert_dev(target, h298, anchor);
      append_dev(h298, t1440);
      append_dev(h298, em101);
      insert_dev(target, t1442, anchor);
      insert_dev(target, ul109, anchor);
      append_dev(ul109, li245);
      append_dev(li245, t1443);
      append_dev(li245, code335);
      append_dev(li245, t1445);
      append_dev(li245, code336);
      append_dev(li245, t1447);
      append_dev(li245, code337);
      append_dev(li245, t1449);
      append_dev(li245, code338);
      append_dev(ul109, t1451);
      append_dev(ul109, li246);
      insert_dev(target, t1453, anchor);
      insert_dev(target, hr5, anchor);
      insert_dev(target, t1454, anchor);
      insert_dev(target, h299, anchor);
      append_dev(h299, t1455);
      append_dev(h299, em102);
      insert_dev(target, t1457, anchor);
      insert_dev(target, ul110, anchor);
      append_dev(ul110, li247);
      append_dev(li247, t1458);
      append_dev(li247, code339);
      append_dev(li247, t1460);
      append_dev(li247, code340);
      append_dev(li247, t1462);
      insert_dev(target, t1463, anchor);
      insert_dev(target, h2100, anchor);
      append_dev(h2100, t1464);
      append_dev(h2100, em103);
      insert_dev(target, t1466, anchor);
      insert_dev(target, ul111, anchor);
      append_dev(ul111, li248);
      append_dev(li248, t1467);
      append_dev(li248, code341);
      append_dev(li248, t1469);
      append_dev(ul111, t1470);
      append_dev(ul111, li249);
      append_dev(li249, t1471);
      append_dev(li249, code342);
      append_dev(li249, t1473);
      insert_dev(target, t1474, anchor);
      insert_dev(target, h2101, anchor);
      append_dev(h2101, t1475);
      append_dev(h2101, em104);
      insert_dev(target, t1477, anchor);
      insert_dev(target, ul112, anchor);
      append_dev(ul112, li250);
      append_dev(li250, t1478);
      append_dev(li250, code343);
      append_dev(li250, t1480);
      append_dev(li250, code344);
      append_dev(li250, t1482);
      append_dev(ul112, t1483);
      append_dev(ul112, li251);
      append_dev(ul112, t1485);
      append_dev(ul112, li252);
      insert_dev(target, t1487, anchor);
      insert_dev(target, h2102, anchor);
      append_dev(h2102, t1488);
      append_dev(h2102, em105);
      insert_dev(target, t1490, anchor);
      insert_dev(target, ul113, anchor);
      append_dev(ul113, li253);
      insert_dev(target, t1492, anchor);
      insert_dev(target, h2103, anchor);
      append_dev(h2103, t1493);
      append_dev(h2103, em106);
      insert_dev(target, t1495, anchor);
      insert_dev(target, ul114, anchor);
      append_dev(ul114, li254);
      append_dev(li254, t1496);
      append_dev(li254, code345);
      append_dev(li254, t1498);
      append_dev(li254, code346);
      append_dev(li254, t1500);
      append_dev(ul114, t1501);
      append_dev(ul114, li255);
      append_dev(li255, t1502);
      append_dev(li255, code347);
      append_dev(li255, t1504);
      insert_dev(target, t1505, anchor);
      insert_dev(target, hr6, anchor);
      insert_dev(target, t1506, anchor);
      insert_dev(target, h2104, anchor);
      append_dev(h2104, t1507);
      append_dev(h2104, em107);
      insert_dev(target, t1509, anchor);
      insert_dev(target, ul115, anchor);
      append_dev(ul115, li256);
      append_dev(li256, t1510);
      append_dev(li256, code348);
      append_dev(li256, t1512);
      append_dev(li256, code349);
      append_dev(li256, t1514);
      insert_dev(target, t1515, anchor);
      insert_dev(target, hr7, anchor);
      insert_dev(target, t1516, anchor);
      insert_dev(target, h2105, anchor);
      append_dev(h2105, t1517);
      append_dev(h2105, em108);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h1);
        detach_dev(t1);
        detach_dev(h20);
        detach_dev(t4);
        detach_dev(ul0);
        detach_dev(t8);
        detach_dev(h21);
        detach_dev(t11);
        detach_dev(ul1);
        detach_dev(t21);
        detach_dev(h22);
        detach_dev(t24);
        detach_dev(ul2);
        detach_dev(t32);
        detach_dev(h23);
        detach_dev(t35);
        detach_dev(ul3);
        detach_dev(t47);
        detach_dev(h24);
        detach_dev(t50);
        detach_dev(ul4);
        detach_dev(t86);
        detach_dev(h25);
        detach_dev(t89);
        detach_dev(ul5);
        detach_dev(t95);
        detach_dev(h26);
        detach_dev(t98);
        detach_dev(ul6);
        detach_dev(t100);
        detach_dev(h27);
        detach_dev(t103);
        detach_dev(ul7);
        detach_dev(t105);
        detach_dev(h28);
        detach_dev(t108);
        detach_dev(ul8);
        detach_dev(t114);
        detach_dev(h29);
        detach_dev(t117);
        detach_dev(ul9);
        detach_dev(t123);
        detach_dev(h210);
        detach_dev(t126);
        detach_dev(ul10);
        detach_dev(t130);
        detach_dev(h211);
        detach_dev(t133);
        detach_dev(ul11);
        detach_dev(t141);
        detach_dev(h212);
        detach_dev(t144);
        detach_dev(ul12);
        detach_dev(t148);
        detach_dev(h213);
        detach_dev(t151);
        detach_dev(ul13);
        detach_dev(t159);
        detach_dev(h214);
        detach_dev(t162);
        detach_dev(ul14);
        detach_dev(t174);
        detach_dev(h215);
        detach_dev(t177);
        detach_dev(ul15);
        detach_dev(t183);
        detach_dev(h216);
        detach_dev(t186);
        detach_dev(ul16);
        detach_dev(t192);
        detach_dev(h217);
        detach_dev(t195);
        detach_dev(ul17);
        detach_dev(t201);
        detach_dev(h218);
        detach_dev(t204);
        detach_dev(ul18);
        detach_dev(t216);
        detach_dev(h219);
        detach_dev(t219);
        detach_dev(ul19);
        detach_dev(t227);
        detach_dev(h220);
        detach_dev(t230);
        detach_dev(ul20);
        detach_dev(t239);
        detach_dev(h221);
        detach_dev(t242);
        detach_dev(ul21);
        detach_dev(t246);
        detach_dev(h222);
        detach_dev(t249);
        detach_dev(ul22);
        detach_dev(t253);
        detach_dev(h223);
        detach_dev(t256);
        detach_dev(ul23);
        detach_dev(t261);
        detach_dev(h224);
        detach_dev(t264);
        detach_dev(ul24);
        detach_dev(t268);
        detach_dev(h225);
        detach_dev(t271);
        detach_dev(ul25);
        detach_dev(t299);
        detach_dev(h226);
        detach_dev(t302);
        detach_dev(ul26);
        detach_dev(t308);
        detach_dev(h227);
        detach_dev(t311);
        detach_dev(ul27);
        detach_dev(t325);
        detach_dev(h228);
        detach_dev(t328);
        detach_dev(ul28);
        detach_dev(t357);
        detach_dev(h30);
        detach_dev(t359);
        detach_dev(ul29);
        detach_dev(t384);
        detach_dev(hr0);
        detach_dev(t385);
        detach_dev(h229);
        detach_dev(t388);
        detach_dev(ul30);
        detach_dev(t404);
        detach_dev(h230);
        detach_dev(t407);
        detach_dev(ul31);
        detach_dev(t411);
        detach_dev(h231);
        detach_dev(t414);
        detach_dev(ul32);
        detach_dev(t431);
        detach_dev(h232);
        detach_dev(t434);
        detach_dev(ul33);
        detach_dev(t448);
        detach_dev(h233);
        detach_dev(t451);
        detach_dev(ul34);
        detach_dev(t488);
        detach_dev(h234);
        detach_dev(t491);
        detach_dev(ul35);
        detach_dev(t529);
        detach_dev(h235);
        detach_dev(t532);
        detach_dev(ul36);
        detach_dev(t543);
        detach_dev(h236);
        detach_dev(t546);
        detach_dev(ul37);
        detach_dev(t562);
        detach_dev(h237);
        detach_dev(t565);
        detach_dev(ul38);
        detach_dev(t571);
        detach_dev(h238);
        detach_dev(t574);
        detach_dev(ul39);
        detach_dev(t591);
        detach_dev(h239);
        detach_dev(t594);
        detach_dev(ul40);
        detach_dev(t598);
        detach_dev(h240);
        detach_dev(t601);
        detach_dev(ul41);
        detach_dev(t617);
        detach_dev(h241);
        detach_dev(t620);
        detach_dev(ul42);
        detach_dev(t625);
        detach_dev(h242);
        detach_dev(t628);
        detach_dev(ul43);
        detach_dev(t641);
        detach_dev(h243);
        detach_dev(t644);
        detach_dev(ul44);
        detach_dev(t710);
        detach_dev(h31);
        detach_dev(t712);
        detach_dev(ul45);
        detach_dev(t767);
        detach_dev(h32);
        detach_dev(t769);
        detach_dev(ul46);
        detach_dev(t797);
        detach_dev(p);
        detach_dev(t803);
        detach_dev(hr1);
        detach_dev(t804);
        detach_dev(h244);
        detach_dev(t807);
        detach_dev(ul47);
        detach_dev(t811);
        detach_dev(h245);
        detach_dev(t814);
        detach_dev(ul48);
        detach_dev(t818);
        detach_dev(h246);
        detach_dev(t821);
        detach_dev(ul49);
        detach_dev(t829);
        detach_dev(h247);
        detach_dev(t832);
        detach_dev(ul50);
        detach_dev(t840);
        detach_dev(h248);
        detach_dev(t843);
        detach_dev(ul51);
        detach_dev(t854);
        detach_dev(h249);
        detach_dev(t857);
        detach_dev(ul52);
        detach_dev(t899);
        detach_dev(h33);
        detach_dev(t901);
        detach_dev(h40);
        detach_dev(t903);
        detach_dev(ul53);
        detach_dev(t914);
        detach_dev(h41);
        detach_dev(t916);
        detach_dev(ul54);
        detach_dev(t921);
        detach_dev(h42);
        detach_dev(t923);
        detach_dev(ul55);
        detach_dev(t928);
        detach_dev(h43);
        detach_dev(t930);
        detach_dev(ul56);
        detach_dev(t935);
        detach_dev(h44);
        detach_dev(t937);
        detach_dev(ul57);
        detach_dev(t941);
        detach_dev(hr2);
        detach_dev(t942);
        detach_dev(h250);
        detach_dev(t945);
        detach_dev(ul58);
        detach_dev(t953);
        detach_dev(h251);
        detach_dev(t956);
        detach_dev(ul59);
        detach_dev(t965);
        detach_dev(h252);
        detach_dev(t968);
        detach_dev(ul60);
        detach_dev(t972);
        detach_dev(h253);
        detach_dev(t975);
        detach_dev(ul62);
        detach_dev(t1013);
        detach_dev(h254);
        detach_dev(t1016);
        detach_dev(ul64);
        detach_dev(t1035);
        detach_dev(h255);
        detach_dev(t1038);
        detach_dev(ul66);
        detach_dev(t1048);
        detach_dev(h256);
        detach_dev(t1051);
        detach_dev(ul67);
        detach_dev(t1055);
        detach_dev(h257);
        detach_dev(t1058);
        detach_dev(ul68);
        detach_dev(t1065);
        detach_dev(h258);
        detach_dev(t1068);
        detach_dev(ul69);
        detach_dev(t1079);
        detach_dev(h259);
        detach_dev(t1082);
        detach_dev(ul70);
        detach_dev(t1094);
        detach_dev(h260);
        detach_dev(t1097);
        detach_dev(ul71);
        detach_dev(t1099);
        detach_dev(h261);
        detach_dev(t1102);
        detach_dev(ul72);
        detach_dev(t1109);
        detach_dev(h262);
        detach_dev(t1112);
        detach_dev(ul73);
        detach_dev(t1124);
        detach_dev(h263);
        detach_dev(t1127);
        detach_dev(ul74);
        detach_dev(t1134);
        detach_dev(h264);
        detach_dev(t1137);
        detach_dev(ul75);
        detach_dev(t1147);
        detach_dev(h265);
        detach_dev(t1150);
        detach_dev(ul76);
        detach_dev(t1152);
        detach_dev(h266);
        detach_dev(t1155);
        detach_dev(ul77);
        detach_dev(t1165);
        detach_dev(h267);
        detach_dev(t1168);
        detach_dev(ul78);
        detach_dev(t1175);
        detach_dev(h268);
        detach_dev(t1178);
        detach_dev(ul79);
        detach_dev(t1180);
        detach_dev(h269);
        detach_dev(t1183);
        detach_dev(ul80);
        detach_dev(t1191);
        detach_dev(h270);
        detach_dev(t1194);
        detach_dev(ul81);
        detach_dev(t1214);
        detach_dev(h271);
        detach_dev(t1217);
        detach_dev(ul82);
        detach_dev(t1231);
        detach_dev(h272);
        detach_dev(t1234);
        detach_dev(ul83);
        detach_dev(t1240);
        detach_dev(h273);
        detach_dev(t1243);
        detach_dev(ul84);
        detach_dev(t1246);
        detach_dev(h274);
        detach_dev(t1249);
        detach_dev(ul85);
        detach_dev(t1253);
        detach_dev(h275);
        detach_dev(t1256);
        detach_dev(ul86);
        detach_dev(t1260);
        detach_dev(h276);
        detach_dev(t1263);
        detach_dev(ul87);
        detach_dev(t1267);
        detach_dev(h277);
        detach_dev(t1270);
        detach_dev(ul88);
        detach_dev(t1272);
        detach_dev(h278);
        detach_dev(t1275);
        detach_dev(ul89);
        detach_dev(t1279);
        detach_dev(h279);
        detach_dev(t1282);
        detach_dev(ul90);
        detach_dev(t1288);
        detach_dev(h280);
        detach_dev(t1291);
        detach_dev(ul91);
        detach_dev(t1294);
        detach_dev(h281);
        detach_dev(t1297);
        detach_dev(ul92);
        detach_dev(t1309);
        detach_dev(h282);
        detach_dev(t1312);
        detach_dev(ul93);
        detach_dev(t1314);
        detach_dev(h283);
        detach_dev(t1317);
        detach_dev(ul94);
        detach_dev(t1319);
        detach_dev(h284);
        detach_dev(t1322);
        detach_dev(ul95);
        detach_dev(t1332);
        detach_dev(h285);
        detach_dev(t1335);
        detach_dev(ul96);
        detach_dev(t1339);
        detach_dev(h286);
        detach_dev(t1342);
        detach_dev(ul97);
        detach_dev(t1345);
        detach_dev(h287);
        detach_dev(t1348);
        detach_dev(ul98);
        detach_dev(t1353);
        detach_dev(hr3);
        detach_dev(t1354);
        detach_dev(h288);
        detach_dev(t1357);
        detach_dev(ul99);
        detach_dev(t1363);
        detach_dev(h289);
        detach_dev(t1366);
        detach_dev(ul100);
        detach_dev(t1368);
        detach_dev(h290);
        detach_dev(t1371);
        detach_dev(ul101);
        detach_dev(t1373);
        detach_dev(h291);
        detach_dev(t1376);
        detach_dev(ul102);
        detach_dev(t1380);
        detach_dev(h292);
        detach_dev(t1383);
        detach_dev(ul103);
        detach_dev(t1387);
        detach_dev(h293);
        detach_dev(t1390);
        detach_dev(ul104);
        detach_dev(t1394);
        detach_dev(h294);
        detach_dev(t1397);
        detach_dev(ul105);
        detach_dev(t1399);
        detach_dev(h295);
        detach_dev(t1402);
        detach_dev(ul106);
        detach_dev(t1406);
        detach_dev(h296);
        detach_dev(t1409);
        detach_dev(ul107);
        detach_dev(t1413);
        detach_dev(h297);
        detach_dev(t1416);
        detach_dev(ul108);
        detach_dev(t1438);
        detach_dev(hr4);
        detach_dev(t1439);
        detach_dev(h298);
        detach_dev(t1442);
        detach_dev(ul109);
        detach_dev(t1453);
        detach_dev(hr5);
        detach_dev(t1454);
        detach_dev(h299);
        detach_dev(t1457);
        detach_dev(ul110);
        detach_dev(t1463);
        detach_dev(h2100);
        detach_dev(t1466);
        detach_dev(ul111);
        detach_dev(t1474);
        detach_dev(h2101);
        detach_dev(t1477);
        detach_dev(ul112);
        detach_dev(t1487);
        detach_dev(h2102);
        detach_dev(t1490);
        detach_dev(ul113);
        detach_dev(t1492);
        detach_dev(h2103);
        detach_dev(t1495);
        detach_dev(ul114);
        detach_dev(t1505);
        detach_dev(hr6);
        detach_dev(t1506);
        detach_dev(h2104);
        detach_dev(t1509);
        detach_dev(ul115);
        detach_dev(t1515);
        detach_dev(hr7);
        detach_dev(t1516);
        detach_dev(h2105);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance53($$self2, $$props2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Changelog", slots2, []);
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Changelog> was created with unknown prop '${key}'`);
  });
  return [];
}
var Changelog = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance53, create_fragment53, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Changelog",
      options,
      id: create_fragment53.name
    });
  }
};
var changelog_default = Changelog;

// docs-src/components/index.js
var components_exports = {};
__export(components_exports, {
  Button: () => Button_default2,
  ButtonGroup: () => ButtonGroup_default2,
  ButtonToggle: () => ButtonToggle_default2,
  Checkbox: () => Checkbox_default2,
  ColorPalette: () => ColorPalette_default,
  Combobox: () => Combobox_default2,
  Dialog: () => Dialog_default2,
  Drawer: () => Drawer_default2,
  Grid: () => Grid_default2,
  Icon: () => Icon_default2,
  InfoBar: () => InfoBar_default2,
  InputDate: () => InputDate_default2,
  InputMath: () => InputMath_default2,
  InputNumber: () => InputNumber_default2,
  InputPassword: () => InputPassword_default2,
  InputRating: () => InputRating_default2,
  InputSearch: () => InputSearch_default2,
  InputTag: () => InputTag_default2,
  InputText: () => InputText_default2,
  InputTime: () => InputTime_default2,
  Menu: () => Menu_default2,
  MessageBox: () => MessageBox_default2,
  NotificationCenter: () => NotificationCenter_default2,
  Panel: () => Panel_default2,
  Popover: () => Popover_default2,
  PushButton: () => PushButton_default2,
  Radio: () => Radio_default2,
  Range: () => Range_default2,
  Select: () => Select_default2,
  Splitter: () => Splitter_default2,
  Table: () => Table_default2,
  Tag: () => Tag_default2,
  Textarea: () => Textarea_default2,
  Toggle: () => Toggle_default2,
  Tooltip: () => Tooltip_default2,
  Tree: () => Tree_default2,
  Utils: () => Utils_default
});

// docs-src/api-table/ApiTable.svelte
var file47 = "docs-src/api-table/ApiTable.svelte";
function get_each_context17(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_if_block28(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      add_location(p, file47, 2, 1, 36);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      p.innerHTML = /*description*/
      ctx[1];
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*description*/
      2)
        p.innerHTML = /*description*/
        ctx2[1];
      ;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block28.name,
    type: "if",
    source: "(2:0) {#if description}",
    ctx
  });
  return block;
}
function create_each_block17(ctx) {
  let tr;
  let td0;
  let t0_value = (
    /*prop*/
    ctx[3].name + ""
  );
  let t0;
  let t1;
  let td1;
  let raw0_value = buildType(
    /*prop*/
    ctx[3]
  ) + "";
  let t2;
  let td2;
  let raw1_value = (
    /*prop*/
    ctx[3].description + ""
  );
  let t3;
  const block = {
    c: function create() {
      tr = element2("tr");
      td0 = element2("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element2("td");
      t2 = space();
      td2 = element2("td");
      t3 = space();
      add_location(td0, file47, 11, 4, 253);
      add_location(td1, file47, 12, 4, 278);
      add_location(td2, file47, 13, 4, 315);
      add_location(tr, file47, 10, 3, 244);
    },
    m: function mount(target, anchor) {
      insert_dev(target, tr, anchor);
      append_dev(tr, td0);
      append_dev(td0, t0);
      append_dev(tr, t1);
      append_dev(tr, td1);
      td1.innerHTML = raw0_value;
      append_dev(tr, t2);
      append_dev(tr, td2);
      td2.innerHTML = raw1_value;
      append_dev(tr, t3);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*props*/
      4 && t0_value !== (t0_value = /*prop*/
      ctx2[3].name + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*props*/
      4 && raw0_value !== (raw0_value = buildType(
        /*prop*/
        ctx2[3]
      ) + ""))
        td1.innerHTML = raw0_value;
      ;
      if (dirty & /*props*/
      4 && raw1_value !== (raw1_value = /*prop*/
      ctx2[3].description + ""))
        td2.innerHTML = raw1_value;
      ;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block17.name,
    type: "each",
    source: "(10:2) {#each props as prop}",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let thead;
  let tr;
  let th0;
  let th1;
  let th2;
  let t3;
  let tbody;
  let each_value = ensure_array_like_dev(
    /*props*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block17(get_each_context17(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      thead = element2("thead");
      tr = element2("tr");
      th0 = element2("th");
      th0.textContent = "Attribute";
      th1 = element2("th");
      th1.textContent = "Type/Value";
      th2 = element2("th");
      th2.textContent = "Description";
      t3 = space();
      tbody = element2("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      add_location(th0, file47, 6, 6, 135);
      add_location(th1, file47, 6, 24, 153);
      add_location(th2, file47, 6, 43, 172);
      add_location(tr, file47, 6, 2, 131);
      add_location(thead, file47, 5, 1, 121);
      add_location(tbody, file47, 8, 1, 209);
    },
    m: function mount(target, anchor) {
      insert_dev(target, thead, anchor);
      append_dev(thead, tr);
      append_dev(tr, th0);
      append_dev(tr, th1);
      append_dev(tr, th2);
      insert_dev(target, t3, anchor);
      insert_dev(target, tbody, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*props, buildType*/
      4) {
        each_value = ensure_array_like_dev(
          /*props*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context17(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block17(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tbody, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(thead);
        detach_dev(t3);
        detach_dev(tbody);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: '(5:0) <Table class=\\"api-table\\" selectable=\\"false\\" round>',
    ctx
  });
  return block;
}
function create_fragment54(ctx) {
  let h3;
  let t0;
  let t1;
  let t2;
  let table;
  let current;
  let if_block = (
    /*description*/
    ctx[1] && create_if_block28(ctx)
  );
  table = new Table_default({
    props: {
      class: "api-table",
      selectable: "false",
      round: true,
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      h3 = element2("h3");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      create_component(table.$$.fragment);
      add_location(h3, file47, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h3, anchor);
      append_dev(h3, t0);
      insert_dev(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(table, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      if (!current || dirty & /*title*/
      1)
        set_data_dev(
          t0,
          /*title*/
          ctx2[0]
        );
      if (
        /*description*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block28(ctx2);
          if_block.c();
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const table_changes = {};
      if (dirty & /*$$scope, props*/
      68) {
        table_changes.$$scope = { dirty, ctx: ctx2 };
      }
      table.$set(table_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(table.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(table.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h3);
        detach_dev(t1);
        detach_dev(t2);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_component(table, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function buildType(prop) {
  const res = [];
  if (!prop.type)
    prop.type = "-";
  const types = (Array.isArray(prop.type) ? prop.type : [prop.type]).map((t) => `<i>${t}</i>`);
  res.push(types.join(" | "));
  if (typeof prop.required !== "undefined")
    res.push("<em>required</em>");
  if (typeof prop.default !== "undefined")
    res.push(`<br>(defaults to ${prop.default})`);
  return res.join(" ");
}
function instance54($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("ApiTable", slots2, []);
  let { title = "API" } = $$props2;
  let { description = "" } = $$props2;
  let { props = [
    {
      name: "id",
      type: "string",
      defalut: "",
      required: true,
      description: "assign ID to the underlying component"
    }
  ] } = $$props2;
  const writable_props = ["title", "description", "props"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ApiTable> was created with unknown prop '${key}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("title" in $$props3)
      $$invalidate2(0, title = $$props3.title);
    if ("description" in $$props3)
      $$invalidate2(1, description = $$props3.description);
    if ("props" in $$props3)
      $$invalidate2(2, props = $$props3.props);
  };
  $$self2.$capture_state = () => ({
    Table: Table_default,
    title,
    description,
    props,
    buildType
  });
  $$self2.$inject_state = ($$props3) => {
    if ("title" in $$props3)
      $$invalidate2(0, title = $$props3.title);
    if ("description" in $$props3)
      $$invalidate2(1, description = $$props3.description);
    if ("props" in $$props3)
      $$invalidate2(2, props = $$props3.props);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [title, description, props];
}
var ApiTable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment54, safe_not_equal, { title: 0, description: 1, props: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ApiTable",
      options,
      id: create_fragment54.name
    });
  }
  get title() {
    throw new Error("<ApiTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value2) {
    throw new Error("<ApiTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<ApiTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value2) {
    throw new Error("<ApiTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<ApiTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value2) {
    throw new Error("<ApiTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ApiTable_default = ApiTable;

// docs-src/code-example/CodeExample.svelte
var file48 = "docs-src/code-example/CodeExample.svelte";
function create_if_block29(ctx) {
  let t0;
  let h3;
  let if_block = (
    /*nohr*/
    ctx[2] === void 0 && create_if_block_17(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t0 = space();
      h3 = element2("h3");
      h3.textContent = "Example";
      add_location(h3, file48, 2, 1, 51);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, h3, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (
        /*nohr*/
        ctx2[2] === void 0
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_17(ctx2);
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(h3);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block29.name,
    type: "if",
    source: "(1:0) {#if !notitle}",
    ctx
  });
  return block;
}
function create_if_block_17(ctx) {
  let hr;
  const block = {
    c: function create() {
      hr = element2("hr");
      add_location(hr, file48, 1, 25, 40);
    },
    m: function mount(target, anchor) {
      insert_dev(target, hr, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(hr);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(2:1) {#if nohr === undefined}",
    ctx
  });
  return block;
}
function create_fragment55(ctx) {
  let t0;
  let pre;
  let code;
  let t1;
  let html_tag;
  let raw_value = encode(
    /*html*/
    ctx[0]
  ) + "";
  let t2;
  let if_block = !/*notitle*/
  ctx[1] && create_if_block29(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t0 = space();
      pre = element2("pre");
      code = element2("code");
      t1 = text("\n	");
      html_tag = new HtmlTag(false);
      t2 = text("\n");
      html_tag.a = t2;
      attr_dev(code, "class", "language-svelte");
      add_location(code, file48, 4, 5, 79);
      add_location(pre, file48, 4, 0, 74);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, pre, anchor);
      append_dev(pre, code);
      append_dev(code, t1);
      html_tag.m(raw_value, code);
      append_dev(code, t2);
    },
    p: function update2(ctx2, [dirty]) {
      if (!/*notitle*/
      ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block29(ctx2);
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*html*/
      1 && raw_value !== (raw_value = encode(
        /*html*/
        ctx2[0]
      ) + ""))
        html_tag.p(raw_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(pre);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function encode(s) {
  return s.replace(/{/gim, "&lbrace;").replace(/}/gim, "&rbrace;").replace(/</gim, "&lt;").replace(/>/gim, "&gt;").replace(/\t/gim, "    ").trim();
}
function instance55($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("CodeExample", slots2, []);
  let { html = "" } = $$props2;
  let { notitle = false } = $$props2;
  let { nohr = void 0 } = $$props2;
  const writable_props = ["html", "notitle", "nohr"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CodeExample> was created with unknown prop '${key}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("html" in $$props3)
      $$invalidate2(0, html = $$props3.html);
    if ("notitle" in $$props3)
      $$invalidate2(1, notitle = $$props3.notitle);
    if ("nohr" in $$props3)
      $$invalidate2(2, nohr = $$props3.nohr);
  };
  $$self2.$capture_state = () => ({ html, notitle, nohr, encode });
  $$self2.$inject_state = ($$props3) => {
    if ("html" in $$props3)
      $$invalidate2(0, html = $$props3.html);
    if ("notitle" in $$props3)
      $$invalidate2(1, notitle = $$props3.notitle);
    if ("nohr" in $$props3)
      $$invalidate2(2, nohr = $$props3.nohr);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [html, notitle, nohr];
}
var CodeExample = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance55, create_fragment55, safe_not_equal, { html: 0, notitle: 1, nohr: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeExample",
      options,
      id: create_fragment55.name
    });
  }
  get html() {
    throw new Error("<CodeExample>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set html(value2) {
    throw new Error("<CodeExample>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notitle() {
    throw new Error("<CodeExample>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notitle(value2) {
    throw new Error("<CodeExample>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nohr() {
    throw new Error("<CodeExample>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nohr(value2) {
    throw new Error("<CodeExample>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeExample_default = CodeExample;

// docs-src/code-example/CodeBox.svelte
var file49 = "docs-src/code-example/CodeBox.svelte";
function create_fragment56(ctx) {
  let pre;
  let code;
  const block = {
    c: function create() {
      pre = element2("pre");
      code = element2("code");
      attr_dev(code, "class", "language-");
      add_location(code, file49, 0, 5, 5);
      add_location(pre, file49, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, pre, anchor);
      append_dev(pre, code);
      code.innerHTML = /*html*/
      ctx[0];
    },
    p: function update2(ctx2, [dirty]) {
      if (dirty & /*html*/
      1)
        code.innerHTML = /*html*/
        ctx2[0];
      ;
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(pre);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance56($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("CodeBox", slots2, []);
  let { tag = "div" } = $$props2;
  let { props = {} } = $$props2;
  let { text: text2 = "" } = $$props2;
  let html = "";
  afterUpdate(() => {
    requestAnimationFrame(update2);
  });
  function update2() {
    $$invalidate2(0, html = window.Prism.highlight(buildHtml(), window.Prism.languages.svelte, "svelte"));
  }
  function buildHtml() {
    const _props = {};
    for (const prop in props) {
      if (props[prop] === false)
        continue;
      if (props[prop] === "")
        continue;
      _props[prop] = props[prop];
    }
    let propsStr = JSON.stringify(_props).replace(/"([^"]+)":/g, "$1:").replace(/(:)/g, "=").replace(/,/g, " ").replace(/({|}|=true|default)/g, "").trim();
    if (propsStr)
      propsStr = " " + propsStr;
    if (!text2)
      return `<${tag}${propsStr}/>`;
    return `<${tag}${propsStr}>${text2}</${tag}>`;
  }
  const writable_props = ["tag", "props", "text"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CodeBox> was created with unknown prop '${key}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("tag" in $$props3)
      $$invalidate2(1, tag = $$props3.tag);
    if ("props" in $$props3)
      $$invalidate2(2, props = $$props3.props);
    if ("text" in $$props3)
      $$invalidate2(3, text2 = $$props3.text);
  };
  $$self2.$capture_state = () => ({
    afterUpdate,
    tag,
    props,
    text: text2,
    html,
    update: update2,
    buildHtml
  });
  $$self2.$inject_state = ($$props3) => {
    if ("tag" in $$props3)
      $$invalidate2(1, tag = $$props3.tag);
    if ("props" in $$props3)
      $$invalidate2(2, props = $$props3.props);
    if ("text" in $$props3)
      $$invalidate2(3, text2 = $$props3.text);
    if ("html" in $$props3)
      $$invalidate2(0, html = $$props3.html);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [html, tag, props, text2];
}
var CodeBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance56, create_fragment56, safe_not_equal, { tag: 1, props: 2, text: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeBox",
      options,
      id: create_fragment56.name
    });
  }
  get tag() {
    throw new Error("<CodeBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value2) {
    throw new Error("<CodeBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<CodeBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value2) {
    throw new Error("<CodeBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<CodeBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value2) {
    throw new Error("<CodeBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeBox_default = CodeBox;

// docs-src/code-example/JsonBox.svelte
var file50 = "docs-src/code-example/JsonBox.svelte";
function create_fragment57(ctx) {
  let pre;
  let code_1;
  const block = {
    c: function create() {
      pre = element2("pre");
      code_1 = element2("code");
      attr_dev(code_1, "class", "language-json");
      add_location(code_1, file50, 0, 5, 5);
      add_location(pre, file50, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, pre, anchor);
      append_dev(pre, code_1);
      code_1.innerHTML = /*code*/
      ctx[0];
    },
    p: function update2(ctx2, [dirty]) {
      if (dirty & /*code*/
      1)
        code_1.innerHTML = /*code*/
        ctx2[0];
      ;
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(pre);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function stringify(json) {
  if (!json)
    return "";
  let s = JSON.stringify(json);
  s = s.replace(/([:,])/g, "$1 ");
  if (s.match(/^{/))
    s = s.replace(/{/g, "{ ");
  else {
    if (s.match(/}/))
      s = s.replace(/\]/g, "\n]");
    s = s.replace(/{/g, "\n    { ");
  }
  s = s.replace(/}/g, " }");
  return s;
}
function instance57($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("JsonBox", slots2, []);
  let { value: value2 = "" } = $$props2;
  let code = "";
  afterUpdate(() => {
    requestAnimationFrame(update2);
  });
  function update2() {
    if (typeof value2 !== "string")
      $$invalidate2(1, value2 = stringify(value2));
    $$invalidate2(0, code = window.Prism.highlight(value2, window.Prism.languages.json, "json"));
  }
  const writable_props = ["value"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<JsonBox> was created with unknown prop '${key}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("value" in $$props3)
      $$invalidate2(1, value2 = $$props3.value);
  };
  $$self2.$capture_state = () => ({
    afterUpdate,
    value: value2,
    code,
    update: update2,
    stringify
  });
  $$self2.$inject_state = ($$props3) => {
    if ("value" in $$props3)
      $$invalidate2(1, value2 = $$props3.value);
    if ("code" in $$props3)
      $$invalidate2(0, code = $$props3.code);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [code, value2];
}
var JsonBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment57, safe_not_equal, { value: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JsonBox",
      options,
      id: create_fragment57.name
    });
  }
  get value() {
    throw new Error("<JsonBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value2) {
    throw new Error("<JsonBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var JsonBox_default = JsonBox;

// docs-src/components/button/Button.svelte
var file51 = "docs-src/components/button/Button.svelte";
function create_else_block6(ctx) {
  let button;
  let current;
  const button_spread_levels = [
    /*props*/
    ctx[0]
  ];
  let button_props = {};
  for (let i = 0; i < button_spread_levels.length; i += 1) {
    button_props = assign(button_props, button_spread_levels[i]);
  }
  button = new Button_default({ props: button_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button_changes = dirty & /*props*/
      1 ? get_spread_update(button_spread_levels, [get_spread_object(
        /*props*/
        ctx2[0]
      )]) : {};
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(7:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block30(ctx) {
  let button;
  let current;
  const button_spread_levels = [
    { "data-one": "123" },
    /*props*/
    ctx[0]
  ];
  let button_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button_spread_levels.length; i += 1) {
    button_props = assign(button_props, button_spread_levels[i]);
  }
  button = new Button_default({ props: button_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button_changes = dirty & /*props*/
      1 ? get_spread_update(button_spread_levels, [button_spread_levels[0], get_spread_object(
        /*props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope, buttonText*/
      8194) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block30.name,
    type: "if",
    source: "(5:1) {#if buttonText}",
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*buttonText*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*buttonText*/
      2)
        set_data_dev(
          t,
          /*buttonText*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: '(6:2) <Button data-one=\\"123\\" {...props}>',
    ctx
  });
  return block;
}
function create_fragment58(ctx) {
  let h2;
  let t1;
  let h3;
  let t3;
  let div0;
  let current_block_type_index;
  let if_block;
  let t4;
  let codebox;
  let t5;
  let hr0;
  let t6;
  let div1;
  let inputtext;
  let updating_value;
  let t7;
  let buttontoggle0;
  let t8;
  let buttontoggle1;
  let t9;
  let buttontoggle2;
  let t10;
  let toggle0;
  let updating_value_1;
  let t11;
  let toggle1;
  let updating_value_2;
  let t12;
  let hr1;
  let t13;
  let api;
  let current;
  const if_block_creators = [create_if_block30, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*buttonText*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  codebox = new CodeBox_default({
    props: {
      tag: "Button",
      text: (
        /*buttonText*/
        ctx[1]
      ),
      props: (
        /*props*/
        ctx[0]
      )
    },
    $$inline: true
  });
  function inputtext_value_binding(value2) {
    ctx[9](value2);
  }
  let inputtext_props = { label: "Text" };
  if (
    /*buttonText*/
    ctx[1] !== void 0
  ) {
    inputtext_props.value = /*buttonText*/
    ctx[1];
  }
  inputtext = new InputText_default({ props: inputtext_props, $$inline: true });
  binding_callbacks.push(() => bind(inputtext, "value", inputtext_value_binding));
  buttontoggle0 = new ButtonToggle_default({
    props: {
      label: "Style",
      items: (
        /*buttonStyles*/
        ctx[3]
      ),
      value: ""
    },
    $$inline: true
  });
  buttontoggle0.$on(
    "change",
    /*onStyleChange*/
    ctx[6]
  );
  buttontoggle1 = new ButtonToggle_default({
    props: {
      label: "Type",
      items: (
        /*buttonTypes*/
        ctx[4]
      ),
      value: ""
    },
    $$inline: true
  });
  buttontoggle1.$on(
    "change",
    /*onTypeChange*/
    ctx[7]
  );
  buttontoggle2 = new ButtonToggle_default({
    props: {
      label: "Icon",
      items: (
        /*buttonIcons*/
        ctx[5]
      ),
      value: ""
    },
    $$inline: true
  });
  buttontoggle2.$on(
    "change",
    /*onIconChange*/
    ctx[8]
  );
  function toggle0_value_binding(value2) {
    ctx[10](value2);
  }
  let toggle0_props = { label: "Round" };
  if (
    /*props*/
    ctx[0].round !== void 0
  ) {
    toggle0_props.value = /*props*/
    ctx[0].round;
  }
  toggle0 = new Toggle_default({ props: toggle0_props, $$inline: true });
  binding_callbacks.push(() => bind(toggle0, "value", toggle0_value_binding));
  function toggle1_value_binding(value2) {
    ctx[11](value2);
  }
  let toggle1_props = { label: "Disabled" };
  if (
    /*props*/
    ctx[0].disabled !== void 0
  ) {
    toggle1_props.value = /*props*/
    ctx[0].disabled;
  }
  toggle1 = new Toggle_default({ props: toggle1_props, $$inline: true });
  binding_callbacks.push(() => bind(toggle1, "value", toggle1_value_binding));
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[2]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Button";
      t1 = space();
      h3 = element2("h3");
      h3.textContent = "Live demo";
      t3 = space();
      div0 = element2("div");
      if_block.c();
      t4 = space();
      create_component(codebox.$$.fragment);
      t5 = space();
      hr0 = element2("hr");
      t6 = space();
      div1 = element2("div");
      create_component(inputtext.$$.fragment);
      t7 = space();
      create_component(buttontoggle0.$$.fragment);
      t8 = space();
      create_component(buttontoggle1.$$.fragment);
      t9 = space();
      create_component(buttontoggle2.$$.fragment);
      t10 = space();
      create_component(toggle0.$$.fragment);
      t11 = space();
      create_component(toggle1.$$.fragment);
      t12 = space();
      hr1 = element2("hr");
      t13 = space();
      create_component(api.$$.fragment);
      add_location(h2, file51, 0, 0, 0);
      add_location(h3, file51, 2, 0, 17);
      attr_dev(div0, "class", "docs-buttons-row");
      set_style(div0, "height", "3rem");
      add_location(div0, file51, 3, 0, 36);
      add_location(hr0, file51, 13, 0, 266);
      attr_dev(div1, "class", "button-demo-props");
      add_location(div1, file51, 15, 0, 272);
      add_location(hr1, file51, 25, 0, 746);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h3, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, div0, anchor);
      if_blocks[current_block_type_index].m(div0, null);
      insert_dev(target, t4, anchor);
      mount_component(codebox, target, anchor);
      insert_dev(target, t5, anchor);
      insert_dev(target, hr0, anchor);
      insert_dev(target, t6, anchor);
      insert_dev(target, div1, anchor);
      mount_component(inputtext, div1, null);
      append_dev(div1, t7);
      mount_component(buttontoggle0, div1, null);
      append_dev(div1, t8);
      mount_component(buttontoggle1, div1, null);
      append_dev(div1, t9);
      mount_component(buttontoggle2, div1, null);
      append_dev(div1, t10);
      mount_component(toggle0, div1, null);
      append_dev(div1, t11);
      mount_component(toggle1, div1, null);
      insert_dev(target, t12, anchor);
      insert_dev(target, hr1, anchor);
      insert_dev(target, t13, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, null);
      }
      const codebox_changes = {};
      if (dirty & /*buttonText*/
      2)
        codebox_changes.text = /*buttonText*/
        ctx2[1];
      if (dirty & /*props*/
      1)
        codebox_changes.props = /*props*/
        ctx2[0];
      codebox.$set(codebox_changes);
      const inputtext_changes = {};
      if (!updating_value && dirty & /*buttonText*/
      2) {
        updating_value = true;
        inputtext_changes.value = /*buttonText*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      inputtext.$set(inputtext_changes);
      const toggle0_changes = {};
      if (!updating_value_1 && dirty & /*props*/
      1) {
        updating_value_1 = true;
        toggle0_changes.value = /*props*/
        ctx2[0].round;
        add_flush_callback(() => updating_value_1 = false);
      }
      toggle0.$set(toggle0_changes);
      const toggle1_changes = {};
      if (!updating_value_2 && dirty & /*props*/
      1) {
        updating_value_2 = true;
        toggle1_changes.value = /*props*/
        ctx2[0].disabled;
        add_flush_callback(() => updating_value_2 = false);
      }
      toggle1.$set(toggle1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(codebox.$$.fragment, local);
      transition_in(inputtext.$$.fragment, local);
      transition_in(buttontoggle0.$$.fragment, local);
      transition_in(buttontoggle1.$$.fragment, local);
      transition_in(buttontoggle2.$$.fragment, local);
      transition_in(toggle0.$$.fragment, local);
      transition_in(toggle1.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(codebox.$$.fragment, local);
      transition_out(inputtext.$$.fragment, local);
      transition_out(buttontoggle0.$$.fragment, local);
      transition_out(buttontoggle1.$$.fragment, local);
      transition_out(buttontoggle2.$$.fragment, local);
      transition_out(toggle0.$$.fragment, local);
      transition_out(toggle1.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(h3);
        detach_dev(t3);
        detach_dev(div0);
        detach_dev(t4);
        detach_dev(t5);
        detach_dev(hr0);
        detach_dev(t6);
        detach_dev(div1);
        detach_dev(t12);
        detach_dev(hr1);
        detach_dev(t13);
      }
      if_blocks[current_block_type_index].d();
      destroy_component(codebox, detaching);
      destroy_component(inputtext);
      destroy_component(buttontoggle0);
      destroy_component(buttontoggle1);
      destroy_component(buttontoggle2);
      destroy_component(toggle0);
      destroy_component(toggle1);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance58($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Button", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "danger",
      description: "Button type: danger"
    },
    {
      name: "data-",
      description: "Dataset attribute allows to pass some data of a primitive type (string, number, boolean), which will be accessible in the <em>on:click</em> event listener, via button reference."
    },
    {
      name: "disabled",
      description: "Makes the button <i>disabled</i>"
    },
    {
      name: "icon",
      type: "string",
      description: 'Adds an icon, with this name, to the button (see <a href="#Icon">icons</a> section for icon names)'
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying button"
    },
    {
      name: "info",
      description: "Button type: info"
    },
    {
      name: "link",
      description: "Button style: link"
    },
    {
      name: "outline",
      description: "Button style: outline"
    },
    {
      name: "round",
      description: "Makes the button round"
    },
    {
      name: "submit",
      type: ["true", "false"],
      default: "false",
      description: "If <i>true</i> button type is set to <i>submit</i>, otherwise it's <i>button</i>"
    },
    {
      name: "success",
      description: "Button type: success"
    },
    {
      name: "text",
      description: "Button style: text"
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying button"
    },
    {
      name: "warning",
      description: "Button type: warning"
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "on:click",
      type: "function",
      description: "Triggered when the button is clicked."
    }
  ];
  const props = {};
  let buttonText = "Demo button";
  const buttonStyles = [
    { name: "Normal", value: "" },
    { name: "Outline", value: "outline" },
    { name: "Text", value: "text" },
    { name: "Link", value: "link" }
  ];
  const buttonTypes = [
    { name: "Default", value: "" },
    { name: "Info", value: "info" },
    { name: "Success", value: "success" },
    { name: "Warning", value: "warning" },
    { name: "Danger", value: "danger" }
  ];
  const buttonIcons = [
    { name: "none", value: "" },
    { name: "info", value: "info" },
    { name: "check", value: "check" },
    { name: "alert", value: "alert" },
    { name: "trash", value: "trash" }
  ];
  function onStyleChange(e) {
    $$invalidate2(0, props.outline = false, props);
    $$invalidate2(0, props.text = false, props);
    $$invalidate2(0, props.link = false, props);
    setProp(e.detail, true);
  }
  function onTypeChange(e) {
    $$invalidate2(0, props.info = false, props);
    $$invalidate2(0, props.success = false, props);
    $$invalidate2(0, props.warning = false, props);
    $$invalidate2(0, props.danger = false, props);
    setProp(e.detail, true);
  }
  function onIconChange(e) {
    setProp("icon", e.detail);
  }
  function setProp(name2, val) {
    if (!name2 || typeof val === "undefined")
      return;
    $$invalidate2(0, props[name2] = val, props);
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Button> was created with unknown prop '${key}'`);
  });
  function inputtext_value_binding(value2) {
    buttonText = value2;
    $$invalidate2(1, buttonText);
  }
  function toggle0_value_binding(value2) {
    if ($$self2.$$.not_equal(props.round, value2)) {
      props.round = value2;
      $$invalidate2(0, props);
    }
  }
  function toggle1_value_binding(value2) {
    if ($$self2.$$.not_equal(props.disabled, value2)) {
      props.disabled = value2;
      $$invalidate2(0, props);
    }
  }
  $$self2.$capture_state = () => ({
    Button: Button_default,
    ButtonToggle: ButtonToggle_default,
    Toggle: Toggle_default,
    InputText: InputText_default,
    API: ApiTable_default,
    CodeBox: CodeBox_default,
    apiProps,
    props,
    buttonText,
    buttonStyles,
    buttonTypes,
    buttonIcons,
    onStyleChange,
    onTypeChange,
    onIconChange,
    setProp
  });
  $$self2.$inject_state = ($$props3) => {
    if ("buttonText" in $$props3)
      $$invalidate2(1, buttonText = $$props3.buttonText);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    props,
    buttonText,
    apiProps,
    buttonStyles,
    buttonTypes,
    buttonIcons,
    onStyleChange,
    onTypeChange,
    onIconChange,
    inputtext_value_binding,
    toggle0_value_binding,
    toggle1_value_binding
  ];
}
var Button_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance58, create_fragment58, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button_1",
      options,
      id: create_fragment58.name
    });
  }
};
var Button_default2 = Button_1;

// docs-src/components/push-button/PushButton.svelte
var file52 = "docs-src/components/push-button/PushButton.svelte";
function create_default_slot_24(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Hello");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_24.name,
    type: "slot",
    source: "(7:1) <PushButton>",
    ctx
  });
  return block;
}
function create_default_slot_23(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Info");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_23.name,
    type: "slot",
    source: "(8:1) <PushButton info>",
    ctx
  });
  return block;
}
function create_default_slot_222(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Warning");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_222.name,
    type: "slot",
    source: "(9:1) <PushButton success>",
    ctx
  });
  return block;
}
function create_default_slot_21(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Warning");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_21.name,
    type: "slot",
    source: "(10:1) <PushButton warning>",
    ctx
  });
  return block;
}
function create_default_slot_20(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Danger");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_20.name,
    type: "slot",
    source: "(11:1) <PushButton danger>",
    ctx
  });
  return block;
}
function create_default_slot_19(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Hello");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_19.name,
    type: "slot",
    source: "(17:1) <PushButton pressed>",
    ctx
  });
  return block;
}
function create_default_slot_18(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Info");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_18.name,
    type: "slot",
    source: "(18:1) <PushButton pressed info>",
    ctx
  });
  return block;
}
function create_default_slot_17(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Warning");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_17.name,
    type: "slot",
    source: "(19:1) <PushButton pressed success>",
    ctx
  });
  return block;
}
function create_default_slot_16(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Warning");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16.name,
    type: "slot",
    source: "(20:1) <PushButton pressed warning>",
    ctx
  });
  return block;
}
function create_default_slot_15(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Danger");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: "(21:1) <PushButton pressed danger>",
    ctx
  });
  return block;
}
function create_default_slot_14(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Hello");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: "(27:1) <PushButton pressed disabled>",
    ctx
  });
  return block;
}
function create_default_slot_132(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Info");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_132.name,
    type: "slot",
    source: "(28:1) <PushButton pressed disabled info>",
    ctx
  });
  return block;
}
function create_default_slot_122(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Success");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_122.name,
    type: "slot",
    source: "(29:1) <PushButton pressed disabled success>",
    ctx
  });
  return block;
}
function create_default_slot_11(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Warning");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_11.name,
    type: "slot",
    source: "(30:1) <PushButton pressed disabled warning>",
    ctx
  });
  return block;
}
function create_default_slot_10(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Danger");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_10.name,
    type: "slot",
    source: "(31:1) <PushButton pressed disabled danger>",
    ctx
  });
  return block;
}
function create_default_slot_9(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Help");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9.name,
    type: "slot",
    source: '(37:1) <PushButton icon=\\"help\\">',
    ctx
  });
  return block;
}
function create_default_slot_8(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Info");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8.name,
    type: "slot",
    source: '(38:1) <PushButton icon=\\"info\\" info>',
    ctx
  });
  return block;
}
function create_default_slot_7(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Success");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7.name,
    type: "slot",
    source: '(39:1) <PushButton icon=\\"check\\" success>',
    ctx
  });
  return block;
}
function create_default_slot_6(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Warning");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6.name,
    type: "slot",
    source: '(40:1) <PushButton icon=\\"alert\\" warning>',
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Delete");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: '(41:1) <PushButton icon=\\"trash\\" danger>',
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Hello");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(47:1) <PushButton outline>",
    ctx
  });
  return block;
}
function create_default_slot_32(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Info");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_32.name,
    type: "slot",
    source: "(48:1) <PushButton outline info>",
    ctx
  });
  return block;
}
function create_default_slot_25(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Warning");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_25.name,
    type: "slot",
    source: "(49:1) <PushButton outline success>",
    ctx
  });
  return block;
}
function create_default_slot_110(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Warning");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_110.name,
    type: "slot",
    source: "(50:1) <PushButton outline warning>",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Danger");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(51:1) <PushButton outline danger>",
    ctx
  });
  return block;
}
function create_fragment59(ctx) {
  let h2;
  let t1;
  let h30;
  let t3;
  let h40;
  let t5;
  let div0;
  let pushbutton0;
  let t6;
  let pushbutton1;
  let t7;
  let pushbutton2;
  let t8;
  let pushbutton3;
  let t9;
  let pushbutton4;
  let t10;
  let h41;
  let t12;
  let div1;
  let pushbutton5;
  let t13;
  let pushbutton6;
  let t14;
  let pushbutton7;
  let t15;
  let pushbutton8;
  let t16;
  let pushbutton9;
  let t17;
  let h42;
  let t19;
  let div2;
  let pushbutton10;
  let t20;
  let pushbutton11;
  let t21;
  let pushbutton12;
  let t22;
  let pushbutton13;
  let t23;
  let pushbutton14;
  let t24;
  let h43;
  let t26;
  let div3;
  let pushbutton15;
  let t27;
  let pushbutton16;
  let t28;
  let pushbutton17;
  let t29;
  let pushbutton18;
  let t30;
  let pushbutton19;
  let t31;
  let h44;
  let t33;
  let div4;
  let pushbutton20;
  let t34;
  let pushbutton21;
  let t35;
  let pushbutton22;
  let t36;
  let pushbutton23;
  let t37;
  let pushbutton24;
  let t38;
  let hr0;
  let t39;
  let h31;
  let t41;
  let h45;
  let t43;
  let div5;
  let pushbutton25;
  let t44;
  let pushbutton26;
  let t45;
  let pushbutton27;
  let t46;
  let pushbutton28;
  let t47;
  let pushbutton29;
  let t48;
  let hr1;
  let t49;
  let h32;
  let t51;
  let h46;
  let t53;
  let div6;
  let pushbutton30;
  let t54;
  let pushbutton31;
  let t55;
  let pushbutton32;
  let t56;
  let pushbutton33;
  let t57;
  let pushbutton34;
  let t58;
  let codeexample;
  let t59;
  let api;
  let current;
  pushbutton0 = new PushButton_default({
    props: {
      $$slots: { default: [create_default_slot_24] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton1 = new PushButton_default({
    props: {
      info: true,
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton2 = new PushButton_default({
    props: {
      success: true,
      $$slots: { default: [create_default_slot_222] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton3 = new PushButton_default({
    props: {
      warning: true,
      $$slots: { default: [create_default_slot_21] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton4 = new PushButton_default({
    props: {
      danger: true,
      $$slots: { default: [create_default_slot_20] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton5 = new PushButton_default({
    props: {
      pressed: true,
      $$slots: { default: [create_default_slot_19] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton6 = new PushButton_default({
    props: {
      pressed: true,
      info: true,
      $$slots: { default: [create_default_slot_18] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton7 = new PushButton_default({
    props: {
      pressed: true,
      success: true,
      $$slots: { default: [create_default_slot_17] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton8 = new PushButton_default({
    props: {
      pressed: true,
      warning: true,
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton9 = new PushButton_default({
    props: {
      pressed: true,
      danger: true,
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton10 = new PushButton_default({
    props: {
      pressed: true,
      disabled: true,
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton11 = new PushButton_default({
    props: {
      pressed: true,
      disabled: true,
      info: true,
      $$slots: { default: [create_default_slot_132] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton12 = new PushButton_default({
    props: {
      pressed: true,
      disabled: true,
      success: true,
      $$slots: { default: [create_default_slot_122] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton13 = new PushButton_default({
    props: {
      pressed: true,
      disabled: true,
      warning: true,
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton14 = new PushButton_default({
    props: {
      pressed: true,
      disabled: true,
      danger: true,
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton15 = new PushButton_default({
    props: {
      icon: "help",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton16 = new PushButton_default({
    props: {
      icon: "info",
      info: true,
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton17 = new PushButton_default({
    props: {
      icon: "check",
      success: true,
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton18 = new PushButton_default({
    props: {
      icon: "alert",
      warning: true,
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton19 = new PushButton_default({
    props: {
      icon: "trash",
      danger: true,
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton20 = new PushButton_default({
    props: {
      outline: true,
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton21 = new PushButton_default({
    props: {
      outline: true,
      info: true,
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton22 = new PushButton_default({
    props: {
      outline: true,
      success: true,
      $$slots: { default: [create_default_slot_25] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton23 = new PushButton_default({
    props: {
      outline: true,
      warning: true,
      $$slots: { default: [create_default_slot_110] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton24 = new PushButton_default({
    props: {
      outline: true,
      danger: true,
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton25 = new PushButton_default({ props: { icon: "help" }, $$inline: true });
  pushbutton26 = new PushButton_default({
    props: { icon: "info", info: true },
    $$inline: true
  });
  pushbutton27 = new PushButton_default({
    props: { icon: "check", success: true },
    $$inline: true
  });
  pushbutton28 = new PushButton_default({
    props: { icon: "alert", warning: true },
    $$inline: true
  });
  pushbutton29 = new PushButton_default({
    props: { icon: "trash", danger: true },
    $$inline: true
  });
  pushbutton30 = new PushButton_default({
    props: { round: true, icon: "help" },
    $$inline: true
  });
  pushbutton31 = new PushButton_default({
    props: { round: true, icon: "info", info: true },
    $$inline: true
  });
  pushbutton32 = new PushButton_default({
    props: {
      round: true,
      icon: "check",
      success: true
    },
    $$inline: true
  });
  pushbutton33 = new PushButton_default({
    props: {
      round: true,
      icon: "alert",
      warning: true
    },
    $$inline: true
  });
  pushbutton34 = new PushButton_default({
    props: { round: true, icon: "trash", danger: true },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[1]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Push Button";
      t1 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t3 = space();
      h40 = element2("h4");
      h40.textContent = "Default";
      t5 = space();
      div0 = element2("div");
      create_component(pushbutton0.$$.fragment);
      t6 = space();
      create_component(pushbutton1.$$.fragment);
      t7 = space();
      create_component(pushbutton2.$$.fragment);
      t8 = space();
      create_component(pushbutton3.$$.fragment);
      t9 = space();
      create_component(pushbutton4.$$.fragment);
      t10 = space();
      h41 = element2("h4");
      h41.textContent = "Pressed";
      t12 = space();
      div1 = element2("div");
      create_component(pushbutton5.$$.fragment);
      t13 = space();
      create_component(pushbutton6.$$.fragment);
      t14 = space();
      create_component(pushbutton7.$$.fragment);
      t15 = space();
      create_component(pushbutton8.$$.fragment);
      t16 = space();
      create_component(pushbutton9.$$.fragment);
      t17 = space();
      h42 = element2("h4");
      h42.textContent = "Disabled";
      t19 = space();
      div2 = element2("div");
      create_component(pushbutton10.$$.fragment);
      t20 = space();
      create_component(pushbutton11.$$.fragment);
      t21 = space();
      create_component(pushbutton12.$$.fragment);
      t22 = space();
      create_component(pushbutton13.$$.fragment);
      t23 = space();
      create_component(pushbutton14.$$.fragment);
      t24 = space();
      h43 = element2("h4");
      h43.textContent = "With icon";
      t26 = space();
      div3 = element2("div");
      create_component(pushbutton15.$$.fragment);
      t27 = space();
      create_component(pushbutton16.$$.fragment);
      t28 = space();
      create_component(pushbutton17.$$.fragment);
      t29 = space();
      create_component(pushbutton18.$$.fragment);
      t30 = space();
      create_component(pushbutton19.$$.fragment);
      t31 = space();
      h44 = element2("h4");
      h44.textContent = "Outline";
      t33 = space();
      div4 = element2("div");
      create_component(pushbutton20.$$.fragment);
      t34 = space();
      create_component(pushbutton21.$$.fragment);
      t35 = space();
      create_component(pushbutton22.$$.fragment);
      t36 = space();
      create_component(pushbutton23.$$.fragment);
      t37 = space();
      create_component(pushbutton24.$$.fragment);
      t38 = space();
      hr0 = element2("hr");
      t39 = space();
      h31 = element2("h3");
      h31.textContent = "Icon only buttons";
      t41 = space();
      h45 = element2("h4");
      h45.textContent = "Default";
      t43 = space();
      div5 = element2("div");
      create_component(pushbutton25.$$.fragment);
      t44 = space();
      create_component(pushbutton26.$$.fragment);
      t45 = space();
      create_component(pushbutton27.$$.fragment);
      t46 = space();
      create_component(pushbutton28.$$.fragment);
      t47 = space();
      create_component(pushbutton29.$$.fragment);
      t48 = space();
      hr1 = element2("hr");
      t49 = space();
      h32 = element2("h3");
      h32.textContent = "Icon only, and round";
      t51 = space();
      h46 = element2("h4");
      h46.textContent = "Default";
      t53 = space();
      div6 = element2("div");
      create_component(pushbutton30.$$.fragment);
      t54 = space();
      create_component(pushbutton31.$$.fragment);
      t55 = space();
      create_component(pushbutton32.$$.fragment);
      t56 = space();
      create_component(pushbutton33.$$.fragment);
      t57 = space();
      create_component(pushbutton34.$$.fragment);
      t58 = space();
      create_component(codeexample.$$.fragment);
      t59 = space();
      create_component(api.$$.fragment);
      add_location(h2, file52, 0, 0, 0);
      add_location(h30, file52, 2, 0, 22);
      add_location(h40, file52, 4, 0, 39);
      attr_dev(div0, "class", "docs-buttons-row");
      add_location(div0, file52, 5, 0, 56);
      add_location(h41, file52, 14, 0, 288);
      attr_dev(div1, "class", "docs-buttons-row");
      add_location(div1, file52, 15, 0, 305);
      add_location(h42, file52, 24, 0, 577);
      attr_dev(div2, "class", "docs-buttons-row");
      add_location(div2, file52, 25, 0, 595);
      add_location(h43, file52, 34, 0, 912);
      attr_dev(div3, "class", "docs-buttons-row");
      add_location(div3, file52, 35, 0, 931);
      add_location(h44, file52, 44, 0, 1225);
      attr_dev(div4, "class", "docs-buttons-row");
      add_location(div4, file52, 45, 0, 1242);
      add_location(hr0, file52, 54, 0, 1514);
      add_location(h31, file52, 55, 0, 1519);
      add_location(h45, file52, 57, 0, 1547);
      attr_dev(div5, "class", "docs-buttons-row");
      add_location(div5, file52, 58, 0, 1564);
      add_location(hr1, file52, 67, 0, 1830);
      add_location(h32, file52, 68, 0, 1835);
      add_location(h46, file52, 70, 0, 1866);
      attr_dev(div6, "class", "docs-buttons-row");
      add_location(div6, file52, 71, 0, 1883);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, h40, anchor);
      insert_dev(target, t5, anchor);
      insert_dev(target, div0, anchor);
      mount_component(pushbutton0, div0, null);
      append_dev(div0, t6);
      mount_component(pushbutton1, div0, null);
      append_dev(div0, t7);
      mount_component(pushbutton2, div0, null);
      append_dev(div0, t8);
      mount_component(pushbutton3, div0, null);
      append_dev(div0, t9);
      mount_component(pushbutton4, div0, null);
      insert_dev(target, t10, anchor);
      insert_dev(target, h41, anchor);
      insert_dev(target, t12, anchor);
      insert_dev(target, div1, anchor);
      mount_component(pushbutton5, div1, null);
      append_dev(div1, t13);
      mount_component(pushbutton6, div1, null);
      append_dev(div1, t14);
      mount_component(pushbutton7, div1, null);
      append_dev(div1, t15);
      mount_component(pushbutton8, div1, null);
      append_dev(div1, t16);
      mount_component(pushbutton9, div1, null);
      insert_dev(target, t17, anchor);
      insert_dev(target, h42, anchor);
      insert_dev(target, t19, anchor);
      insert_dev(target, div2, anchor);
      mount_component(pushbutton10, div2, null);
      append_dev(div2, t20);
      mount_component(pushbutton11, div2, null);
      append_dev(div2, t21);
      mount_component(pushbutton12, div2, null);
      append_dev(div2, t22);
      mount_component(pushbutton13, div2, null);
      append_dev(div2, t23);
      mount_component(pushbutton14, div2, null);
      insert_dev(target, t24, anchor);
      insert_dev(target, h43, anchor);
      insert_dev(target, t26, anchor);
      insert_dev(target, div3, anchor);
      mount_component(pushbutton15, div3, null);
      append_dev(div3, t27);
      mount_component(pushbutton16, div3, null);
      append_dev(div3, t28);
      mount_component(pushbutton17, div3, null);
      append_dev(div3, t29);
      mount_component(pushbutton18, div3, null);
      append_dev(div3, t30);
      mount_component(pushbutton19, div3, null);
      insert_dev(target, t31, anchor);
      insert_dev(target, h44, anchor);
      insert_dev(target, t33, anchor);
      insert_dev(target, div4, anchor);
      mount_component(pushbutton20, div4, null);
      append_dev(div4, t34);
      mount_component(pushbutton21, div4, null);
      append_dev(div4, t35);
      mount_component(pushbutton22, div4, null);
      append_dev(div4, t36);
      mount_component(pushbutton23, div4, null);
      append_dev(div4, t37);
      mount_component(pushbutton24, div4, null);
      insert_dev(target, t38, anchor);
      insert_dev(target, hr0, anchor);
      insert_dev(target, t39, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t41, anchor);
      insert_dev(target, h45, anchor);
      insert_dev(target, t43, anchor);
      insert_dev(target, div5, anchor);
      mount_component(pushbutton25, div5, null);
      append_dev(div5, t44);
      mount_component(pushbutton26, div5, null);
      append_dev(div5, t45);
      mount_component(pushbutton27, div5, null);
      append_dev(div5, t46);
      mount_component(pushbutton28, div5, null);
      append_dev(div5, t47);
      mount_component(pushbutton29, div5, null);
      insert_dev(target, t48, anchor);
      insert_dev(target, hr1, anchor);
      insert_dev(target, t49, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t51, anchor);
      insert_dev(target, h46, anchor);
      insert_dev(target, t53, anchor);
      insert_dev(target, div6, anchor);
      mount_component(pushbutton30, div6, null);
      append_dev(div6, t54);
      mount_component(pushbutton31, div6, null);
      append_dev(div6, t55);
      mount_component(pushbutton32, div6, null);
      append_dev(div6, t56);
      mount_component(pushbutton33, div6, null);
      append_dev(div6, t57);
      mount_component(pushbutton34, div6, null);
      insert_dev(target, t58, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t59, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const pushbutton0_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton0.$set(pushbutton0_changes);
      const pushbutton1_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton1.$set(pushbutton1_changes);
      const pushbutton2_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton2.$set(pushbutton2_changes);
      const pushbutton3_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton3.$set(pushbutton3_changes);
      const pushbutton4_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton4.$set(pushbutton4_changes);
      const pushbutton5_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton5.$set(pushbutton5_changes);
      const pushbutton6_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton6.$set(pushbutton6_changes);
      const pushbutton7_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton7.$set(pushbutton7_changes);
      const pushbutton8_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton8_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton8.$set(pushbutton8_changes);
      const pushbutton9_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton9_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton9.$set(pushbutton9_changes);
      const pushbutton10_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton10_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton10.$set(pushbutton10_changes);
      const pushbutton11_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton11_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton11.$set(pushbutton11_changes);
      const pushbutton12_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton12_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton12.$set(pushbutton12_changes);
      const pushbutton13_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton13_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton13.$set(pushbutton13_changes);
      const pushbutton14_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton14_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton14.$set(pushbutton14_changes);
      const pushbutton15_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton15_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton15.$set(pushbutton15_changes);
      const pushbutton16_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton16_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton16.$set(pushbutton16_changes);
      const pushbutton17_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton17_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton17.$set(pushbutton17_changes);
      const pushbutton18_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton18_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton18.$set(pushbutton18_changes);
      const pushbutton19_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton19_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton19.$set(pushbutton19_changes);
      const pushbutton20_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton20_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton20.$set(pushbutton20_changes);
      const pushbutton21_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton21_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton21.$set(pushbutton21_changes);
      const pushbutton22_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton22_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton22.$set(pushbutton22_changes);
      const pushbutton23_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton23_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton23.$set(pushbutton23_changes);
      const pushbutton24_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton24_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton24.$set(pushbutton24_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pushbutton0.$$.fragment, local);
      transition_in(pushbutton1.$$.fragment, local);
      transition_in(pushbutton2.$$.fragment, local);
      transition_in(pushbutton3.$$.fragment, local);
      transition_in(pushbutton4.$$.fragment, local);
      transition_in(pushbutton5.$$.fragment, local);
      transition_in(pushbutton6.$$.fragment, local);
      transition_in(pushbutton7.$$.fragment, local);
      transition_in(pushbutton8.$$.fragment, local);
      transition_in(pushbutton9.$$.fragment, local);
      transition_in(pushbutton10.$$.fragment, local);
      transition_in(pushbutton11.$$.fragment, local);
      transition_in(pushbutton12.$$.fragment, local);
      transition_in(pushbutton13.$$.fragment, local);
      transition_in(pushbutton14.$$.fragment, local);
      transition_in(pushbutton15.$$.fragment, local);
      transition_in(pushbutton16.$$.fragment, local);
      transition_in(pushbutton17.$$.fragment, local);
      transition_in(pushbutton18.$$.fragment, local);
      transition_in(pushbutton19.$$.fragment, local);
      transition_in(pushbutton20.$$.fragment, local);
      transition_in(pushbutton21.$$.fragment, local);
      transition_in(pushbutton22.$$.fragment, local);
      transition_in(pushbutton23.$$.fragment, local);
      transition_in(pushbutton24.$$.fragment, local);
      transition_in(pushbutton25.$$.fragment, local);
      transition_in(pushbutton26.$$.fragment, local);
      transition_in(pushbutton27.$$.fragment, local);
      transition_in(pushbutton28.$$.fragment, local);
      transition_in(pushbutton29.$$.fragment, local);
      transition_in(pushbutton30.$$.fragment, local);
      transition_in(pushbutton31.$$.fragment, local);
      transition_in(pushbutton32.$$.fragment, local);
      transition_in(pushbutton33.$$.fragment, local);
      transition_in(pushbutton34.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pushbutton0.$$.fragment, local);
      transition_out(pushbutton1.$$.fragment, local);
      transition_out(pushbutton2.$$.fragment, local);
      transition_out(pushbutton3.$$.fragment, local);
      transition_out(pushbutton4.$$.fragment, local);
      transition_out(pushbutton5.$$.fragment, local);
      transition_out(pushbutton6.$$.fragment, local);
      transition_out(pushbutton7.$$.fragment, local);
      transition_out(pushbutton8.$$.fragment, local);
      transition_out(pushbutton9.$$.fragment, local);
      transition_out(pushbutton10.$$.fragment, local);
      transition_out(pushbutton11.$$.fragment, local);
      transition_out(pushbutton12.$$.fragment, local);
      transition_out(pushbutton13.$$.fragment, local);
      transition_out(pushbutton14.$$.fragment, local);
      transition_out(pushbutton15.$$.fragment, local);
      transition_out(pushbutton16.$$.fragment, local);
      transition_out(pushbutton17.$$.fragment, local);
      transition_out(pushbutton18.$$.fragment, local);
      transition_out(pushbutton19.$$.fragment, local);
      transition_out(pushbutton20.$$.fragment, local);
      transition_out(pushbutton21.$$.fragment, local);
      transition_out(pushbutton22.$$.fragment, local);
      transition_out(pushbutton23.$$.fragment, local);
      transition_out(pushbutton24.$$.fragment, local);
      transition_out(pushbutton25.$$.fragment, local);
      transition_out(pushbutton26.$$.fragment, local);
      transition_out(pushbutton27.$$.fragment, local);
      transition_out(pushbutton28.$$.fragment, local);
      transition_out(pushbutton29.$$.fragment, local);
      transition_out(pushbutton30.$$.fragment, local);
      transition_out(pushbutton31.$$.fragment, local);
      transition_out(pushbutton32.$$.fragment, local);
      transition_out(pushbutton33.$$.fragment, local);
      transition_out(pushbutton34.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(h30);
        detach_dev(t3);
        detach_dev(h40);
        detach_dev(t5);
        detach_dev(div0);
        detach_dev(t10);
        detach_dev(h41);
        detach_dev(t12);
        detach_dev(div1);
        detach_dev(t17);
        detach_dev(h42);
        detach_dev(t19);
        detach_dev(div2);
        detach_dev(t24);
        detach_dev(h43);
        detach_dev(t26);
        detach_dev(div3);
        detach_dev(t31);
        detach_dev(h44);
        detach_dev(t33);
        detach_dev(div4);
        detach_dev(t38);
        detach_dev(hr0);
        detach_dev(t39);
        detach_dev(h31);
        detach_dev(t41);
        detach_dev(h45);
        detach_dev(t43);
        detach_dev(div5);
        detach_dev(t48);
        detach_dev(hr1);
        detach_dev(t49);
        detach_dev(h32);
        detach_dev(t51);
        detach_dev(h46);
        detach_dev(t53);
        detach_dev(div6);
        detach_dev(t58);
        detach_dev(t59);
      }
      destroy_component(pushbutton0);
      destroy_component(pushbutton1);
      destroy_component(pushbutton2);
      destroy_component(pushbutton3);
      destroy_component(pushbutton4);
      destroy_component(pushbutton5);
      destroy_component(pushbutton6);
      destroy_component(pushbutton7);
      destroy_component(pushbutton8);
      destroy_component(pushbutton9);
      destroy_component(pushbutton10);
      destroy_component(pushbutton11);
      destroy_component(pushbutton12);
      destroy_component(pushbutton13);
      destroy_component(pushbutton14);
      destroy_component(pushbutton15);
      destroy_component(pushbutton16);
      destroy_component(pushbutton17);
      destroy_component(pushbutton18);
      destroy_component(pushbutton19);
      destroy_component(pushbutton20);
      destroy_component(pushbutton21);
      destroy_component(pushbutton22);
      destroy_component(pushbutton23);
      destroy_component(pushbutton24);
      destroy_component(pushbutton25);
      destroy_component(pushbutton26);
      destroy_component(pushbutton27);
      destroy_component(pushbutton28);
      destroy_component(pushbutton29);
      destroy_component(pushbutton30);
      destroy_component(pushbutton31);
      destroy_component(pushbutton32);
      destroy_component(pushbutton33);
      destroy_component(pushbutton34);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment59.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance59($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("PushButton", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "danger",
      description: "Button type: danger"
    },
    {
      name: "disabled",
      description: "Makes the button <i>disabled</i>"
    },
    {
      name: "icon",
      type: "string",
      description: 'Adds an icon, with this name, to the button (see <a href="#Icon">icons</a> section for icon names)'
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying button"
    },
    {
      name: "outline",
      description: "Button style: outline"
    },
    {
      name: "pressed",
      type: ["true", "false"],
      default: "false",
      description: "Initial <i>pressed</i> state of the button."
    },
    {
      name: "round",
      description: "Makes the button round"
    },
    {
      name: "submit",
      type: ["true", "false"],
      default: "false",
      description: "If <i>true</i> button type is set to <i>submit</i>, otherwise it's <i>button</i>"
    },
    {
      name: "success",
      description: "Button type: success"
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying button"
    },
    {
      name: "warning",
      description: "Button type: warning"
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "on:click",
      type: "function",
      description: "Triggered when the button is clicked."
    }
  ];
  const exampleHtml = `
<PushButton round icon="info" on:change="{onChange}"></PushButton>

<script>
function onChange (e) {
    const { pressed } = e.detail;
    console.log('is pressed:', pressed);
}
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PushButton> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    PushButton: PushButton_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    exampleHtml
  });
  return [apiProps, exampleHtml];
}
var PushButton_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance59, create_fragment59, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PushButton_1",
      options,
      id: create_fragment59.name
    });
  }
};
var PushButton_default2 = PushButton_1;

// docs-src/components/button-group/ButtonGroup.svelte
var file53 = "docs-src/components/button-group/ButtonGroup.svelte";
function create_default_slot_44(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("One");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_44.name,
    type: "slot",
    source: "(6:1) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_43(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Disabled");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_43.name,
    type: "slot",
    source: "(7:1) <Button disabled>",
    ctx
  });
  return block;
}
function create_default_slot_42(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Three");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_42.name,
    type: "slot",
    source: "(8:1) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_41(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Four");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_41.name,
    type: "slot",
    source: "(9:1) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_40(ctx) {
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let t2;
  let button3;
  let current;
  button0 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_44] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1 = new Button_default({
    props: {
      disabled: true,
      $$slots: { default: [create_default_slot_43] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button2 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_42] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button3 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_41] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
      t2 = space();
      create_component(button3.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(button1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(button2, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(button3, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      const button3_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button3.$set(button3_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
      destroy_component(button0, detaching);
      destroy_component(button1, detaching);
      destroy_component(button2, detaching);
      destroy_component(button3, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_40.name,
    type: "slot",
    source: "(5:0) <ButtonGroup>",
    ctx
  });
  return block;
}
function create_default_slot_39(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("One");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_39.name,
    type: "slot",
    source: "(15:2) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_38(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Disabled");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_38.name,
    type: "slot",
    source: "(16:2) <Button disabled>",
    ctx
  });
  return block;
}
function create_default_slot_37(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Three");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_37.name,
    type: "slot",
    source: "(17:2) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_36(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Four");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_36.name,
    type: "slot",
    source: "(18:2) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_35(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Five");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_35.name,
    type: "slot",
    source: "(19:2) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_34(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Six");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_34.name,
    type: "slot",
    source: "(20:2) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_33(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Seven");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_33.name,
    type: "slot",
    source: "(21:2) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_322(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Eight");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_322.name,
    type: "slot",
    source: "(22:2) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_31(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Nine");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_31.name,
    type: "slot",
    source: "(23:2) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_30(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Ten");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_30.name,
    type: "slot",
    source: "(24:2) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_29(ctx) {
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let t2;
  let button3;
  let t3;
  let button4;
  let t4;
  let button5;
  let t5;
  let button6;
  let t6;
  let button7;
  let t7;
  let button8;
  let t8;
  let button9;
  let current;
  button0 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_39] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1 = new Button_default({
    props: {
      disabled: true,
      $$slots: { default: [create_default_slot_38] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button2 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_37] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button3 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_36] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button4 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_35] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button5 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_34] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button6 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_33] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button7 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_322] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button8 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_31] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button9 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_30] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
      t2 = space();
      create_component(button3.$$.fragment);
      t3 = space();
      create_component(button4.$$.fragment);
      t4 = space();
      create_component(button5.$$.fragment);
      t5 = space();
      create_component(button6.$$.fragment);
      t6 = space();
      create_component(button7.$$.fragment);
      t7 = space();
      create_component(button8.$$.fragment);
      t8 = space();
      create_component(button9.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(button1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(button2, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(button3, target, anchor);
      insert_dev(target, t3, anchor);
      mount_component(button4, target, anchor);
      insert_dev(target, t4, anchor);
      mount_component(button5, target, anchor);
      insert_dev(target, t5, anchor);
      mount_component(button6, target, anchor);
      insert_dev(target, t6, anchor);
      mount_component(button7, target, anchor);
      insert_dev(target, t7, anchor);
      mount_component(button8, target, anchor);
      insert_dev(target, t8, anchor);
      mount_component(button9, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      const button3_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button3.$set(button3_changes);
      const button4_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button4.$set(button4_changes);
      const button5_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button5.$set(button5_changes);
      const button6_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button6.$set(button6_changes);
      const button7_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button7.$set(button7_changes);
      const button8_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button8_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button8.$set(button8_changes);
      const button9_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button9_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button9.$set(button9_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      transition_in(button4.$$.fragment, local);
      transition_in(button5.$$.fragment, local);
      transition_in(button6.$$.fragment, local);
      transition_in(button7.$$.fragment, local);
      transition_in(button8.$$.fragment, local);
      transition_in(button9.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      transition_out(button4.$$.fragment, local);
      transition_out(button5.$$.fragment, local);
      transition_out(button6.$$.fragment, local);
      transition_out(button7.$$.fragment, local);
      transition_out(button8.$$.fragment, local);
      transition_out(button9.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(t5);
        detach_dev(t6);
        detach_dev(t7);
        detach_dev(t8);
      }
      destroy_component(button0, detaching);
      destroy_component(button1, detaching);
      destroy_component(button2, detaching);
      destroy_component(button3, detaching);
      destroy_component(button4, detaching);
      destroy_component(button5, detaching);
      destroy_component(button6, detaching);
      destroy_component(button7, detaching);
      destroy_component(button8, detaching);
      destroy_component(button9, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_29.name,
    type: "slot",
    source: "(14:1) <ButtonGroup>",
    ctx
  });
  return block;
}
function create_default_slot_28(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("One");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_28.name,
    type: "slot",
    source: "(30:1) <Button info>",
    ctx
  });
  return block;
}
function create_default_slot_27(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Disabled");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_27.name,
    type: "slot",
    source: "(31:1) <Button success disabled>",
    ctx
  });
  return block;
}
function create_default_slot_26(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Three");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_26.name,
    type: "slot",
    source: "(32:1) <Button warning>",
    ctx
  });
  return block;
}
function create_default_slot_252(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Four");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_252.name,
    type: "slot",
    source: "(33:1) <Button danger>",
    ctx
  });
  return block;
}
function create_default_slot_242(ctx) {
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let t2;
  let button3;
  let current;
  button0 = new Button_default({
    props: {
      info: true,
      $$slots: { default: [create_default_slot_28] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1 = new Button_default({
    props: {
      success: true,
      disabled: true,
      $$slots: { default: [create_default_slot_27] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button2 = new Button_default({
    props: {
      warning: true,
      $$slots: { default: [create_default_slot_26] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button3 = new Button_default({
    props: {
      danger: true,
      $$slots: { default: [create_default_slot_252] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
      t2 = space();
      create_component(button3.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(button1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(button2, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(button3, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      const button3_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button3.$set(button3_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
      destroy_component(button0, detaching);
      destroy_component(button1, detaching);
      destroy_component(button2, detaching);
      destroy_component(button3, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_242.name,
    type: "slot",
    source: "(29:0) <ButtonGroup>",
    ctx
  });
  return block;
}
function create_default_slot_232(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("One");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_232.name,
    type: "slot",
    source: "(38:1) <Button outline>",
    ctx
  });
  return block;
}
function create_default_slot_223(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Two");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_223.name,
    type: "slot",
    source: "(39:1) <Button outline>",
    ctx
  });
  return block;
}
function create_default_slot_212(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Disabled");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_212.name,
    type: "slot",
    source: "(40:1) <Button outline disabled>",
    ctx
  });
  return block;
}
function create_default_slot_202(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Four");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_202.name,
    type: "slot",
    source: "(41:1) <Button outline>",
    ctx
  });
  return block;
}
function create_default_slot_192(ctx) {
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let t2;
  let button3;
  let current;
  button0 = new Button_default({
    props: {
      outline: true,
      $$slots: { default: [create_default_slot_232] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1 = new Button_default({
    props: {
      outline: true,
      $$slots: { default: [create_default_slot_223] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button2 = new Button_default({
    props: {
      outline: true,
      disabled: true,
      $$slots: { default: [create_default_slot_212] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button3 = new Button_default({
    props: {
      outline: true,
      $$slots: { default: [create_default_slot_202] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
      t2 = space();
      create_component(button3.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(button1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(button2, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(button3, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      const button3_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button3.$set(button3_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
      destroy_component(button0, detaching);
      destroy_component(button1, detaching);
      destroy_component(button2, detaching);
      destroy_component(button3, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_192.name,
    type: "slot",
    source: "(37:0) <ButtonGroup>",
    ctx
  });
  return block;
}
function create_default_slot_182(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("One");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_182.name,
    type: "slot",
    source: "(47:1) <Button text>",
    ctx
  });
  return block;
}
function create_default_slot_172(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Disabled");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_172.name,
    type: "slot",
    source: "(48:1) <Button text disabled>",
    ctx
  });
  return block;
}
function create_default_slot_162(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Three");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_162.name,
    type: "slot",
    source: "(49:1) <Button text>",
    ctx
  });
  return block;
}
function create_default_slot_152(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Four");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_152.name,
    type: "slot",
    source: "(50:1) <Button text>",
    ctx
  });
  return block;
}
function create_default_slot_142(ctx) {
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let t2;
  let button3;
  let current;
  button0 = new Button_default({
    props: {
      text: true,
      $$slots: { default: [create_default_slot_182] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1 = new Button_default({
    props: {
      text: true,
      disabled: true,
      $$slots: { default: [create_default_slot_172] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button2 = new Button_default({
    props: {
      text: true,
      $$slots: { default: [create_default_slot_162] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button3 = new Button_default({
    props: {
      text: true,
      $$slots: { default: [create_default_slot_152] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
      t2 = space();
      create_component(button3.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(button1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(button2, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(button3, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      const button3_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button3.$set(button3_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
      destroy_component(button0, detaching);
      destroy_component(button1, detaching);
      destroy_component(button2, detaching);
      destroy_component(button3, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_142.name,
    type: "slot",
    source: "(46:0) <ButtonGroup>",
    ctx
  });
  return block;
}
function create_default_slot_133(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("One");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_133.name,
    type: "slot",
    source: "(56:1) <PushButton>",
    ctx
  });
  return block;
}
function create_default_slot_123(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Two");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_123.name,
    type: "slot",
    source: "(57:1) <PushButton>",
    ctx
  });
  return block;
}
function create_default_slot_112(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Three");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_112.name,
    type: "slot",
    source: "(58:1) <PushButton>",
    ctx
  });
  return block;
}
function create_default_slot_102(ctx) {
  let pushbutton0;
  let t0;
  let pushbutton1;
  let t1;
  let pushbutton2;
  let current;
  pushbutton0 = new PushButton_default({
    props: {
      $$slots: { default: [create_default_slot_133] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton1 = new PushButton_default({
    props: {
      $$slots: { default: [create_default_slot_123] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pushbutton2 = new PushButton_default({
    props: {
      $$slots: { default: [create_default_slot_112] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(pushbutton0.$$.fragment);
      t0 = space();
      create_component(pushbutton1.$$.fragment);
      t1 = space();
      create_component(pushbutton2.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(pushbutton0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(pushbutton1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(pushbutton2, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const pushbutton0_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton0.$set(pushbutton0_changes);
      const pushbutton1_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton1.$set(pushbutton1_changes);
      const pushbutton2_changes = {};
      if (dirty & /*$$scope*/
      4) {
        pushbutton2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pushbutton2.$set(pushbutton2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pushbutton0.$$.fragment, local);
      transition_in(pushbutton1.$$.fragment, local);
      transition_in(pushbutton2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pushbutton0.$$.fragment, local);
      transition_out(pushbutton1.$$.fragment, local);
      transition_out(pushbutton2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      destroy_component(pushbutton0, detaching);
      destroy_component(pushbutton1, detaching);
      destroy_component(pushbutton2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_102.name,
    type: "slot",
    source: "(55:0) <ButtonGroup>",
    ctx
  });
  return block;
}
function create_default_slot_92(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("One");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_92.name,
    type: "slot",
    source: "(64:1) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_82(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Two");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_82.name,
    type: "slot",
    source: "(65:1) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_72(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Three");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_72.name,
    type: "slot",
    source: "(66:1) <Button>",
    ctx
  });
  return block;
}
function create_default_slot_62(ctx) {
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let current;
  button0 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_92] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_82] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button2 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_72] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(button1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(button2, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      destroy_component(button0, detaching);
      destroy_component(button1, detaching);
      destroy_component(button2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_62.name,
    type: "slot",
    source: "(63:0) <ButtonGroup round>",
    ctx
  });
  return block;
}
function create_default_slot_52(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("One");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_52.name,
    type: "slot",
    source: '(72:1) <Button icon=\\"info\\">',
    ctx
  });
  return block;
}
function create_default_slot_45(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Two");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_45.name,
    type: "slot",
    source: '(73:1) <Button icon=\\"check\\">',
    ctx
  });
  return block;
}
function create_default_slot_310(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Three");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_310.name,
    type: "slot",
    source: '(74:1) <Button icon=\\"alert\\">',
    ctx
  });
  return block;
}
function create_default_slot_210(ctx) {
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let current;
  button0 = new Button_default({
    props: {
      icon: "info",
      $$slots: { default: [create_default_slot_52] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1 = new Button_default({
    props: {
      icon: "check",
      $$slots: { default: [create_default_slot_45] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button2 = new Button_default({
    props: {
      icon: "alert",
      $$slots: { default: [create_default_slot_310] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(button1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(button2, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      destroy_component(button0, detaching);
      destroy_component(button1, detaching);
      destroy_component(button2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_210.name,
    type: "slot",
    source: "(71:0) <ButtonGroup>",
    ctx
  });
  return block;
}
function create_default_slot_111(ctx) {
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let current;
  button0 = new Button_default({ props: { icon: "info" }, $$inline: true });
  button1 = new Button_default({ props: { icon: "check" }, $$inline: true });
  button2 = new Button_default({ props: { icon: "alert" }, $$inline: true });
  const block = {
    c: function create() {
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(button1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(button2, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      destroy_component(button0, detaching);
      destroy_component(button1, detaching);
      destroy_component(button2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_111.name,
    type: "slot",
    source: "(79:0) <ButtonGroup>",
    ctx
  });
  return block;
}
function create_default_slot8(ctx) {
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let current;
  button0 = new Button_default({ props: { icon: "info" }, $$inline: true });
  button1 = new Button_default({ props: { icon: "check" }, $$inline: true });
  button2 = new Button_default({ props: { icon: "alert" }, $$inline: true });
  const block = {
    c: function create() {
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(button1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(button2, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      destroy_component(button0, detaching);
      destroy_component(button1, detaching);
      destroy_component(button2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(87:0) <ButtonGroup round>",
    ctx
  });
  return block;
}
function create_fragment60(ctx) {
  let h2;
  let t1;
  let h30;
  let t3;
  let buttongroup0;
  let t4;
  let h31;
  let t6;
  let div;
  let buttongroup1;
  let t7;
  let h32;
  let t9;
  let buttongroup2;
  let t10;
  let h33;
  let t12;
  let buttongroup3;
  let t13;
  let h34;
  let t15;
  let buttongroup4;
  let t16;
  let h35;
  let t18;
  let buttongroup5;
  let t19;
  let h36;
  let t21;
  let buttongroup6;
  let t22;
  let h37;
  let t24;
  let buttongroup7;
  let t25;
  let h38;
  let t27;
  let buttongroup8;
  let t28;
  let h39;
  let t30;
  let buttongroup9;
  let t31;
  let codeexample;
  let t32;
  let api;
  let current;
  buttongroup0 = new ButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_40] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  buttongroup1 = new ButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_29] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  buttongroup2 = new ButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_242] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  buttongroup3 = new ButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_192] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  buttongroup4 = new ButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_142] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  buttongroup5 = new ButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_102] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  buttongroup6 = new ButtonGroup_default({
    props: {
      round: true,
      $$slots: { default: [create_default_slot_62] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  buttongroup7 = new ButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_210] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  buttongroup8 = new ButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_111] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  buttongroup9 = new ButtonGroup_default({
    props: {
      round: true,
      $$slots: { default: [create_default_slot8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[1]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Button Group";
      t1 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t3 = space();
      create_component(buttongroup0.$$.fragment);
      t4 = space();
      h31 = element2("h3");
      h31.textContent = "Long";
      t6 = space();
      div = element2("div");
      create_component(buttongroup1.$$.fragment);
      t7 = space();
      h32 = element2("h3");
      h32.textContent = "Normal, info, success, warning, danger";
      t9 = space();
      create_component(buttongroup2.$$.fragment);
      t10 = space();
      h33 = element2("h3");
      h33.textContent = "Outline Buttons";
      t12 = space();
      create_component(buttongroup3.$$.fragment);
      t13 = space();
      h34 = element2("h3");
      h34.textContent = "Text Buttons";
      t15 = space();
      create_component(buttongroup4.$$.fragment);
      t16 = space();
      h35 = element2("h3");
      h35.textContent = "Push Buttons";
      t18 = space();
      create_component(buttongroup5.$$.fragment);
      t19 = space();
      h36 = element2("h3");
      h36.textContent = "Round";
      t21 = space();
      create_component(buttongroup6.$$.fragment);
      t22 = space();
      h37 = element2("h3");
      h37.textContent = "With icons";
      t24 = space();
      create_component(buttongroup7.$$.fragment);
      t25 = space();
      h38 = element2("h3");
      h38.textContent = "Icons only";
      t27 = space();
      create_component(buttongroup8.$$.fragment);
      t28 = space();
      h39 = element2("h3");
      h39.textContent = "Icons only, and round";
      t30 = space();
      create_component(buttongroup9.$$.fragment);
      t31 = space();
      create_component(codeexample.$$.fragment);
      t32 = space();
      create_component(api.$$.fragment);
      add_location(h2, file53, 0, 0, 0);
      add_location(h30, file53, 3, 0, 24);
      add_location(h31, file53, 11, 0, 175);
      set_style(div, "width", "400px");
      set_style(div, "max-width", "100%");
      add_location(div, file53, 12, 0, 189);
      add_location(h32, file53, 27, 0, 525);
      add_location(h33, file53, 35, 0, 736);
      add_location(h34, file53, 44, 0, 927);
      add_location(h35, file53, 53, 0, 1105);
      add_location(h36, file53, 61, 0, 1250);
      add_location(h37, file53, 69, 0, 1370);
      add_location(h38, file53, 77, 0, 1527);
      add_location(h39, file53, 85, 0, 1673);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t3, anchor);
      mount_component(buttongroup0, target, anchor);
      insert_dev(target, t4, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t6, anchor);
      insert_dev(target, div, anchor);
      mount_component(buttongroup1, div, null);
      insert_dev(target, t7, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t9, anchor);
      mount_component(buttongroup2, target, anchor);
      insert_dev(target, t10, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t12, anchor);
      mount_component(buttongroup3, target, anchor);
      insert_dev(target, t13, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t15, anchor);
      mount_component(buttongroup4, target, anchor);
      insert_dev(target, t16, anchor);
      insert_dev(target, h35, anchor);
      insert_dev(target, t18, anchor);
      mount_component(buttongroup5, target, anchor);
      insert_dev(target, t19, anchor);
      insert_dev(target, h36, anchor);
      insert_dev(target, t21, anchor);
      mount_component(buttongroup6, target, anchor);
      insert_dev(target, t22, anchor);
      insert_dev(target, h37, anchor);
      insert_dev(target, t24, anchor);
      mount_component(buttongroup7, target, anchor);
      insert_dev(target, t25, anchor);
      insert_dev(target, h38, anchor);
      insert_dev(target, t27, anchor);
      mount_component(buttongroup8, target, anchor);
      insert_dev(target, t28, anchor);
      insert_dev(target, h39, anchor);
      insert_dev(target, t30, anchor);
      mount_component(buttongroup9, target, anchor);
      insert_dev(target, t31, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t32, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const buttongroup0_changes = {};
      if (dirty & /*$$scope*/
      4) {
        buttongroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttongroup0.$set(buttongroup0_changes);
      const buttongroup1_changes = {};
      if (dirty & /*$$scope*/
      4) {
        buttongroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttongroup1.$set(buttongroup1_changes);
      const buttongroup2_changes = {};
      if (dirty & /*$$scope*/
      4) {
        buttongroup2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttongroup2.$set(buttongroup2_changes);
      const buttongroup3_changes = {};
      if (dirty & /*$$scope*/
      4) {
        buttongroup3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttongroup3.$set(buttongroup3_changes);
      const buttongroup4_changes = {};
      if (dirty & /*$$scope*/
      4) {
        buttongroup4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttongroup4.$set(buttongroup4_changes);
      const buttongroup5_changes = {};
      if (dirty & /*$$scope*/
      4) {
        buttongroup5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttongroup5.$set(buttongroup5_changes);
      const buttongroup6_changes = {};
      if (dirty & /*$$scope*/
      4) {
        buttongroup6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttongroup6.$set(buttongroup6_changes);
      const buttongroup7_changes = {};
      if (dirty & /*$$scope*/
      4) {
        buttongroup7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttongroup7.$set(buttongroup7_changes);
      const buttongroup8_changes = {};
      if (dirty & /*$$scope*/
      4) {
        buttongroup8_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttongroup8.$set(buttongroup8_changes);
      const buttongroup9_changes = {};
      if (dirty & /*$$scope*/
      4) {
        buttongroup9_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttongroup9.$set(buttongroup9_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(buttongroup0.$$.fragment, local);
      transition_in(buttongroup1.$$.fragment, local);
      transition_in(buttongroup2.$$.fragment, local);
      transition_in(buttongroup3.$$.fragment, local);
      transition_in(buttongroup4.$$.fragment, local);
      transition_in(buttongroup5.$$.fragment, local);
      transition_in(buttongroup6.$$.fragment, local);
      transition_in(buttongroup7.$$.fragment, local);
      transition_in(buttongroup8.$$.fragment, local);
      transition_in(buttongroup9.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttongroup0.$$.fragment, local);
      transition_out(buttongroup1.$$.fragment, local);
      transition_out(buttongroup2.$$.fragment, local);
      transition_out(buttongroup3.$$.fragment, local);
      transition_out(buttongroup4.$$.fragment, local);
      transition_out(buttongroup5.$$.fragment, local);
      transition_out(buttongroup6.$$.fragment, local);
      transition_out(buttongroup7.$$.fragment, local);
      transition_out(buttongroup8.$$.fragment, local);
      transition_out(buttongroup9.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(h30);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(h31);
        detach_dev(t6);
        detach_dev(div);
        detach_dev(t7);
        detach_dev(h32);
        detach_dev(t9);
        detach_dev(t10);
        detach_dev(h33);
        detach_dev(t12);
        detach_dev(t13);
        detach_dev(h34);
        detach_dev(t15);
        detach_dev(t16);
        detach_dev(h35);
        detach_dev(t18);
        detach_dev(t19);
        detach_dev(h36);
        detach_dev(t21);
        detach_dev(t22);
        detach_dev(h37);
        detach_dev(t24);
        detach_dev(t25);
        detach_dev(h38);
        detach_dev(t27);
        detach_dev(t28);
        detach_dev(h39);
        detach_dev(t30);
        detach_dev(t31);
        detach_dev(t32);
      }
      destroy_component(buttongroup0, detaching);
      destroy_component(buttongroup1);
      destroy_component(buttongroup2, detaching);
      destroy_component(buttongroup3, detaching);
      destroy_component(buttongroup4, detaching);
      destroy_component(buttongroup5, detaching);
      destroy_component(buttongroup6, detaching);
      destroy_component(buttongroup7, detaching);
      destroy_component(buttongroup8, detaching);
      destroy_component(buttongroup9, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment60.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance60($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("ButtonGroup", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "round",
      description: "Makes the buttons, on both sides of the group, round."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    }
  ];
  const exampleHtml = `
<ButtonGroup>
    <Button>One</Button>
    <Button>Two</Button>
    <Button>Three</Button>
</ButtonGroup>

<script>
function onChange (e) {
    const { value, oldValue } = e.detail;
    console.log({ value, oldValue });
}
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ButtonGroup> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    Button: Button_default,
    ButtonGroup: ButtonGroup_default,
    PushButton: PushButton_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    exampleHtml
  });
  return [apiProps, exampleHtml];
}
var ButtonGroup_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance60, create_fragment60, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonGroup_1",
      options,
      id: create_fragment60.name
    });
  }
};
var ButtonGroup_default2 = ButtonGroup_1;

// docs-src/components/input/button-toggle/ButtonToggle.svelte
var { console: console_1 } = globals;
var file54 = "docs-src/components/input/button-toggle/ButtonToggle.svelte";
function create_fragment61(ctx) {
  let h2;
  let t1;
  let p;
  let t3;
  let h30;
  let t5;
  let buttontoggle0;
  let t6;
  let h31;
  let t8;
  let div0;
  let buttontoggle1;
  let t9;
  let h32;
  let t11;
  let div1;
  let buttontoggle2;
  let t12;
  let br0;
  let br1;
  let t13;
  let h40;
  let t15;
  let buttontoggle3;
  let br2;
  let br3;
  let t16;
  let h41;
  let t18;
  let buttontoggle4;
  let br4;
  let br5;
  let t19;
  let h42;
  let t21;
  let buttontoggle5;
  let br6;
  let br7;
  let t22;
  let h33;
  let t24;
  let buttontoggle6;
  let br8;
  let br9;
  let t25;
  let h34;
  let t27;
  let buttontoggle7;
  let br10;
  let br11;
  let t28;
  let h35;
  let t29;
  let em0;
  let t31;
  let buttontoggle8;
  let br12;
  let br13;
  let t32;
  let h36;
  let t34;
  let buttontoggle9;
  let t35;
  let h37;
  let t37;
  let buttontoggle10;
  let t38;
  let h38;
  let t40;
  let buttontoggle11;
  let t41;
  let h39;
  let t43;
  let buttontoggle12;
  let t44;
  let codeexample0;
  let t45;
  let em1;
  let t47;
  let i0;
  let t49;
  let i1;
  let t51;
  let i2;
  let t53;
  let i3;
  let t55;
  let codeexample1;
  let t56;
  let api;
  let current;
  buttontoggle0 = new ButtonToggle_default({
    props: { items: (
      /*buttons*/
      ctx[4]
    ), value: "1" },
    $$inline: true
  });
  buttontoggle1 = new ButtonToggle_default({
    props: { items: (
      /*buttons*/
      ctx[4]
    ), value: "1" },
    $$inline: true
  });
  buttontoggle2 = new ButtonToggle_default({
    props: {
      items: (
        /*buttonsGalore*/
        ctx[5]
      ),
      value: "1"
    },
    $$inline: true
  });
  buttontoggle3 = new ButtonToggle_default({
    props: {
      disabled: true,
      items: (
        /*buttons*/
        ctx[4]
      )
    },
    $$inline: true
  });
  buttontoggle4 = new ButtonToggle_default({
    props: {
      round: true,
      items: (
        /*buttons*/
        ctx[4]
      ),
      value: "2"
    },
    $$inline: true
  });
  buttontoggle5 = new ButtonToggle_default({
    props: { items: (
      /*items*/
      ctx[6]
    ), value: "3" },
    $$inline: true
  });
  buttontoggle6 = new ButtonToggle_default({
    props: { items: (
      /*icons*/
      ctx[7]
    ), value: "1" },
    $$inline: true
  });
  buttontoggle7 = new ButtonToggle_default({
    props: {
      round: true,
      items: (
        /*icons*/
        ctx[7]
      ),
      value: "2"
    },
    $$inline: true
  });
  buttontoggle8 = new ButtonToggle_default({
    props: { items: (
      /*strings*/
      ctx[8]
    ), value: "One" },
    $$inline: true
  });
  buttontoggle9 = new ButtonToggle_default({
    props: {
      items: (
        /*items*/
        ctx[6]
      ),
      label: "Pick one"
    },
    $$inline: true
  });
  buttontoggle10 = new ButtonToggle_default({
    props: {
      items: (
        /*items*/
        ctx[6]
      ),
      label: "Pick one",
      info: "Pick your pick"
    },
    $$inline: true
  });
  buttontoggle11 = new ButtonToggle_default({
    props: {
      items: (
        /*items*/
        ctx[6]
      ),
      label: "Pick one",
      error: (
        /*error*/
        ctx[0]
      )
    },
    $$inline: true
  });
  buttontoggle11.$on(
    "change",
    /*onchange*/
    ctx[9]
  );
  buttontoggle12 = new ButtonToggle_default({
    props: {
      items: (
        /*items*/
        ctx[6]
      ),
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample0 = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[2]
    ) },
    $$inline: true
  });
  codeexample1 = new CodeExample_default({
    props: {
      notitle: true,
      html: (
        /*exampleHtml2*/
        ctx[3]
      )
    },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[1]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Button Toggle";
      t1 = space();
      p = element2("p");
      p.textContent = "This adds a nice visual styling of the buttons on top of a radio-button group.";
      t3 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t5 = space();
      create_component(buttontoggle0.$$.fragment);
      t6 = space();
      h31 = element2("h3");
      h31.textContent = "Fit width";
      t8 = space();
      div0 = element2("div");
      create_component(buttontoggle1.$$.fragment);
      t9 = space();
      h32 = element2("h3");
      h32.textContent = "With scroller";
      t11 = space();
      div1 = element2("div");
      create_component(buttontoggle2.$$.fragment);
      t12 = space();
      br0 = element2("br");
      br1 = element2("br");
      t13 = space();
      h40 = element2("h4");
      h40.textContent = "Disabled";
      t15 = space();
      create_component(buttontoggle3.$$.fragment);
      br2 = element2("br");
      br3 = element2("br");
      t16 = space();
      h41 = element2("h4");
      h41.textContent = "Round";
      t18 = space();
      create_component(buttontoggle4.$$.fragment);
      br4 = element2("br");
      br5 = element2("br");
      t19 = space();
      h42 = element2("h4");
      h42.textContent = "With icon";
      t21 = space();
      create_component(buttontoggle5.$$.fragment);
      br6 = element2("br");
      br7 = element2("br");
      t22 = space();
      h33 = element2("h3");
      h33.textContent = "Icon only buttons";
      t24 = space();
      create_component(buttontoggle6.$$.fragment);
      br8 = element2("br");
      br9 = element2("br");
      t25 = space();
      h34 = element2("h3");
      h34.textContent = "Icon only, and round";
      t27 = space();
      create_component(buttontoggle7.$$.fragment);
      br10 = element2("br");
      br11 = element2("br");
      t28 = space();
      h35 = element2("h3");
      t29 = text("Array of strings for ");
      em0 = element2("em");
      em0.textContent = "items";
      t31 = space();
      create_component(buttontoggle8.$$.fragment);
      br12 = element2("br");
      br13 = element2("br");
      t32 = space();
      h36 = element2("h3");
      h36.textContent = "Label";
      t34 = space();
      create_component(buttontoggle9.$$.fragment);
      t35 = space();
      h37 = element2("h3");
      h37.textContent = "Info";
      t37 = space();
      create_component(buttontoggle10.$$.fragment);
      t38 = space();
      h38 = element2("h3");
      h38.textContent = "Error";
      t40 = space();
      create_component(buttontoggle11.$$.fragment);
      t41 = space();
      h39 = element2("h3");
      h39.textContent = "Label on the left";
      t43 = space();
      create_component(buttontoggle12.$$.fragment);
      t44 = space();
      create_component(codeexample0.$$.fragment);
      t45 = space();
      em1 = element2("em");
      em1.textContent = "Note:";
      t47 = text(" the component ");
      i0 = element2("i");
      i0.textContent = "value";
      t49 = text(" type and the item's ");
      i1 = element2("i");
      i1.textContent = "value";
      t51 = text(" type must match,\nso you can either use ");
      i2 = element2("i");
      i2.textContent = "string";
      t53 = text(" for both - like in the example, or ");
      i3 = element2("i");
      i3.textContent = "number";
      t55 = text(", like so:\n");
      create_component(codeexample1.$$.fragment);
      t56 = space();
      create_component(api.$$.fragment);
      add_location(h2, file54, 0, 0, 0);
      add_location(p, file54, 2, 0, 24);
      add_location(h30, file54, 4, 0, 111);
      add_location(h31, file54, 7, 0, 173);
      attr_dev(div0, "class", "button-toggle-wrapper-wide");
      add_location(div0, file54, 8, 0, 192);
      add_location(h32, file54, 12, 0, 287);
      attr_dev(div1, "class", "button-toggle-wrapper-wide");
      add_location(div1, file54, 13, 0, 310);
      add_location(br0, file54, 17, 0, 411);
      add_location(br1, file54, 17, 4, 415);
      add_location(h40, file54, 19, 0, 421);
      add_location(br2, file54, 20, 42, 481);
      add_location(br3, file54, 20, 46, 485);
      add_location(h41, file54, 22, 0, 491);
      add_location(br4, file54, 23, 50, 556);
      add_location(br5, file54, 23, 54, 560);
      add_location(h42, file54, 25, 0, 566);
      add_location(br6, file54, 26, 42, 627);
      add_location(br7, file54, 26, 46, 631);
      add_location(h33, file54, 28, 0, 637);
      add_location(br8, file54, 29, 42, 706);
      add_location(br9, file54, 29, 46, 710);
      add_location(h34, file54, 32, 0, 717);
      add_location(br10, file54, 33, 48, 795);
      add_location(br11, file54, 33, 52, 799);
      add_location(em0, file54, 35, 25, 830);
      add_location(h35, file54, 35, 0, 805);
      add_location(br12, file54, 36, 46, 896);
      add_location(br13, file54, 36, 50, 900);
      add_location(h36, file54, 39, 0, 907);
      add_location(h37, file54, 42, 0, 973);
      add_location(h38, file54, 45, 0, 1060);
      add_location(h39, file54, 52, 0, 1168);
      add_location(em1, file54, 58, 0, 1318);
      add_location(i0, file54, 58, 29, 1347);
      add_location(i1, file54, 58, 62, 1380);
      add_location(i2, file54, 59, 22, 1432);
      add_location(i3, file54, 59, 71, 1481);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t5, anchor);
      mount_component(buttontoggle0, target, anchor);
      insert_dev(target, t6, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t8, anchor);
      insert_dev(target, div0, anchor);
      mount_component(buttontoggle1, div0, null);
      insert_dev(target, t9, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t11, anchor);
      insert_dev(target, div1, anchor);
      mount_component(buttontoggle2, div1, null);
      insert_dev(target, t12, anchor);
      insert_dev(target, br0, anchor);
      insert_dev(target, br1, anchor);
      insert_dev(target, t13, anchor);
      insert_dev(target, h40, anchor);
      insert_dev(target, t15, anchor);
      mount_component(buttontoggle3, target, anchor);
      insert_dev(target, br2, anchor);
      insert_dev(target, br3, anchor);
      insert_dev(target, t16, anchor);
      insert_dev(target, h41, anchor);
      insert_dev(target, t18, anchor);
      mount_component(buttontoggle4, target, anchor);
      insert_dev(target, br4, anchor);
      insert_dev(target, br5, anchor);
      insert_dev(target, t19, anchor);
      insert_dev(target, h42, anchor);
      insert_dev(target, t21, anchor);
      mount_component(buttontoggle5, target, anchor);
      insert_dev(target, br6, anchor);
      insert_dev(target, br7, anchor);
      insert_dev(target, t22, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t24, anchor);
      mount_component(buttontoggle6, target, anchor);
      insert_dev(target, br8, anchor);
      insert_dev(target, br9, anchor);
      insert_dev(target, t25, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t27, anchor);
      mount_component(buttontoggle7, target, anchor);
      insert_dev(target, br10, anchor);
      insert_dev(target, br11, anchor);
      insert_dev(target, t28, anchor);
      insert_dev(target, h35, anchor);
      append_dev(h35, t29);
      append_dev(h35, em0);
      insert_dev(target, t31, anchor);
      mount_component(buttontoggle8, target, anchor);
      insert_dev(target, br12, anchor);
      insert_dev(target, br13, anchor);
      insert_dev(target, t32, anchor);
      insert_dev(target, h36, anchor);
      insert_dev(target, t34, anchor);
      mount_component(buttontoggle9, target, anchor);
      insert_dev(target, t35, anchor);
      insert_dev(target, h37, anchor);
      insert_dev(target, t37, anchor);
      mount_component(buttontoggle10, target, anchor);
      insert_dev(target, t38, anchor);
      insert_dev(target, h38, anchor);
      insert_dev(target, t40, anchor);
      mount_component(buttontoggle11, target, anchor);
      insert_dev(target, t41, anchor);
      insert_dev(target, h39, anchor);
      insert_dev(target, t43, anchor);
      mount_component(buttontoggle12, target, anchor);
      insert_dev(target, t44, anchor);
      mount_component(codeexample0, target, anchor);
      insert_dev(target, t45, anchor);
      insert_dev(target, em1, anchor);
      insert_dev(target, t47, anchor);
      insert_dev(target, i0, anchor);
      insert_dev(target, t49, anchor);
      insert_dev(target, i1, anchor);
      insert_dev(target, t51, anchor);
      insert_dev(target, i2, anchor);
      insert_dev(target, t53, anchor);
      insert_dev(target, i3, anchor);
      insert_dev(target, t55, anchor);
      mount_component(codeexample1, target, anchor);
      insert_dev(target, t56, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const buttontoggle11_changes = {};
      if (dirty & /*error*/
      1)
        buttontoggle11_changes.error = /*error*/
        ctx2[0];
      buttontoggle11.$set(buttontoggle11_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(buttontoggle0.$$.fragment, local);
      transition_in(buttontoggle1.$$.fragment, local);
      transition_in(buttontoggle2.$$.fragment, local);
      transition_in(buttontoggle3.$$.fragment, local);
      transition_in(buttontoggle4.$$.fragment, local);
      transition_in(buttontoggle5.$$.fragment, local);
      transition_in(buttontoggle6.$$.fragment, local);
      transition_in(buttontoggle7.$$.fragment, local);
      transition_in(buttontoggle8.$$.fragment, local);
      transition_in(buttontoggle9.$$.fragment, local);
      transition_in(buttontoggle10.$$.fragment, local);
      transition_in(buttontoggle11.$$.fragment, local);
      transition_in(buttontoggle12.$$.fragment, local);
      transition_in(codeexample0.$$.fragment, local);
      transition_in(codeexample1.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttontoggle0.$$.fragment, local);
      transition_out(buttontoggle1.$$.fragment, local);
      transition_out(buttontoggle2.$$.fragment, local);
      transition_out(buttontoggle3.$$.fragment, local);
      transition_out(buttontoggle4.$$.fragment, local);
      transition_out(buttontoggle5.$$.fragment, local);
      transition_out(buttontoggle6.$$.fragment, local);
      transition_out(buttontoggle7.$$.fragment, local);
      transition_out(buttontoggle8.$$.fragment, local);
      transition_out(buttontoggle9.$$.fragment, local);
      transition_out(buttontoggle10.$$.fragment, local);
      transition_out(buttontoggle11.$$.fragment, local);
      transition_out(buttontoggle12.$$.fragment, local);
      transition_out(codeexample0.$$.fragment, local);
      transition_out(codeexample1.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p);
        detach_dev(t3);
        detach_dev(h30);
        detach_dev(t5);
        detach_dev(t6);
        detach_dev(h31);
        detach_dev(t8);
        detach_dev(div0);
        detach_dev(t9);
        detach_dev(h32);
        detach_dev(t11);
        detach_dev(div1);
        detach_dev(t12);
        detach_dev(br0);
        detach_dev(br1);
        detach_dev(t13);
        detach_dev(h40);
        detach_dev(t15);
        detach_dev(br2);
        detach_dev(br3);
        detach_dev(t16);
        detach_dev(h41);
        detach_dev(t18);
        detach_dev(br4);
        detach_dev(br5);
        detach_dev(t19);
        detach_dev(h42);
        detach_dev(t21);
        detach_dev(br6);
        detach_dev(br7);
        detach_dev(t22);
        detach_dev(h33);
        detach_dev(t24);
        detach_dev(br8);
        detach_dev(br9);
        detach_dev(t25);
        detach_dev(h34);
        detach_dev(t27);
        detach_dev(br10);
        detach_dev(br11);
        detach_dev(t28);
        detach_dev(h35);
        detach_dev(t31);
        detach_dev(br12);
        detach_dev(br13);
        detach_dev(t32);
        detach_dev(h36);
        detach_dev(t34);
        detach_dev(t35);
        detach_dev(h37);
        detach_dev(t37);
        detach_dev(t38);
        detach_dev(h38);
        detach_dev(t40);
        detach_dev(t41);
        detach_dev(h39);
        detach_dev(t43);
        detach_dev(t44);
        detach_dev(t45);
        detach_dev(em1);
        detach_dev(t47);
        detach_dev(i0);
        detach_dev(t49);
        detach_dev(i1);
        detach_dev(t51);
        detach_dev(i2);
        detach_dev(t53);
        detach_dev(i3);
        detach_dev(t55);
        detach_dev(t56);
      }
      destroy_component(buttontoggle0, detaching);
      destroy_component(buttontoggle1);
      destroy_component(buttontoggle2);
      destroy_component(buttontoggle3, detaching);
      destroy_component(buttontoggle4, detaching);
      destroy_component(buttontoggle5, detaching);
      destroy_component(buttontoggle6, detaching);
      destroy_component(buttontoggle7, detaching);
      destroy_component(buttontoggle8, detaching);
      destroy_component(buttontoggle9, detaching);
      destroy_component(buttontoggle10, detaching);
      destroy_component(buttontoggle11, detaching);
      destroy_component(buttontoggle12, detaching);
      destroy_component(codeexample0, detaching);
      destroy_component(codeexample1, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment61.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance61($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("ButtonToggle", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "disabled",
      description: "Makes the component disabled."
    },
    {
      name: "id",
      type: "string",
      description: "Assign id to the first radio button in the group (useful for the associate label's <i>for</i> attribute)"
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the toggle."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the toggle."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the toggle."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "items",
      type: "array",
      required: true,
      description: "An array of strings or objects in the following format: <code>&lbrace; name: string, value: string | number, icon?: string &rbrace;</code>"
    },
    {
      name: "name",
      type: "string",
      description: "Assign name to the underlying radio group"
    },
    {
      name: "round",
      description: "Makes the buttons, on both sides of the group, round."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the component"
    },
    {
      name: "value",
      type: ["string", "number"],
      description: "Assign initial value to the underlying radio group"
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered when the value changes."
    }
  ];
  const exampleHtml = `
<ButtonToggle items="{buttons}" value="2" />

<script>
const buttons = [
    { name: 'One', value: '1' },
    { name: 'Two', value: '2' },
    { name: 'Three', value: '3' },
];
&lt;/script>
`;
  const exampleHtml2 = `
<ButtonToggle items="{buttons}" value="{2}" />

<script>
const buttons = [
    { name: 'One', value: 1 },
    { name: 'Two', value: 2 },
    { name: 'Three', value: 3 },
];
&lt;/script>
`;
  const buttons = [
    { name: "One", value: "1" },
    { name: "Two", value: "2" },
    { name: "Three", value: "3" }
  ];
  const buttonsGalore = [
    "One",
    "Two",
    "Three",
    "Four",
    "Five",
    "Six",
    "Seven",
    "Eight",
    "Nine",
    "Ten",
    "Eleven",
    "Twelve",
    "Thirteen",
    "Fourteen",
    "Fifteen",
    "Sixteen",
    "Seventeen"
  ];
  const items = [
    { name: "One", icon: "info", value: "1" },
    {
      name: "Two and some long text",
      icon: "check",
      value: "2"
    },
    { name: "Three", icon: "alert", value: "3" }
  ];
  const icons2 = [
    { icon: "info", value: "1" },
    { icon: "check", value: "2" },
    { icon: "alert", value: "3" }
  ];
  const strings = ["One", "Two", "Three"];
  let error2 = "You picked wrong!";
  function onchange5(e) {
    const val = e.detail;
    console.log(val);
    $$invalidate2(0, error2 = val === "1" ? "" : "You picked wrong!");
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<ButtonToggle> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    ButtonToggle: ButtonToggle_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    exampleHtml,
    exampleHtml2,
    buttons,
    buttonsGalore,
    items,
    icons: icons2,
    strings,
    error: error2,
    onchange: onchange5
  });
  $$self2.$inject_state = ($$props3) => {
    if ("error" in $$props3)
      $$invalidate2(0, error2 = $$props3.error);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    error2,
    apiProps,
    exampleHtml,
    exampleHtml2,
    buttons,
    buttonsGalore,
    items,
    icons2,
    strings,
    onchange5
  ];
}
var ButtonToggle_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance61, create_fragment61, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonToggle_1",
      options,
      id: create_fragment61.name
    });
  }
};
var ButtonToggle_default2 = ButtonToggle_1;

// docs-src/components/input/checkbox/Checkbox.svelte
var { console: console_12 } = globals;
var file55 = "docs-src/components/input/checkbox/Checkbox.svelte";
function create_fragment62(ctx) {
  let h2;
  let t1;
  let h30;
  let t3;
  let checkbox0;
  let t4;
  let h31;
  let t6;
  let checkbox1;
  let br;
  let t7;
  let checkbox2;
  let t8;
  let h32;
  let t10;
  let checkbox3;
  let t11;
  let h33;
  let t13;
  let checkbox4;
  let t14;
  let h34;
  let t16;
  let checkbox5;
  let t17;
  let h35;
  let t19;
  let checkbox6;
  let t20;
  let h36;
  let t22;
  let checkbox7;
  let t23;
  let h37;
  let t25;
  let checkbox8;
  let t26;
  let codeexample;
  let t27;
  let api;
  let current;
  checkbox0 = new Checkbox_default({
    props: {
      label: "I do not wish to be excluded from the dont-send-newsletter list, not."
    },
    $$inline: true
  });
  checkbox0.$on(
    "change",
    /*onchange*/
    ctx[3]
  );
  checkbox1 = new Checkbox_default({
    props: {
      disabled: true,
      label: "I would like to receive all your spam, please."
    },
    $$inline: true
  });
  checkbox2 = new Checkbox_default({
    props: {
      checked: "true",
      disabled: true,
      label: "You can't check me!"
    },
    $$inline: true
  });
  checkbox3 = new Checkbox_default({
    props: {
      checked: "true",
      label: "Check the checkbox to have the checkbox checked."
    },
    $$inline: true
  });
  checkbox4 = new Checkbox_default({
    props: {
      indeterminate: "true",
      label: "Check, mate!"
    },
    $$inline: true
  });
  checkbox5 = new Checkbox_default({
    props: {
      error: (
        /*error*/
        ctx[0]
      ),
      label: "Please, check this by mistake."
    },
    $$inline: true
  });
  checkbox5.$on(
    "change",
    /*onchange*/
    ctx[3]
  );
  checkbox6 = new Checkbox_default({
    props: {
      info: "This checkbox is the most important box ever!",
      label: "Please, check this by mistake."
    },
    $$inline: true
  });
  checkbox7 = new Checkbox_default({
    props: {
      info: "This checkbox is the most important box ever!",
      error: "And you're wrong!",
      label: "Please, check this by mistake."
    },
    $$inline: true
  });
  checkbox8 = new Checkbox_default({
    props: {
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[2]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[1]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Checkbox";
      t1 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t3 = space();
      create_component(checkbox0.$$.fragment);
      t4 = space();
      h31 = element2("h3");
      h31.textContent = "Disabled";
      t6 = space();
      create_component(checkbox1.$$.fragment);
      br = element2("br");
      t7 = space();
      create_component(checkbox2.$$.fragment);
      t8 = space();
      h32 = element2("h3");
      h32.textContent = "Checked";
      t10 = space();
      create_component(checkbox3.$$.fragment);
      t11 = space();
      h33 = element2("h3");
      h33.textContent = "Indeterminate";
      t13 = space();
      create_component(checkbox4.$$.fragment);
      t14 = space();
      h34 = element2("h3");
      h34.textContent = "With error and live validation";
      t16 = space();
      create_component(checkbox5.$$.fragment);
      t17 = space();
      h35 = element2("h3");
      h35.textContent = "With info";
      t19 = space();
      create_component(checkbox6.$$.fragment);
      t20 = space();
      h36 = element2("h3");
      h36.textContent = "With error and info";
      t22 = space();
      create_component(checkbox7.$$.fragment);
      t23 = space();
      h37 = element2("h3");
      h37.textContent = "Label on the left";
      t25 = space();
      create_component(checkbox8.$$.fragment);
      t26 = space();
      create_component(codeexample.$$.fragment);
      t27 = space();
      create_component(api.$$.fragment);
      add_location(h2, file55, 0, 0, 0);
      add_location(h30, file55, 2, 0, 19);
      add_location(h31, file55, 5, 0, 150);
      add_location(br, file55, 6, 75, 243);
      add_location(h32, file55, 9, 0, 313);
      add_location(h33, file55, 13, 0, 416);
      add_location(h34, file55, 17, 0, 495);
      add_location(h35, file55, 20, 0, 618);
      add_location(h36, file55, 23, 0, 742);
      add_location(h37, file55, 30, 0, 906);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t3, anchor);
      mount_component(checkbox0, target, anchor);
      insert_dev(target, t4, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t6, anchor);
      mount_component(checkbox1, target, anchor);
      insert_dev(target, br, anchor);
      insert_dev(target, t7, anchor);
      mount_component(checkbox2, target, anchor);
      insert_dev(target, t8, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t10, anchor);
      mount_component(checkbox3, target, anchor);
      insert_dev(target, t11, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t13, anchor);
      mount_component(checkbox4, target, anchor);
      insert_dev(target, t14, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t16, anchor);
      mount_component(checkbox5, target, anchor);
      insert_dev(target, t17, anchor);
      insert_dev(target, h35, anchor);
      insert_dev(target, t19, anchor);
      mount_component(checkbox6, target, anchor);
      insert_dev(target, t20, anchor);
      insert_dev(target, h36, anchor);
      insert_dev(target, t22, anchor);
      mount_component(checkbox7, target, anchor);
      insert_dev(target, t23, anchor);
      insert_dev(target, h37, anchor);
      insert_dev(target, t25, anchor);
      mount_component(checkbox8, target, anchor);
      insert_dev(target, t26, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t27, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const checkbox5_changes = {};
      if (dirty & /*error*/
      1)
        checkbox5_changes.error = /*error*/
        ctx2[0];
      checkbox5.$set(checkbox5_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkbox0.$$.fragment, local);
      transition_in(checkbox1.$$.fragment, local);
      transition_in(checkbox2.$$.fragment, local);
      transition_in(checkbox3.$$.fragment, local);
      transition_in(checkbox4.$$.fragment, local);
      transition_in(checkbox5.$$.fragment, local);
      transition_in(checkbox6.$$.fragment, local);
      transition_in(checkbox7.$$.fragment, local);
      transition_in(checkbox8.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkbox0.$$.fragment, local);
      transition_out(checkbox1.$$.fragment, local);
      transition_out(checkbox2.$$.fragment, local);
      transition_out(checkbox3.$$.fragment, local);
      transition_out(checkbox4.$$.fragment, local);
      transition_out(checkbox5.$$.fragment, local);
      transition_out(checkbox6.$$.fragment, local);
      transition_out(checkbox7.$$.fragment, local);
      transition_out(checkbox8.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(h30);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(h31);
        detach_dev(t6);
        detach_dev(br);
        detach_dev(t7);
        detach_dev(t8);
        detach_dev(h32);
        detach_dev(t10);
        detach_dev(t11);
        detach_dev(h33);
        detach_dev(t13);
        detach_dev(t14);
        detach_dev(h34);
        detach_dev(t16);
        detach_dev(t17);
        detach_dev(h35);
        detach_dev(t19);
        detach_dev(t20);
        detach_dev(h36);
        detach_dev(t22);
        detach_dev(t23);
        detach_dev(h37);
        detach_dev(t25);
        detach_dev(t26);
        detach_dev(t27);
      }
      destroy_component(checkbox0, detaching);
      destroy_component(checkbox1, detaching);
      destroy_component(checkbox2, detaching);
      destroy_component(checkbox3, detaching);
      destroy_component(checkbox4, detaching);
      destroy_component(checkbox5, detaching);
      destroy_component(checkbox6, detaching);
      destroy_component(checkbox7, detaching);
      destroy_component(checkbox8, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment62.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance62($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Checkbox", slots2, []);
  const apiProps = [
    {
      name: "checked",
      type: ["true", "false"],
      description: "Make the checkbox checked or unchecked."
    },
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "disabled",
      description: "Make the input disabled."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the input."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying input."
    },
    {
      name: "indeterminate",
      type: ["true", "false"],
      description: "If set to <i>true</i> it makes the checkbox show its 3rd state - indeterminate."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the input."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the input."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the component."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying input."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered when the value changes."
    }
  ];
  const exampleHtml = `
<Checkbox on:change="{onChange}" label="I'm a little label" {error} />

<script>
let error = '';

function onChange (e) {
	const { checked, indeterminate } = e.detail;
	error = checked ? '' : 'You must check me!'
	console.log({ checked, indeterminate });
}
&lt;/script>
`;
  let error2 = "You must check me!";
  function onchange5(e) {
    const { checked, indeterminate } = e.detail;
    $$invalidate2(0, error2 = checked ? "" : "You must check me!");
    console.log({ checked, indeterminate });
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_12.warn(`<Checkbox> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    Checkbox: Checkbox_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    exampleHtml,
    error: error2,
    onchange: onchange5
  });
  $$self2.$inject_state = ($$props3) => {
    if ("error" in $$props3)
      $$invalidate2(0, error2 = $$props3.error);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [error2, apiProps, exampleHtml, onchange5];
}
var Checkbox_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance62, create_fragment62, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkbox_1",
      options,
      id: create_fragment62.name
    });
  }
};
var Checkbox_default2 = Checkbox_1;

// docs-src/components/input/combobox/Combobox.svelte
var { console: console_13 } = globals;
var file56 = "docs-src/components/input/combobox/Combobox.svelte";
function create_default_slot_113(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Reset");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_113.name,
    type: "slot",
    source: '(11:0) <Button on:click=\\"{resetSingle}\\">',
    ctx
  });
  return block;
}
function create_default_slot9(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Reset");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: '(68:0) <Button on:click=\\"{resetMulti}\\">',
    ctx
  });
  return block;
}
function create_fragment63(ctx) {
  let h20;
  let t1;
  let h30;
  let t3;
  let combobox0;
  let updating_value;
  let t4;
  let h40;
  let t6;
  let jsonbox0;
  let t7;
  let button0;
  let t8;
  let h31;
  let t10;
  let combobox1;
  let updating_value_1;
  let t11;
  let h32;
  let t13;
  let combobox2;
  let updating_value_2;
  let t14;
  let h33;
  let t16;
  let combobox3;
  let updating_value_3;
  let t17;
  let h34;
  let t19;
  let combobox4;
  let updating_value_4;
  let t20;
  let h41;
  let t22;
  let jsonbox1;
  let t23;
  let h35;
  let t25;
  let combobox5;
  let updating_value_5;
  let t26;
  let h42;
  let t28;
  let jsonbox2;
  let t29;
  let h36;
  let t31;
  let combobox6;
  let t32;
  let h37;
  let t34;
  let combobox7;
  let t35;
  let h38;
  let t37;
  let combobox8;
  let t38;
  let h39;
  let t40;
  let combobox9;
  let t41;
  let h21;
  let a;
  let t43;
  let p;
  let t44;
  let br;
  let t45;
  let t46;
  let h310;
  let t48;
  let combobox10;
  let updating_value_6;
  let t49;
  let h43;
  let t51;
  let jsonbox3;
  let t52;
  let button1;
  let t53;
  let h311;
  let t55;
  let combobox11;
  let updating_value_7;
  let t56;
  let h44;
  let t58;
  let jsonbox4;
  let t59;
  let codeexample;
  let t60;
  let hr;
  let t61;
  let api;
  let current;
  function combobox0_value_binding(value2) {
    ctx[12](value2);
  }
  let combobox0_props = { items: (
    /*items*/
    ctx[7]
  ) };
  if (
    /*itemValue*/
    ctx[0] !== void 0
  ) {
    combobox0_props.value = /*itemValue*/
    ctx[0];
  }
  combobox0 = new Combobox_default({ props: combobox0_props, $$inline: true });
  binding_callbacks.push(() => bind(combobox0, "value", combobox0_value_binding));
  combobox0.$on("change", onChange);
  jsonbox0 = new JsonBox_default({
    props: { value: (
      /*itemValue*/
      ctx[0]
    ) },
    $$inline: true
  });
  button0 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_113] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button0.$on(
    "click",
    /*resetSingle*/
    ctx[10]
  );
  function combobox1_value_binding(value2) {
    ctx[13](value2);
  }
  let combobox1_props = { disabled: true, items: (
    /*items*/
    ctx[7]
  ) };
  if (
    /*itemValue*/
    ctx[0] !== void 0
  ) {
    combobox1_props.value = /*itemValue*/
    ctx[0];
  }
  combobox1 = new Combobox_default({ props: combobox1_props, $$inline: true });
  binding_callbacks.push(() => bind(combobox1, "value", combobox1_value_binding));
  function combobox2_value_binding(value2) {
    ctx[14](value2);
  }
  let combobox2_props = {
    items: (
      /*items*/
      ctx[7]
    ),
    placeholder: "Type to filter",
    allowNew: true
  };
  if (
    /*itemValue*/
    ctx[0] !== void 0
  ) {
    combobox2_props.value = /*itemValue*/
    ctx[0];
  }
  combobox2 = new Combobox_default({ props: combobox2_props, $$inline: true });
  binding_callbacks.push(() => bind(combobox2, "value", combobox2_value_binding));
  function combobox3_value_binding(value2) {
    ctx[15](value2);
  }
  let combobox3_props = {
    showOnFocus: "true",
    items: (
      /*items*/
      ctx[7]
    )
  };
  if (
    /*itemValue*/
    ctx[0] !== void 0
  ) {
    combobox3_props.value = /*itemValue*/
    ctx[0];
  }
  combobox3 = new Combobox_default({ props: combobox3_props, $$inline: true });
  binding_callbacks.push(() => bind(combobox3, "value", combobox3_value_binding));
  function combobox4_value_binding(value2) {
    ctx[16](value2);
  }
  let combobox4_props = {
    items: (
      /*dataSimpler*/
      ctx[8]
    ),
    placeholder: "Type to filter"
  };
  if (
    /*valueSimpler*/
    ctx[2] !== void 0
  ) {
    combobox4_props.value = /*valueSimpler*/
    ctx[2];
  }
  combobox4 = new Combobox_default({ props: combobox4_props, $$inline: true });
  binding_callbacks.push(() => bind(combobox4, "value", combobox4_value_binding));
  jsonbox1 = new JsonBox_default({
    props: { value: (
      /*valueSimpler*/
      ctx[2]
    ) },
    $$inline: true
  });
  function combobox5_value_binding(value2) {
    ctx[17](value2);
  }
  let combobox5_props = {
    items: (
      /*dataSimple*/
      ctx[9]
    ),
    placeholder: "Type to filter"
  };
  if (
    /*valueSimple*/
    ctx[3] !== void 0
  ) {
    combobox5_props.value = /*valueSimple*/
    ctx[3];
  }
  combobox5 = new Combobox_default({ props: combobox5_props, $$inline: true });
  binding_callbacks.push(() => bind(combobox5, "value", combobox5_value_binding));
  jsonbox2 = new JsonBox_default({
    props: { value: (
      /*valueSimple*/
      ctx[3]
    ) },
    $$inline: true
  });
  combobox6 = new Combobox_default({
    props: {
      items: (
        /*items*/
        ctx[7]
      ),
      label: "Combobox label"
    },
    $$inline: true
  });
  combobox7 = new Combobox_default({
    props: {
      items: (
        /*items*/
        ctx[7]
      ),
      label: "Combobox label",
      info: "Select something here"
    },
    $$inline: true
  });
  combobox8 = new Combobox_default({
    props: {
      items: (
        /*items*/
        ctx[7]
      ),
      label: "Combobox label",
      error: "You picked the wrong side!"
    },
    $$inline: true
  });
  combobox9 = new Combobox_default({
    props: {
      items: (
        /*items*/
        ctx[7]
      ),
      label: "Label is on the left",
      labelOnTheLeft: true
    },
    $$inline: true
  });
  function combobox10_value_binding(value2) {
    ctx[18](value2);
  }
  let combobox10_props = {
    items: (
      /*dataSimple*/
      ctx[9]
    ),
    multiselect: true,
    clearOnEsc: true
  };
  if (
    /*multiselectSimpleValue*/
    ctx[4] !== void 0
  ) {
    combobox10_props.value = /*multiselectSimpleValue*/
    ctx[4];
  }
  combobox10 = new Combobox_default({ props: combobox10_props, $$inline: true });
  binding_callbacks.push(() => bind(combobox10, "value", combobox10_value_binding));
  jsonbox3 = new JsonBox_default({
    props: { value: (
      /*multiselectSimpleValue*/
      ctx[4]
    ) },
    $$inline: true
  });
  button1 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1.$on(
    "click",
    /*resetMulti*/
    ctx[11]
  );
  function combobox11_value_binding(value2) {
    ctx[19](value2);
  }
  let combobox11_props = {
    items: (
      /*items*/
      ctx[7]
    ),
    multiselect: true
  };
  if (
    /*multiselectValue*/
    ctx[1] !== void 0
  ) {
    combobox11_props.value = /*multiselectValue*/
    ctx[1];
  }
  combobox11 = new Combobox_default({ props: combobox11_props, $$inline: true });
  binding_callbacks.push(() => bind(combobox11, "value", combobox11_value_binding));
  jsonbox4 = new JsonBox_default({
    props: { value: (
      /*multiselectValue*/
      ctx[1]
    ) },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[6]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[5]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h20 = element2("h2");
      h20.textContent = "Combobox";
      t1 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t3 = space();
      create_component(combobox0.$$.fragment);
      t4 = space();
      h40 = element2("h4");
      h40.textContent = "Selected value:";
      t6 = space();
      create_component(jsonbox0.$$.fragment);
      t7 = space();
      create_component(button0.$$.fragment);
      t8 = space();
      h31 = element2("h3");
      h31.textContent = "Disabled";
      t10 = space();
      create_component(combobox1.$$.fragment);
      t11 = space();
      h32 = element2("h3");
      h32.textContent = "Allow arbitrary values";
      t13 = space();
      create_component(combobox2.$$.fragment);
      t14 = space();
      h33 = element2("h3");
      h33.textContent = "Show on focus";
      t16 = space();
      create_component(combobox3.$$.fragment);
      t17 = space();
      h34 = element2("h3");
      h34.textContent = "Simpler data (no ID, just 'name')";
      t19 = space();
      create_component(combobox4.$$.fragment);
      t20 = space();
      h41 = element2("h4");
      h41.textContent = "Selected value:";
      t22 = space();
      create_component(jsonbox1.$$.fragment);
      t23 = space();
      h35 = element2("h3");
      h35.textContent = "Simple data (just an array of strings)";
      t25 = space();
      create_component(combobox5.$$.fragment);
      t26 = space();
      h42 = element2("h4");
      h42.textContent = "Selected value:";
      t28 = space();
      create_component(jsonbox2.$$.fragment);
      t29 = space();
      h36 = element2("h3");
      h36.textContent = "Label";
      t31 = space();
      create_component(combobox6.$$.fragment);
      t32 = space();
      h37 = element2("h3");
      h37.textContent = "Info";
      t34 = space();
      create_component(combobox7.$$.fragment);
      t35 = space();
      h38 = element2("h3");
      h38.textContent = "Error";
      t37 = space();
      create_component(combobox8.$$.fragment);
      t38 = space();
      h39 = element2("h3");
      h39.textContent = "Label on the left";
      t40 = space();
      create_component(combobox9.$$.fragment);
      t41 = space();
      h21 = element2("h2");
      a = element2("a");
      a.textContent = "Multiselect";
      t43 = space();
      p = element2("p");
      t44 = text("This adds checkboxes to the list items, but it disables the auto-lookup functionality,");
      br = element2("br");
      t45 = text("as the input value string becomes a comma-separated list of selected items' names.");
      t46 = space();
      h310 = element2("h3");
      h310.textContent = "Simple data";
      t48 = space();
      create_component(combobox10.$$.fragment);
      t49 = space();
      h43 = element2("h4");
      h43.textContent = "Selected value:";
      t51 = space();
      create_component(jsonbox3.$$.fragment);
      t52 = space();
      create_component(button1.$$.fragment);
      t53 = space();
      h311 = element2("h3");
      h311.textContent = "Complex data";
      t55 = space();
      create_component(combobox11.$$.fragment);
      t56 = space();
      h44 = element2("h4");
      h44.textContent = "Selected value:";
      t58 = space();
      create_component(jsonbox4.$$.fragment);
      t59 = space();
      create_component(codeexample.$$.fragment);
      t60 = space();
      hr = element2("hr");
      t61 = space();
      create_component(api.$$.fragment);
      add_location(h20, file56, 0, 0, 0);
      add_location(h30, file56, 2, 0, 19);
      add_location(h40, file56, 8, 0, 108);
      add_location(h31, file56, 12, 0, 215);
      add_location(h32, file56, 15, 0, 289);
      add_location(h33, file56, 23, 0, 411);
      add_location(h34, file56, 26, 0, 500);
      add_location(h41, file56, 30, 0, 637);
      add_location(h35, file56, 34, 0, 700);
      add_location(h42, file56, 38, 0, 840);
      add_location(h36, file56, 42, 0, 902);
      add_location(h37, file56, 45, 0, 962);
      add_location(h38, file56, 48, 0, 1050);
      add_location(h39, file56, 51, 0, 1145);
      attr_dev(a, "href", "#Combobox/Multiselect");
      add_location(a, file56, 56, 21, 1260);
      attr_dev(h21, "id", "Multiselect");
      add_location(h21, file56, 56, 0, 1239);
      add_location(br, file56, 58, 89, 1403);
      add_location(p, file56, 58, 0, 1314);
      add_location(h310, file56, 59, 0, 1494);
      add_location(h43, file56, 65, 0, 1614);
      add_location(h311, file56, 69, 0, 1733);
      add_location(h44, file56, 74, 0, 1823);
      add_location(hr, file56, 81, 0, 1929);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h20, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t3, anchor);
      mount_component(combobox0, target, anchor);
      insert_dev(target, t4, anchor);
      insert_dev(target, h40, anchor);
      insert_dev(target, t6, anchor);
      mount_component(jsonbox0, target, anchor);
      insert_dev(target, t7, anchor);
      mount_component(button0, target, anchor);
      insert_dev(target, t8, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t10, anchor);
      mount_component(combobox1, target, anchor);
      insert_dev(target, t11, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t13, anchor);
      mount_component(combobox2, target, anchor);
      insert_dev(target, t14, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t16, anchor);
      mount_component(combobox3, target, anchor);
      insert_dev(target, t17, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t19, anchor);
      mount_component(combobox4, target, anchor);
      insert_dev(target, t20, anchor);
      insert_dev(target, h41, anchor);
      insert_dev(target, t22, anchor);
      mount_component(jsonbox1, target, anchor);
      insert_dev(target, t23, anchor);
      insert_dev(target, h35, anchor);
      insert_dev(target, t25, anchor);
      mount_component(combobox5, target, anchor);
      insert_dev(target, t26, anchor);
      insert_dev(target, h42, anchor);
      insert_dev(target, t28, anchor);
      mount_component(jsonbox2, target, anchor);
      insert_dev(target, t29, anchor);
      insert_dev(target, h36, anchor);
      insert_dev(target, t31, anchor);
      mount_component(combobox6, target, anchor);
      insert_dev(target, t32, anchor);
      insert_dev(target, h37, anchor);
      insert_dev(target, t34, anchor);
      mount_component(combobox7, target, anchor);
      insert_dev(target, t35, anchor);
      insert_dev(target, h38, anchor);
      insert_dev(target, t37, anchor);
      mount_component(combobox8, target, anchor);
      insert_dev(target, t38, anchor);
      insert_dev(target, h39, anchor);
      insert_dev(target, t40, anchor);
      mount_component(combobox9, target, anchor);
      insert_dev(target, t41, anchor);
      insert_dev(target, h21, anchor);
      append_dev(h21, a);
      insert_dev(target, t43, anchor);
      insert_dev(target, p, anchor);
      append_dev(p, t44);
      append_dev(p, br);
      append_dev(p, t45);
      insert_dev(target, t46, anchor);
      insert_dev(target, h310, anchor);
      insert_dev(target, t48, anchor);
      mount_component(combobox10, target, anchor);
      insert_dev(target, t49, anchor);
      insert_dev(target, h43, anchor);
      insert_dev(target, t51, anchor);
      mount_component(jsonbox3, target, anchor);
      insert_dev(target, t52, anchor);
      mount_component(button1, target, anchor);
      insert_dev(target, t53, anchor);
      insert_dev(target, h311, anchor);
      insert_dev(target, t55, anchor);
      mount_component(combobox11, target, anchor);
      insert_dev(target, t56, anchor);
      insert_dev(target, h44, anchor);
      insert_dev(target, t58, anchor);
      mount_component(jsonbox4, target, anchor);
      insert_dev(target, t59, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t60, anchor);
      insert_dev(target, hr, anchor);
      insert_dev(target, t61, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const combobox0_changes = {};
      if (!updating_value && dirty & /*itemValue*/
      1) {
        updating_value = true;
        combobox0_changes.value = /*itemValue*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      combobox0.$set(combobox0_changes);
      const jsonbox0_changes = {};
      if (dirty & /*itemValue*/
      1)
        jsonbox0_changes.value = /*itemValue*/
        ctx2[0];
      jsonbox0.$set(jsonbox0_changes);
      const button0_changes = {};
      if (dirty & /*$$scope*/
      1048576) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const combobox1_changes = {};
      if (!updating_value_1 && dirty & /*itemValue*/
      1) {
        updating_value_1 = true;
        combobox1_changes.value = /*itemValue*/
        ctx2[0];
        add_flush_callback(() => updating_value_1 = false);
      }
      combobox1.$set(combobox1_changes);
      const combobox2_changes = {};
      if (!updating_value_2 && dirty & /*itemValue*/
      1) {
        updating_value_2 = true;
        combobox2_changes.value = /*itemValue*/
        ctx2[0];
        add_flush_callback(() => updating_value_2 = false);
      }
      combobox2.$set(combobox2_changes);
      const combobox3_changes = {};
      if (!updating_value_3 && dirty & /*itemValue*/
      1) {
        updating_value_3 = true;
        combobox3_changes.value = /*itemValue*/
        ctx2[0];
        add_flush_callback(() => updating_value_3 = false);
      }
      combobox3.$set(combobox3_changes);
      const combobox4_changes = {};
      if (!updating_value_4 && dirty & /*valueSimpler*/
      4) {
        updating_value_4 = true;
        combobox4_changes.value = /*valueSimpler*/
        ctx2[2];
        add_flush_callback(() => updating_value_4 = false);
      }
      combobox4.$set(combobox4_changes);
      const jsonbox1_changes = {};
      if (dirty & /*valueSimpler*/
      4)
        jsonbox1_changes.value = /*valueSimpler*/
        ctx2[2];
      jsonbox1.$set(jsonbox1_changes);
      const combobox5_changes = {};
      if (!updating_value_5 && dirty & /*valueSimple*/
      8) {
        updating_value_5 = true;
        combobox5_changes.value = /*valueSimple*/
        ctx2[3];
        add_flush_callback(() => updating_value_5 = false);
      }
      combobox5.$set(combobox5_changes);
      const jsonbox2_changes = {};
      if (dirty & /*valueSimple*/
      8)
        jsonbox2_changes.value = /*valueSimple*/
        ctx2[3];
      jsonbox2.$set(jsonbox2_changes);
      const combobox10_changes = {};
      if (!updating_value_6 && dirty & /*multiselectSimpleValue*/
      16) {
        updating_value_6 = true;
        combobox10_changes.value = /*multiselectSimpleValue*/
        ctx2[4];
        add_flush_callback(() => updating_value_6 = false);
      }
      combobox10.$set(combobox10_changes);
      const jsonbox3_changes = {};
      if (dirty & /*multiselectSimpleValue*/
      16)
        jsonbox3_changes.value = /*multiselectSimpleValue*/
        ctx2[4];
      jsonbox3.$set(jsonbox3_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      1048576) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const combobox11_changes = {};
      if (!updating_value_7 && dirty & /*multiselectValue*/
      2) {
        updating_value_7 = true;
        combobox11_changes.value = /*multiselectValue*/
        ctx2[1];
        add_flush_callback(() => updating_value_7 = false);
      }
      combobox11.$set(combobox11_changes);
      const jsonbox4_changes = {};
      if (dirty & /*multiselectValue*/
      2)
        jsonbox4_changes.value = /*multiselectValue*/
        ctx2[1];
      jsonbox4.$set(jsonbox4_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(combobox0.$$.fragment, local);
      transition_in(jsonbox0.$$.fragment, local);
      transition_in(button0.$$.fragment, local);
      transition_in(combobox1.$$.fragment, local);
      transition_in(combobox2.$$.fragment, local);
      transition_in(combobox3.$$.fragment, local);
      transition_in(combobox4.$$.fragment, local);
      transition_in(jsonbox1.$$.fragment, local);
      transition_in(combobox5.$$.fragment, local);
      transition_in(jsonbox2.$$.fragment, local);
      transition_in(combobox6.$$.fragment, local);
      transition_in(combobox7.$$.fragment, local);
      transition_in(combobox8.$$.fragment, local);
      transition_in(combobox9.$$.fragment, local);
      transition_in(combobox10.$$.fragment, local);
      transition_in(jsonbox3.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(combobox11.$$.fragment, local);
      transition_in(jsonbox4.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(combobox0.$$.fragment, local);
      transition_out(jsonbox0.$$.fragment, local);
      transition_out(button0.$$.fragment, local);
      transition_out(combobox1.$$.fragment, local);
      transition_out(combobox2.$$.fragment, local);
      transition_out(combobox3.$$.fragment, local);
      transition_out(combobox4.$$.fragment, local);
      transition_out(jsonbox1.$$.fragment, local);
      transition_out(combobox5.$$.fragment, local);
      transition_out(jsonbox2.$$.fragment, local);
      transition_out(combobox6.$$.fragment, local);
      transition_out(combobox7.$$.fragment, local);
      transition_out(combobox8.$$.fragment, local);
      transition_out(combobox9.$$.fragment, local);
      transition_out(combobox10.$$.fragment, local);
      transition_out(jsonbox3.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(combobox11.$$.fragment, local);
      transition_out(jsonbox4.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h20);
        detach_dev(t1);
        detach_dev(h30);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(h40);
        detach_dev(t6);
        detach_dev(t7);
        detach_dev(t8);
        detach_dev(h31);
        detach_dev(t10);
        detach_dev(t11);
        detach_dev(h32);
        detach_dev(t13);
        detach_dev(t14);
        detach_dev(h33);
        detach_dev(t16);
        detach_dev(t17);
        detach_dev(h34);
        detach_dev(t19);
        detach_dev(t20);
        detach_dev(h41);
        detach_dev(t22);
        detach_dev(t23);
        detach_dev(h35);
        detach_dev(t25);
        detach_dev(t26);
        detach_dev(h42);
        detach_dev(t28);
        detach_dev(t29);
        detach_dev(h36);
        detach_dev(t31);
        detach_dev(t32);
        detach_dev(h37);
        detach_dev(t34);
        detach_dev(t35);
        detach_dev(h38);
        detach_dev(t37);
        detach_dev(t38);
        detach_dev(h39);
        detach_dev(t40);
        detach_dev(t41);
        detach_dev(h21);
        detach_dev(t43);
        detach_dev(p);
        detach_dev(t46);
        detach_dev(h310);
        detach_dev(t48);
        detach_dev(t49);
        detach_dev(h43);
        detach_dev(t51);
        detach_dev(t52);
        detach_dev(t53);
        detach_dev(h311);
        detach_dev(t55);
        detach_dev(t56);
        detach_dev(h44);
        detach_dev(t58);
        detach_dev(t59);
        detach_dev(t60);
        detach_dev(hr);
        detach_dev(t61);
      }
      destroy_component(combobox0, detaching);
      destroy_component(jsonbox0, detaching);
      destroy_component(button0, detaching);
      destroy_component(combobox1, detaching);
      destroy_component(combobox2, detaching);
      destroy_component(combobox3, detaching);
      destroy_component(combobox4, detaching);
      destroy_component(jsonbox1, detaching);
      destroy_component(combobox5, detaching);
      destroy_component(jsonbox2, detaching);
      destroy_component(combobox6, detaching);
      destroy_component(combobox7, detaching);
      destroy_component(combobox8, detaching);
      destroy_component(combobox9, detaching);
      destroy_component(combobox10, detaching);
      destroy_component(jsonbox3, detaching);
      destroy_component(button1, detaching);
      destroy_component(combobox11, detaching);
      destroy_component(jsonbox4, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment63.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function onChange(e) {
  const { value: value2, oldValue } = e.detail;
  console.log({ value: value2, oldValue });
}
function instance63($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Combobox", slots2, []);
  const apiProps = [
    {
      name: "allowNew",
      description: "Whether to allow arbitrary values (that don't exist in the list)."
    },
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "clearOnEsc",
      description: "If present - the combobox will be cleared when Escape is pressed."
    },
    {
      name: "disabled",
      description: "Make the combobox disabled."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the combobox."
    },
    {
      name: "hideOnResize",
      description: "If present - resizing the window will close the popup."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying input."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the combobox."
    },
    {
      name: "items",
      type: "array",
      required: true,
      description: "An array of strings or objects in the following format: <code>&lbrace; name: string, id?: string | number, group?: string &rbrace;</code>(<i>name</i> should be unique, or - if <i>id</i> is present - <i>id</i> should be unique)."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the combobox."
    },
    {
      name: "labelOnTheLeft",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "multiselect",
      description: "This changes the control to a multiselect. The following changes will apply:<ul><li>dropdown items will receive checkboxes,<li>and the control will only allow to change the value by clicking on items (or check them using the `Space` key),<li>the value will become an array,<li>argument `allowNew` will have no effect.</ul>"
    },
    {
      name: "placeholder",
      type: "string",
      description: "Shows placeholder text."
    },
    {
      name: "required",
      description: "Mark the combobox as <i>aria-required</i>."
    },
    {
      name: "showOnFocus",
      description: "If present - the popup will be automatically open when the combobox gets focus (as opposed to, when the user starts typing)."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "value",
      type: ["string", "number", "object", "array"],
      description: "Value of the combobox.<br>If combobox is <em>multiselect</em>, the value will be an array of strings or objects. "
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying input."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered when the value changes."
    },
    {
      name: "on:keydown",
      type: "function",
      description: "Triggered when a key is down."
    }
  ];
  const exampleHtml = `
<Combobox
    {items}
    on:change="{ onChange }"
    bind:value="{ value }" />

<script>
const items = [
    { id: 1, name: 'Alpha', group: 'Group 1' },
    { id: 2, name: 'Beta', group: 'Group 1' },
    { id: 3, name: 'Gamma', group: 'Group 2' },
    { id: 4, name: 'Delta', group: 'Group 2' },
];
let value = data[1];

function onChange (e) {
    const { value, oldValue } = e.detail;
    console.log({ value, oldValue });
}
&lt;/script>
`;
  const items = [
    { id: 1, name: "Alpha", group: "Group 1" },
    { id: 2, name: "Beta", group: "Group 1" },
    { id: 3, name: "Gamma", group: "Group 1" },
    { id: 4, name: "Delta", group: "Group 1" },
    { id: 5, name: "Epsilon", group: "Group 1" },
    {
      id: 6,
      name: "Zeta",
      group: "\u{1F600} Group 2 has a very long name"
    },
    {
      id: 7,
      name: "Eta",
      group: "\u{1F600} Group 2 has a very long name"
    },
    {
      id: 8,
      name: "Theta",
      group: "\u{1F600} Group 2 has a very long name"
    },
    {
      id: 9,
      name: "Iota",
      group: "\u{1F600} Group 2 has a very long name"
    },
    {
      id: 10,
      name: "Kappa",
      group: "\u{1F600} Group 2 has a very long name"
    },
    {
      id: 11,
      name: "Lambda is the last item in Group 2",
      group: "\u{1F600} Group 2 has a very long name"
    },
    { id: 12, name: "Zeta", group: "Group 3" },
    { id: 13, name: "Eta", group: "Group 3" },
    { id: 14, name: "Theta", group: "Group 3" },
    { id: 15, name: "Iota", group: "Group 3" },
    { id: 16, name: "Kappa", group: "Group 3" },
    { id: 17, name: "Lambda", group: "Group 3" }
  ];
  let itemValue = items[1];
  let multiselectValue = [items[0], items[1]];
  const dataSimpler = [
    { name: "Alpha", group: "Group 1" },
    { name: "Beta", group: "Group 1" },
    { name: "Gamma", group: "Group 1" },
    { name: "Delta", group: "Group 1" },
    { name: "Epsilon", group: "Group 1" },
    {
      name: "Zeta",
      group: "\u{1F600} Group 2 has a very long name"
    },
    {
      name: "Eta",
      group: "\u{1F600} Group 2 has a very long name"
    },
    {
      name: "Theta",
      group: "\u{1F600} Group 2 has a very long name"
    },
    {
      name: "Iota",
      group: "\u{1F600} Group 2 has a very long name"
    },
    {
      name: "Kappa",
      group: "\u{1F600} Group 2 has a very long name"
    },
    {
      name: "Lambda is the last item in Group 2",
      group: "\u{1F600} Group 2 has a very long name"
    },
    { name: "Alpha" },
    { name: "Beta" },
    { name: "Gamma" },
    { name: "Delta" },
    { name: "Epsilon" }
  ];
  let valueSimpler = dataSimpler[3];
  const dataSimple = [
    "Alpha",
    "Beta",
    "Gamma",
    "Delta",
    "Epsilon",
    "Zeta",
    "Eta",
    "Theta",
    "Iota",
    "Kappa",
    "Lambda is the last item in this list"
  ];
  let valueSimple = "Gamma";
  let multiselectSimpleValue = [dataSimple[0], dataSimple[1]];
  function resetSingle() {
    $$invalidate2(0, itemValue = null);
  }
  function resetMulti() {
    $$invalidate2(4, multiselectSimpleValue = []);
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_13.warn(`<Combobox> was created with unknown prop '${key}'`);
  });
  function combobox0_value_binding(value2) {
    itemValue = value2;
    $$invalidate2(0, itemValue);
  }
  function combobox1_value_binding(value2) {
    itemValue = value2;
    $$invalidate2(0, itemValue);
  }
  function combobox2_value_binding(value2) {
    itemValue = value2;
    $$invalidate2(0, itemValue);
  }
  function combobox3_value_binding(value2) {
    itemValue = value2;
    $$invalidate2(0, itemValue);
  }
  function combobox4_value_binding(value2) {
    valueSimpler = value2;
    $$invalidate2(2, valueSimpler);
  }
  function combobox5_value_binding(value2) {
    valueSimple = value2;
    $$invalidate2(3, valueSimple);
  }
  function combobox10_value_binding(value2) {
    multiselectSimpleValue = value2;
    $$invalidate2(4, multiselectSimpleValue);
  }
  function combobox11_value_binding(value2) {
    multiselectValue = value2;
    $$invalidate2(1, multiselectValue);
  }
  $$self2.$capture_state = () => ({
    Combobox: Combobox_default,
    Button: Button_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    JsonBox: JsonBox_default,
    apiProps,
    exampleHtml,
    items,
    itemValue,
    multiselectValue,
    dataSimpler,
    valueSimpler,
    dataSimple,
    valueSimple,
    multiselectSimpleValue,
    onChange,
    resetSingle,
    resetMulti
  });
  $$self2.$inject_state = ($$props3) => {
    if ("itemValue" in $$props3)
      $$invalidate2(0, itemValue = $$props3.itemValue);
    if ("multiselectValue" in $$props3)
      $$invalidate2(1, multiselectValue = $$props3.multiselectValue);
    if ("valueSimpler" in $$props3)
      $$invalidate2(2, valueSimpler = $$props3.valueSimpler);
    if ("valueSimple" in $$props3)
      $$invalidate2(3, valueSimple = $$props3.valueSimple);
    if ("multiselectSimpleValue" in $$props3)
      $$invalidate2(4, multiselectSimpleValue = $$props3.multiselectSimpleValue);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    itemValue,
    multiselectValue,
    valueSimpler,
    valueSimple,
    multiselectSimpleValue,
    apiProps,
    exampleHtml,
    items,
    dataSimpler,
    dataSimple,
    resetSingle,
    resetMulti,
    combobox0_value_binding,
    combobox1_value_binding,
    combobox2_value_binding,
    combobox3_value_binding,
    combobox4_value_binding,
    combobox5_value_binding,
    combobox10_value_binding,
    combobox11_value_binding
  ];
}
var Combobox_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance63, create_fragment63, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Combobox_1",
      options,
      id: create_fragment63.name
    });
  }
};
var Combobox_default2 = Combobox_1;

// docs-src/components/input/input-date/InputDate.svelte
var { console: console_14 } = globals;
var file57 = "docs-src/components/input/input-date/InputDate.svelte";
function create_fragment64(ctx) {
  let h2;
  let t1;
  let p0;
  let t2;
  let a;
  let t4;
  let t5;
  let br;
  let t6;
  let h30;
  let t8;
  let inputdate0;
  let updating_value;
  let t9;
  let t10_value = (
    /*item*/
    (ctx[0].datevalue || "") + ""
  );
  let t10;
  let t11;
  let h31;
  let t13;
  let inputdate1;
  let t14;
  let h32;
  let t16;
  let inputdate2;
  let t17;
  let h33;
  let t19;
  let inputdate3;
  let t20;
  let h34;
  let t22;
  let inputdate4;
  let t23;
  let h35;
  let t24;
  let em0;
  let t26;
  let p1;
  let t27;
  let em1;
  let t29;
  let em2;
  let t31;
  let t32;
  let div;
  let small;
  let t34;
  let inputdate5;
  let t35;
  let p2;
  let t36;
  let em3;
  let t38;
  let t39;
  let h36;
  let t41;
  let inputdate6;
  let t42;
  let h37;
  let t44;
  let inputdate7;
  let t45;
  let h38;
  let t47;
  let inputdate8;
  let t48;
  let h39;
  let t50;
  let inputdate9;
  let t51;
  let codeexample;
  let t52;
  let api;
  let current;
  function inputdate0_value_binding(value2) {
    ctx[5](value2);
  }
  let inputdate0_props = {};
  if (
    /*item*/
    ctx[0].datevalue !== void 0
  ) {
    inputdate0_props.value = /*item*/
    ctx[0].datevalue;
  }
  inputdate0 = new InputDate_default({ props: inputdate0_props, $$inline: true });
  binding_callbacks.push(() => bind(inputdate0, "value", inputdate0_value_binding));
  inputdate0.$on("keydown", onkey);
  inputdate1 = new InputDate_default({
    props: {
      showOnFocus: "true",
      placeholder: "Custom placeholder"
    },
    $$inline: true
  });
  inputdate2 = new InputDate_default({
    props: { value: "2061-01-01" },
    $$inline: true
  });
  inputdate3 = new InputDate_default({
    props: {
      useNativeOnMobile: true,
      value: "2061-01-01"
    },
    $$inline: true
  });
  inputdate4 = new InputDate_default({
    props: { format: "dd-mm-yy" },
    $$inline: true
  });
  inputdate5 = new InputDate_default({
    props: { elevate: "true" },
    $$inline: true
  });
  inputdate6 = new InputDate_default({
    props: { label: "Pick one" },
    $$inline: true
  });
  inputdate7 = new InputDate_default({
    props: {
      label: "Pick one",
      info: "Pick your pick"
    },
    $$inline: true
  });
  inputdate8 = new InputDate_default({
    props: {
      label: "Pick one",
      error: (
        /*error*/
        ctx[1]
      )
    },
    $$inline: true
  });
  inputdate8.$on(
    "change",
    /*onchange*/
    ctx[4]
  );
  inputdate9 = new InputDate_default({
    props: {
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[3]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[2]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Input Date";
      t1 = space();
      p0 = element2("p");
      t2 = text("This is a wrapper for the vanilla javascript component ");
      a = element2("a");
      a.textContent = "vanillajs-datepicker";
      t4 = text(".");
      t5 = space();
      br = element2("br");
      t6 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t8 = space();
      create_component(inputdate0.$$.fragment);
      t9 = space();
      t10 = text(t10_value);
      t11 = space();
      h31 = element2("h3");
      h31.textContent = "Show on focus (when using keyboard)";
      t13 = space();
      create_component(inputdate1.$$.fragment);
      t14 = space();
      h32 = element2("h3");
      h32.textContent = "Initial value";
      t16 = space();
      create_component(inputdate2.$$.fragment);
      t17 = space();
      h33 = element2("h3");
      h33.textContent = "Use native on mobile";
      t19 = space();
      create_component(inputdate3.$$.fragment);
      t20 = space();
      h34 = element2("h3");
      h34.textContent = "Change date format";
      t22 = space();
      create_component(inputdate4.$$.fragment);
      t23 = space();
      h35 = element2("h3");
      t24 = text("In a container with ");
      em0 = element2("em");
      em0.textContent = "overflow: hidden";
      t26 = space();
      p1 = element2("p");
      t27 = text("Where parent container has ");
      em1 = element2("em");
      em1.textContent = "overflow: hidden";
      t29 = text(", ");
      em2 = element2("em");
      em2.textContent = 'elevate="true"';
      t31 = text("\n	property must be set on the component.");
      t32 = space();
      div = element2("div");
      small = element2("small");
      small.textContent = "overflow: hidden";
      t34 = space();
      create_component(inputdate5.$$.fragment);
      t35 = space();
      p2 = element2("p");
      t36 = text("This option should only be used when absolutely necessary (e.g. when InputDate\n	is used inside dialogs/popups), because it makes the component less accessible\n	(the list container is rendered directly in the ");
      em3 = element2("em");
      em3.textContent = "<body>";
      t38 = text(", and not next to the input).");
      t39 = space();
      h36 = element2("h3");
      h36.textContent = "Label";
      t41 = space();
      create_component(inputdate6.$$.fragment);
      t42 = space();
      h37 = element2("h3");
      h37.textContent = "Info";
      t44 = space();
      create_component(inputdate7.$$.fragment);
      t45 = space();
      h38 = element2("h3");
      h38.textContent = "Error";
      t47 = space();
      create_component(inputdate8.$$.fragment);
      t48 = space();
      h39 = element2("h3");
      h39.textContent = "Label on the left";
      t50 = space();
      create_component(inputdate9.$$.fragment);
      t51 = space();
      create_component(codeexample.$$.fragment);
      t52 = space();
      create_component(api.$$.fragment);
      add_location(h2, file57, 0, 0, 0);
      attr_dev(a, "href", "https://mymth.github.io/vanillajs-datepicker/#/");
      add_location(a, file57, 1, 58, 78);
      add_location(p0, file57, 1, 0, 20);
      add_location(br, file57, 2, 0, 166);
      add_location(h30, file57, 4, 0, 172);
      add_location(h31, file57, 8, 0, 276);
      add_location(h32, file57, 12, 0, 389);
      add_location(h33, file57, 15, 0, 445);
      add_location(h34, file57, 19, 0, 528);
      add_location(em0, file57, 23, 24, 614);
      add_location(h35, file57, 23, 0, 590);
      add_location(em1, file57, 24, 30, 675);
      add_location(em2, file57, 24, 57, 702);
      add_location(p1, file57, 24, 0, 645);
      add_location(small, file57, 27, 1, 803);
      attr_dev(div, "class", "docs-overflow-box");
      add_location(div, file57, 26, 0, 770);
      add_location(em3, file57, 32, 49, 1083);
      add_location(p2, file57, 30, 0, 872);
      add_location(h36, file57, 35, 0, 1140);
      add_location(h37, file57, 38, 0, 1187);
      add_location(h38, file57, 41, 0, 1255);
      add_location(h39, file57, 48, 0, 1344);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p0, anchor);
      append_dev(p0, t2);
      append_dev(p0, a);
      append_dev(p0, t4);
      insert_dev(target, t5, anchor);
      insert_dev(target, br, anchor);
      insert_dev(target, t6, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t8, anchor);
      mount_component(inputdate0, target, anchor);
      insert_dev(target, t9, anchor);
      insert_dev(target, t10, anchor);
      insert_dev(target, t11, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t13, anchor);
      mount_component(inputdate1, target, anchor);
      insert_dev(target, t14, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t16, anchor);
      mount_component(inputdate2, target, anchor);
      insert_dev(target, t17, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t19, anchor);
      mount_component(inputdate3, target, anchor);
      insert_dev(target, t20, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t22, anchor);
      mount_component(inputdate4, target, anchor);
      insert_dev(target, t23, anchor);
      insert_dev(target, h35, anchor);
      append_dev(h35, t24);
      append_dev(h35, em0);
      insert_dev(target, t26, anchor);
      insert_dev(target, p1, anchor);
      append_dev(p1, t27);
      append_dev(p1, em1);
      append_dev(p1, t29);
      append_dev(p1, em2);
      append_dev(p1, t31);
      insert_dev(target, t32, anchor);
      insert_dev(target, div, anchor);
      append_dev(div, small);
      append_dev(div, t34);
      mount_component(inputdate5, div, null);
      insert_dev(target, t35, anchor);
      insert_dev(target, p2, anchor);
      append_dev(p2, t36);
      append_dev(p2, em3);
      append_dev(p2, t38);
      insert_dev(target, t39, anchor);
      insert_dev(target, h36, anchor);
      insert_dev(target, t41, anchor);
      mount_component(inputdate6, target, anchor);
      insert_dev(target, t42, anchor);
      insert_dev(target, h37, anchor);
      insert_dev(target, t44, anchor);
      mount_component(inputdate7, target, anchor);
      insert_dev(target, t45, anchor);
      insert_dev(target, h38, anchor);
      insert_dev(target, t47, anchor);
      mount_component(inputdate8, target, anchor);
      insert_dev(target, t48, anchor);
      insert_dev(target, h39, anchor);
      insert_dev(target, t50, anchor);
      mount_component(inputdate9, target, anchor);
      insert_dev(target, t51, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t52, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const inputdate0_changes = {};
      if (!updating_value && dirty & /*item*/
      1) {
        updating_value = true;
        inputdate0_changes.value = /*item*/
        ctx2[0].datevalue;
        add_flush_callback(() => updating_value = false);
      }
      inputdate0.$set(inputdate0_changes);
      if ((!current || dirty & /*item*/
      1) && t10_value !== (t10_value = /*item*/
      (ctx2[0].datevalue || "") + ""))
        set_data_dev(t10, t10_value);
      const inputdate8_changes = {};
      if (dirty & /*error*/
      2)
        inputdate8_changes.error = /*error*/
        ctx2[1];
      inputdate8.$set(inputdate8_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputdate0.$$.fragment, local);
      transition_in(inputdate1.$$.fragment, local);
      transition_in(inputdate2.$$.fragment, local);
      transition_in(inputdate3.$$.fragment, local);
      transition_in(inputdate4.$$.fragment, local);
      transition_in(inputdate5.$$.fragment, local);
      transition_in(inputdate6.$$.fragment, local);
      transition_in(inputdate7.$$.fragment, local);
      transition_in(inputdate8.$$.fragment, local);
      transition_in(inputdate9.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputdate0.$$.fragment, local);
      transition_out(inputdate1.$$.fragment, local);
      transition_out(inputdate2.$$.fragment, local);
      transition_out(inputdate3.$$.fragment, local);
      transition_out(inputdate4.$$.fragment, local);
      transition_out(inputdate5.$$.fragment, local);
      transition_out(inputdate6.$$.fragment, local);
      transition_out(inputdate7.$$.fragment, local);
      transition_out(inputdate8.$$.fragment, local);
      transition_out(inputdate9.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p0);
        detach_dev(t5);
        detach_dev(br);
        detach_dev(t6);
        detach_dev(h30);
        detach_dev(t8);
        detach_dev(t9);
        detach_dev(t10);
        detach_dev(t11);
        detach_dev(h31);
        detach_dev(t13);
        detach_dev(t14);
        detach_dev(h32);
        detach_dev(t16);
        detach_dev(t17);
        detach_dev(h33);
        detach_dev(t19);
        detach_dev(t20);
        detach_dev(h34);
        detach_dev(t22);
        detach_dev(t23);
        detach_dev(h35);
        detach_dev(t26);
        detach_dev(p1);
        detach_dev(t32);
        detach_dev(div);
        detach_dev(t35);
        detach_dev(p2);
        detach_dev(t39);
        detach_dev(h36);
        detach_dev(t41);
        detach_dev(t42);
        detach_dev(h37);
        detach_dev(t44);
        detach_dev(t45);
        detach_dev(h38);
        detach_dev(t47);
        detach_dev(t48);
        detach_dev(h39);
        detach_dev(t50);
        detach_dev(t51);
        detach_dev(t52);
      }
      destroy_component(inputdate0, detaching);
      destroy_component(inputdate1, detaching);
      destroy_component(inputdate2, detaching);
      destroy_component(inputdate3, detaching);
      destroy_component(inputdate4, detaching);
      destroy_component(inputdate5);
      destroy_component(inputdate6, detaching);
      destroy_component(inputdate7, detaching);
      destroy_component(inputdate8, detaching);
      destroy_component(inputdate9, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment64.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function onkey(e) {
  console.log(1111, e.detail.event.key);
}
function instance64($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputDate", slots2, []);
  const item = {};
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component container."
    },
    {
      name: "disabled",
      description: "Make the input disabled."
    },
    {
      name: "elevate",
      type: ["true", "false"],
      default: "false",
      description: "If <i>true</i> - the popup will be rendered into the <i>body</i>, to ensure it's not hidden under some elements (see example above)."
    },
    {
      name: "format",
      type: "string",
      default: "yyyy-mm-dd",
      description: 'Date format (<a href="https://mymth.github.io/vanillajs-datepicker/#/date-string+format" target="_blank">docs</a>).'
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying input."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the input."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the input."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the input."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "placeholder",
      type: "string",
      default: "yyyy-mm-dd",
      description: "Add a custom placeholder for the input."
    },
    {
      name: "required",
      description: "Mark the input as <i>required</i> for form submission and effectively shows it as invalid, until checked."
    },
    {
      name: "showOnFocus",
      type: ["true", "false"],
      default: "false",
      description: "If <i>true</i> - the datepicker will be automatically open when the input gets focus (normally opens on click)."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "useNativeOnMobile",
      type: ["true", "false"],
      default: "false",
      description: "Use native date picker on mobile devices.<br>In some cases this may provide prefered UX, but it has also some restrictions depending on the device/browser, like date format is enforced by device locale and placeholder text may not be available."
    },
    {
      name: "value",
      type: "string",
      description: "Initial value of the input."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying input."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered when the value changes."
    },
    {
      name: "on:keydown",
      type: "function",
      description: "Triggered when a key is down."
    }
  ];
  const exampleHtml = `
<InputDate on:change="{ onChange }" />

<script>
function onChange (e) {
    console.log(e.detail.value);
}
&lt;/script>

`;
  let error2 = "You picked wrong!";
  function onchange5(e) {
    const val = e.detail;
    $$invalidate2(1, error2 = val === "1" ? "" : "You picked wrong!");
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_14.warn(`<InputDate> was created with unknown prop '${key}'`);
  });
  function inputdate0_value_binding(value2) {
    if ($$self2.$$.not_equal(item.datevalue, value2)) {
      item.datevalue = value2;
      $$invalidate2(0, item);
    }
  }
  $$self2.$capture_state = () => ({
    InputDate: InputDate_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    item,
    apiProps,
    exampleHtml,
    error: error2,
    onchange: onchange5,
    onkey
  });
  $$self2.$inject_state = ($$props3) => {
    if ("error" in $$props3)
      $$invalidate2(1, error2 = $$props3.error);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [item, error2, apiProps, exampleHtml, onchange5, inputdate0_value_binding];
}
var InputDate_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance64, create_fragment64, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputDate_1",
      options,
      id: create_fragment64.name
    });
  }
};
var InputDate_default2 = InputDate_1;

// docs-src/components/input/input-math/InputMath.svelte
var file58 = "docs-src/components/input/input-math/InputMath.svelte";
function create_fragment65(ctx) {
  let h2;
  let t1;
  let p;
  let t2;
  let em;
  let br;
  let t4;
  let t5;
  let hr;
  let t6;
  let h30;
  let t8;
  let inputmath0;
  let t9;
  let h31;
  let t11;
  let inputmath1;
  let t12;
  let h32;
  let t14;
  let inputmath2;
  let t15;
  let h33;
  let t17;
  let inputmath3;
  let t18;
  let codeexample;
  let t19;
  let api;
  let current;
  inputmath0 = new InputMath_default({
    props: { label: "Enter amount" },
    $$inline: true
  });
  inputmath1 = new InputMath_default({
    props: {
      label: "Enter amount",
      info: "You can add 2 numbers here"
    },
    $$inline: true
  });
  inputmath2 = new InputMath_default({
    props: {
      label: "Enter amount",
      info: "You can add 2 numbers here",
      error: "Number must be big!"
    },
    $$inline: true
  });
  inputmath3 = new InputMath_default({
    props: {
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[1]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Input Math";
      t1 = space();
      p = element2("p");
      t2 = text("Enhanced input number field, which allows user to enter the basic math symbols: ");
      em = element2("em");
      em.textContent = "+ - * / ( )";
      br = element2("br");
      t4 = text("\n	and - on blur - replaces the equasion with the resolved number.");
      t5 = space();
      hr = element2("hr");
      t6 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t8 = space();
      create_component(inputmath0.$$.fragment);
      t9 = space();
      h31 = element2("h3");
      h31.textContent = "With info box";
      t11 = space();
      create_component(inputmath1.$$.fragment);
      t12 = space();
      h32 = element2("h3");
      h32.textContent = "With info box and error.";
      t14 = space();
      create_component(inputmath2.$$.fragment);
      t15 = space();
      h33 = element2("h3");
      h33.textContent = "Label on the left";
      t17 = space();
      create_component(inputmath3.$$.fragment);
      t18 = space();
      create_component(codeexample.$$.fragment);
      t19 = space();
      create_component(api.$$.fragment);
      add_location(h2, file58, 0, 0, 0);
      add_location(em, file58, 1, 83, 103);
      add_location(br, file58, 1, 103, 123);
      add_location(p, file58, 1, 0, 20);
      add_location(hr, file58, 4, 0, 198);
      add_location(h30, file58, 6, 0, 204);
      add_location(h31, file58, 9, 0, 256);
      add_location(h32, file58, 12, 0, 348);
      add_location(h33, file58, 15, 0, 479);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p, anchor);
      append_dev(p, t2);
      append_dev(p, em);
      append_dev(p, br);
      append_dev(p, t4);
      insert_dev(target, t5, anchor);
      insert_dev(target, hr, anchor);
      insert_dev(target, t6, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t8, anchor);
      mount_component(inputmath0, target, anchor);
      insert_dev(target, t9, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t11, anchor);
      mount_component(inputmath1, target, anchor);
      insert_dev(target, t12, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t14, anchor);
      mount_component(inputmath2, target, anchor);
      insert_dev(target, t15, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t17, anchor);
      mount_component(inputmath3, target, anchor);
      insert_dev(target, t18, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t19, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputmath0.$$.fragment, local);
      transition_in(inputmath1.$$.fragment, local);
      transition_in(inputmath2.$$.fragment, local);
      transition_in(inputmath3.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputmath0.$$.fragment, local);
      transition_out(inputmath1.$$.fragment, local);
      transition_out(inputmath2.$$.fragment, local);
      transition_out(inputmath3.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p);
        detach_dev(t5);
        detach_dev(hr);
        detach_dev(t6);
        detach_dev(h30);
        detach_dev(t8);
        detach_dev(t9);
        detach_dev(h31);
        detach_dev(t11);
        detach_dev(t12);
        detach_dev(h32);
        detach_dev(t14);
        detach_dev(t15);
        detach_dev(h33);
        detach_dev(t17);
        detach_dev(t18);
        detach_dev(t19);
      }
      destroy_component(inputmath0, detaching);
      destroy_component(inputmath1, detaching);
      destroy_component(inputmath2, detaching);
      destroy_component(inputmath3, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment65.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance65($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputMath", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "disabled",
      description: "Make the input disabled."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying input."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the input."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the input."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the input."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "placeholder",
      type: "string",
      description: "Assign placeholder to the underlying input."
    },
    {
      name: "required",
      description: "Mark the input as <i>aria-required</i>."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "value",
      type: ["string", "number"],
      description: "Initial value of the input."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying input."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered when the value changes."
    },
    {
      name: "on:keydown",
      type: "function",
      description: "Triggered when a key is down."
    }
  ];
  const exampleHtml = `
<InputMath label="Enter amount" on:change="{onChange}" />

<script>
function onChange (e) {
    const { value, oldValue } = e.detail;
    console.log({ value, oldValue });
}
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InputMath> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    InputMath: InputMath_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    exampleHtml
  });
  return [apiProps, exampleHtml];
}
var InputMath_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance65, create_fragment65, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputMath_1",
      options,
      id: create_fragment65.name
    });
  }
};
var InputMath_default2 = InputMath_1;

// docs-src/components/input/input-number/InputNumber.svelte
var file59 = "docs-src/components/input/input-number/InputNumber.svelte";
function create_fragment66(ctx) {
  let h2;
  let t1;
  let p;
  let t3;
  let h30;
  let t5;
  let inputnumber0;
  let t6;
  let h31;
  let t8;
  let inputnumber1;
  let updating_value;
  let t9;
  let h32;
  let t11;
  let inputnumber2;
  let t12;
  let h33;
  let t14;
  let inputnumber3;
  let t15;
  let h34;
  let t17;
  let inputnumber4;
  let t18;
  let codeexample;
  let t19;
  let api;
  let current;
  inputnumber0 = new InputNumber_default({
    props: { label: "Enter amount" },
    $$inline: true
  });
  function inputnumber1_value_binding(value2) {
    ctx[5](value2);
  }
  let inputnumber1_props = {
    label: "Enter amount",
    error: (
      /*error*/
      ctx[0]
    )
  };
  if (
    /*value*/
    ctx[1] !== void 0
  ) {
    inputnumber1_props.value = /*value*/
    ctx[1];
  }
  inputnumber1 = new InputNumber_default({
    props: inputnumber1_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(inputnumber1, "value", inputnumber1_value_binding));
  inputnumber1.$on(
    "input",
    /*validator*/
    ctx[4]
  );
  inputnumber2 = new InputNumber_default({
    props: {
      label: "Enter amount",
      info: "Additional information."
    },
    $$inline: true
  });
  inputnumber3 = new InputNumber_default({
    props: { label: "Enter amount", separator: "," },
    $$inline: true
  });
  inputnumber4 = new InputNumber_default({
    props: {
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[3]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[2]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Input Number";
      t1 = space();
      p = element2("p");
      p.textContent = "Only allows numbers, a single dot (for decimals) and the minus sign at the beginning.";
      t3 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t5 = space();
      create_component(inputnumber0.$$.fragment);
      t6 = space();
      h31 = element2("h3");
      h31.textContent = "With validation error";
      t8 = space();
      create_component(inputnumber1.$$.fragment);
      t9 = space();
      h32 = element2("h3");
      h32.textContent = "With info box";
      t11 = space();
      create_component(inputnumber2.$$.fragment);
      t12 = space();
      h33 = element2("h3");
      h33.textContent = "With comma as the decimal separator";
      t14 = space();
      create_component(inputnumber3.$$.fragment);
      t15 = space();
      h34 = element2("h3");
      h34.textContent = "Label on the left";
      t17 = space();
      create_component(inputnumber4.$$.fragment);
      t18 = space();
      create_component(codeexample.$$.fragment);
      t19 = space();
      create_component(api.$$.fragment);
      add_location(h2, file59, 0, 0, 0);
      add_location(p, file59, 1, 0, 22);
      add_location(h30, file59, 4, 0, 117);
      add_location(h31, file59, 7, 0, 171);
      add_location(h32, file59, 10, 0, 292);
      add_location(h33, file59, 13, 0, 384);
      add_location(h34, file59, 16, 0, 481);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t5, anchor);
      mount_component(inputnumber0, target, anchor);
      insert_dev(target, t6, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t8, anchor);
      mount_component(inputnumber1, target, anchor);
      insert_dev(target, t9, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t11, anchor);
      mount_component(inputnumber2, target, anchor);
      insert_dev(target, t12, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t14, anchor);
      mount_component(inputnumber3, target, anchor);
      insert_dev(target, t15, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t17, anchor);
      mount_component(inputnumber4, target, anchor);
      insert_dev(target, t18, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t19, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const inputnumber1_changes = {};
      if (dirty & /*error*/
      1)
        inputnumber1_changes.error = /*error*/
        ctx2[0];
      if (!updating_value && dirty & /*value*/
      2) {
        updating_value = true;
        inputnumber1_changes.value = /*value*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      inputnumber1.$set(inputnumber1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputnumber0.$$.fragment, local);
      transition_in(inputnumber1.$$.fragment, local);
      transition_in(inputnumber2.$$.fragment, local);
      transition_in(inputnumber3.$$.fragment, local);
      transition_in(inputnumber4.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputnumber0.$$.fragment, local);
      transition_out(inputnumber1.$$.fragment, local);
      transition_out(inputnumber2.$$.fragment, local);
      transition_out(inputnumber3.$$.fragment, local);
      transition_out(inputnumber4.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p);
        detach_dev(t3);
        detach_dev(h30);
        detach_dev(t5);
        detach_dev(t6);
        detach_dev(h31);
        detach_dev(t8);
        detach_dev(t9);
        detach_dev(h32);
        detach_dev(t11);
        detach_dev(t12);
        detach_dev(h33);
        detach_dev(t14);
        detach_dev(t15);
        detach_dev(h34);
        detach_dev(t17);
        detach_dev(t18);
        detach_dev(t19);
      }
      destroy_component(inputnumber0, detaching);
      destroy_component(inputnumber1, detaching);
      destroy_component(inputnumber2, detaching);
      destroy_component(inputnumber3, detaching);
      destroy_component(inputnumber4, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment66.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance66($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputNumber", slots2, []);
  let error2 = "Number must be <100";
  let value2 = 123;
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "disabled",
      description: "Make the input disabled."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying input."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the input."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the input."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the input."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "placeholder",
      type: "string",
      description: "Assign placeholder to the underlying input."
    },
    {
      name: "required",
      description: "Mark the input as <i>aria-required</i>. The actual validation must be done in the consumer."
    },
    {
      name: "separator",
      type: "string",
      default: ".",
      description: "Custom decimal separator."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "value",
      type: ["string", "number"],
      description: "Initial value of the input."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying input."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered after the value changes and the focus leaves the input."
    },
    {
      name: "on:input",
      type: "function",
      description: "Triggered as soon as the input value changes."
    }
  ];
  const exampleHtml = `
<InputNumber label="Enter amount"/>
`;
  function validator(e) {
    const num2 = parseFloat("" + e.target.value) || 0;
    $$invalidate2(0, error2 = num2 > 100 ? "Number must be <100" : "");
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InputNumber> was created with unknown prop '${key}'`);
  });
  function inputnumber1_value_binding(value$1) {
    value2 = value$1;
    $$invalidate2(1, value2);
  }
  $$self2.$capture_state = () => ({
    InputNumber: InputNumber_default,
    CodeExample: CodeExample_default,
    API: ApiTable_default,
    error: error2,
    value: value2,
    apiProps,
    exampleHtml,
    validator
  });
  $$self2.$inject_state = ($$props3) => {
    if ("error" in $$props3)
      $$invalidate2(0, error2 = $$props3.error);
    if ("value" in $$props3)
      $$invalidate2(1, value2 = $$props3.value);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [error2, value2, apiProps, exampleHtml, validator, inputnumber1_value_binding];
}
var InputNumber_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance66, create_fragment66, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputNumber_1",
      options,
      id: create_fragment66.name
    });
  }
};
var InputNumber_default2 = InputNumber_1;

// docs-src/components/input/input-password/InputPassword.svelte
var file60 = "docs-src/components/input/input-password/InputPassword.svelte";
function create_fragment67(ctx) {
  let h2;
  let t1;
  let p0;
  let t3;
  let p1;
  let t4;
  let a;
  let t6;
  let em0;
  let t8;
  let br0;
  let t9;
  let em1;
  let t11;
  let br1;
  let t12;
  let em2;
  let t14;
  let t15;
  let hr;
  let t16;
  let h30;
  let t18;
  let inputpassword0;
  let updating_value;
  let br2;
  let t19;
  let p2;
  let t20;
  let t21;
  let t22;
  let h31;
  let t24;
  let inputpassword1;
  let updating_value_1;
  let br3;
  let t25;
  let h32;
  let t27;
  let inputpassword2;
  let t28;
  let h33;
  let t30;
  let inputpassword3;
  let t31;
  let h34;
  let t33;
  let inputpassword4;
  let t34;
  let h35;
  let t36;
  let inputpassword5;
  let t37;
  let h36;
  let t39;
  let inputpassword6;
  let t40;
  let h37;
  let t42;
  let inputpassword7;
  let t43;
  let codeexample;
  let t44;
  let api;
  let current;
  function inputpassword0_value_binding(value2) {
    ctx[3](value2);
  }
  let inputpassword0_props = {
    label: "Current password",
    name: "password",
    placeholder: "Not 123456"
  };
  if (
    /*val*/
    ctx[0] !== void 0
  ) {
    inputpassword0_props.value = /*val*/
    ctx[0];
  }
  inputpassword0 = new InputPassword_default({
    props: inputpassword0_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(inputpassword0, "value", inputpassword0_value_binding));
  function inputpassword1_value_binding(value2) {
    ctx[4](value2);
  }
  let inputpassword1_props = {
    label: "Current password",
    name: "password",
    disabled: true
  };
  if (
    /*val*/
    ctx[0] !== void 0
  ) {
    inputpassword1_props.value = /*val*/
    ctx[0];
  }
  inputpassword1 = new InputPassword_default({
    props: inputpassword1_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(inputpassword1, "value", inputpassword1_value_binding));
  inputpassword2 = new InputPassword_default({
    props: { strength: true },
    $$inline: true
  });
  inputpassword3 = new InputPassword_default({
    props: { strength: true, label: "New password" },
    $$inline: true
  });
  inputpassword4 = new InputPassword_default({
    props: {
      strength: true,
      label: "New password",
      info: "Password rules"
    },
    $$inline: true
  });
  inputpassword5 = new InputPassword_default({
    props: {
      strength: true,
      label: "New password",
      info: "Password rules",
      error: "Your password is weak!"
    },
    $$inline: true
  });
  inputpassword6 = new InputPassword_default({
    props: {
      label: "Label is on the left",
      labelOnTheLeft: true
    },
    $$inline: true
  });
  inputpassword7 = new InputPassword_default({
    props: {
      strength: true,
      labelOnTheLeft: true,
      label: "New password"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[2]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[1]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Input Password";
      t1 = space();
      p0 = element2("p");
      p0.textContent = "Enhanced input password field with password strength indicator.";
      t3 = space();
      p1 = element2("p");
      t4 = text("To be able to use the password strength indicator, ");
      a = element2("a");
      a.textContent = "zxcvbn";
      t6 = text(" lib must be available on the global scope (");
      em0 = element2("em");
      em0.textContent = "window.zxcvbn";
      t8 = text(").");
      br0 = element2("br");
      t9 = text("\n	This script file is available in this npm package ");
      em1 = element2("em");
      em1.textContent = "node_modules/@perfectthings/ui/docs/zxcvbn.js";
      t11 = text(", from where it can be copied and loaded,");
      br1 = element2("br");
      t12 = text("\n	e.g. in a ");
      em2 = element2("em");
      em2.textContent = "<script>";
      t14 = text(" tag.");
      t15 = space();
      hr = element2("hr");
      t16 = space();
      h30 = element2("h3");
      h30.textContent = "Default";
      t18 = space();
      create_component(inputpassword0.$$.fragment);
      br2 = element2("br");
      t19 = space();
      p2 = element2("p");
      t20 = text("Your secret password is: ");
      t21 = text(
        /*val*/
        ctx[0]
      );
      t22 = space();
      h31 = element2("h3");
      h31.textContent = "Disabled";
      t24 = space();
      create_component(inputpassword1.$$.fragment);
      br3 = element2("br");
      t25 = space();
      h32 = element2("h3");
      h32.textContent = "With password strength indicator";
      t27 = space();
      create_component(inputpassword2.$$.fragment);
      t28 = space();
      h33 = element2("h3");
      h33.textContent = "With password strength indicator and label";
      t30 = space();
      create_component(inputpassword3.$$.fragment);
      t31 = space();
      h34 = element2("h3");
      h34.textContent = "With password strength indicator, label, and info box";
      t33 = space();
      create_component(inputpassword4.$$.fragment);
      t34 = space();
      h35 = element2("h3");
      h35.textContent = "With password strength indicator, label, info box, and error";
      t36 = space();
      create_component(inputpassword5.$$.fragment);
      t37 = space();
      h36 = element2("h3");
      h36.textContent = "Label on the left";
      t39 = space();
      create_component(inputpassword6.$$.fragment);
      t40 = space();
      h37 = element2("h3");
      h37.textContent = "With password strength and label on the left";
      t42 = space();
      create_component(inputpassword7.$$.fragment);
      t43 = space();
      create_component(codeexample.$$.fragment);
      t44 = space();
      create_component(api.$$.fragment);
      add_location(h2, file60, 0, 0, 0);
      add_location(p0, file60, 1, 0, 24);
      attr_dev(a, "href", "https://github.com/dropbox/zxcvbn");
      add_location(a, file60, 2, 54, 149);
      add_location(em0, file60, 2, 152, 247);
      add_location(br0, file60, 2, 176, 271);
      add_location(em1, file60, 3, 51, 327);
      add_location(br1, file60, 3, 146, 422);
      add_location(em2, file60, 4, 11, 438);
      add_location(p1, file60, 2, 0, 95);
      add_location(hr, file60, 8, 0, 474);
      add_location(h30, file60, 10, 0, 480);
      add_location(br2, file60, 11, 101, 598);
      add_location(p2, file60, 12, 0, 603);
      add_location(h31, file60, 14, 0, 642);
      add_location(br3, file60, 15, 85, 745);
      add_location(h32, file60, 17, 0, 751);
      add_location(h33, file60, 22, 0, 823);
      add_location(h34, file60, 25, 0, 923);
      add_location(h35, file60, 28, 0, 1056);
      add_location(h36, file60, 31, 0, 1227);
      add_location(h37, file60, 34, 0, 1316);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p0, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, p1, anchor);
      append_dev(p1, t4);
      append_dev(p1, a);
      append_dev(p1, t6);
      append_dev(p1, em0);
      append_dev(p1, t8);
      append_dev(p1, br0);
      append_dev(p1, t9);
      append_dev(p1, em1);
      append_dev(p1, t11);
      append_dev(p1, br1);
      append_dev(p1, t12);
      append_dev(p1, em2);
      append_dev(p1, t14);
      insert_dev(target, t15, anchor);
      insert_dev(target, hr, anchor);
      insert_dev(target, t16, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t18, anchor);
      mount_component(inputpassword0, target, anchor);
      insert_dev(target, br2, anchor);
      insert_dev(target, t19, anchor);
      insert_dev(target, p2, anchor);
      append_dev(p2, t20);
      append_dev(p2, t21);
      insert_dev(target, t22, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t24, anchor);
      mount_component(inputpassword1, target, anchor);
      insert_dev(target, br3, anchor);
      insert_dev(target, t25, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t27, anchor);
      mount_component(inputpassword2, target, anchor);
      insert_dev(target, t28, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t30, anchor);
      mount_component(inputpassword3, target, anchor);
      insert_dev(target, t31, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t33, anchor);
      mount_component(inputpassword4, target, anchor);
      insert_dev(target, t34, anchor);
      insert_dev(target, h35, anchor);
      insert_dev(target, t36, anchor);
      mount_component(inputpassword5, target, anchor);
      insert_dev(target, t37, anchor);
      insert_dev(target, h36, anchor);
      insert_dev(target, t39, anchor);
      mount_component(inputpassword6, target, anchor);
      insert_dev(target, t40, anchor);
      insert_dev(target, h37, anchor);
      insert_dev(target, t42, anchor);
      mount_component(inputpassword7, target, anchor);
      insert_dev(target, t43, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t44, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const inputpassword0_changes = {};
      if (!updating_value && dirty & /*val*/
      1) {
        updating_value = true;
        inputpassword0_changes.value = /*val*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      inputpassword0.$set(inputpassword0_changes);
      if (!current || dirty & /*val*/
      1)
        set_data_dev(
          t21,
          /*val*/
          ctx2[0]
        );
      const inputpassword1_changes = {};
      if (!updating_value_1 && dirty & /*val*/
      1) {
        updating_value_1 = true;
        inputpassword1_changes.value = /*val*/
        ctx2[0];
        add_flush_callback(() => updating_value_1 = false);
      }
      inputpassword1.$set(inputpassword1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputpassword0.$$.fragment, local);
      transition_in(inputpassword1.$$.fragment, local);
      transition_in(inputpassword2.$$.fragment, local);
      transition_in(inputpassword3.$$.fragment, local);
      transition_in(inputpassword4.$$.fragment, local);
      transition_in(inputpassword5.$$.fragment, local);
      transition_in(inputpassword6.$$.fragment, local);
      transition_in(inputpassword7.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputpassword0.$$.fragment, local);
      transition_out(inputpassword1.$$.fragment, local);
      transition_out(inputpassword2.$$.fragment, local);
      transition_out(inputpassword3.$$.fragment, local);
      transition_out(inputpassword4.$$.fragment, local);
      transition_out(inputpassword5.$$.fragment, local);
      transition_out(inputpassword6.$$.fragment, local);
      transition_out(inputpassword7.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p0);
        detach_dev(t3);
        detach_dev(p1);
        detach_dev(t15);
        detach_dev(hr);
        detach_dev(t16);
        detach_dev(h30);
        detach_dev(t18);
        detach_dev(br2);
        detach_dev(t19);
        detach_dev(p2);
        detach_dev(t22);
        detach_dev(h31);
        detach_dev(t24);
        detach_dev(br3);
        detach_dev(t25);
        detach_dev(h32);
        detach_dev(t27);
        detach_dev(t28);
        detach_dev(h33);
        detach_dev(t30);
        detach_dev(t31);
        detach_dev(h34);
        detach_dev(t33);
        detach_dev(t34);
        detach_dev(h35);
        detach_dev(t36);
        detach_dev(t37);
        detach_dev(h36);
        detach_dev(t39);
        detach_dev(t40);
        detach_dev(h37);
        detach_dev(t42);
        detach_dev(t43);
        detach_dev(t44);
      }
      destroy_component(inputpassword0, detaching);
      destroy_component(inputpassword1, detaching);
      destroy_component(inputpassword2, detaching);
      destroy_component(inputpassword3, detaching);
      destroy_component(inputpassword4, detaching);
      destroy_component(inputpassword5, detaching);
      destroy_component(inputpassword6, detaching);
      destroy_component(inputpassword7, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment67.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance67($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputPassword", slots2, []);
  let val;
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "disabled",
      description: "Make the input disabled."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying input."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the input."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the input."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the input."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "placeholder",
      type: "string",
      description: "Assign placeholder to the underlying input."
    },
    {
      name: "required",
      description: "Mark the input as <i>required</i> for form submission and effectively shows it as invalid, until filled."
    },
    {
      name: "strength",
      description: "Provide the password strength UI (zxcvbn lib must be loaded)."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "value",
      type: ["string", "number"],
      description: "Initial value of the input."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying input."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered when the value changes."
    },
    {
      name: "on:keydown",
      type: "function",
      description: "Triggered when a key is down."
    }
  ];
  const exampleHtml = `
<InputPassword strength label="Current password" on:change="{onChange}" />

<script>
function onChange (e) {
    console.log('value', e.target.value);
}
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InputPassword> was created with unknown prop '${key}'`);
  });
  function inputpassword0_value_binding(value2) {
    val = value2;
    $$invalidate2(0, val);
  }
  function inputpassword1_value_binding(value2) {
    val = value2;
    $$invalidate2(0, val);
  }
  $$self2.$capture_state = () => ({
    InputPassword: InputPassword_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    val,
    apiProps,
    exampleHtml
  });
  $$self2.$inject_state = ($$props3) => {
    if ("val" in $$props3)
      $$invalidate2(0, val = $$props3.val);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    val,
    apiProps,
    exampleHtml,
    inputpassword0_value_binding,
    inputpassword1_value_binding
  ];
}
var InputPassword_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance67, create_fragment67, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputPassword_1",
      options,
      id: create_fragment67.name
    });
  }
};
var InputPassword_default2 = InputPassword_1;

// docs-src/components/input/input-rating/InputRating.svelte
var { console: console_15 } = globals;
var file61 = "docs-src/components/input/input-rating/InputRating.svelte";
function create_fragment68(ctx) {
  let h2;
  let t1;
  let br;
  let t2;
  let h30;
  let t4;
  let inputrating0;
  let updating_value;
  let t5;
  let t6_value = (
    /*item*/
    (ctx[0].value || "") + ""
  );
  let t6;
  let t7;
  let h31;
  let t9;
  let inputrating1;
  let t10;
  let h32;
  let t12;
  let inputrating2;
  let t13;
  let h33;
  let t15;
  let inputrating3;
  let t16;
  let h34;
  let t18;
  let inputrating4;
  let t19;
  let h35;
  let t21;
  let inputrating5;
  let t22;
  let h36;
  let t24;
  let inputrating6;
  let t25;
  let h37;
  let t27;
  let inputrating7;
  let t28;
  let codeexample;
  let t29;
  let api;
  let current;
  function inputrating0_value_binding(value2) {
    ctx[5](value2);
  }
  let inputrating0_props = {};
  if (
    /*item*/
    ctx[0].value !== void 0
  ) {
    inputrating0_props.value = /*item*/
    ctx[0].value;
  }
  inputrating0 = new InputRating_default({
    props: inputrating0_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(inputrating0, "value", inputrating0_value_binding));
  inputrating0.$on("keydown", onkey2);
  inputrating1 = new InputRating_default({
    props: { icon: "circle" },
    $$inline: true
  });
  inputrating2 = new InputRating_default({ props: { max: "8" }, $$inline: true });
  inputrating3 = new InputRating_default({ props: { light: true }, $$inline: true });
  inputrating4 = new InputRating_default({
    props: { label: "Pick one" },
    $$inline: true
  });
  inputrating5 = new InputRating_default({
    props: {
      label: "Pick one",
      info: "Pick your pick"
    },
    $$inline: true
  });
  inputrating6 = new InputRating_default({
    props: {
      label: "Pick one",
      error: (
        /*error*/
        ctx[1]
      )
    },
    $$inline: true
  });
  inputrating6.$on(
    "change",
    /*onchange*/
    ctx[4]
  );
  inputrating7 = new InputRating_default({
    props: {
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[3]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[2]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Input Rating";
      t1 = space();
      br = element2("br");
      t2 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t4 = space();
      create_component(inputrating0.$$.fragment);
      t5 = space();
      t6 = text(t6_value);
      t7 = space();
      h31 = element2("h3");
      h31.textContent = "Different symbol";
      t9 = space();
      create_component(inputrating1.$$.fragment);
      t10 = space();
      h32 = element2("h3");
      h32.textContent = "More stars";
      t12 = space();
      create_component(inputrating2.$$.fragment);
      t13 = space();
      h33 = element2("h3");
      h33.textContent = "Light (no background)";
      t15 = space();
      create_component(inputrating3.$$.fragment);
      t16 = space();
      h34 = element2("h3");
      h34.textContent = "Label";
      t18 = space();
      create_component(inputrating4.$$.fragment);
      t19 = space();
      h35 = element2("h3");
      h35.textContent = "Info";
      t21 = space();
      create_component(inputrating5.$$.fragment);
      t22 = space();
      h36 = element2("h3");
      h36.textContent = "Error";
      t24 = space();
      create_component(inputrating6.$$.fragment);
      t25 = space();
      h37 = element2("h3");
      h37.textContent = "Label on the left";
      t27 = space();
      create_component(inputrating7.$$.fragment);
      t28 = space();
      create_component(codeexample.$$.fragment);
      t29 = space();
      create_component(api.$$.fragment);
      add_location(h2, file61, 0, 0, 0);
      add_location(br, file61, 2, 0, 23);
      add_location(h30, file61, 4, 0, 29);
      add_location(h31, file61, 9, 0, 128);
      add_location(h32, file61, 13, 0, 186);
      add_location(h33, file61, 17, 0, 232);
      add_location(h34, file61, 21, 0, 287);
      add_location(h35, file61, 25, 0, 337);
      add_location(h36, file61, 29, 0, 408);
      add_location(h37, file61, 36, 0, 499);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, br, anchor);
      insert_dev(target, t2, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t4, anchor);
      mount_component(inputrating0, target, anchor);
      insert_dev(target, t5, anchor);
      insert_dev(target, t6, anchor);
      insert_dev(target, t7, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t9, anchor);
      mount_component(inputrating1, target, anchor);
      insert_dev(target, t10, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t12, anchor);
      mount_component(inputrating2, target, anchor);
      insert_dev(target, t13, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t15, anchor);
      mount_component(inputrating3, target, anchor);
      insert_dev(target, t16, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t18, anchor);
      mount_component(inputrating4, target, anchor);
      insert_dev(target, t19, anchor);
      insert_dev(target, h35, anchor);
      insert_dev(target, t21, anchor);
      mount_component(inputrating5, target, anchor);
      insert_dev(target, t22, anchor);
      insert_dev(target, h36, anchor);
      insert_dev(target, t24, anchor);
      mount_component(inputrating6, target, anchor);
      insert_dev(target, t25, anchor);
      insert_dev(target, h37, anchor);
      insert_dev(target, t27, anchor);
      mount_component(inputrating7, target, anchor);
      insert_dev(target, t28, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t29, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const inputrating0_changes = {};
      if (!updating_value && dirty & /*item*/
      1) {
        updating_value = true;
        inputrating0_changes.value = /*item*/
        ctx2[0].value;
        add_flush_callback(() => updating_value = false);
      }
      inputrating0.$set(inputrating0_changes);
      if ((!current || dirty & /*item*/
      1) && t6_value !== (t6_value = /*item*/
      (ctx2[0].value || "") + ""))
        set_data_dev(t6, t6_value);
      const inputrating6_changes = {};
      if (dirty & /*error*/
      2)
        inputrating6_changes.error = /*error*/
        ctx2[1];
      inputrating6.$set(inputrating6_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputrating0.$$.fragment, local);
      transition_in(inputrating1.$$.fragment, local);
      transition_in(inputrating2.$$.fragment, local);
      transition_in(inputrating3.$$.fragment, local);
      transition_in(inputrating4.$$.fragment, local);
      transition_in(inputrating5.$$.fragment, local);
      transition_in(inputrating6.$$.fragment, local);
      transition_in(inputrating7.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputrating0.$$.fragment, local);
      transition_out(inputrating1.$$.fragment, local);
      transition_out(inputrating2.$$.fragment, local);
      transition_out(inputrating3.$$.fragment, local);
      transition_out(inputrating4.$$.fragment, local);
      transition_out(inputrating5.$$.fragment, local);
      transition_out(inputrating6.$$.fragment, local);
      transition_out(inputrating7.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(br);
        detach_dev(t2);
        detach_dev(h30);
        detach_dev(t4);
        detach_dev(t5);
        detach_dev(t6);
        detach_dev(t7);
        detach_dev(h31);
        detach_dev(t9);
        detach_dev(t10);
        detach_dev(h32);
        detach_dev(t12);
        detach_dev(t13);
        detach_dev(h33);
        detach_dev(t15);
        detach_dev(t16);
        detach_dev(h34);
        detach_dev(t18);
        detach_dev(t19);
        detach_dev(h35);
        detach_dev(t21);
        detach_dev(t22);
        detach_dev(h36);
        detach_dev(t24);
        detach_dev(t25);
        detach_dev(h37);
        detach_dev(t27);
        detach_dev(t28);
        detach_dev(t29);
      }
      destroy_component(inputrating0, detaching);
      destroy_component(inputrating1, detaching);
      destroy_component(inputrating2, detaching);
      destroy_component(inputrating3, detaching);
      destroy_component(inputrating4, detaching);
      destroy_component(inputrating5, detaching);
      destroy_component(inputrating6, detaching);
      destroy_component(inputrating7, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment68.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function onkey2(e) {
  console.log(e.detail.event.key);
}
function instance68($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputRating", slots2, []);
  const item = { value: 2 };
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component container."
    },
    {
      name: "disabled",
      description: "Make the input disabled."
    },
    {
      name: "icon",
      type: "string",
      default: "star",
      description: "Icon name for the symbol."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying input."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the input."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the input."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the input."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "light",
      description: "Disable background and border - for use cases other than in form context.<br>Light does not work when the input has error."
    },
    {
      name: "max",
      type: "number",
      description: "How many stars to show."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "required",
      description: "Mark the input as <i>required</i> for form submission and effectively shows it as invalid, until checked."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "value",
      type: "string",
      description: "Initial value of the input."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying input."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered when the value changes."
    },
    {
      name: "on:keydown",
      type: "function",
      description: "Triggered when a key is down."
    }
  ];
  const exampleHtml = `
<InputRating on:change="{ onChange }" bind:value="{value}" />

<script>
let value = 4;
function onChange (e) {
	const val = e.detail;
    console.log(val);
}
&lt;/script>

`;
  let error2 = "You picked wrong!";
  function onchange5(e) {
    const val = e.detail;
    $$invalidate2(1, error2 = val === "1" ? "" : "You picked wrong!");
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_15.warn(`<InputRating> was created with unknown prop '${key}'`);
  });
  function inputrating0_value_binding(value2) {
    if ($$self2.$$.not_equal(item.value, value2)) {
      item.value = value2;
      $$invalidate2(0, item);
    }
  }
  $$self2.$capture_state = () => ({
    InputRating: InputRating_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    item,
    apiProps,
    exampleHtml,
    error: error2,
    onchange: onchange5,
    onkey: onkey2
  });
  $$self2.$inject_state = ($$props3) => {
    if ("error" in $$props3)
      $$invalidate2(1, error2 = $$props3.error);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [item, error2, apiProps, exampleHtml, onchange5, inputrating0_value_binding];
}
var InputRating_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance68, create_fragment68, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputRating_1",
      options,
      id: create_fragment68.name
    });
  }
};
var InputRating_default2 = InputRating_1;

// docs-src/components/input/input-search/InputSearch.svelte
var { console: console_16 } = globals;
var file62 = "docs-src/components/input/input-search/InputSearch.svelte";
function create_fragment69(ctx) {
  let h2;
  let t1;
  let h30;
  let t3;
  let inputsearch0;
  let updating_value;
  let t4;
  let p;
  let t5;
  let t6;
  let t7;
  let h31;
  let t9;
  let inputsearch1;
  let t10;
  let h32;
  let t12;
  let inputsearch2;
  let t13;
  let br;
  let t14;
  let inputsearch3;
  let t15;
  let h33;
  let t17;
  let inputsearch4;
  let t18;
  let codeexample;
  let t19;
  let api;
  let current;
  function inputsearch0_value_binding(value2) {
    ctx[7](value2);
  }
  let inputsearch0_props = {};
  if (
    /*val*/
    ctx[0] !== void 0
  ) {
    inputsearch0_props.value = /*val*/
    ctx[0];
  }
  inputsearch0 = new InputSearch_default({
    props: inputsearch0_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(inputsearch0, "value", inputsearch0_value_binding));
  inputsearch0.$on(
    "input",
    /*oninput*/
    ctx[6]
  );
  inputsearch1 = new InputSearch_default({
    props: { disabled: true, value: "disabled value" },
    $$inline: true
  });
  inputsearch1.$on(
    "input",
    /*oninput*/
    ctx[6]
  );
  inputsearch2 = new InputSearch_default({
    props: {
      label: "Validate on change",
      error: (
        /*error1*/
        ctx[1]
      ),
      value: (
        /*val*/
        ctx[0]
      )
    },
    $$inline: true
  });
  inputsearch2.$on(
    "change",
    /*onchange*/
    ctx[5]
  );
  inputsearch3 = new InputSearch_default({
    props: {
      label: "Validate on input",
      info: "This should be avoided in most cases. Validating input as user is typing is a bad UX.",
      required: true,
      error: (
        /*error2*/
        ctx[2]
      ),
      value: (
        /*val*/
        ctx[0]
      )
    },
    $$inline: true
  });
  inputsearch3.$on(
    "input",
    /*oninput*/
    ctx[6]
  );
  inputsearch4 = new InputSearch_default({
    props: {
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[4]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[3]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Input Search";
      t1 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t3 = space();
      create_component(inputsearch0.$$.fragment);
      t4 = space();
      p = element2("p");
      t5 = text("Input value: ");
      t6 = text(
        /*val*/
        ctx[0]
      );
      t7 = space();
      h31 = element2("h3");
      h31.textContent = "Disabled";
      t9 = space();
      create_component(inputsearch1.$$.fragment);
      t10 = space();
      h32 = element2("h3");
      h32.textContent = "With validation";
      t12 = space();
      create_component(inputsearch2.$$.fragment);
      t13 = space();
      br = element2("br");
      t14 = space();
      create_component(inputsearch3.$$.fragment);
      t15 = space();
      h33 = element2("h3");
      h33.textContent = "Label on the left";
      t17 = space();
      create_component(inputsearch4.$$.fragment);
      t18 = space();
      create_component(codeexample.$$.fragment);
      t19 = space();
      create_component(api.$$.fragment);
      add_location(h2, file62, 0, 0, 0);
      add_location(h30, file62, 3, 0, 24);
      add_location(p, file62, 5, 0, 96);
      add_location(h31, file62, 7, 0, 123);
      add_location(h32, file62, 11, 0, 212);
      add_location(br, file62, 18, 0, 339);
      add_location(h33, file62, 29, 0, 549);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t3, anchor);
      mount_component(inputsearch0, target, anchor);
      insert_dev(target, t4, anchor);
      insert_dev(target, p, anchor);
      append_dev(p, t5);
      append_dev(p, t6);
      insert_dev(target, t7, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t9, anchor);
      mount_component(inputsearch1, target, anchor);
      insert_dev(target, t10, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t12, anchor);
      mount_component(inputsearch2, target, anchor);
      insert_dev(target, t13, anchor);
      insert_dev(target, br, anchor);
      insert_dev(target, t14, anchor);
      mount_component(inputsearch3, target, anchor);
      insert_dev(target, t15, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t17, anchor);
      mount_component(inputsearch4, target, anchor);
      insert_dev(target, t18, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t19, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const inputsearch0_changes = {};
      if (!updating_value && dirty & /*val*/
      1) {
        updating_value = true;
        inputsearch0_changes.value = /*val*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      inputsearch0.$set(inputsearch0_changes);
      if (!current || dirty & /*val*/
      1)
        set_data_dev(
          t6,
          /*val*/
          ctx2[0]
        );
      const inputsearch2_changes = {};
      if (dirty & /*error1*/
      2)
        inputsearch2_changes.error = /*error1*/
        ctx2[1];
      if (dirty & /*val*/
      1)
        inputsearch2_changes.value = /*val*/
        ctx2[0];
      inputsearch2.$set(inputsearch2_changes);
      const inputsearch3_changes = {};
      if (dirty & /*error2*/
      4)
        inputsearch3_changes.error = /*error2*/
        ctx2[2];
      if (dirty & /*val*/
      1)
        inputsearch3_changes.value = /*val*/
        ctx2[0];
      inputsearch3.$set(inputsearch3_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputsearch0.$$.fragment, local);
      transition_in(inputsearch1.$$.fragment, local);
      transition_in(inputsearch2.$$.fragment, local);
      transition_in(inputsearch3.$$.fragment, local);
      transition_in(inputsearch4.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputsearch0.$$.fragment, local);
      transition_out(inputsearch1.$$.fragment, local);
      transition_out(inputsearch2.$$.fragment, local);
      transition_out(inputsearch3.$$.fragment, local);
      transition_out(inputsearch4.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(h30);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(p);
        detach_dev(t7);
        detach_dev(h31);
        detach_dev(t9);
        detach_dev(t10);
        detach_dev(h32);
        detach_dev(t12);
        detach_dev(t13);
        detach_dev(br);
        detach_dev(t14);
        detach_dev(t15);
        detach_dev(h33);
        detach_dev(t17);
        detach_dev(t18);
        detach_dev(t19);
      }
      destroy_component(inputsearch0, detaching);
      destroy_component(inputsearch1, detaching);
      destroy_component(inputsearch2, detaching);
      destroy_component(inputsearch3, detaching);
      destroy_component(inputsearch4, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment69.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function validate(v) {
  if (!v)
    return "This field is required";
  return;
}
function instance69($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputSearch", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "disabled",
      description: "Make the input disabled."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying input."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the input."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the input."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the input."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "placeholder",
      type: "string",
      description: "Assign placeholder to the underlying input."
    },
    {
      name: "required",
      description: "Mark the input as <i>aria-required</i>. The actual validation must be done in the consumer."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "value",
      type: ["string", "number"],
      description: "Initial value of the input."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying input."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered after the value changes and the focus leaves the input."
    },
    {
      name: "on:input",
      type: "function",
      description: "Triggered as soon as the input value changes."
    }
  ];
  const exampleHtml = `
<InputSearch label="Email" error="Invalid email" value="admin" on:change="{onChange}" />

<script>
function onChange (e) {
    console.log('value', e.target.value);
}
&lt;/script>
`;
  let val = "Hi!";
  let error1 = "", error2 = "";
  function onchange5(e) {
    $$invalidate2(1, error1 = validate(e.target.value));
    console.log(e.target.value);
  }
  function oninput(e) {
    $$invalidate2(2, error2 = validate(e.target.value));
    console.log(e.target.value);
  }
  oninput({ target: { value: "-" } });
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_16.warn(`<InputSearch> was created with unknown prop '${key}'`);
  });
  function inputsearch0_value_binding(value2) {
    val = value2;
    $$invalidate2(0, val);
  }
  $$self2.$capture_state = () => ({
    InputSearch: InputSearch_default,
    CodeExample: CodeExample_default,
    API: ApiTable_default,
    apiProps,
    exampleHtml,
    val,
    error1,
    error2,
    validate,
    onchange: onchange5,
    oninput
  });
  $$self2.$inject_state = ($$props3) => {
    if ("val" in $$props3)
      $$invalidate2(0, val = $$props3.val);
    if ("error1" in $$props3)
      $$invalidate2(1, error1 = $$props3.error1);
    if ("error2" in $$props3)
      $$invalidate2(2, error2 = $$props3.error2);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    val,
    error1,
    error2,
    apiProps,
    exampleHtml,
    onchange5,
    oninput,
    inputsearch0_value_binding
  ];
}
var InputSearch_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance69, create_fragment69, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputSearch_1",
      options,
      id: create_fragment69.name
    });
  }
};
var InputSearch_default2 = InputSearch_1;

// docs-src/components/input/input-tag/InputTag.svelte
var { console: console_17 } = globals;
var file63 = "docs-src/components/input/input-tag/InputTag.svelte";
function create_fragment70(ctx) {
  let h2;
  let t1;
  let h30;
  let t3;
  let inputtag0;
  let updating_value;
  let t4;
  let p;
  let t5;
  let t6;
  let t7;
  let h31;
  let t9;
  let inputtag1;
  let t10;
  let h32;
  let t12;
  let inputtag2;
  let t13;
  let h33;
  let t15;
  let inputtag3;
  let t16;
  let h34;
  let t18;
  let inputtag4;
  let t19;
  let codeexample;
  let t20;
  let api;
  let current;
  function inputtag0_value_binding(value2) {
    ctx[5](value2);
  }
  let inputtag0_props = {};
  if (
    /*val*/
    ctx[0] !== void 0
  ) {
    inputtag0_props.value = /*val*/
    ctx[0];
  }
  inputtag0 = new InputTag_default({ props: inputtag0_props, $$inline: true });
  binding_callbacks.push(() => bind(inputtag0, "value", inputtag0_value_binding));
  inputtag1 = new InputTag_default({
    props: {
      value: "tag1, anotherOne, long-tag-name",
      tags: (
        /*tags*/
        ctx[3]
      )
    },
    $$inline: true
  });
  inputtag1.$on("change", onchange2);
  inputtag2 = new InputTag_default({
    props: {
      value: "tag1, anotherOne, long-tag-name",
      tags: (
        /*tags2*/
        ctx[4]
      )
    },
    $$inline: true
  });
  inputtag3 = new InputTag_default({
    props: { disabled: true, value: "disabled" },
    $$inline: true
  });
  inputtag4 = new InputTag_default({
    props: {
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[2]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[1]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Input Tag";
      t1 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t3 = space();
      create_component(inputtag0.$$.fragment);
      t4 = space();
      p = element2("p");
      t5 = text("Input value: ");
      t6 = text(
        /*val*/
        ctx[0]
      );
      t7 = space();
      h31 = element2("h3");
      h31.textContent = "With onChange callback";
      t9 = space();
      create_component(inputtag1.$$.fragment);
      t10 = space();
      h32 = element2("h3");
      h32.textContent = "Long list of tags";
      t12 = space();
      create_component(inputtag2.$$.fragment);
      t13 = space();
      h33 = element2("h3");
      h33.textContent = "Disabled";
      t15 = space();
      create_component(inputtag3.$$.fragment);
      t16 = space();
      h34 = element2("h3");
      h34.textContent = "Label on the left";
      t18 = space();
      create_component(inputtag4.$$.fragment);
      t19 = space();
      create_component(codeexample.$$.fragment);
      t20 = space();
      create_component(api.$$.fragment);
      add_location(h2, file63, 0, 0, 0);
      add_location(h30, file63, 3, 0, 21);
      add_location(p, file63, 5, 0, 69);
      add_location(h31, file63, 7, 0, 96);
      add_location(h32, file63, 10, 0, 212);
      add_location(h33, file63, 14, 0, 308);
      add_location(h34, file63, 18, 0, 367);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t3, anchor);
      mount_component(inputtag0, target, anchor);
      insert_dev(target, t4, anchor);
      insert_dev(target, p, anchor);
      append_dev(p, t5);
      append_dev(p, t6);
      insert_dev(target, t7, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t9, anchor);
      mount_component(inputtag1, target, anchor);
      insert_dev(target, t10, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t12, anchor);
      mount_component(inputtag2, target, anchor);
      insert_dev(target, t13, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t15, anchor);
      mount_component(inputtag3, target, anchor);
      insert_dev(target, t16, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t18, anchor);
      mount_component(inputtag4, target, anchor);
      insert_dev(target, t19, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t20, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const inputtag0_changes = {};
      if (!updating_value && dirty & /*val*/
      1) {
        updating_value = true;
        inputtag0_changes.value = /*val*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      inputtag0.$set(inputtag0_changes);
      if (!current || dirty & /*val*/
      1)
        set_data_dev(
          t6,
          /*val*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputtag0.$$.fragment, local);
      transition_in(inputtag1.$$.fragment, local);
      transition_in(inputtag2.$$.fragment, local);
      transition_in(inputtag3.$$.fragment, local);
      transition_in(inputtag4.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputtag0.$$.fragment, local);
      transition_out(inputtag1.$$.fragment, local);
      transition_out(inputtag2.$$.fragment, local);
      transition_out(inputtag3.$$.fragment, local);
      transition_out(inputtag4.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(h30);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(p);
        detach_dev(t7);
        detach_dev(h31);
        detach_dev(t9);
        detach_dev(t10);
        detach_dev(h32);
        detach_dev(t12);
        detach_dev(t13);
        detach_dev(h33);
        detach_dev(t15);
        detach_dev(t16);
        detach_dev(h34);
        detach_dev(t18);
        detach_dev(t19);
        detach_dev(t20);
      }
      destroy_component(inputtag0, detaching);
      destroy_component(inputtag1, detaching);
      destroy_component(inputtag2, detaching);
      destroy_component(inputtag3, detaching);
      destroy_component(inputtag4, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment70.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function onchange2(e) {
  console.log("value", e.detail.value);
}
function instance70($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputTag", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "disabled",
      description: "Make the input disabled."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying input."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the input."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the input."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the input."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "tags",
      type: "array",
      required: true,
      description: "An array of strings (the list should contain unique values)."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the component"
    },
    {
      name: "value",
      type: ["string"],
      description: "Initial value of the input - a comma-separated string."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying input."
    },
    {
      name: "bind:listElement",
      type: "element",
      description: "Exposes the HTML element of the list."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered when tag is added/removed from the input value."
    }
  ];
  const exampleHtml = `
<InputTag label="Tags" value="tag1, tag2" on:change="{onChange}" />

<script>
function onChange (e) {
    console.log('tags', e.detail.value);
}
&lt;/script>
`;
  let val = "tag1, tag2";
  const tags = [
    "Tag1",
    "AnotherOne",
    "Long-name-tag-3",
    ...Array.from({ length: 40 }, (v, i) => `Long-name-tag-${i + 4}`)
  ];
  const tags2 = Array.from({ length: 40 }, (v, i) => "Tag-" + i);
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_17.warn(`<InputTag> was created with unknown prop '${key}'`);
  });
  function inputtag0_value_binding(value2) {
    val = value2;
    $$invalidate2(0, val);
  }
  $$self2.$capture_state = () => ({
    InputTag: InputTag_default,
    CodeExample: CodeExample_default,
    API: ApiTable_default,
    apiProps,
    exampleHtml,
    val,
    tags,
    tags2,
    onchange: onchange2
  });
  $$self2.$inject_state = ($$props3) => {
    if ("val" in $$props3)
      $$invalidate2(0, val = $$props3.val);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [val, apiProps, exampleHtml, tags, tags2, inputtag0_value_binding];
}
var InputTag_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance70, create_fragment70, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputTag_1",
      options,
      id: create_fragment70.name
    });
  }
};
var InputTag_default2 = InputTag_1;

// docs-src/components/input/input-time/InputTime.svelte
var { console: console_18 } = globals;
var file64 = "docs-src/components/input/input-time/InputTime.svelte";
function create_fragment71(ctx) {
  let h2;
  let t1;
  let p0;
  let t3;
  let h30;
  let t5;
  let inputtime0;
  let updating_value;
  let t6;
  let p1;
  let t7;
  let t8;
  let t9;
  let h31;
  let t11;
  let inputtime1;
  let t12;
  let h32;
  let t14;
  let inputtime2;
  let t15;
  let h33;
  let t17;
  let inputtime3;
  let t18;
  let codeexample;
  let t19;
  let api;
  let current;
  function inputtime0_value_binding(value2) {
    ctx[5](value2);
  }
  let inputtime0_props = {};
  if (
    /*val*/
    ctx[0] !== void 0
  ) {
    inputtime0_props.value = /*val*/
    ctx[0];
  }
  inputtime0 = new InputTime_default({ props: inputtime0_props, $$inline: true });
  binding_callbacks.push(() => bind(inputtime0, "value", inputtime0_value_binding));
  inputtime1 = new InputTime_default({
    props: { disabled: true, value: "00:00" },
    $$inline: true
  });
  inputtime2 = new InputTime_default({
    props: {
      label: "Select Midnight",
      error: (
        /*error1*/
        ctx[1]
      ),
      value: "00:01"
    },
    $$inline: true
  });
  inputtime2.$on(
    "change",
    /*onchange*/
    ctx[4]
  );
  inputtime3 = new InputTime_default({
    props: {
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[3]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[2]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Input Time";
      t1 = space();
      p0 = element2("p");
      p0.textContent = "This is just a simple wrapper around the native input time control.";
      t3 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t5 = space();
      create_component(inputtime0.$$.fragment);
      t6 = space();
      p1 = element2("p");
      t7 = text("Input value: ");
      t8 = text(
        /*val*/
        ctx[0]
      );
      t9 = space();
      h31 = element2("h3");
      h31.textContent = "Disabled";
      t11 = space();
      create_component(inputtime1.$$.fragment);
      t12 = space();
      h32 = element2("h3");
      h32.textContent = "With validation";
      t14 = space();
      create_component(inputtime2.$$.fragment);
      t15 = space();
      h33 = element2("h3");
      h33.textContent = "Label on the left";
      t17 = space();
      create_component(inputtime3.$$.fragment);
      t18 = space();
      create_component(codeexample.$$.fragment);
      t19 = space();
      create_component(api.$$.fragment);
      add_location(h2, file64, 0, 0, 0);
      add_location(p0, file64, 1, 0, 20);
      add_location(h30, file64, 4, 0, 97);
      add_location(p1, file64, 6, 0, 146);
      add_location(h31, file64, 8, 0, 173);
      add_location(h32, file64, 12, 0, 229);
      add_location(h33, file64, 20, 0, 352);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p0, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t5, anchor);
      mount_component(inputtime0, target, anchor);
      insert_dev(target, t6, anchor);
      insert_dev(target, p1, anchor);
      append_dev(p1, t7);
      append_dev(p1, t8);
      insert_dev(target, t9, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t11, anchor);
      mount_component(inputtime1, target, anchor);
      insert_dev(target, t12, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t14, anchor);
      mount_component(inputtime2, target, anchor);
      insert_dev(target, t15, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t17, anchor);
      mount_component(inputtime3, target, anchor);
      insert_dev(target, t18, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t19, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const inputtime0_changes = {};
      if (!updating_value && dirty & /*val*/
      1) {
        updating_value = true;
        inputtime0_changes.value = /*val*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      inputtime0.$set(inputtime0_changes);
      if (!current || dirty & /*val*/
      1)
        set_data_dev(
          t8,
          /*val*/
          ctx2[0]
        );
      const inputtime2_changes = {};
      if (dirty & /*error1*/
      2)
        inputtime2_changes.error = /*error1*/
        ctx2[1];
      inputtime2.$set(inputtime2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputtime0.$$.fragment, local);
      transition_in(inputtime1.$$.fragment, local);
      transition_in(inputtime2.$$.fragment, local);
      transition_in(inputtime3.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputtime0.$$.fragment, local);
      transition_out(inputtime1.$$.fragment, local);
      transition_out(inputtime2.$$.fragment, local);
      transition_out(inputtime3.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p0);
        detach_dev(t3);
        detach_dev(h30);
        detach_dev(t5);
        detach_dev(t6);
        detach_dev(p1);
        detach_dev(t9);
        detach_dev(h31);
        detach_dev(t11);
        detach_dev(t12);
        detach_dev(h32);
        detach_dev(t14);
        detach_dev(t15);
        detach_dev(h33);
        detach_dev(t17);
        detach_dev(t18);
        detach_dev(t19);
      }
      destroy_component(inputtime0, detaching);
      destroy_component(inputtime1, detaching);
      destroy_component(inputtime2, detaching);
      destroy_component(inputtime3, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment71.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance71($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputTime", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "disabled",
      description: "Make the input disabled."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying input."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the input."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the input."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the input."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "placeholder",
      type: "string",
      description: "Assign placeholder to the underlying input."
    },
    {
      name: "required",
      description: "Mark the input as <i>aria-required</i>. The actual validation must be done in the consumer."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "value",
      type: ["string", "number"],
      description: "Initial value of the input."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying input."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered after the value changes and the focus leaves the input."
    },
    {
      name: "on:input",
      type: "function",
      description: "Triggered as soon as the input value changes."
    }
  ];
  const exampleHtml = `
<InputTime label="Email" error="Invalid email" value="00:00" on:change="{onChange}" />

<script>
function onChange (e) {
    console.log('value', e.target.value);
}
&lt;/script>
`;
  let val = "00:00";
  let error1 = "Select midnight please.";
  function onchange5(e) {
    $$invalidate2(1, error1 = e.target.value === "00:00" ? "" : "Select midnight please.");
    console.log(e.target.value);
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_18.warn(`<InputTime> was created with unknown prop '${key}'`);
  });
  function inputtime0_value_binding(value2) {
    val = value2;
    $$invalidate2(0, val);
  }
  $$self2.$capture_state = () => ({
    InputTime: InputTime_default,
    CodeExample: CodeExample_default,
    API: ApiTable_default,
    apiProps,
    exampleHtml,
    val,
    error1,
    onchange: onchange5
  });
  $$self2.$inject_state = ($$props3) => {
    if ("val" in $$props3)
      $$invalidate2(0, val = $$props3.val);
    if ("error1" in $$props3)
      $$invalidate2(1, error1 = $$props3.error1);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [val, error1, apiProps, exampleHtml, onchange5, inputtime0_value_binding];
}
var InputTime_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance71, create_fragment71, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputTime_1",
      options,
      id: create_fragment71.name
    });
  }
};
var InputTime_default2 = InputTime_1;

// docs-src/components/input/input-text/InputText.svelte
var { console: console_19 } = globals;
var file65 = "docs-src/components/input/input-text/InputText.svelte";
function create_fragment72(ctx) {
  let h2;
  let t1;
  let p0;
  let t2;
  let br0;
  let t3;
  let t4;
  let br1;
  let t5;
  let h30;
  let t7;
  let inputtext0;
  let updating_value;
  let t8;
  let p1;
  let t9;
  let t10;
  let t11;
  let h31;
  let t13;
  let inputtext1;
  let t14;
  let h32;
  let t16;
  let inputtext2;
  let t17;
  let br2;
  let t18;
  let inputtext3;
  let t19;
  let h33;
  let t21;
  let inputtext4;
  let t22;
  let codeexample;
  let t23;
  let api;
  let current;
  function inputtext0_value_binding(value2) {
    ctx[7](value2);
  }
  let inputtext0_props = {};
  if (
    /*val*/
    ctx[0] !== void 0
  ) {
    inputtext0_props.value = /*val*/
    ctx[0];
  }
  inputtext0 = new InputText_default({ props: inputtext0_props, $$inline: true });
  binding_callbacks.push(() => bind(inputtext0, "value", inputtext0_value_binding));
  inputtext0.$on(
    "input",
    /*oninput*/
    ctx[6]
  );
  inputtext1 = new InputText_default({
    props: { disabled: true, value: "disabled value" },
    $$inline: true
  });
  inputtext1.$on(
    "input",
    /*oninput*/
    ctx[6]
  );
  inputtext2 = new InputText_default({
    props: {
      label: "Validate on change",
      error: (
        /*error1*/
        ctx[1]
      ),
      value: (
        /*val*/
        ctx[0]
      )
    },
    $$inline: true
  });
  inputtext2.$on(
    "change",
    /*onchange*/
    ctx[5]
  );
  inputtext3 = new InputText_default({
    props: {
      label: "Validate on input",
      info: "This should be avoided in most cases. Validating input as user is typing is a bad UX.",
      required: true,
      error: (
        /*error2*/
        ctx[2]
      ),
      value: (
        /*val*/
        ctx[0]
      )
    },
    $$inline: true
  });
  inputtext3.$on(
    "input",
    /*oninput*/
    ctx[6]
  );
  inputtext4 = new InputText_default({
    props: {
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[4]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[3]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Input";
      t1 = space();
      p0 = element2("p");
      t2 = text("The basic inputs are styled with css.");
      br0 = element2("br");
      t3 = text("\n	Enhanced components provide additional functionality and better DX.");
      t4 = space();
      br1 = element2("br");
      t5 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t7 = space();
      create_component(inputtext0.$$.fragment);
      t8 = space();
      p1 = element2("p");
      t9 = text("Input value: ");
      t10 = text(
        /*val*/
        ctx[0]
      );
      t11 = space();
      h31 = element2("h3");
      h31.textContent = "Disabled";
      t13 = space();
      create_component(inputtext1.$$.fragment);
      t14 = space();
      h32 = element2("h3");
      h32.textContent = "With validation";
      t16 = space();
      create_component(inputtext2.$$.fragment);
      t17 = space();
      br2 = element2("br");
      t18 = space();
      create_component(inputtext3.$$.fragment);
      t19 = space();
      h33 = element2("h3");
      h33.textContent = "Label on the left";
      t21 = space();
      create_component(inputtext4.$$.fragment);
      t22 = space();
      create_component(codeexample.$$.fragment);
      t23 = space();
      create_component(api.$$.fragment);
      add_location(h2, file65, 0, 0, 0);
      add_location(br0, file65, 3, 38, 58);
      add_location(p0, file65, 2, 0, 16);
      add_location(br1, file65, 7, 0, 138);
      add_location(h30, file65, 9, 0, 144);
      add_location(p1, file65, 11, 0, 214);
      add_location(h31, file65, 13, 0, 241);
      add_location(h32, file65, 17, 0, 328);
      add_location(br2, file65, 24, 0, 453);
      add_location(h33, file65, 35, 0, 661);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p0, anchor);
      append_dev(p0, t2);
      append_dev(p0, br0);
      append_dev(p0, t3);
      insert_dev(target, t4, anchor);
      insert_dev(target, br1, anchor);
      insert_dev(target, t5, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t7, anchor);
      mount_component(inputtext0, target, anchor);
      insert_dev(target, t8, anchor);
      insert_dev(target, p1, anchor);
      append_dev(p1, t9);
      append_dev(p1, t10);
      insert_dev(target, t11, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t13, anchor);
      mount_component(inputtext1, target, anchor);
      insert_dev(target, t14, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t16, anchor);
      mount_component(inputtext2, target, anchor);
      insert_dev(target, t17, anchor);
      insert_dev(target, br2, anchor);
      insert_dev(target, t18, anchor);
      mount_component(inputtext3, target, anchor);
      insert_dev(target, t19, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t21, anchor);
      mount_component(inputtext4, target, anchor);
      insert_dev(target, t22, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t23, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const inputtext0_changes = {};
      if (!updating_value && dirty & /*val*/
      1) {
        updating_value = true;
        inputtext0_changes.value = /*val*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      inputtext0.$set(inputtext0_changes);
      if (!current || dirty & /*val*/
      1)
        set_data_dev(
          t10,
          /*val*/
          ctx2[0]
        );
      const inputtext2_changes = {};
      if (dirty & /*error1*/
      2)
        inputtext2_changes.error = /*error1*/
        ctx2[1];
      if (dirty & /*val*/
      1)
        inputtext2_changes.value = /*val*/
        ctx2[0];
      inputtext2.$set(inputtext2_changes);
      const inputtext3_changes = {};
      if (dirty & /*error2*/
      4)
        inputtext3_changes.error = /*error2*/
        ctx2[2];
      if (dirty & /*val*/
      1)
        inputtext3_changes.value = /*val*/
        ctx2[0];
      inputtext3.$set(inputtext3_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputtext0.$$.fragment, local);
      transition_in(inputtext1.$$.fragment, local);
      transition_in(inputtext2.$$.fragment, local);
      transition_in(inputtext3.$$.fragment, local);
      transition_in(inputtext4.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputtext0.$$.fragment, local);
      transition_out(inputtext1.$$.fragment, local);
      transition_out(inputtext2.$$.fragment, local);
      transition_out(inputtext3.$$.fragment, local);
      transition_out(inputtext4.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p0);
        detach_dev(t4);
        detach_dev(br1);
        detach_dev(t5);
        detach_dev(h30);
        detach_dev(t7);
        detach_dev(t8);
        detach_dev(p1);
        detach_dev(t11);
        detach_dev(h31);
        detach_dev(t13);
        detach_dev(t14);
        detach_dev(h32);
        detach_dev(t16);
        detach_dev(t17);
        detach_dev(br2);
        detach_dev(t18);
        detach_dev(t19);
        detach_dev(h33);
        detach_dev(t21);
        detach_dev(t22);
        detach_dev(t23);
      }
      destroy_component(inputtext0, detaching);
      destroy_component(inputtext1, detaching);
      destroy_component(inputtext2, detaching);
      destroy_component(inputtext3, detaching);
      destroy_component(inputtext4, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment72.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
function validate2(v) {
  if (!v)
    return "This field is required";
  if (!email.test(v))
    return "Invalid email";
  return;
}
function instance72($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InputText", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "disabled",
      description: "Make the input disabled."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying input."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the input."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the input."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the input."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "placeholder",
      type: "string",
      description: "Assign placeholder to the underlying input."
    },
    {
      name: "required",
      description: "Mark the input as <i>aria-required</i>. The actual validation must be done in the consumer."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "value",
      type: ["string", "number"],
      description: "Initial value of the input."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying input."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered after the value changes and the focus leaves the input."
    },
    {
      name: "on:input",
      type: "function",
      description: "Triggered as soon as the input value changes."
    }
  ];
  const exampleHtml = `
<InputText label="Email" error="Invalid email" value="admin" on:change="{onChange}" />

<script>
function onChange (e) {
    console.log('value', e.target.value);
}
&lt;/script>
`;
  let val = "Hi!";
  let error1 = "", error2 = "";
  function onchange5(e) {
    $$invalidate2(1, error1 = validate2(e.target.value));
    console.log(e.target.value);
  }
  function oninput(e) {
    $$invalidate2(2, error2 = validate2(e.target.value));
    console.log(e.target.value);
  }
  oninput({ target: { value: "-" } });
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_19.warn(`<InputText> was created with unknown prop '${key}'`);
  });
  function inputtext0_value_binding(value2) {
    val = value2;
    $$invalidate2(0, val);
  }
  $$self2.$capture_state = () => ({
    InputText: InputText_default,
    CodeExample: CodeExample_default,
    API: ApiTable_default,
    apiProps,
    exampleHtml,
    val,
    error1,
    error2,
    email,
    validate: validate2,
    onchange: onchange5,
    oninput
  });
  $$self2.$inject_state = ($$props3) => {
    if ("val" in $$props3)
      $$invalidate2(0, val = $$props3.val);
    if ("error1" in $$props3)
      $$invalidate2(1, error1 = $$props3.error1);
    if ("error2" in $$props3)
      $$invalidate2(2, error2 = $$props3.error2);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    val,
    error1,
    error2,
    apiProps,
    exampleHtml,
    onchange5,
    oninput,
    inputtext0_value_binding
  ];
}
var InputText_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance72, create_fragment72, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputText_1",
      options,
      id: create_fragment72.name
    });
  }
};
var InputText_default2 = InputText_1;

// docs-src/components/input/radio/Radio.svelte
var { console: console_110 } = globals;
var file66 = "docs-src/components/input/radio/Radio.svelte";
function create_fragment73(ctx) {
  let h2;
  let t1;
  let h30;
  let t3;
  let radio0;
  let updating_value;
  let t4;
  let h31;
  let t6;
  let radio1;
  let t7;
  let h32;
  let t9;
  let radio2;
  let t10;
  let h33;
  let t12;
  let radio3;
  let t13;
  let h34;
  let t15;
  let radio4;
  let t16;
  let h35;
  let t18;
  let radio5;
  let t19;
  let h36;
  let t21;
  let radio6;
  let t22;
  let codeexample;
  let t23;
  let api;
  let current;
  function radio0_value_binding(value2) {
    ctx[8](value2);
  }
  let radio0_props = {
    items: (
      /*items1*/
      ctx[4]
    ),
    name: "my-radio1",
    label: "Select option 1"
  };
  if (
    /*val*/
    ctx[0] !== void 0
  ) {
    radio0_props.value = /*val*/
    ctx[0];
  }
  radio0 = new Radio_default({ props: radio0_props, $$inline: true });
  binding_callbacks.push(() => bind(radio0, "value", radio0_value_binding));
  radio0.$on("change", onchange3);
  radio1 = new Radio_default({
    props: {
      items: (
        /*items2*/
        ctx[5]
      ),
      name: "my-radio2",
      label: "Select option 2",
      disabled: true
    },
    $$inline: true
  });
  radio2 = new Radio_default({
    props: {
      items: (
        /*strings*/
        ctx[6]
      ),
      name: "my-radio3",
      label: "Select option 3"
    },
    $$inline: true
  });
  radio2.$on("change", onchange3);
  radio3 = new Radio_default({
    props: {
      items: (
        /*strings*/
        ctx[6]
      ),
      name: "my-radio4",
      label: "Select option 4",
      error: (
        /*error4*/
        ctx[1]
      )
    },
    $$inline: true
  });
  radio3.$on(
    "change",
    /*validate4*/
    ctx[7]
  );
  radio4 = new Radio_default({
    props: {
      items: (
        /*strings*/
        ctx[6]
      ),
      name: "my-radio5",
      label: "Select option 5",
      info: "Here be info message."
    },
    $$inline: true
  });
  radio5 = new Radio_default({
    props: {
      items: (
        /*strings*/
        ctx[6]
      ),
      name: "my-radio6",
      label: "Select option 5",
      error: "Here be error message.",
      info: "Here be info message."
    },
    $$inline: true
  });
  radio6 = new Radio_default({
    props: {
      items: (
        /*strings*/
        ctx[6]
      ),
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[3]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[2]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Radio";
      t1 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t3 = space();
      create_component(radio0.$$.fragment);
      t4 = space();
      h31 = element2("h3");
      h31.textContent = "Disabled";
      t6 = space();
      create_component(radio1.$$.fragment);
      t7 = space();
      h32 = element2("h3");
      h32.textContent = "List of strings as values";
      t9 = space();
      create_component(radio2.$$.fragment);
      t10 = space();
      h33 = element2("h3");
      h33.textContent = "With error and live validation";
      t12 = space();
      create_component(radio3.$$.fragment);
      t13 = space();
      h34 = element2("h3");
      h34.textContent = "With info";
      t15 = space();
      create_component(radio4.$$.fragment);
      t16 = space();
      h35 = element2("h3");
      h35.textContent = "With info and error";
      t18 = space();
      create_component(radio5.$$.fragment);
      t19 = space();
      h36 = element2("h3");
      h36.textContent = "Label on the left";
      t21 = space();
      create_component(radio6.$$.fragment);
      t22 = space();
      create_component(codeexample.$$.fragment);
      t23 = space();
      create_component(api.$$.fragment);
      add_location(h2, file66, 0, 0, 0);
      add_location(h30, file66, 2, 0, 16);
      add_location(h31, file66, 5, 0, 143);
      add_location(h32, file66, 8, 0, 239);
      add_location(h33, file66, 11, 0, 367);
      add_location(h34, file66, 14, 0, 518);
      add_location(h35, file66, 17, 0, 636);
      add_location(h36, file66, 26, 0, 801);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t3, anchor);
      mount_component(radio0, target, anchor);
      insert_dev(target, t4, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t6, anchor);
      mount_component(radio1, target, anchor);
      insert_dev(target, t7, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t9, anchor);
      mount_component(radio2, target, anchor);
      insert_dev(target, t10, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t12, anchor);
      mount_component(radio3, target, anchor);
      insert_dev(target, t13, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t15, anchor);
      mount_component(radio4, target, anchor);
      insert_dev(target, t16, anchor);
      insert_dev(target, h35, anchor);
      insert_dev(target, t18, anchor);
      mount_component(radio5, target, anchor);
      insert_dev(target, t19, anchor);
      insert_dev(target, h36, anchor);
      insert_dev(target, t21, anchor);
      mount_component(radio6, target, anchor);
      insert_dev(target, t22, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t23, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const radio0_changes = {};
      if (!updating_value && dirty & /*val*/
      1) {
        updating_value = true;
        radio0_changes.value = /*val*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      radio0.$set(radio0_changes);
      const radio3_changes = {};
      if (dirty & /*error4*/
      2)
        radio3_changes.error = /*error4*/
        ctx2[1];
      radio3.$set(radio3_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(radio0.$$.fragment, local);
      transition_in(radio1.$$.fragment, local);
      transition_in(radio2.$$.fragment, local);
      transition_in(radio3.$$.fragment, local);
      transition_in(radio4.$$.fragment, local);
      transition_in(radio5.$$.fragment, local);
      transition_in(radio6.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(radio0.$$.fragment, local);
      transition_out(radio1.$$.fragment, local);
      transition_out(radio2.$$.fragment, local);
      transition_out(radio3.$$.fragment, local);
      transition_out(radio4.$$.fragment, local);
      transition_out(radio5.$$.fragment, local);
      transition_out(radio6.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(h30);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(h31);
        detach_dev(t6);
        detach_dev(t7);
        detach_dev(h32);
        detach_dev(t9);
        detach_dev(t10);
        detach_dev(h33);
        detach_dev(t12);
        detach_dev(t13);
        detach_dev(h34);
        detach_dev(t15);
        detach_dev(t16);
        detach_dev(h35);
        detach_dev(t18);
        detach_dev(t19);
        detach_dev(h36);
        detach_dev(t21);
        detach_dev(t22);
        detach_dev(t23);
      }
      destroy_component(radio0, detaching);
      destroy_component(radio1, detaching);
      destroy_component(radio2, detaching);
      destroy_component(radio3, detaching);
      destroy_component(radio4, detaching);
      destroy_component(radio5, detaching);
      destroy_component(radio6, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment73.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function onchange3(e) {
  const { item, value: value2 } = e.detail;
  console.log(item, value2);
}
function instance73($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Radio", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "disabled",
      description: "Make all radio buttons disabled."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the whole component."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the inputs."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the inputs."
    },
    {
      name: "items",
      type: "array",
      required: true,
      description: "An array of strings or objects in the following format: <code>&lbrace; name: string, value: string | number, id?: string | number, disabled?: boolean &rbrace;</code>(if <i>id</i> is present - it should be unique)."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the whole component."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to whole component."
    },
    {
      name: "value",
      type: ["string", "number"],
      description: "Value of the component (=value of the checked item)."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered when the value changes."
    }
  ];
  const exampleHtml = `
<Radio {items} name="my-radio" bind:value="{value}" label="Select option" />


<script>
const items = [
	{ name: 'One', value: 1, disabled: true },
	{ name: 'Two', value: 2 },
	{ name: 'Three', value: 3 },
	{ name: 'Four', value: 4 },
];

function onChange (e) {
    console.log('value', e.target.value);
}
&lt;/script>
`;
  const items1 = [
    { name: "One", value: 1, disabled: true },
    { name: "Two", value: 2 },
    { name: "Three", value: 3 },
    { name: "Four", value: 4 }
  ];
  let val = items1[1].value;
  const items2 = ["One", "Two", "Three", "Four"];
  const strings = ["One", "Two", "Three", "Four"];
  let error4 = 'You must select "Four"!';
  function validate4(e) {
    const { value: value2 } = e.detail;
    $$invalidate2(1, error4 = value2 === strings[3] ? "" : 'You must select "Four"!');
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_110.warn(`<Radio> was created with unknown prop '${key}'`);
  });
  function radio0_value_binding(value2) {
    val = value2;
    $$invalidate2(0, val);
  }
  $$self2.$capture_state = () => ({
    Radio: Radio_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    exampleHtml,
    items1,
    val,
    items2,
    strings,
    onchange: onchange3,
    error4,
    validate4
  });
  $$self2.$inject_state = ($$props3) => {
    if ("val" in $$props3)
      $$invalidate2(0, val = $$props3.val);
    if ("error4" in $$props3)
      $$invalidate2(1, error4 = $$props3.error4);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    val,
    error4,
    apiProps,
    exampleHtml,
    items1,
    items2,
    strings,
    validate4,
    radio0_value_binding
  ];
}
var Radio_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance73, create_fragment73, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Radio_1",
      options,
      id: create_fragment73.name
    });
  }
};
var Radio_default2 = Radio_1;

// docs-src/components/input/range/Range.svelte
var file67 = "docs-src/components/input/range/Range.svelte";
function create_fragment74(ctx) {
  let h2;
  let t1;
  let p;
  let t3;
  let h30;
  let t5;
  let range0;
  let t6;
  let h31;
  let t8;
  let range1;
  let t9;
  let h32;
  let t11;
  let range2;
  let t12;
  let h33;
  let t14;
  let range3;
  let t15;
  let h34;
  let t17;
  let range4;
  let t18;
  let h35;
  let t20;
  let range5;
  let t21;
  let h36;
  let t23;
  let range6;
  let t24;
  let h37;
  let t26;
  let range7;
  let t27;
  let h38;
  let t29;
  let range8;
  let t30;
  let codeexample;
  let t31;
  let api;
  let current;
  range0 = new Range_default({ $$inline: true });
  range1 = new Range_default({
    props: { disabled: true },
    $$inline: true
  });
  range2 = new Range_default({
    props: { hideTicks: true },
    $$inline: true
  });
  range3 = new Range_default({
    props: { min: "10", max: "100", step: "5" },
    $$inline: true
  });
  range4 = new Range_default({
    props: { label: "Slide to the right" },
    $$inline: true
  });
  range5 = new Range_default({
    props: {
      label: "Write some text",
      info: "This is some info for you"
    },
    $$inline: true
  });
  range6 = new Range_default({
    props: {
      label: "Move the slider",
      error: (
        /*error*/
        ctx[0]
      ),
      value: "5"
    },
    $$inline: true
  });
  range6.$on(
    "change",
    /*onChange*/
    ctx[3]
  );
  range7 = new Range_default({
    props: {
      label: "Move the slider",
      info: "Don't make any mistakes!",
      error: "You did not slide!"
    },
    $$inline: true
  });
  range8 = new Range_default({
    props: {
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[2]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[1]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Range";
      t1 = space();
      p = element2("p");
      p.textContent = "A wrapper around the native range input.";
      t3 = space();
      h30 = element2("h3");
      h30.textContent = "Default";
      t5 = space();
      create_component(range0.$$.fragment);
      t6 = space();
      h31 = element2("h3");
      h31.textContent = "Disabled";
      t8 = space();
      create_component(range1.$$.fragment);
      t9 = space();
      h32 = element2("h3");
      h32.textContent = "With ticks hidden";
      t11 = space();
      create_component(range2.$$.fragment);
      t12 = space();
      h33 = element2("h3");
      h33.textContent = "With different constraints";
      t14 = space();
      create_component(range3.$$.fragment);
      t15 = space();
      h34 = element2("h3");
      h34.textContent = "With label";
      t17 = space();
      create_component(range4.$$.fragment);
      t18 = space();
      h35 = element2("h3");
      h35.textContent = "With label and info text";
      t20 = space();
      create_component(range5.$$.fragment);
      t21 = space();
      h36 = element2("h3");
      h36.textContent = "With label and error and live validation";
      t23 = space();
      create_component(range6.$$.fragment);
      t24 = space();
      h37 = element2("h3");
      h37.textContent = "With label, info, and error";
      t26 = space();
      create_component(range7.$$.fragment);
      t27 = space();
      h38 = element2("h3");
      h38.textContent = "Label on the left";
      t29 = space();
      create_component(range8.$$.fragment);
      t30 = space();
      create_component(codeexample.$$.fragment);
      t31 = space();
      create_component(api.$$.fragment);
      add_location(h2, file67, 0, 0, 0);
      add_location(p, file67, 1, 0, 15);
      add_location(h30, file67, 3, 0, 64);
      add_location(h31, file67, 6, 0, 92);
      add_location(h32, file67, 9, 0, 130);
      add_location(h33, file67, 12, 0, 178);
      add_location(h34, file67, 15, 0, 253);
      add_location(h35, file67, 18, 0, 311);
      add_location(h36, file67, 21, 0, 413);
      add_location(h37, file67, 24, 0, 539);
      add_location(h38, file67, 27, 0, 670);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t5, anchor);
      mount_component(range0, target, anchor);
      insert_dev(target, t6, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t8, anchor);
      mount_component(range1, target, anchor);
      insert_dev(target, t9, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t11, anchor);
      mount_component(range2, target, anchor);
      insert_dev(target, t12, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t14, anchor);
      mount_component(range3, target, anchor);
      insert_dev(target, t15, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t17, anchor);
      mount_component(range4, target, anchor);
      insert_dev(target, t18, anchor);
      insert_dev(target, h35, anchor);
      insert_dev(target, t20, anchor);
      mount_component(range5, target, anchor);
      insert_dev(target, t21, anchor);
      insert_dev(target, h36, anchor);
      insert_dev(target, t23, anchor);
      mount_component(range6, target, anchor);
      insert_dev(target, t24, anchor);
      insert_dev(target, h37, anchor);
      insert_dev(target, t26, anchor);
      mount_component(range7, target, anchor);
      insert_dev(target, t27, anchor);
      insert_dev(target, h38, anchor);
      insert_dev(target, t29, anchor);
      mount_component(range8, target, anchor);
      insert_dev(target, t30, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t31, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const range6_changes = {};
      if (dirty & /*error*/
      1)
        range6_changes.error = /*error*/
        ctx2[0];
      range6.$set(range6_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(range0.$$.fragment, local);
      transition_in(range1.$$.fragment, local);
      transition_in(range2.$$.fragment, local);
      transition_in(range3.$$.fragment, local);
      transition_in(range4.$$.fragment, local);
      transition_in(range5.$$.fragment, local);
      transition_in(range6.$$.fragment, local);
      transition_in(range7.$$.fragment, local);
      transition_in(range8.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(range0.$$.fragment, local);
      transition_out(range1.$$.fragment, local);
      transition_out(range2.$$.fragment, local);
      transition_out(range3.$$.fragment, local);
      transition_out(range4.$$.fragment, local);
      transition_out(range5.$$.fragment, local);
      transition_out(range6.$$.fragment, local);
      transition_out(range7.$$.fragment, local);
      transition_out(range8.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p);
        detach_dev(t3);
        detach_dev(h30);
        detach_dev(t5);
        detach_dev(t6);
        detach_dev(h31);
        detach_dev(t8);
        detach_dev(t9);
        detach_dev(h32);
        detach_dev(t11);
        detach_dev(t12);
        detach_dev(h33);
        detach_dev(t14);
        detach_dev(t15);
        detach_dev(h34);
        detach_dev(t17);
        detach_dev(t18);
        detach_dev(h35);
        detach_dev(t20);
        detach_dev(t21);
        detach_dev(h36);
        detach_dev(t23);
        detach_dev(t24);
        detach_dev(h37);
        detach_dev(t26);
        detach_dev(t27);
        detach_dev(h38);
        detach_dev(t29);
        detach_dev(t30);
        detach_dev(t31);
      }
      destroy_component(range0, detaching);
      destroy_component(range1, detaching);
      destroy_component(range2, detaching);
      destroy_component(range3, detaching);
      destroy_component(range4, detaching);
      destroy_component(range5, detaching);
      destroy_component(range6, detaching);
      destroy_component(range7, detaching);
      destroy_component(range8, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment74.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance74($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Range", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "disabled",
      description: "Make the input disabled."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying input."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the input."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the input."
    },
    {
      name: "hideTicks",
      description: "If present, the ticks will not be shown."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the input."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "max",
      type: ["number"],
      default: "10",
      description: "Max value of the input."
    },
    {
      name: "min",
      type: ["number"],
      default: "0",
      description: "Min value of the input."
    },
    {
      name: "step",
      type: ["number"],
      default: "1",
      description: "Step value of the input."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "value",
      type: "string",
      description: "Initial value of the input."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying input."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered when the value changes."
    },
    {
      name: "on:input",
      type: "function",
      description: "Triggered when input value is edited."
    }
  ];
  const exampleHtml = `
<Range on:change="{onChange}" error="Invalid text" />

<script>
function onChange (e) {
    console.log('value', e.target.value);
}
&lt;/script>
`;
  let error2 = "Move to 6.";
  function onChange2(e) {
    $$invalidate2(0, error2 = e.target.value === "6" ? "" : "Move to 6.");
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Range> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    Range: Range_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    exampleHtml,
    error: error2,
    onChange: onChange2
  });
  $$self2.$inject_state = ($$props3) => {
    if ("error" in $$props3)
      $$invalidate2(0, error2 = $$props3.error);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [error2, apiProps, exampleHtml, onChange2];
}
var Range_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance74, create_fragment74, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Range_1",
      options,
      id: create_fragment74.name
    });
  }
};
var Range_default2 = Range_1;

// docs-src/components/input/select/Select.svelte
var file68 = "docs-src/components/input/select/Select.svelte";
function create_fragment75(ctx) {
  let h2;
  let t1;
  let p;
  let t2;
  let br0;
  let t3;
  let br1;
  let t4;
  let t5;
  let h30;
  let t7;
  let select0;
  let t8;
  let h31;
  let t10;
  let select1;
  let t11;
  let h32;
  let t13;
  let select2;
  let t14;
  let h33;
  let t16;
  let select3;
  let updating_value;
  let t17;
  let t18;
  let t19;
  let h34;
  let t20;
  let em;
  let t22;
  let select4;
  let updating_value_1;
  let t23;
  let t24;
  let t25;
  let h35;
  let t27;
  let select5;
  let t28;
  let h36;
  let t30;
  let select6;
  let t31;
  let h37;
  let t33;
  let select7;
  let t34;
  let h38;
  let t36;
  let select8;
  let t37;
  let codeexample;
  let t38;
  let api;
  let current;
  select0 = new Select_default({
    props: {
      placeholder: "None",
      items: (
        /*selectItems*/
        ctx[3]
      )
    },
    $$inline: true
  });
  select1 = new Select_default({
    props: {
      items: [{ name: "Disabled" }],
      disabled: true
    },
    $$inline: true
  });
  select2 = new Select_default({
    props: {
      placeholder: "Select something",
      items: []
    },
    $$inline: true
  });
  function select3_value_binding(value2) {
    ctx[5](value2);
  }
  let select3_props = {
    placeholder: "Empty",
    items: (
      /*selectItems*/
      ctx[3]
    )
  };
  if (
    /*val*/
    ctx[0] !== void 0
  ) {
    select3_props.value = /*val*/
    ctx[0];
  }
  select3 = new Select_default({ props: select3_props, $$inline: true });
  binding_callbacks.push(() => bind(select3, "value", select3_value_binding));
  function select4_value_binding(value2) {
    ctx[6](value2);
  }
  let select4_props = {
    placeholder: "Please select...",
    items: (
      /*stringItems*/
      ctx[4]
    )
  };
  if (
    /*val*/
    ctx[0] !== void 0
  ) {
    select4_props.value = /*val*/
    ctx[0];
  }
  select4 = new Select_default({ props: select4_props, $$inline: true });
  binding_callbacks.push(() => bind(select4, "value", select4_value_binding));
  select5 = new Select_default({
    props: {
      items: (
        /*selectItems*/
        ctx[3]
      ),
      label: "Select label"
    },
    $$inline: true
  });
  select6 = new Select_default({
    props: {
      items: (
        /*selectItems*/
        ctx[3]
      ),
      label: "Select label",
      info: "Select something here"
    },
    $$inline: true
  });
  select7 = new Select_default({
    props: {
      items: (
        /*selectItems*/
        ctx[3]
      ),
      label: "Select label",
      error: "You picked the wrong side!"
    },
    $$inline: true
  });
  select8 = new Select_default({
    props: {
      items: (
        /*selectItems*/
        ctx[3]
      ),
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[2]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[1]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Select";
      t1 = space();
      p = element2("p");
      t2 = text("Select component is based on the native HTML select control.");
      br0 = element2("br");
      t3 = text("\n	It provides some visual styling and also better data management,");
      br1 = element2("br");
      t4 = text("\n	i.e. it accepts an array of strings or objects.");
      t5 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t7 = space();
      create_component(select0.$$.fragment);
      t8 = space();
      h31 = element2("h3");
      h31.textContent = "Disabled";
      t10 = space();
      create_component(select1.$$.fragment);
      t11 = space();
      h32 = element2("h3");
      h32.textContent = "With placeholder";
      t13 = space();
      create_component(select2.$$.fragment);
      t14 = space();
      h33 = element2("h3");
      h33.textContent = "With initial value";
      t16 = space();
      create_component(select3.$$.fragment);
      t17 = text(" Selected value: ");
      t18 = text(
        /*val*/
        ctx[0]
      );
      t19 = space();
      h34 = element2("h3");
      t20 = text("With array of strings for ");
      em = element2("em");
      em.textContent = "items";
      t22 = space();
      create_component(select4.$$.fragment);
      t23 = text(" Selected value: ");
      t24 = text(
        /*val*/
        ctx[0]
      );
      t25 = space();
      h35 = element2("h3");
      h35.textContent = "Label";
      t27 = space();
      create_component(select5.$$.fragment);
      t28 = space();
      h36 = element2("h3");
      h36.textContent = "Info";
      t30 = space();
      create_component(select6.$$.fragment);
      t31 = space();
      h37 = element2("h3");
      h37.textContent = "Error";
      t33 = space();
      create_component(select7.$$.fragment);
      t34 = space();
      h38 = element2("h3");
      h38.textContent = "Label on the left";
      t36 = space();
      create_component(select8.$$.fragment);
      t37 = space();
      create_component(codeexample.$$.fragment);
      t38 = space();
      create_component(api.$$.fragment);
      add_location(h2, file68, 0, 0, 0);
      add_location(br0, file68, 1, 63, 79);
      add_location(br1, file68, 2, 65, 149);
      add_location(p, file68, 1, 0, 16);
      add_location(h30, file68, 6, 0, 209);
      add_location(h31, file68, 9, 0, 277);
      add_location(h32, file68, 12, 0, 348);
      add_location(h33, file68, 15, 0, 430);
      add_location(em, file68, 18, 30, 582);
      add_location(h34, file68, 18, 0, 552);
      add_location(h35, file68, 22, 0, 708);
      add_location(h36, file68, 25, 0, 778);
      add_location(h37, file68, 28, 0, 876);
      add_location(h38, file68, 31, 0, 981);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p, anchor);
      append_dev(p, t2);
      append_dev(p, br0);
      append_dev(p, t3);
      append_dev(p, br1);
      append_dev(p, t4);
      insert_dev(target, t5, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t7, anchor);
      mount_component(select0, target, anchor);
      insert_dev(target, t8, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t10, anchor);
      mount_component(select1, target, anchor);
      insert_dev(target, t11, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t13, anchor);
      mount_component(select2, target, anchor);
      insert_dev(target, t14, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t16, anchor);
      mount_component(select3, target, anchor);
      insert_dev(target, t17, anchor);
      insert_dev(target, t18, anchor);
      insert_dev(target, t19, anchor);
      insert_dev(target, h34, anchor);
      append_dev(h34, t20);
      append_dev(h34, em);
      insert_dev(target, t22, anchor);
      mount_component(select4, target, anchor);
      insert_dev(target, t23, anchor);
      insert_dev(target, t24, anchor);
      insert_dev(target, t25, anchor);
      insert_dev(target, h35, anchor);
      insert_dev(target, t27, anchor);
      mount_component(select5, target, anchor);
      insert_dev(target, t28, anchor);
      insert_dev(target, h36, anchor);
      insert_dev(target, t30, anchor);
      mount_component(select6, target, anchor);
      insert_dev(target, t31, anchor);
      insert_dev(target, h37, anchor);
      insert_dev(target, t33, anchor);
      mount_component(select7, target, anchor);
      insert_dev(target, t34, anchor);
      insert_dev(target, h38, anchor);
      insert_dev(target, t36, anchor);
      mount_component(select8, target, anchor);
      insert_dev(target, t37, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t38, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const select3_changes = {};
      if (!updating_value && dirty & /*val*/
      1) {
        updating_value = true;
        select3_changes.value = /*val*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      select3.$set(select3_changes);
      if (!current || dirty & /*val*/
      1)
        set_data_dev(
          t18,
          /*val*/
          ctx2[0]
        );
      const select4_changes = {};
      if (!updating_value_1 && dirty & /*val*/
      1) {
        updating_value_1 = true;
        select4_changes.value = /*val*/
        ctx2[0];
        add_flush_callback(() => updating_value_1 = false);
      }
      select4.$set(select4_changes);
      if (!current || dirty & /*val*/
      1)
        set_data_dev(
          t24,
          /*val*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(select0.$$.fragment, local);
      transition_in(select1.$$.fragment, local);
      transition_in(select2.$$.fragment, local);
      transition_in(select3.$$.fragment, local);
      transition_in(select4.$$.fragment, local);
      transition_in(select5.$$.fragment, local);
      transition_in(select6.$$.fragment, local);
      transition_in(select7.$$.fragment, local);
      transition_in(select8.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select0.$$.fragment, local);
      transition_out(select1.$$.fragment, local);
      transition_out(select2.$$.fragment, local);
      transition_out(select3.$$.fragment, local);
      transition_out(select4.$$.fragment, local);
      transition_out(select5.$$.fragment, local);
      transition_out(select6.$$.fragment, local);
      transition_out(select7.$$.fragment, local);
      transition_out(select8.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p);
        detach_dev(t5);
        detach_dev(h30);
        detach_dev(t7);
        detach_dev(t8);
        detach_dev(h31);
        detach_dev(t10);
        detach_dev(t11);
        detach_dev(h32);
        detach_dev(t13);
        detach_dev(t14);
        detach_dev(h33);
        detach_dev(t16);
        detach_dev(t17);
        detach_dev(t18);
        detach_dev(t19);
        detach_dev(h34);
        detach_dev(t22);
        detach_dev(t23);
        detach_dev(t24);
        detach_dev(t25);
        detach_dev(h35);
        detach_dev(t27);
        detach_dev(t28);
        detach_dev(h36);
        detach_dev(t30);
        detach_dev(t31);
        detach_dev(h37);
        detach_dev(t33);
        detach_dev(t34);
        detach_dev(h38);
        detach_dev(t36);
        detach_dev(t37);
        detach_dev(t38);
      }
      destroy_component(select0, detaching);
      destroy_component(select1, detaching);
      destroy_component(select2, detaching);
      destroy_component(select3, detaching);
      destroy_component(select4, detaching);
      destroy_component(select5, detaching);
      destroy_component(select6, detaching);
      destroy_component(select7, detaching);
      destroy_component(select8, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment75.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance75($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Select", slots2, []);
  let val = "Beta";
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "disabled",
      description: "Make the select disabled."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying select."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the select."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the select."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the select."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "items",
      type: "array",
      required: true,
      description: "An array of strings or objects in the following format: <code>&lbrace; name: string, id?: string | number, group?: string &rbrace;</code>(<i>name</i> should be unique, or - if <i>id</i> is present - <i>id</i> should be unique)."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying select."
    },
    {
      name: "placeholder",
      type: "string",
      description: "Adds an item to the beginning of the options list."
    },
    {
      name: "required",
      description: "Mark the select as <i>aria-required</i>."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying select."
    },
    {
      name: "value",
      type: ["string", "number"],
      description: "Initial value of the select.<br>If the list is an array of strings - it would match the item,<br>if the list is an array of objects - it should match the id of the item. "
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying select."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered when the value changes."
    }
  ];
  const exampleHtml = `
<Select items="{items}" on:change="{onChange}" />

<script>
const items = [
	{ id: '1', name: 'Alpha', group: 'Group 1' },
	{ id: '2', name: 'Beta', group: 'Group 1' },
	{ id: '3', name: 'Gamma', group: 'Group 1' },
];
function onChange (e) {
	const { value, oldValue } = e.detail;
	console.log({ value, oldValue });
}
&lt;/script>
`;
  const selectItems = [
    {
      id: "Alpha",
      name: "Alpha",
      group: "Group 1"
    },
    {
      id: "Beta",
      name: "Beta",
      group: "Group 1"
    },
    {
      id: "Gamma",
      name: "Gamma",
      group: "Group 1"
    },
    {
      id: "Delta",
      name: "Delta",
      group: "Group 1"
    },
    { id: "Epsilon", name: "Epsilon" },
    { id: "Zeta", name: "Zeta" },
    { id: "Eta", name: "Eta", group: "Group 2" },
    {
      id: "Theta",
      name: "Theta",
      group: "Group 2"
    },
    {
      id: "Iota",
      name: "Iota",
      group: "Group 2"
    },
    {
      id: "Kappa",
      name: "Kappa",
      group: "Group 2"
    },
    {
      id: "Lambda",
      name: "Lambda",
      group: "Group 2"
    },
    {
      id: "long-one",
      name: "A very long text",
      group: "Group 2"
    },
    { id: "Eta", name: "Eta", group: "Group 3" },
    {
      id: "Theta",
      name: "Theta",
      group: "Group 3"
    },
    {
      id: "Iota",
      name: "Iota",
      group: "Group 3"
    },
    {
      id: "Kappa",
      name: "Kappa",
      group: "Group 3"
    },
    {
      id: "Lambda",
      name: "Lambda",
      group: "Group 3"
    },
    {
      id: "long-one",
      name: "A very long text",
      group: "Group 3"
    },
    { id: "Eta", name: "Eta", group: "Group 4" },
    {
      id: "Theta",
      name: "Theta",
      group: "Group 4"
    },
    {
      id: "Iota",
      name: "Iota",
      group: "Group 4"
    },
    {
      id: "Kappa",
      name: "Kappa",
      group: "Group 4"
    },
    {
      id: "Lambda",
      name: "Lambda",
      group: "Group 4"
    },
    {
      id: "long-one",
      name: "A very long text",
      group: "Group 4"
    }
  ];
  const stringItems = ["Alpha", "Beta", "Gamma", "Delta"];
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Select> was created with unknown prop '${key}'`);
  });
  function select3_value_binding(value2) {
    val = value2;
    $$invalidate2(0, val);
  }
  function select4_value_binding(value2) {
    val = value2;
    $$invalidate2(0, val);
  }
  $$self2.$capture_state = () => ({
    Select: Select_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    val,
    apiProps,
    exampleHtml,
    selectItems,
    stringItems
  });
  $$self2.$inject_state = ($$props3) => {
    if ("val" in $$props3)
      $$invalidate2(0, val = $$props3.val);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    val,
    apiProps,
    exampleHtml,
    selectItems,
    stringItems,
    select3_value_binding,
    select4_value_binding
  ];
}
var Select_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance75, create_fragment75, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select_1",
      options,
      id: create_fragment75.name
    });
  }
};
var Select_default2 = Select_1;

// docs-src/components/input/textarea/Textarea.svelte
var file69 = "docs-src/components/input/textarea/Textarea.svelte";
function create_fragment76(ctx) {
  let h2;
  let t1;
  let h30;
  let t3;
  let textarea0;
  let t4;
  let h31;
  let t6;
  let textarea1;
  let t7;
  let h32;
  let t9;
  let textarea2;
  let t10;
  let h33;
  let t12;
  let textarea3;
  let t13;
  let h34;
  let t15;
  let textarea4;
  let t16;
  let h35;
  let t18;
  let textarea5;
  let t19;
  let h36;
  let t21;
  let textarea6;
  let t22;
  let h37;
  let t24;
  let textarea7;
  let t25;
  let codeexample;
  let t26;
  let api;
  let current;
  textarea0 = new Textarea_default({
    props: { label: "Write some text" },
    $$inline: true
  });
  textarea1 = new Textarea_default({
    props: { label: "Write some text", disabled: true },
    $$inline: true
  });
  textarea2 = new Textarea_default({
    props: {
      label: "Write some text",
      placeholder: "Add some text"
    },
    $$inline: true
  });
  textarea3 = new Textarea_default({
    props: { label: "Write some text", autogrow: true },
    $$inline: true
  });
  textarea4 = new Textarea_default({
    props: {
      label: "Write some text",
      info: "This is some extra info for you"
    },
    $$inline: true
  });
  textarea5 = new Textarea_default({
    props: {
      label: "Write some text",
      error: (
        /*error*/
        ctx[0]
      )
    },
    $$inline: true
  });
  textarea5.$on(
    "input",
    /*oninput*/
    ctx[3]
  );
  textarea6 = new Textarea_default({
    props: {
      label: "Write some text",
      info: "Don't make any mistakes!",
      error: "You have a typo somewhere in here",
      autogrow: true
    },
    $$inline: true
  });
  textarea7 = new Textarea_default({
    props: {
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[2]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[1]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Textarea";
      t1 = space();
      h30 = element2("h3");
      h30.textContent = "Default";
      t3 = space();
      create_component(textarea0.$$.fragment);
      t4 = space();
      h31 = element2("h3");
      h31.textContent = "Disabled";
      t6 = space();
      create_component(textarea1.$$.fragment);
      t7 = space();
      h32 = element2("h3");
      h32.textContent = "Placeholder";
      t9 = space();
      create_component(textarea2.$$.fragment);
      t10 = space();
      h33 = element2("h3");
      h33.textContent = "Autogrow";
      t12 = space();
      create_component(textarea3.$$.fragment);
      t13 = space();
      h34 = element2("h3");
      h34.textContent = "With info text";
      t15 = space();
      create_component(textarea4.$$.fragment);
      t16 = space();
      h35 = element2("h3");
      h35.textContent = "With error and live validation";
      t18 = space();
      create_component(textarea5.$$.fragment);
      t19 = space();
      h36 = element2("h3");
      h36.textContent = "With info, error and autogrow";
      t21 = space();
      create_component(textarea6.$$.fragment);
      t22 = space();
      h37 = element2("h3");
      h37.textContent = "Label on the left";
      t24 = space();
      create_component(textarea7.$$.fragment);
      t25 = space();
      create_component(codeexample.$$.fragment);
      t26 = space();
      create_component(api.$$.fragment);
      add_location(h2, file69, 0, 0, 0);
      add_location(h30, file69, 2, 0, 19);
      add_location(h31, file69, 5, 0, 83);
      add_location(h32, file69, 8, 0, 157);
      add_location(h33, file69, 12, 0, 254);
      add_location(h34, file69, 16, 0, 329);
      add_location(h35, file69, 19, 0, 439);
      add_location(h36, file69, 22, 0, 555);
      add_location(h37, file69, 25, 0, 724);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t3, anchor);
      mount_component(textarea0, target, anchor);
      insert_dev(target, t4, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t6, anchor);
      mount_component(textarea1, target, anchor);
      insert_dev(target, t7, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t9, anchor);
      mount_component(textarea2, target, anchor);
      insert_dev(target, t10, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t12, anchor);
      mount_component(textarea3, target, anchor);
      insert_dev(target, t13, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t15, anchor);
      mount_component(textarea4, target, anchor);
      insert_dev(target, t16, anchor);
      insert_dev(target, h35, anchor);
      insert_dev(target, t18, anchor);
      mount_component(textarea5, target, anchor);
      insert_dev(target, t19, anchor);
      insert_dev(target, h36, anchor);
      insert_dev(target, t21, anchor);
      mount_component(textarea6, target, anchor);
      insert_dev(target, t22, anchor);
      insert_dev(target, h37, anchor);
      insert_dev(target, t24, anchor);
      mount_component(textarea7, target, anchor);
      insert_dev(target, t25, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t26, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const textarea5_changes = {};
      if (dirty & /*error*/
      1)
        textarea5_changes.error = /*error*/
        ctx2[0];
      textarea5.$set(textarea5_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textarea0.$$.fragment, local);
      transition_in(textarea1.$$.fragment, local);
      transition_in(textarea2.$$.fragment, local);
      transition_in(textarea3.$$.fragment, local);
      transition_in(textarea4.$$.fragment, local);
      transition_in(textarea5.$$.fragment, local);
      transition_in(textarea6.$$.fragment, local);
      transition_in(textarea7.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textarea0.$$.fragment, local);
      transition_out(textarea1.$$.fragment, local);
      transition_out(textarea2.$$.fragment, local);
      transition_out(textarea3.$$.fragment, local);
      transition_out(textarea4.$$.fragment, local);
      transition_out(textarea5.$$.fragment, local);
      transition_out(textarea6.$$.fragment, local);
      transition_out(textarea7.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(h30);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(h31);
        detach_dev(t6);
        detach_dev(t7);
        detach_dev(h32);
        detach_dev(t9);
        detach_dev(t10);
        detach_dev(h33);
        detach_dev(t12);
        detach_dev(t13);
        detach_dev(h34);
        detach_dev(t15);
        detach_dev(t16);
        detach_dev(h35);
        detach_dev(t18);
        detach_dev(t19);
        detach_dev(h36);
        detach_dev(t21);
        detach_dev(t22);
        detach_dev(h37);
        detach_dev(t24);
        detach_dev(t25);
        detach_dev(t26);
      }
      destroy_component(textarea0, detaching);
      destroy_component(textarea1, detaching);
      destroy_component(textarea2, detaching);
      destroy_component(textarea3, detaching);
      destroy_component(textarea4, detaching);
      destroy_component(textarea5, detaching);
      destroy_component(textarea6, detaching);
      destroy_component(textarea7, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment76.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance76($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Textarea", slots2, []);
  const apiProps = [
    {
      name: "autogrow",
      description: "If present - the textarea will grow in height to match the text and avoid scrollbar."
    },
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "disabled",
      description: "Make the textarea disabled."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying textarea."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the textarea."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the textarea."
    },
    {
      name: "name",
      type: "string",
      description: "Assign title to the underlying textarea."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the textarea."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "placeholder",
      type: "string",
      description: "Assign placeholder to the underlying textarea."
    },
    {
      name: "required",
      description: "Mark the textarea as <i>aria-required</i>."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying textarea."
    },
    {
      name: "value",
      type: "string",
      description: "Initial value of the textarea."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying input."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered when the value changes."
    },
    {
      name: "on:input",
      type: "function",
      description: "Triggered when textarea value is edited."
    }
  ];
  const exampleHtml = `
<Textarea autogrow on:change="{onChange}" error="Invalid text" />

<script>
function onChange (e) {
    console.log('value', e.target.value);
}
&lt;/script>
`;
  let error2 = 'Enter "hello" to pass.';
  function oninput(e) {
    $$invalidate2(0, error2 = e.target.value === "hello" ? "" : 'Enter "hello" to pass.');
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Textarea> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    Textarea: Textarea_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    exampleHtml,
    error: error2,
    oninput
  });
  $$self2.$inject_state = ($$props3) => {
    if ("error" in $$props3)
      $$invalidate2(0, error2 = $$props3.error);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [error2, apiProps, exampleHtml, oninput];
}
var Textarea_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance76, create_fragment76, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Textarea_1",
      options,
      id: create_fragment76.name
    });
  }
};
var Textarea_default2 = Textarea_1;

// docs-src/components/input/toggle/Toggle.svelte
var { console: console_111 } = globals;
var file70 = "docs-src/components/input/toggle/Toggle.svelte";
function create_fragment77(ctx) {
  let h2;
  let t1;
  let ul;
  let li0;
  let t2;
  let em0;
  let t4;
  let em1;
  let t6;
  let li1;
  let t7;
  let em2;
  let t9;
  let em3;
  let t11;
  let li2;
  let li3;
  let t14;
  let hr;
  let t15;
  let h30;
  let t17;
  let toggle0;
  let updating_value;
  let t18;
  let t19;
  let t20;
  let div;
  let toggle1;
  let t21;
  let br0;
  let t22;
  let toggle2;
  let t23;
  let t24;
  let br1;
  let br2;
  let br3;
  let t25;
  let h31;
  let t27;
  let toggle3;
  let t28;
  let h32;
  let t30;
  let toggle4;
  let t31;
  let h33;
  let t33;
  let toggle5;
  let t34;
  let h34;
  let t36;
  let toggle6;
  let t37;
  let h35;
  let t39;
  let toggle7;
  let t40;
  let codeexample;
  let t41;
  let api;
  let current;
  function toggle0_value_binding(value2) {
    ctx[5](value2);
  }
  let toggle0_props = {};
  if (
    /*toggleValue*/
    ctx[1] !== void 0
  ) {
    toggle0_props.value = /*toggleValue*/
    ctx[1];
  }
  toggle0 = new Toggle_default({ props: toggle0_props, $$inline: true });
  binding_callbacks.push(() => bind(toggle0, "value", toggle0_value_binding));
  toggle1 = new Toggle_default({ $$inline: true });
  toggle2 = new Toggle_default({ props: { value: "true" }, $$inline: true });
  toggle3 = new Toggle_default({
    props: { value: true, disabled: true },
    $$inline: true
  });
  toggle4 = new Toggle_default({
    props: { label: "Toggle the lights" },
    $$inline: true
  });
  toggle5 = new Toggle_default({
    props: {
      label: "Toggle the lights",
      info: "This toggle switches the bathroom lights on/off"
    },
    $$inline: true
  });
  toggle6 = new Toggle_default({
    props: {
      label: "Toggle the lights",
      error: (
        /*error*/
        ctx[0]
      )
    },
    $$inline: true
  });
  toggle6.$on(
    "change",
    /*onchange*/
    ctx[4]
  );
  toggle7 = new Toggle_default({
    props: {
      label: "Label is on the left",
      labelOnTheLeft: "true"
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[3]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[2]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Toggle";
      t1 = text("\n\nThe perfect toggle component in Svelte:\n");
      ul = element2("ul");
      li0 = element2("li");
      t2 = text("allows ");
      em0 = element2("em");
      em0.textContent = "click";
      t4 = text(" as well as ");
      em1 = element2("em");
      em1.textContent = "drag";
      t6 = text(" to toggle\n	");
      li1 = element2("li");
      t7 = text("keyboard support: press ");
      em2 = element2("em");
      em2.textContent = "Enter";
      t9 = text(" or ");
      em3 = element2("em");
      em3.textContent = "Space";
      t11 = text(" to toggle\n	");
      li2 = element2("li");
      li2.textContent = "accessible (based on a checkbox input)\n	";
      li3 = element2("li");
      li3.textContent = "no bloat, no dependencies";
      t14 = space();
      hr = element2("hr");
      t15 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t17 = space();
      create_component(toggle0.$$.fragment);
      t18 = space();
      t19 = text(
        /*toggleValue*/
        ctx[1]
      );
      t20 = space();
      div = element2("div");
      create_component(toggle1.$$.fragment);
      t21 = text(" hidden initially");
      br0 = element2("br");
      t22 = space();
      create_component(toggle2.$$.fragment);
      t23 = text(" hidden initially");
      t24 = space();
      br1 = element2("br");
      br2 = element2("br");
      br3 = element2("br");
      t25 = space();
      h31 = element2("h3");
      h31.textContent = "Disabled";
      t27 = space();
      create_component(toggle3.$$.fragment);
      t28 = text(" (disabled)\n\n\n");
      h32 = element2("h3");
      h32.textContent = "Label";
      t30 = space();
      create_component(toggle4.$$.fragment);
      t31 = space();
      h33 = element2("h3");
      h33.textContent = "Info";
      t33 = space();
      create_component(toggle5.$$.fragment);
      t34 = space();
      h34 = element2("h3");
      h34.textContent = "Error";
      t36 = space();
      create_component(toggle6.$$.fragment);
      t37 = space();
      h35 = element2("h3");
      h35.textContent = "Label on the left";
      t39 = space();
      create_component(toggle7.$$.fragment);
      t40 = space();
      create_component(codeexample.$$.fragment);
      t41 = space();
      create_component(api.$$.fragment);
      add_location(h2, file70, 0, 0, 0);
      add_location(em0, file70, 4, 12, 74);
      add_location(em1, file70, 4, 38, 100);
      add_location(li0, file70, 4, 1, 63);
      add_location(em2, file70, 5, 29, 153);
      add_location(em3, file70, 5, 47, 171);
      add_location(li1, file70, 5, 1, 125);
      add_location(li2, file70, 6, 1, 197);
      add_location(li3, file70, 7, 1, 241);
      add_location(ul, file70, 3, 0, 57);
      add_location(hr, file70, 10, 0, 278);
      add_location(h30, file70, 12, 0, 284);
      add_location(br0, file70, 15, 28, 435);
      attr_dev(div, "class", "toggle-box");
      toggle_class(
        div,
        "visible",
        /*toggleValue*/
        ctx[1]
      );
      add_location(div, file70, 14, 0, 352);
      add_location(br1, file70, 18, 0, 488);
      add_location(br2, file70, 18, 4, 492);
      add_location(br3, file70, 18, 8, 496);
      add_location(h31, file70, 20, 0, 502);
      add_location(h32, file70, 24, 0, 568);
      add_location(h33, file70, 27, 0, 621);
      add_location(h34, file70, 30, 0, 728);
      add_location(h35, file70, 33, 0, 819);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, ul, anchor);
      append_dev(ul, li0);
      append_dev(li0, t2);
      append_dev(li0, em0);
      append_dev(li0, t4);
      append_dev(li0, em1);
      append_dev(li0, t6);
      append_dev(ul, li1);
      append_dev(li1, t7);
      append_dev(li1, em2);
      append_dev(li1, t9);
      append_dev(li1, em3);
      append_dev(li1, t11);
      append_dev(ul, li2);
      append_dev(ul, li3);
      insert_dev(target, t14, anchor);
      insert_dev(target, hr, anchor);
      insert_dev(target, t15, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t17, anchor);
      mount_component(toggle0, target, anchor);
      insert_dev(target, t18, anchor);
      insert_dev(target, t19, anchor);
      insert_dev(target, t20, anchor);
      insert_dev(target, div, anchor);
      mount_component(toggle1, div, null);
      append_dev(div, t21);
      append_dev(div, br0);
      append_dev(div, t22);
      mount_component(toggle2, div, null);
      append_dev(div, t23);
      insert_dev(target, t24, anchor);
      insert_dev(target, br1, anchor);
      insert_dev(target, br2, anchor);
      insert_dev(target, br3, anchor);
      insert_dev(target, t25, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t27, anchor);
      mount_component(toggle3, target, anchor);
      insert_dev(target, t28, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t30, anchor);
      mount_component(toggle4, target, anchor);
      insert_dev(target, t31, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t33, anchor);
      mount_component(toggle5, target, anchor);
      insert_dev(target, t34, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t36, anchor);
      mount_component(toggle6, target, anchor);
      insert_dev(target, t37, anchor);
      insert_dev(target, h35, anchor);
      insert_dev(target, t39, anchor);
      mount_component(toggle7, target, anchor);
      insert_dev(target, t40, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t41, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const toggle0_changes = {};
      if (!updating_value && dirty & /*toggleValue*/
      2) {
        updating_value = true;
        toggle0_changes.value = /*toggleValue*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      toggle0.$set(toggle0_changes);
      if (!current || dirty & /*toggleValue*/
      2)
        set_data_dev(
          t19,
          /*toggleValue*/
          ctx2[1]
        );
      if (!current || dirty & /*toggleValue*/
      2) {
        toggle_class(
          div,
          "visible",
          /*toggleValue*/
          ctx2[1]
        );
      }
      const toggle6_changes = {};
      if (dirty & /*error*/
      1)
        toggle6_changes.error = /*error*/
        ctx2[0];
      toggle6.$set(toggle6_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toggle0.$$.fragment, local);
      transition_in(toggle1.$$.fragment, local);
      transition_in(toggle2.$$.fragment, local);
      transition_in(toggle3.$$.fragment, local);
      transition_in(toggle4.$$.fragment, local);
      transition_in(toggle5.$$.fragment, local);
      transition_in(toggle6.$$.fragment, local);
      transition_in(toggle7.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toggle0.$$.fragment, local);
      transition_out(toggle1.$$.fragment, local);
      transition_out(toggle2.$$.fragment, local);
      transition_out(toggle3.$$.fragment, local);
      transition_out(toggle4.$$.fragment, local);
      transition_out(toggle5.$$.fragment, local);
      transition_out(toggle6.$$.fragment, local);
      transition_out(toggle7.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(ul);
        detach_dev(t14);
        detach_dev(hr);
        detach_dev(t15);
        detach_dev(h30);
        detach_dev(t17);
        detach_dev(t18);
        detach_dev(t19);
        detach_dev(t20);
        detach_dev(div);
        detach_dev(t24);
        detach_dev(br1);
        detach_dev(br2);
        detach_dev(br3);
        detach_dev(t25);
        detach_dev(h31);
        detach_dev(t27);
        detach_dev(t28);
        detach_dev(h32);
        detach_dev(t30);
        detach_dev(t31);
        detach_dev(h33);
        detach_dev(t33);
        detach_dev(t34);
        detach_dev(h34);
        detach_dev(t36);
        detach_dev(t37);
        detach_dev(h35);
        detach_dev(t39);
        detach_dev(t40);
        detach_dev(t41);
      }
      destroy_component(toggle0, detaching);
      destroy_component(toggle1);
      destroy_component(toggle2);
      destroy_component(toggle3, detaching);
      destroy_component(toggle4, detaching);
      destroy_component(toggle5, detaching);
      destroy_component(toggle6, detaching);
      destroy_component(toggle7, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment77.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance77($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Toggle", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "disabled",
      description: "Make the input disabled."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying input (if not set, a random string will be assigned)."
    },
    {
      name: "info",
      type: "string",
      description: "Show info message above the toggle."
    },
    {
      name: "error",
      type: "string",
      description: "Error message to show above the toggle."
    },
    {
      name: "name",
      type: "string",
      description: "Assign name to the underlying input."
    },
    {
      name: "label",
      type: "string",
      description: "Label for the input."
    },
    {
      name: "labelOnTheLeft",
      type: ["true", "false"],
      default: "false",
      description: "Put label to the left of the input (instead of at the top). Usually in longer forms, to align labels and inputs, hence input also gets <em>width: 100%</em>, as it will be constraint by the form container."
    },
    {
      name: "required",
      description: "Mark the input as <i>aria-required</i>."
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying input."
    },
    {
      name: "value",
      type: ["true", "false"],
      description: "Initial value of the toggle."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:inputElement",
      type: "element",
      description: "Exposes the HTML element of the underlying input."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered when the value changes."
    }
  ];
  const exampleHtml = `
<Toggle value="true" label="Field label" on:change="{onChange}" />

<script>
function onChange (e) {
    console.log('onchange', e.detail);
}
&lt;/script>
`;
  let error2 = "I can't see anything now!";
  let toggleValue = false;
  function onchange5(e) {
    const val = e.detail;
    $$invalidate2(0, error2 = val ? "" : "I can't see anything now!");
    console.log("onchange", e.detail);
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_111.warn(`<Toggle> was created with unknown prop '${key}'`);
  });
  function toggle0_value_binding(value2) {
    toggleValue = value2;
    $$invalidate2(1, toggleValue);
  }
  $$self2.$capture_state = () => ({
    Toggle: Toggle_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    exampleHtml,
    error: error2,
    toggleValue,
    onchange: onchange5
  });
  $$self2.$inject_state = ($$props3) => {
    if ("error" in $$props3)
      $$invalidate2(0, error2 = $$props3.error);
    if ("toggleValue" in $$props3)
      $$invalidate2(1, toggleValue = $$props3.toggleValue);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [error2, toggleValue, apiProps, exampleHtml, onchange5, toggle0_value_binding];
}
var Toggle_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance77, create_fragment77, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toggle_1",
      options,
      id: create_fragment77.name
    });
  }
};
var Toggle_default2 = Toggle_1;

// docs-src/components/info-bar/InfoBar.svelte
var { Error: Error_13 } = globals;
var file71 = "docs-src/components/info-bar/InfoBar.svelte";
function create_fragment78(ctx) {
  let h2;
  let t1;
  let p0;
  let t3;
  let p1;
  let t4;
  let em0;
  let t6;
  let em1;
  let t8;
  let em2;
  let t10;
  let em3;
  let t12;
  let t13;
  let br;
  let t14;
  let h30;
  let t16;
  let infobar;
  let t17;
  let h31;
  let t19;
  let info2;
  let t20;
  let warning;
  let t21;
  let error2;
  let t22;
  let success;
  let t23;
  let codeexample;
  let t24;
  let api;
  let current;
  infobar = new InfoBar_default({
    props: {
      id: "msg001",
      msg: "This is a comprehensive explanation of a thing.",
      type: "info"
    },
    $$inline: true
  });
  info2 = new Info_default({
    props: { msg: "Some info text" },
    $$inline: true
  });
  warning = new Warning_default({
    props: { msg: "Some warning text" },
    $$inline: true
  });
  error2 = new Error_default({
    props: { msg: "Some error text" },
    $$inline: true
  });
  success = new Success_default({
    props: { msg: "Some success text" },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[1]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "InfoBar";
      t1 = space();
      p0 = element2("p");
      p0.textContent = "A simple information box with type-styling.";
      t3 = space();
      p1 = element2("p");
      t4 = text("There are also shortcut-components available, for more semantic HTML:\n	");
      em0 = element2("em");
      em0.textContent = "Info";
      t6 = text(", ");
      em1 = element2("em");
      em1.textContent = "Warning";
      t8 = text(", ");
      em2 = element2("em");
      em2.textContent = "Error";
      t10 = text(", and ");
      em3 = element2("em");
      em3.textContent = "Success";
      t12 = text(".");
      t13 = space();
      br = element2("br");
      t14 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t16 = space();
      create_component(infobar.$$.fragment);
      t17 = space();
      h31 = element2("h3");
      h31.textContent = "Using shortcuts";
      t19 = space();
      create_component(info2.$$.fragment);
      t20 = space();
      create_component(warning.$$.fragment);
      t21 = space();
      create_component(error2.$$.fragment);
      t22 = space();
      create_component(success.$$.fragment);
      t23 = space();
      create_component(codeexample.$$.fragment);
      t24 = space();
      create_component(api.$$.fragment);
      add_location(h2, file71, 0, 0, 0);
      add_location(p0, file71, 2, 0, 18);
      add_location(em0, file71, 4, 1, 143);
      add_location(em1, file71, 4, 16, 158);
      add_location(em2, file71, 4, 34, 176);
      add_location(em3, file71, 4, 54, 196);
      add_location(p1, file71, 3, 0, 69);
      add_location(br, file71, 6, 0, 219);
      add_location(h30, file71, 8, 0, 225);
      add_location(h31, file71, 12, 0, 333);
    },
    l: function claim(nodes) {
      throw new Error_13("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p0, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, p1, anchor);
      append_dev(p1, t4);
      append_dev(p1, em0);
      append_dev(p1, t6);
      append_dev(p1, em1);
      append_dev(p1, t8);
      append_dev(p1, em2);
      append_dev(p1, t10);
      append_dev(p1, em3);
      append_dev(p1, t12);
      insert_dev(target, t13, anchor);
      insert_dev(target, br, anchor);
      insert_dev(target, t14, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t16, anchor);
      mount_component(infobar, target, anchor);
      insert_dev(target, t17, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t19, anchor);
      mount_component(info2, target, anchor);
      insert_dev(target, t20, anchor);
      mount_component(warning, target, anchor);
      insert_dev(target, t21, anchor);
      mount_component(error2, target, anchor);
      insert_dev(target, t22, anchor);
      mount_component(success, target, anchor);
      insert_dev(target, t23, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t24, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(infobar.$$.fragment, local);
      transition_in(info2.$$.fragment, local);
      transition_in(warning.$$.fragment, local);
      transition_in(error2.$$.fragment, local);
      transition_in(success.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(infobar.$$.fragment, local);
      transition_out(info2.$$.fragment, local);
      transition_out(warning.$$.fragment, local);
      transition_out(error2.$$.fragment, local);
      transition_out(success.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p0);
        detach_dev(t3);
        detach_dev(p1);
        detach_dev(t13);
        detach_dev(br);
        detach_dev(t14);
        detach_dev(h30);
        detach_dev(t16);
        detach_dev(t17);
        detach_dev(h31);
        detach_dev(t19);
        detach_dev(t20);
        detach_dev(t21);
        detach_dev(t22);
        detach_dev(t23);
        detach_dev(t24);
      }
      destroy_component(infobar, detaching);
      destroy_component(info2, detaching);
      destroy_component(warning, detaching);
      destroy_component(error2, detaching);
      destroy_component(success, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment78.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance78($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("InfoBar", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the message paragraph."
    },
    {
      name: "msg",
      type: "string",
      description: "Message to display. It can use simple html for formatting (message is wrapped in <em>&lt;p&gt;</em> tag)."
    },
    {
      name: "type",
      type: ["info", "warning", "error", "success"],
      default: "info",
      description: "Type of the info-bar. This property only exists on the <em>&lt;InfoBar&gt;</em> component, not on the shortcut-components."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    }
  ];
  const exampleHtml = `
<InfoBar id="msg001" msg="This is a comprehensive explanation of a thing." type="info" />

<!-- Using shortcuts -->
<Info msg="Some info text" />
<Warning msg="Some warning text" />
<Error msg="Some error text" />
<Success msg="Some success text" />
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InfoBar> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    InfoBar: InfoBar_default,
    Info: Info_default,
    Error: Error_default,
    Success: Success_default,
    Warning: Warning_default,
    CodeExample: CodeExample_default,
    API: ApiTable_default,
    apiProps,
    exampleHtml
  });
  return [apiProps, exampleHtml];
}
var InfoBar_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance78, create_fragment78, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InfoBar_1",
      options,
      id: create_fragment78.name
    });
  }
};
var InfoBar_default2 = InfoBar_1;

// docs-src/components/notification-center/NotificationCenter.svelte
var { console: console_112 } = globals;
var file72 = "docs-src/components/notification-center/NotificationCenter.svelte";
function create_default_slot_73(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show info");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_73.name,
    type: "slot",
    source: `(31:1) <Button info on:click=\\"{() => showNotification('Hello')}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_63(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show success");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_63.name,
    type: "slot",
    source: `(32:1) <Button success on:click=\\"{() => showNotification('Hello', 'success')}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_53(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show warning");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_53.name,
    type: "slot",
    source: `(33:1) <Button warning on:click=\\"{() => showNotification('Hello', 'warning')}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_46(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show error for 10s");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_46.name,
    type: "slot",
    source: `(34:1) <Button danger on:click=\\"{() => showNotification('Hello', 'error', 10000, 'Undo', cb)}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_311(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("A very long message");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_311.name,
    type: "slot",
    source: `(39:1) <Button info on:click=\\"{() => showNotification('This is a very long message in a toast, to show how the long text will wrap inside the toast message.', 'info', false)}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_211(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show success");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_211.name,
    type: "slot",
    source: `(40:1) <Button success on:click=\\"{() => showNotification('Hello', 'success', false)}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_114(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show warning");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_114.name,
    type: "slot",
    source: `(41:1) <Button warning on:click=\\"{() => showNotification('Hello', 'warning', false)}\\">`,
    ctx
  });
  return block;
}
function create_default_slot10(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show error");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: `(42:1) <Button danger on:click=\\"{() => showNotification('Hello', 'error', false)}\\">`,
    ctx
  });
  return block;
}
function create_fragment79(ctx) {
  let h2;
  let t1;
  let p0;
  let t2;
  let b0;
  let t4;
  let b1;
  let t6;
  let t7;
  let p1;
  let t8;
  let br0;
  let t9;
  let em;
  let t11;
  let b2;
  let t13;
  let b3;
  let t15;
  let t16;
  let p2;
  let t17;
  let b4;
  let t19;
  let br1;
  let t20;
  let t21;
  let p3;
  let t22;
  let b5;
  let t24;
  let t25;
  let hr;
  let t26;
  let h30;
  let t28;
  let div0;
  let label0;
  let t30;
  let notificationcenter;
  let t31;
  let div1;
  let label1;
  let t33;
  let toggle;
  let updating_value;
  let t34;
  let h31;
  let t36;
  let div2;
  let button0;
  let t37;
  let button1;
  let t38;
  let button2;
  let t39;
  let button3;
  let t40;
  let h32;
  let t42;
  let div3;
  let button4;
  let t43;
  let button5;
  let t44;
  let button6;
  let t45;
  let button7;
  let t46;
  let codeexample;
  let t47;
  let api0;
  let t48;
  let api1;
  let t49;
  let api2;
  let current;
  notificationcenter = new NotificationCenter_default({
    props: {
      outline: true,
      round: true,
      hideButton: (
        /*hideButton*/
        ctx[0]
      )
    },
    $$inline: true
  });
  function toggle_value_binding(value2) {
    ctx[6](value2);
  }
  let toggle_props = { id: "button-toggle" };
  if (
    /*hideButton*/
    ctx[0] !== void 0
  ) {
    toggle_props.value = /*hideButton*/
    ctx[0];
  }
  toggle = new Toggle_default({ props: toggle_props, $$inline: true });
  binding_callbacks.push(() => bind(toggle, "value", toggle_value_binding));
  button0 = new Button_default({
    props: {
      info: true,
      $$slots: { default: [create_default_slot_73] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button0.$on(
    "click",
    /*click_handler*/
    ctx[7]
  );
  button1 = new Button_default({
    props: {
      success: true,
      $$slots: { default: [create_default_slot_63] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1.$on(
    "click",
    /*click_handler_1*/
    ctx[8]
  );
  button2 = new Button_default({
    props: {
      warning: true,
      $$slots: { default: [create_default_slot_53] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button2.$on(
    "click",
    /*click_handler_2*/
    ctx[9]
  );
  button3 = new Button_default({
    props: {
      danger: true,
      $$slots: { default: [create_default_slot_46] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button3.$on(
    "click",
    /*click_handler_3*/
    ctx[10]
  );
  button4 = new Button_default({
    props: {
      info: true,
      $$slots: { default: [create_default_slot_311] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button4.$on(
    "click",
    /*click_handler_4*/
    ctx[11]
  );
  button5 = new Button_default({
    props: {
      success: true,
      $$slots: { default: [create_default_slot_211] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button5.$on(
    "click",
    /*click_handler_5*/
    ctx[12]
  );
  button6 = new Button_default({
    props: {
      warning: true,
      $$slots: { default: [create_default_slot_114] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button6.$on(
    "click",
    /*click_handler_6*/
    ctx[13]
  );
  button7 = new Button_default({
    props: {
      danger: true,
      $$slots: { default: [create_default_slot10] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button7.$on(
    "click",
    /*click_handler_7*/
    ctx[14]
  );
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[4]
    ) },
    $$inline: true
  });
  api0 = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[1]
    ) },
    $$inline: true
  });
  api1 = new ApiTable_default({
    props: {
      props: (
        /*showNotificationAPI*/
        ctx[2]
      ),
      title: "showNotification function",
      description: "A component exports a global <em>showNotification</em> function with the following arguments:"
    },
    $$inline: true
  });
  api2 = new ApiTable_default({
    props: {
      props: (
        /*hideNotificationAPI*/
        ctx[3]
      ),
      title: "hideNotification function",
      description: "A component exports a global <em>hideNotification</em> function with the following arguments:"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Notification Center";
      t1 = space();
      p0 = element2("p");
      t2 = text("With the aim of improving accessibility and usability, the ");
      b0 = element2("b");
      b0.textContent = "Toaster";
      t4 = text(" component has been redesigned into a ");
      b1 = element2("b");
      b1.textContent = "NotificationCenter";
      t6 = text(".");
      t7 = space();
      p1 = element2("p");
      t8 = text('This component renders a bell button that shows a list of "archived" notifications when clicked.');
      br0 = element2("br");
      t9 = text("\nButton can be hidden using the ");
      em = element2("em");
      em.textContent = 'hideButton="true"';
      t11 = text(" property, in which case the ");
      b2 = element2("b");
      b2.textContent = "NotificationCenter";
      t13 = text(" will work as a regular ");
      b3 = element2("b");
      b3.textContent = "Toaster";
      t15 = text(" component.");
      t16 = space();
      p2 = element2("p");
      t17 = text(`A notification first shows normally on screen, then, when it's dismissed or auto-closed, it's moved to the "archive" and available in the `);
      b4 = element2("b");
      b4.textContent = "NotificationCenter";
      t19 = text(".");
      br1 = element2("br");
      t20 = text("\nNotifications remain in the archive as long as the user remains on the page. When the user navigates away from the page, or reloads it, the archive is cleared.");
      t21 = space();
      p3 = element2("p");
      t22 = text("The goal of the ");
      b5 = element2("b");
      b5.textContent = "NotificationCenter";
      t24 = text(" is to allow the user to read the notifications that they may have missed.");
      t25 = space();
      hr = element2("hr");
      t26 = space();
      h30 = element2("h3");
      h30.textContent = "Notification button";
      t28 = space();
      div0 = element2("div");
      label0 = element2("label");
      label0.textContent = "Toggle notification center:";
      t30 = space();
      create_component(notificationcenter.$$.fragment);
      t31 = space();
      div1 = element2("div");
      label1 = element2("label");
      label1.textContent = "Hide button:";
      t33 = space();
      create_component(toggle.$$.fragment);
      t34 = space();
      h31 = element2("h3");
      h31.textContent = "Notifications";
      t36 = space();
      div2 = element2("div");
      create_component(button0.$$.fragment);
      t37 = space();
      create_component(button1.$$.fragment);
      t38 = space();
      create_component(button2.$$.fragment);
      t39 = space();
      create_component(button3.$$.fragment);
      t40 = space();
      h32 = element2("h3");
      h32.textContent = "No auto-close";
      t42 = space();
      div3 = element2("div");
      create_component(button4.$$.fragment);
      t43 = space();
      create_component(button5.$$.fragment);
      t44 = space();
      create_component(button6.$$.fragment);
      t45 = space();
      create_component(button7.$$.fragment);
      t46 = space();
      create_component(codeexample.$$.fragment);
      t47 = space();
      create_component(api0.$$.fragment);
      t48 = space();
      create_component(api1.$$.fragment);
      t49 = space();
      create_component(api2.$$.fragment);
      add_location(h2, file72, 0, 0, 0);
      add_location(b0, file72, 2, 62, 92);
      add_location(b1, file72, 2, 114, 144);
      add_location(p0, file72, 2, 0, 30);
      add_location(br0, file72, 4, 99, 275);
      add_location(em, file72, 5, 31, 311);
      add_location(b2, file72, 5, 86, 366);
      add_location(b3, file72, 5, 135, 415);
      add_location(p1, file72, 4, 0, 176);
      add_location(b4, file72, 7, 141, 587);
      add_location(br1, file72, 7, 167, 613);
      add_location(p2, file72, 7, 0, 446);
      add_location(b5, file72, 10, 19, 802);
      add_location(p3, file72, 10, 0, 783);
      add_location(hr, file72, 12, 0, 907);
      add_location(h30, file72, 14, 0, 913);
      add_location(label0, file72, 18, 1, 1025);
      attr_dev(div0, "class", "prop-row");
      add_location(div0, file72, 16, 0, 943);
      attr_dev(label1, "for", "button-toggle");
      add_location(label1, file72, 22, 1, 1151);
      attr_dev(div1, "class", "prop-row");
      add_location(div1, file72, 21, 0, 1127);
      add_location(h31, file72, 28, 0, 1267);
      attr_dev(div2, "class", "docs-buttons-row");
      add_location(div2, file72, 29, 0, 1290);
      add_location(h32, file72, 36, 0, 1714);
      attr_dev(div3, "class", "docs-buttons-row");
      add_location(div3, file72, 37, 0, 1737);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p0, anchor);
      append_dev(p0, t2);
      append_dev(p0, b0);
      append_dev(p0, t4);
      append_dev(p0, b1);
      append_dev(p0, t6);
      insert_dev(target, t7, anchor);
      insert_dev(target, p1, anchor);
      append_dev(p1, t8);
      append_dev(p1, br0);
      append_dev(p1, t9);
      append_dev(p1, em);
      append_dev(p1, t11);
      append_dev(p1, b2);
      append_dev(p1, t13);
      append_dev(p1, b3);
      append_dev(p1, t15);
      insert_dev(target, t16, anchor);
      insert_dev(target, p2, anchor);
      append_dev(p2, t17);
      append_dev(p2, b4);
      append_dev(p2, t19);
      append_dev(p2, br1);
      append_dev(p2, t20);
      insert_dev(target, t21, anchor);
      insert_dev(target, p3, anchor);
      append_dev(p3, t22);
      append_dev(p3, b5);
      append_dev(p3, t24);
      insert_dev(target, t25, anchor);
      insert_dev(target, hr, anchor);
      insert_dev(target, t26, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t28, anchor);
      insert_dev(target, div0, anchor);
      append_dev(div0, label0);
      append_dev(div0, t30);
      mount_component(notificationcenter, div0, null);
      insert_dev(target, t31, anchor);
      insert_dev(target, div1, anchor);
      append_dev(div1, label1);
      append_dev(div1, t33);
      mount_component(toggle, div1, null);
      insert_dev(target, t34, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t36, anchor);
      insert_dev(target, div2, anchor);
      mount_component(button0, div2, null);
      append_dev(div2, t37);
      mount_component(button1, div2, null);
      append_dev(div2, t38);
      mount_component(button2, div2, null);
      append_dev(div2, t39);
      mount_component(button3, div2, null);
      insert_dev(target, t40, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t42, anchor);
      insert_dev(target, div3, anchor);
      mount_component(button4, div3, null);
      append_dev(div3, t43);
      mount_component(button5, div3, null);
      append_dev(div3, t44);
      mount_component(button6, div3, null);
      append_dev(div3, t45);
      mount_component(button7, div3, null);
      insert_dev(target, t46, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t47, anchor);
      mount_component(api0, target, anchor);
      insert_dev(target, t48, anchor);
      mount_component(api1, target, anchor);
      insert_dev(target, t49, anchor);
      mount_component(api2, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const notificationcenter_changes = {};
      if (dirty & /*hideButton*/
      1)
        notificationcenter_changes.hideButton = /*hideButton*/
        ctx2[0];
      notificationcenter.$set(notificationcenter_changes);
      const toggle_changes = {};
      if (!updating_value && dirty & /*hideButton*/
      1) {
        updating_value = true;
        toggle_changes.value = /*hideButton*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      toggle.$set(toggle_changes);
      const button0_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      const button3_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button3.$set(button3_changes);
      const button4_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button4.$set(button4_changes);
      const button5_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button5.$set(button5_changes);
      const button6_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button6.$set(button6_changes);
      const button7_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button7.$set(button7_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(notificationcenter.$$.fragment, local);
      transition_in(toggle.$$.fragment, local);
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      transition_in(button4.$$.fragment, local);
      transition_in(button5.$$.fragment, local);
      transition_in(button6.$$.fragment, local);
      transition_in(button7.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api0.$$.fragment, local);
      transition_in(api1.$$.fragment, local);
      transition_in(api2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(notificationcenter.$$.fragment, local);
      transition_out(toggle.$$.fragment, local);
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      transition_out(button4.$$.fragment, local);
      transition_out(button5.$$.fragment, local);
      transition_out(button6.$$.fragment, local);
      transition_out(button7.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api0.$$.fragment, local);
      transition_out(api1.$$.fragment, local);
      transition_out(api2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p0);
        detach_dev(t7);
        detach_dev(p1);
        detach_dev(t16);
        detach_dev(p2);
        detach_dev(t21);
        detach_dev(p3);
        detach_dev(t25);
        detach_dev(hr);
        detach_dev(t26);
        detach_dev(h30);
        detach_dev(t28);
        detach_dev(div0);
        detach_dev(t31);
        detach_dev(div1);
        detach_dev(t34);
        detach_dev(h31);
        detach_dev(t36);
        detach_dev(div2);
        detach_dev(t40);
        detach_dev(h32);
        detach_dev(t42);
        detach_dev(div3);
        detach_dev(t46);
        detach_dev(t47);
        detach_dev(t48);
        detach_dev(t49);
      }
      destroy_component(notificationcenter);
      destroy_component(toggle);
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
      destroy_component(button3);
      destroy_component(button4);
      destroy_component(button5);
      destroy_component(button6);
      destroy_component(button7);
      destroy_component(codeexample, detaching);
      destroy_component(api0, detaching);
      destroy_component(api1, detaching);
      destroy_component(api2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment79.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance79($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("NotificationCenter", slots2, []);
  let hideButton = false;
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "hideButton",
      type: ["true", "false"],
      default: "false",
      description: "If <i>true</i> the button will be hidden."
    },
    {
      name: "outline",
      description: "Notification center button style: outline"
    },
    {
      name: "round",
      description: "Makes the notification center button round"
    }
  ];
  const showNotificationAPI = [
    {
      name: "1. message",
      type: "string",
      required: true,
      description: "Message to show."
    },
    {
      name: "2. type",
      type: ["info", "success", "warning", "error"],
      default: "info",
      description: "Type of the message."
    },
    {
      name: "3. timeout",
      type: ["number", "false"],
      default: 5e3,
      description: 'How long the toast should remain on screen (in milliseconds).<br>If the value is not a number (e.g. "false") - the toast will not auto-close.'
    },
    {
      name: "4. button",
      type: "string",
      description: "Label of the optional button on the toast."
    },
    {
      name: "5. callback",
      type: "function",
      description: "Callback function triggered when the button is clicked.<br>The function receives 1 parameter, which is the ID of the toast."
    }
  ];
  const hideNotificationAPI = [
    {
      name: "id",
      type: "string",
      description: "ID of the toast message that is returned by <em>showNotification</em> function."
    }
  ];
  const exampleHtml = `
<NotificationCenter outline round/>

<Button on:click="{() => showNotification('Hello')}">Show info</Button>
<Button success on:click="{() => showNotification('Hello', 'success')}">Show success</Button>
<Button warning on:click="{() => showNotification('Hello', 'warning')}">Show warning</Button>
<Button danger on:click="{() => showNotification('Hello', 'error', 10000, 'Undo', cb)}">Show error</Button>
<Button danger on:click="{() => showNotification('Hello', 'error', false)}">No auto-close</Button>

<script>
import { NotificationCenter, showNotification, hideNotification, Button } from '@perfectthings/ui';

function cb (id) {
	console.log('do something');
	hideNotification(id);
}
&lt;/script>
`;
  function cb(id2) {
    console.log(id2);
    hideNotification(id2);
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_112.warn(`<NotificationCenter> was created with unknown prop '${key}'`);
  });
  function toggle_value_binding(value2) {
    hideButton = value2;
    $$invalidate2(0, hideButton);
  }
  const click_handler = () => showNotification("Hello");
  const click_handler_1 = () => showNotification("Hello", "success");
  const click_handler_2 = () => showNotification("Hello", "warning");
  const click_handler_3 = () => showNotification("Hello", "error", 1e4, "Undo", cb);
  const click_handler_4 = () => showNotification("This is a very long message in a toast, to show how the long text will wrap inside the toast message.", "info", false);
  const click_handler_5 = () => showNotification("Hello", "success", false);
  const click_handler_6 = () => showNotification("Hello", "warning", false);
  const click_handler_7 = () => showNotification("Hello", "error", false);
  $$self2.$capture_state = () => ({
    Button: Button_default,
    NotificationCenter: NotificationCenter_default,
    showNotification,
    hideNotification,
    Toggle: Toggle_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    hideButton,
    apiProps,
    showNotificationAPI,
    hideNotificationAPI,
    exampleHtml,
    cb
  });
  $$self2.$inject_state = ($$props3) => {
    if ("hideButton" in $$props3)
      $$invalidate2(0, hideButton = $$props3.hideButton);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    hideButton,
    apiProps,
    showNotificationAPI,
    hideNotificationAPI,
    exampleHtml,
    cb,
    toggle_value_binding,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6,
    click_handler_7
  ];
}
var NotificationCenter_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance79, create_fragment79, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NotificationCenter_1",
      options,
      id: create_fragment79.name
    });
  }
};
var NotificationCenter_default2 = NotificationCenter_1;

// docs-src/components/message-box/MessageBox.svelte
var { console: console_113 } = globals;
var file73 = "docs-src/components/message-box/MessageBox.svelte";
function create_default_slot_115(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Default message");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_115.name,
    type: "slot",
    source: `(10:1) <Button on:click=\\"{() => showMessage('This is the message')}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_103(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show info");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_103.name,
    type: "slot",
    source: `(11:1) <Button info on:click=\\"{() => showMessage('This is the message', MessageType.INFO)}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_93(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show warning");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_93.name,
    type: "slot",
    source: `(12:1) <Button warning on:click=\\"{() => showMessage('This is the message', MessageType.WARNING)}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_83(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show error");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_83.name,
    type: "slot",
    source: `(13:1) <Button danger on:click=\\"{() => showMessage('This is the message', MessageType.DANGER)}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_74(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show success");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_74.name,
    type: "slot",
    source: `(14:1) <Button success on:click=\\"{() => showMessage('This is the message', MessageType.SUCCESS)}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_64(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show message with title");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_64.name,
    type: "slot",
    source: `(20:1) <Button on:click=\\"{() => showMessage('Default message', null, 'Default title')}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_54(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show message with title");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_54.name,
    type: "slot",
    source: `(21:1) <Button info on:click=\\"{() => showMessage('Info messagebox', MessageType.INFO, 'Info title')}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_47(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show long message");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_47.name,
    type: "slot",
    source: `(22:1) <Button on:click=\\"{() => showMessage(longMessage, null, 'Info title')}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_312(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show long message");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_312.name,
    type: "slot",
    source: `(23:1) <Button info on:click=\\"{() => showMessage(longMessage, MessageType.INFO, 'Info title')}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_213(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show message");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_213.name,
    type: "slot",
    source: `(29:1) <Button on:click=\\"{() => showMessage('Message with <i>html</i><br><a href=\\"#MessageBox\\" target=\\"_blank\\">Link</a>', null, 'Info title', 'Close')}\\">`,
    ctx
  });
  return block;
}
function create_default_slot_116(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show Info with title and button label and callback");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_116.name,
    type: "slot",
    source: `(35:1) <Button on:click=\\"{() => showMessage('Info messagebox', null, 'Info title', 'Close', onclose)}\\">`,
    ctx
  });
  return block;
}
function create_default_slot11(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show complex message");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: '(40:0) <Button info on:click=\\"{showComplex}\\">',
    ctx
  });
  return block;
}
function create_fragment80(ctx) {
  let h2;
  let t1;
  let p;
  let t3;
  let br;
  let t4;
  let h30;
  let t6;
  let div0;
  let button0;
  let t7;
  let button1;
  let t8;
  let button2;
  let t9;
  let button3;
  let t10;
  let button4;
  let t11;
  let h31;
  let t13;
  let div1;
  let button5;
  let t14;
  let button6;
  let t15;
  let button7;
  let t16;
  let button8;
  let t17;
  let h32;
  let t19;
  let div2;
  let button9;
  let t20;
  let h33;
  let t22;
  let div3;
  let button10;
  let t23;
  let h34;
  let t25;
  let button11;
  let t26;
  let messagebox;
  let t27;
  let codeexample;
  let t28;
  let api;
  let current;
  button0 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_115] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button0.$on(
    "click",
    /*click_handler*/
    ctx[3]
  );
  button1 = new Button_default({
    props: {
      info: true,
      $$slots: { default: [create_default_slot_103] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1.$on(
    "click",
    /*click_handler_1*/
    ctx[4]
  );
  button2 = new Button_default({
    props: {
      warning: true,
      $$slots: { default: [create_default_slot_93] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button2.$on(
    "click",
    /*click_handler_2*/
    ctx[5]
  );
  button3 = new Button_default({
    props: {
      danger: true,
      $$slots: { default: [create_default_slot_83] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button3.$on(
    "click",
    /*click_handler_3*/
    ctx[6]
  );
  button4 = new Button_default({
    props: {
      success: true,
      $$slots: { default: [create_default_slot_74] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button4.$on(
    "click",
    /*click_handler_4*/
    ctx[7]
  );
  button5 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_64] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button5.$on(
    "click",
    /*click_handler_5*/
    ctx[8]
  );
  button6 = new Button_default({
    props: {
      info: true,
      $$slots: { default: [create_default_slot_54] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button6.$on(
    "click",
    /*click_handler_6*/
    ctx[9]
  );
  button7 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_47] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button7.$on(
    "click",
    /*click_handler_7*/
    ctx[10]
  );
  button8 = new Button_default({
    props: {
      info: true,
      $$slots: { default: [create_default_slot_312] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button8.$on(
    "click",
    /*click_handler_8*/
    ctx[11]
  );
  button9 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_213] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button9.$on(
    "click",
    /*click_handler_9*/
    ctx[12]
  );
  button10 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_116] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button10.$on(
    "click",
    /*click_handler_10*/
    ctx[13]
  );
  button11 = new Button_default({
    props: {
      info: true,
      $$slots: { default: [create_default_slot11] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button11.$on(
    "click",
    /*showComplex*/
    ctx[0]
  );
  messagebox = new MessageBox_default({ $$inline: true });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[2]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: {
      props: (
        /*apiProps*/
        ctx[1]
      ),
      title: "Function API - arguments",
      description: "A component exports a <em>showMessage</em> function which accepts either\n	a config object or a list of arguments.  If it is a list of arguments - this is the API:"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "MessageBox";
      t1 = space();
      p = element2("p");
      p.textContent = "It uses the Dialog component by adding it to the body once (so it's lightweight)\n	and re-using it for every call";
      t3 = space();
      br = element2("br");
      t4 = space();
      h30 = element2("h3");
      h30.textContent = "Types";
      t6 = space();
      div0 = element2("div");
      create_component(button0.$$.fragment);
      t7 = space();
      create_component(button1.$$.fragment);
      t8 = space();
      create_component(button2.$$.fragment);
      t9 = space();
      create_component(button3.$$.fragment);
      t10 = space();
      create_component(button4.$$.fragment);
      t11 = space();
      h31 = element2("h3");
      h31.textContent = "Title";
      t13 = space();
      div1 = element2("div");
      create_component(button5.$$.fragment);
      t14 = space();
      create_component(button6.$$.fragment);
      t15 = space();
      create_component(button7.$$.fragment);
      t16 = space();
      create_component(button8.$$.fragment);
      t17 = space();
      h32 = element2("h3");
      h32.textContent = "Message with HTML";
      t19 = space();
      div2 = element2("div");
      create_component(button9.$$.fragment);
      t20 = space();
      h33 = element2("h3");
      h33.textContent = "MessageBox with callback action";
      t22 = space();
      div3 = element2("div");
      create_component(button10.$$.fragment);
      t23 = space();
      h34 = element2("h3");
      h34.textContent = "Complex Message";
      t25 = space();
      create_component(button11.$$.fragment);
      t26 = space();
      create_component(messagebox.$$.fragment);
      t27 = space();
      create_component(codeexample.$$.fragment);
      t28 = space();
      create_component(api.$$.fragment);
      add_location(h2, file73, 0, 0, 0);
      add_location(p, file73, 2, 0, 21);
      add_location(br, file73, 5, 0, 142);
      add_location(h30, file73, 7, 0, 148);
      attr_dev(div0, "class", "docs-buttons-row");
      add_location(div0, file73, 8, 0, 163);
      add_location(h31, file73, 17, 0, 734);
      attr_dev(div1, "class", "docs-buttons-row");
      add_location(div1, file73, 18, 0, 749);
      add_location(h32, file73, 26, 0, 1250);
      attr_dev(div2, "class", "docs-buttons-row");
      add_location(div2, file73, 27, 0, 1277);
      add_location(h33, file73, 32, 0, 1486);
      attr_dev(div3, "class", "docs-buttons-row");
      add_location(div3, file73, 33, 0, 1527);
      add_location(h34, file73, 38, 0, 1724);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, br, anchor);
      insert_dev(target, t4, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t6, anchor);
      insert_dev(target, div0, anchor);
      mount_component(button0, div0, null);
      append_dev(div0, t7);
      mount_component(button1, div0, null);
      append_dev(div0, t8);
      mount_component(button2, div0, null);
      append_dev(div0, t9);
      mount_component(button3, div0, null);
      append_dev(div0, t10);
      mount_component(button4, div0, null);
      insert_dev(target, t11, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t13, anchor);
      insert_dev(target, div1, anchor);
      mount_component(button5, div1, null);
      append_dev(div1, t14);
      mount_component(button6, div1, null);
      append_dev(div1, t15);
      mount_component(button7, div1, null);
      append_dev(div1, t16);
      mount_component(button8, div1, null);
      insert_dev(target, t17, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t19, anchor);
      insert_dev(target, div2, anchor);
      mount_component(button9, div2, null);
      insert_dev(target, t20, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t22, anchor);
      insert_dev(target, div3, anchor);
      mount_component(button10, div3, null);
      insert_dev(target, t23, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t25, anchor);
      mount_component(button11, target, anchor);
      insert_dev(target, t26, anchor);
      mount_component(messagebox, target, anchor);
      insert_dev(target, t27, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t28, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const button0_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      const button3_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        button3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button3.$set(button3_changes);
      const button4_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        button4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button4.$set(button4_changes);
      const button5_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        button5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button5.$set(button5_changes);
      const button6_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        button6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button6.$set(button6_changes);
      const button7_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        button7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button7.$set(button7_changes);
      const button8_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        button8_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button8.$set(button8_changes);
      const button9_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        button9_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button9.$set(button9_changes);
      const button10_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        button10_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button10.$set(button10_changes);
      const button11_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        button11_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button11.$set(button11_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      transition_in(button4.$$.fragment, local);
      transition_in(button5.$$.fragment, local);
      transition_in(button6.$$.fragment, local);
      transition_in(button7.$$.fragment, local);
      transition_in(button8.$$.fragment, local);
      transition_in(button9.$$.fragment, local);
      transition_in(button10.$$.fragment, local);
      transition_in(button11.$$.fragment, local);
      transition_in(messagebox.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      transition_out(button4.$$.fragment, local);
      transition_out(button5.$$.fragment, local);
      transition_out(button6.$$.fragment, local);
      transition_out(button7.$$.fragment, local);
      transition_out(button8.$$.fragment, local);
      transition_out(button9.$$.fragment, local);
      transition_out(button10.$$.fragment, local);
      transition_out(button11.$$.fragment, local);
      transition_out(messagebox.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p);
        detach_dev(t3);
        detach_dev(br);
        detach_dev(t4);
        detach_dev(h30);
        detach_dev(t6);
        detach_dev(div0);
        detach_dev(t11);
        detach_dev(h31);
        detach_dev(t13);
        detach_dev(div1);
        detach_dev(t17);
        detach_dev(h32);
        detach_dev(t19);
        detach_dev(div2);
        detach_dev(t20);
        detach_dev(h33);
        detach_dev(t22);
        detach_dev(div3);
        detach_dev(t23);
        detach_dev(h34);
        detach_dev(t25);
        detach_dev(t26);
        detach_dev(t27);
        detach_dev(t28);
      }
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
      destroy_component(button3);
      destroy_component(button4);
      destroy_component(button5);
      destroy_component(button6);
      destroy_component(button7);
      destroy_component(button8);
      destroy_component(button9);
      destroy_component(button10);
      destroy_component(button11, detaching);
      destroy_component(messagebox, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment80.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var longMessage = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce nec euismod turpis. Aliquam aliquam varius dignissim. Sed sit amet leo tempor, dignissim ex euismod, volutpat ante. Etiam sed lacus pharetra, commodo lectus ac, bibendum purus. In vel aliquam arcu, nec aliquam tortor. Cras feugiat porta eros. Nulla eget quam mattis, laoreet elit et, volutpat lacus. Phasellus eget risus in lacus facilisis porta vitae vel nibh. Nam condimentum est risus, sed volutpat metus sodales non. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Phasellus ac euismod arcu. Proin varius, ligula vel ullamcorper rutrum, tortor est imperdiet est, et accumsan nunc mi vitae risus.";
function onclose(res) {
  alert(`You clicked ${res}`);
}
function instance80($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("MessageBox", slots2, []);
  function showComplex(e) {
    showMessage({
      message: "Are you sure you want to delete this thing?",
      type: MessageType.DANGER,
      title: "Confirm",
      buttons: [
        {
          label: "Yes",
          value: "yes",
          type: "danger"
        },
        { label: "No" }
      ],
      target: e.target,
      icon: "help",
      cb: (res) => {
        console.log(`You clicked ${res}`);
      }
    });
  }
  const apiProps = [
    {
      name: "1. message",
      type: "string",
      description: "A message to show."
    },
    {
      name: "2. type",
      type: "string",
      default: "info",
      description: "A message type (for icon and button styling)."
    },
    {
      name: "3. title",
      type: "string",
      default: "",
      description: "A title of the message box."
    },
    {
      name: "4. label",
      type: "string",
      default: "OK",
      description: "A label for the button."
    },
    {
      name: "5. cb",
      type: "function",
      description: "A callback function that will be called on close. A value of the clicked button will be passed to the function."
    }
  ];
  const exampleHtml = `
<MessageBox />

<script>
	import { MessageBox, MessageType, showMessage } from '@perfectthings/ui';

    showMessage('Some info with the OK button');

    showMessage('Some warning with the OK button', MessageType.WARNING);
    showMessage('Some error with the OK button and title', MessageType.ERROR, 'Error', 'Close');

    showMessage({
        message: 'Are you sure you want to delete this item?',
        title: 'Confirm',
        type: MessageType.DANGER,
		icon: 'help',
        buttons: [
            { label: 'OK', value: 'ok', type: 'danger' },
            { label: 'Cancel' }
        ],
		target: buttonElement,  // to be focused on close
        cb: (res) => {}
    });

&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_113.warn(`<MessageBox> was created with unknown prop '${key}'`);
  });
  const click_handler = () => showMessage("This is the message");
  const click_handler_1 = () => showMessage("This is the message", MessageType.INFO);
  const click_handler_2 = () => showMessage("This is the message", MessageType.WARNING);
  const click_handler_3 = () => showMessage("This is the message", MessageType.DANGER);
  const click_handler_4 = () => showMessage("This is the message", MessageType.SUCCESS);
  const click_handler_5 = () => showMessage("Default message", null, "Default title");
  const click_handler_6 = () => showMessage("Info messagebox", MessageType.INFO, "Info title");
  const click_handler_7 = () => showMessage(longMessage, null, "Info title");
  const click_handler_8 = () => showMessage(longMessage, MessageType.INFO, "Info title");
  const click_handler_9 = () => showMessage('Message with <i>html</i><br><a href="#MessageBox" target="_blank">Link</a>', null, "Info title", "Close");
  const click_handler_10 = () => showMessage("Info messagebox", null, "Info title", "Close", onclose);
  $$self2.$capture_state = () => ({
    Button: Button_default,
    MessageBox: MessageBox_default,
    MessageType,
    showMessage,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    longMessage,
    onclose,
    showComplex,
    apiProps,
    exampleHtml
  });
  return [
    showComplex,
    apiProps,
    exampleHtml,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6,
    click_handler_7,
    click_handler_8,
    click_handler_9,
    click_handler_10
  ];
}
var MessageBox_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance80, create_fragment80, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MessageBox_1",
      options,
      id: create_fragment80.name
    });
  }
};
var MessageBox_default2 = MessageBox_1;

// docs-src/components/tooltip/Tooltip.svelte
var file74 = "docs-src/components/tooltip/Tooltip.svelte";
function create_default_slot_94(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Some tooltip text");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_94.name,
    type: "slot",
    source: '(6:0) <Tooltip target=\\"box1\\">',
    ctx
  });
  return block;
}
function create_default_slot_84(ctx) {
  let h1;
  let t1;
  let p0;
  let t2;
  let b;
  let t4;
  let a;
  let t6;
  let p1;
  const block = {
    c: function create() {
      h1 = element2("h1");
      h1.textContent = "Some Title";
      t1 = space();
      p0 = element2("p");
      t2 = text("Some ");
      b = element2("b");
      b.textContent = "html";
      t4 = text(" tooltip content with a ");
      a = element2("a");
      a.textContent = "link";
      t6 = space();
      p1 = element2("p");
      p1.textContent = "lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec a diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante hendrerit.";
      add_location(h1, file74, 10, 1, 390);
      add_location(b, file74, 11, 9, 419);
      attr_dev(a, "href", "#Tooltip");
      add_location(a, file74, 11, 44, 454);
      add_location(p0, file74, 11, 1, 411);
      add_location(p1, file74, 12, 1, 487);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h1, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p0, anchor);
      append_dev(p0, t2);
      append_dev(p0, b);
      append_dev(p0, t4);
      append_dev(p0, a);
      insert_dev(target, t6, anchor);
      insert_dev(target, p1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h1);
        detach_dev(t1);
        detach_dev(p0);
        detach_dev(t6);
        detach_dev(p1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_84.name,
    type: "slot",
    source: '(10:0) <Tooltip target=\\"box2\\" class=\\"tooltip-html\\">',
    ctx
  });
  return block;
}
function create_default_slot_75(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Some tooltip text");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_75.name,
    type: "slot",
    source: '(20:0) <Tooltip info target=\\"box-info\\">',
    ctx
  });
  return block;
}
function create_default_slot_65(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Some tooltip text");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_65.name,
    type: "slot",
    source: '(24:0) <Tooltip success target=\\"box-success\\">',
    ctx
  });
  return block;
}
function create_default_slot_55(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Some tooltip text");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_55.name,
    type: "slot",
    source: '(28:0) <Tooltip warning target=\\"box-warning\\">',
    ctx
  });
  return block;
}
function create_default_slot_48(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Some tooltip text");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_48.name,
    type: "slot",
    source: '(32:0) <Tooltip danger target=\\"box-error\\">',
    ctx
  });
  return block;
}
function create_default_slot_313(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Some tooltip text");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_313.name,
    type: "slot",
    source: '(39:0) <Tooltip position=\\"bottom\\" target=\\"box-below\\">',
    ctx
  });
  return block;
}
function create_default_slot_214(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Smaller offset");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_214.name,
    type: "slot",
    source: '(44:0) <Tooltip target=\\"box-offset\\" offset=\\"-20\\">',
    ctx
  });
  return block;
}
function create_default_slot_117(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Bigger offset");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_117.name,
    type: "slot",
    source: '(48:0) <Tooltip target=\\"box-offset2\\" offset=\\"20\\">',
    ctx
  });
  return block;
}
function create_default_slot12(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Showing with a delay");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: '(54:0) <Tooltip target=\\"box5\\" delay=\\"700\\">',
    ctx
  });
  return block;
}
function create_fragment81(ctx) {
  let h2;
  let t1;
  let h30;
  let t3;
  let div0;
  let t5;
  let tooltip0;
  let t6;
  let div1;
  let t8;
  let tooltip1;
  let t9;
  let h31;
  let t11;
  let div2;
  let t13;
  let tooltip2;
  let t14;
  let div3;
  let t16;
  let tooltip3;
  let t17;
  let div4;
  let t19;
  let tooltip4;
  let t20;
  let div5;
  let t22;
  let tooltip5;
  let t23;
  let h32;
  let t25;
  let div6;
  let t27;
  let tooltip6;
  let t28;
  let h33;
  let t30;
  let div7;
  let t32;
  let tooltip7;
  let t33;
  let div8;
  let t35;
  let tooltip8;
  let t36;
  let h34;
  let t38;
  let div9;
  let t40;
  let tooltip9;
  let t41;
  let codeexample;
  let t42;
  let api;
  let current;
  tooltip0 = new Tooltip_default({
    props: {
      target: "box1",
      $$slots: { default: [create_default_slot_94] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tooltip1 = new Tooltip_default({
    props: {
      target: "box2",
      class: "tooltip-html",
      $$slots: { default: [create_default_slot_84] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tooltip2 = new Tooltip_default({
    props: {
      info: true,
      target: "box-info",
      $$slots: { default: [create_default_slot_75] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tooltip3 = new Tooltip_default({
    props: {
      success: true,
      target: "box-success",
      $$slots: { default: [create_default_slot_65] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tooltip4 = new Tooltip_default({
    props: {
      warning: true,
      target: "box-warning",
      $$slots: { default: [create_default_slot_55] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tooltip5 = new Tooltip_default({
    props: {
      danger: true,
      target: "box-error",
      $$slots: { default: [create_default_slot_48] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tooltip6 = new Tooltip_default({
    props: {
      position: "bottom",
      target: "box-below",
      $$slots: { default: [create_default_slot_313] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tooltip7 = new Tooltip_default({
    props: {
      target: "box-offset",
      offset: "-20",
      $$slots: { default: [create_default_slot_214] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tooltip8 = new Tooltip_default({
    props: {
      target: "box-offset2",
      offset: "20",
      $$slots: { default: [create_default_slot_117] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tooltip9 = new Tooltip_default({
    props: {
      target: "box5",
      delay: "700",
      $$slots: { default: [create_default_slot12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[1]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Tooltip";
      t1 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t3 = space();
      div0 = element2("div");
      div0.textContent = "box with a tooltip";
      t5 = space();
      create_component(tooltip0.$$.fragment);
      t6 = space();
      div1 = element2("div");
      div1.textContent = "box with a tooltip";
      t8 = space();
      create_component(tooltip1.$$.fragment);
      t9 = space();
      h31 = element2("h3");
      h31.textContent = "Colour variants (tooltip type)";
      t11 = space();
      div2 = element2("div");
      div2.textContent = "info";
      t13 = space();
      create_component(tooltip2.$$.fragment);
      t14 = space();
      div3 = element2("div");
      div3.textContent = "success";
      t16 = space();
      create_component(tooltip3.$$.fragment);
      t17 = space();
      div4 = element2("div");
      div4.textContent = "warning";
      t19 = space();
      create_component(tooltip4.$$.fragment);
      t20 = space();
      div5 = element2("div");
      div5.textContent = "danger";
      t22 = space();
      create_component(tooltip5.$$.fragment);
      t23 = space();
      h32 = element2("h3");
      h32.textContent = "Show below target";
      t25 = space();
      div6 = element2("div");
      div6.textContent = "box with a tooltip";
      t27 = space();
      create_component(tooltip6.$$.fragment);
      t28 = space();
      h33 = element2("h3");
      h33.textContent = "Custom offset";
      t30 = space();
      div7 = element2("div");
      div7.textContent = "box with a tooltip";
      t32 = space();
      create_component(tooltip7.$$.fragment);
      t33 = space();
      div8 = element2("div");
      div8.textContent = "box with a tooltip";
      t35 = space();
      create_component(tooltip8.$$.fragment);
      t36 = space();
      h34 = element2("h3");
      h34.textContent = "Show delay";
      t38 = space();
      div9 = element2("div");
      div9.textContent = "box with a tooltip";
      t40 = space();
      create_component(tooltip9.$$.fragment);
      t41 = space();
      create_component(codeexample.$$.fragment);
      t42 = space();
      create_component(api.$$.fragment);
      add_location(h2, file74, 0, 0, 0);
      add_location(h30, file74, 2, 0, 18);
      attr_dev(div0, "class", "tooltip-box");
      attr_dev(div0, "tabindex", "0");
      attr_dev(div0, "id", "box1");
      add_location(div0, file74, 4, 0, 90);
      attr_dev(div1, "class", "tooltip-box");
      attr_dev(div1, "tabindex", "0");
      attr_dev(div1, "id", "box2");
      add_location(div1, file74, 8, 0, 271);
      add_location(h31, file74, 16, 0, 683);
      attr_dev(div2, "class", "tooltip-box");
      attr_dev(div2, "tabindex", "0");
      attr_dev(div2, "id", "box-info");
      add_location(div2, file74, 18, 0, 779);
      attr_dev(div3, "class", "tooltip-box");
      attr_dev(div3, "tabindex", "0");
      attr_dev(div3, "id", "box-success");
      add_location(div3, file74, 22, 0, 959);
      attr_dev(div4, "class", "tooltip-box");
      attr_dev(div4, "tabindex", "0");
      attr_dev(div4, "id", "box-warning");
      add_location(div4, file74, 26, 0, 1151);
      attr_dev(div5, "class", "tooltip-box");
      attr_dev(div5, "tabindex", "0");
      attr_dev(div5, "id", "box-error");
      add_location(div5, file74, 30, 0, 1343);
      add_location(h32, file74, 35, 0, 1475);
      attr_dev(div6, "class", "tooltip-box");
      attr_dev(div6, "tabindex", "0");
      attr_dev(div6, "id", "box-below");
      add_location(div6, file74, 37, 0, 1558);
      add_location(h33, file74, 40, 0, 1711);
      attr_dev(div7, "class", "tooltip-box");
      attr_dev(div7, "tabindex", "0");
      attr_dev(div7, "id", "box-offset");
      add_location(div7, file74, 42, 0, 1790);
      attr_dev(div8, "class", "tooltip-box");
      attr_dev(div8, "tabindex", "0");
      attr_dev(div8, "id", "box-offset2");
      add_location(div8, file74, 46, 0, 1993);
      add_location(h34, file74, 50, 0, 2141);
      attr_dev(div9, "class", "tooltip-box");
      attr_dev(div9, "tabindex", "0");
      attr_dev(div9, "id", "box5");
      add_location(div9, file74, 52, 0, 2217);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, div0, anchor);
      insert_dev(target, t5, anchor);
      mount_component(tooltip0, target, anchor);
      insert_dev(target, t6, anchor);
      insert_dev(target, div1, anchor);
      insert_dev(target, t8, anchor);
      mount_component(tooltip1, target, anchor);
      insert_dev(target, t9, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t11, anchor);
      insert_dev(target, div2, anchor);
      insert_dev(target, t13, anchor);
      mount_component(tooltip2, target, anchor);
      insert_dev(target, t14, anchor);
      insert_dev(target, div3, anchor);
      insert_dev(target, t16, anchor);
      mount_component(tooltip3, target, anchor);
      insert_dev(target, t17, anchor);
      insert_dev(target, div4, anchor);
      insert_dev(target, t19, anchor);
      mount_component(tooltip4, target, anchor);
      insert_dev(target, t20, anchor);
      insert_dev(target, div5, anchor);
      insert_dev(target, t22, anchor);
      mount_component(tooltip5, target, anchor);
      insert_dev(target, t23, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t25, anchor);
      insert_dev(target, div6, anchor);
      insert_dev(target, t27, anchor);
      mount_component(tooltip6, target, anchor);
      insert_dev(target, t28, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t30, anchor);
      insert_dev(target, div7, anchor);
      insert_dev(target, t32, anchor);
      mount_component(tooltip7, target, anchor);
      insert_dev(target, t33, anchor);
      insert_dev(target, div8, anchor);
      insert_dev(target, t35, anchor);
      mount_component(tooltip8, target, anchor);
      insert_dev(target, t36, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t38, anchor);
      insert_dev(target, div9, anchor);
      insert_dev(target, t40, anchor);
      mount_component(tooltip9, target, anchor);
      insert_dev(target, t41, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t42, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const tooltip0_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tooltip0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip0.$set(tooltip0_changes);
      const tooltip1_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tooltip1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip1.$set(tooltip1_changes);
      const tooltip2_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tooltip2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip2.$set(tooltip2_changes);
      const tooltip3_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tooltip3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip3.$set(tooltip3_changes);
      const tooltip4_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tooltip4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip4.$set(tooltip4_changes);
      const tooltip5_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tooltip5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip5.$set(tooltip5_changes);
      const tooltip6_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tooltip6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip6.$set(tooltip6_changes);
      const tooltip7_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tooltip7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip7.$set(tooltip7_changes);
      const tooltip8_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tooltip8_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip8.$set(tooltip8_changes);
      const tooltip9_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tooltip9_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip9.$set(tooltip9_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tooltip0.$$.fragment, local);
      transition_in(tooltip1.$$.fragment, local);
      transition_in(tooltip2.$$.fragment, local);
      transition_in(tooltip3.$$.fragment, local);
      transition_in(tooltip4.$$.fragment, local);
      transition_in(tooltip5.$$.fragment, local);
      transition_in(tooltip6.$$.fragment, local);
      transition_in(tooltip7.$$.fragment, local);
      transition_in(tooltip8.$$.fragment, local);
      transition_in(tooltip9.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tooltip0.$$.fragment, local);
      transition_out(tooltip1.$$.fragment, local);
      transition_out(tooltip2.$$.fragment, local);
      transition_out(tooltip3.$$.fragment, local);
      transition_out(tooltip4.$$.fragment, local);
      transition_out(tooltip5.$$.fragment, local);
      transition_out(tooltip6.$$.fragment, local);
      transition_out(tooltip7.$$.fragment, local);
      transition_out(tooltip8.$$.fragment, local);
      transition_out(tooltip9.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(h30);
        detach_dev(t3);
        detach_dev(div0);
        detach_dev(t5);
        detach_dev(t6);
        detach_dev(div1);
        detach_dev(t8);
        detach_dev(t9);
        detach_dev(h31);
        detach_dev(t11);
        detach_dev(div2);
        detach_dev(t13);
        detach_dev(t14);
        detach_dev(div3);
        detach_dev(t16);
        detach_dev(t17);
        detach_dev(div4);
        detach_dev(t19);
        detach_dev(t20);
        detach_dev(div5);
        detach_dev(t22);
        detach_dev(t23);
        detach_dev(h32);
        detach_dev(t25);
        detach_dev(div6);
        detach_dev(t27);
        detach_dev(t28);
        detach_dev(h33);
        detach_dev(t30);
        detach_dev(div7);
        detach_dev(t32);
        detach_dev(t33);
        detach_dev(div8);
        detach_dev(t35);
        detach_dev(t36);
        detach_dev(h34);
        detach_dev(t38);
        detach_dev(div9);
        detach_dev(t40);
        detach_dev(t41);
        detach_dev(t42);
      }
      destroy_component(tooltip0, detaching);
      destroy_component(tooltip1, detaching);
      destroy_component(tooltip2, detaching);
      destroy_component(tooltip3, detaching);
      destroy_component(tooltip4, detaching);
      destroy_component(tooltip5, detaching);
      destroy_component(tooltip6, detaching);
      destroy_component(tooltip7, detaching);
      destroy_component(tooltip8, detaching);
      destroy_component(tooltip9, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment81.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance81($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Tooltip", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "danger",
      description: "Tooltip type: danger"
    },
    {
      name: "delay",
      type: "number",
      default: "0",
      description: "Delay after which the tooltip should appear (in milliseconds)."
    },
    {
      name: "error",
      description: "Tooltip type: error"
    },
    {
      name: "info",
      description: "Tooltip type: info"
    },
    {
      name: "offset",
      type: "number",
      default: "2",
      description: "Customize tooltip offset. Use negative number for smaller offset or positive for bigger"
    },
    {
      name: "position",
      type: ["top", "bottom"],
      default: "top",
      description: "Prefer the position of the tooltip to be above (top) or below (bottom) the target element."
    },
    {
      name: "success",
      description: "Tooltip type: success"
    },
    {
      name: "target",
      required: true,
      type: "string",
      description: "ID of the target element."
    },
    {
      name: "warning",
      description: "Tooltip type: warning"
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    }
  ];
  const exampleHtml = `
<div id="box1"></div>
<Tooltip position="bottom" target="box1" offset="5">Some tooltip text</Tooltip>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tooltip> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    Tooltip: Tooltip_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    exampleHtml
  });
  return [apiProps, exampleHtml];
}
var Tooltip_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance81, create_fragment81, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tooltip_1",
      options,
      id: create_fragment81.name
    });
  }
};
var Tooltip_default2 = Tooltip_1;

// docs-src/components/dialog/Dialog.svelte
var file75 = "docs-src/components/dialog/Dialog.svelte";
function create_default_slot_163(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Large dialog");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_163.name,
    type: "slot",
    source: '(13:1) <Button on:click=\\"{dialog1.open}\\">',
    ctx
  });
  return block;
}
function create_default_slot_153(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("No buttons");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_153.name,
    type: "slot",
    source: '(14:1) <Button on:click=\\"{dialog2.open}\\">',
    ctx
  });
  return block;
}
function create_default_slot_143(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Confirmation");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_143.name,
    type: "slot",
    source: '(15:1) <Button on:click=\\"{dialog3.open}\\">',
    ctx
  });
  return block;
}
function create_default_slot_134(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("With title and buttons");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_134.name,
    type: "slot",
    source: '(16:1) <Button on:click=\\"{dialog4.open}\\">',
    ctx
  });
  return block;
}
function create_default_slot_124(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Modal");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_124.name,
    type: "slot",
    source: '(17:1) <Button on:click=\\"{dialog5.open}\\">',
    ctx
  });
  return block;
}
function create_default_slot_118(ctx) {
  let t0;
  let br;
  let t1;
  let p0;
  let t3;
  let p1;
  let t5;
  let p2;
  let t7;
  let p3;
  let t9;
  let p4;
  const block = {
    c: function create() {
      t0 = text("dialog contents");
      br = element2("br");
      t1 = text("\n	Hello world!\n\n	");
      p0 = element2("p");
      p0.textContent = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris mollis porttitor justo, eget ornare massa commodo non. Pellentesque semper dictum mauris, id pretium mi mattis in. Proin sodales neque id euismod interdum. Fusce vel blandit orci. Mauris nec ligula aliquam, vestibulum erat nec, ullamcorper nunc. Cras vel lacinia sem. Aenean non tincidunt nisl, vitae consectetur est. Integer id neque tempor, facilisis felis egestas, aliquam turpis. Mauris id consectetur purus. Praesent vehicula, mauris eu hendrerit vehicula, velit tortor fermentum enim, eget malesuada quam eros at quam. Integer mattis egestas tempus.";
      t3 = space();
      p1 = element2("p");
      p1.textContent = "Aliquam et purus enim. Suspendisse potenti. Suspendisse tincidunt ullamcorper nulla non gravida. Morbi at tellus dui. Sed orci ligula, facilisis sit amet odio eu, commodo ultricies lorem. Nullam sagittis sapien metus, eu posuere sem iaculis sed. Duis at nibh feugiat, placerat lectus nec, consectetur elit. In sollicitudin est in ultricies gravida. Ut malesuada ex lacinia, posuere augue eget, imperdiet erat. Phasellus ac dui sit amet ligula condimentum venenatis vitae ornare augue. Vivamus pellentesque felis in orci finibus, a accumsan libero consectetur.";
      t5 = space();
      p2 = element2("p");
      p2.textContent = "Nulla facilisi. Sed in neque hendrerit, convallis neque a, semper sem. Maecenas suscipit ex quis risus mollis, at tincidunt mi faucibus. Pellentesque in faucibus metus. Etiam sollicitudin accumsan arcu interdum sollicitudin. Suspendisse iaculis congue justo id posuere. Ut sed nisi molestie, egestas nulla at, feugiat neque. Nullam vitae libero eu sem ornare tempus vel id tortor. Ut varius ullamcorper nisl et dignissim. Vestibulum sodales massa id odio aliquet ornare. Nunc mollis quis sapien fringilla ullamcorper. Interdum et malesuada fames ac ante ipsum primis in faucibus. Phasellus eget posuere orci.";
      t7 = space();
      p3 = element2("p");
      p3.textContent = "Suspendisse sollicitudin sed ligula nec tempus. Phasellus quis luctus sapien. Nullam nec sapien fringilla, sollicitudin dui sit amet, molestie arcu. Pellentesque id elit et sem pharetra gravida. Donec sed metus ut dui venenatis euismod varius ut libero. Duis ornare odio finibus eros rhoncus ullamcorper. Maecenas auctor lectus volutpat sem pretium volutpat. Mauris blandit quam diam, nec consequat arcu dignissim ut. Donec ac lacus pretium, sollicitudin nisi in, ullamcorper enim. Ut convallis nec eros nec scelerisque. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Mauris non odio a ipsum varius pretium non ut ex. Quisque euismod luctus risus, sit amet venenatis justo vehicula non. Aliquam erat volutpat. Phasellus eu leo ut odio cursus cursus. Pellentesque porta odio id arcu mattis, vitae aliquam risus efficitur.";
      t9 = space();
      p4 = element2("p");
      p4.textContent = "Curabitur nec cursus purus. Nullam scelerisque et odio ut pretium. Donec gravida auctor enim, in venenatis mi viverra sit amet. Integer tincidunt lectus quis sagittis pellentesque. Morbi nec ipsum erat. Donec finibus sit amet lorem et dignissim. Praesent pretium consequat enim, quis rutrum nisl imperdiet ut.";
      add_location(br, file75, 21, 16, 555);
      add_location(p0, file75, 24, 1, 576);
      add_location(p1, file75, 25, 1, 1204);
      add_location(p2, file75, 26, 1, 1772);
      add_location(p3, file75, 27, 1, 2389);
      add_location(p4, file75, 28, 1, 3259);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, br, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p0, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, p1, anchor);
      insert_dev(target, t5, anchor);
      insert_dev(target, p2, anchor);
      insert_dev(target, t7, anchor);
      insert_dev(target, p3, anchor);
      insert_dev(target, t9, anchor);
      insert_dev(target, p4, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(br);
        detach_dev(t1);
        detach_dev(p0);
        detach_dev(t3);
        detach_dev(p1);
        detach_dev(t5);
        detach_dev(p2);
        detach_dev(t7);
        detach_dev(p3);
        detach_dev(t9);
        detach_dev(p4);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_118.name,
    type: "slot",
    source: '(21:0) <Dialog bind:this=\\"{dialog1}\\" title=\\"Hello\\">',
    ctx
  });
  return block;
}
function create_default_slot_104(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Close");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_104.name,
    type: "slot",
    source: '(32:2) <Button on:click=\\"{() => dialog1.close()}\\">',
    ctx
  });
  return block;
}
function create_footer_slot_3(ctx) {
  let div;
  let button;
  let current;
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_104] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[8]
  );
  const block = {
    c: function create() {
      div = element2("div");
      create_component(button.$$.fragment);
      attr_dev(div, "slot", "footer");
      add_location(div, file75, 30, 1, 3579);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(button, div, null);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(button);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_footer_slot_3.name,
    type: "slot",
    source: "(31:1) ",
    ctx
  });
  return block;
}
function create_default_slot_95(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Hello!");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_95.name,
    type: "slot",
    source: '(36:0) <Dialog bind:this=\\"{dialog2}\\" title=\\"Hello\\">',
    ctx
  });
  return block;
}
function create_default_slot_85(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Are you sure?");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_85.name,
    type: "slot",
    source: '(41:0) <Dialog bind:this=\\"{dialog3}\\">',
    ctx
  });
  return block;
}
function create_default_slot_76(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Yes");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_76.name,
    type: "slot",
    source: '(44:2) <Button on:click=\\"{() => dialog3.close()}\\">',
    ctx
  });
  return block;
}
function create_default_slot_66(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("No");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_66.name,
    type: "slot",
    source: '(45:2) <Button on:click=\\"{() => dialog3.close()}\\">',
    ctx
  });
  return block;
}
function create_footer_slot_2(ctx) {
  let div;
  let button0;
  let t;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_76] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button0.$on(
    "click",
    /*click_handler_1*/
    ctx[11]
  );
  button1 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_66] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1.$on(
    "click",
    /*click_handler_2*/
    ctx[12]
  );
  const block = {
    c: function create() {
      div = element2("div");
      create_component(button0.$$.fragment);
      t = space();
      create_component(button1.$$.fragment);
      attr_dev(div, "slot", "footer");
      add_location(div, file75, 42, 1, 3790);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(button0, div, null);
      append_dev(div, t);
      mount_component(button1, div, null);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(button0);
      destroy_component(button1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_footer_slot_2.name,
    type: "slot",
    source: "(43:1) ",
    ctx
  });
  return block;
}
function create_default_slot_56(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Form goes here...");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_56.name,
    type: "slot",
    source: '(50:0) <Dialog bind:this=\\"{dialog4}\\" title=\\"Edit something\\">',
    ctx
  });
  return block;
}
function create_default_slot_49(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Yes");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_49.name,
    type: "slot",
    source: '(53:2) <Button success on:click=\\"{() => dialog4.close()}\\">',
    ctx
  });
  return block;
}
function create_default_slot_314(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("No");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_314.name,
    type: "slot",
    source: '(54:2) <Button on:click=\\"{() => dialog4.close()}\\">',
    ctx
  });
  return block;
}
function create_footer_slot_1(ctx) {
  let div1;
  let button0;
  let t0;
  let button1;
  let t1;
  let div0;
  let t2;
  let button2;
  let current;
  button0 = new Button_default({
    props: {
      success: true,
      $$slots: { default: [create_default_slot_49] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button0.$on(
    "click",
    /*click_handler_3*/
    ctx[14]
  );
  button1 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_314] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1.$on(
    "click",
    /*click_handler_4*/
    ctx[15]
  );
  button2 = new Button_default({
    props: { danger: true, icon: "trash" },
    $$inline: true
  });
  button2.$on(
    "click",
    /*click_handler_5*/
    ctx[16]
  );
  const block = {
    c: function create() {
      div1 = element2("div");
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      div0 = element2("div");
      t2 = space();
      create_component(button2.$$.fragment);
      attr_dev(div0, "class", "flex-spacer");
      add_location(div0, file75, 54, 2, 4164);
      attr_dev(div1, "slot", "footer");
      add_location(div1, file75, 51, 1, 4019);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      mount_component(button0, div1, null);
      append_dev(div1, t0);
      mount_component(button1, div1, null);
      append_dev(div1, t1);
      append_dev(div1, div0);
      append_dev(div1, t2);
      mount_component(button2, div1, null);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_footer_slot_1.name,
    type: "slot",
    source: "(52:1) ",
    ctx
  });
  return block;
}
function create_default_slot_215(ctx) {
  let p;
  let t0;
  let br;
  let t1;
  const block = {
    c: function create() {
      p = element2("p");
      t0 = text("This means that it will not close when clicking outside of it.");
      br = element2("br");
      t1 = text("\n		This is useful for when an intentional action is required from the user.");
      add_location(br, file75, 61, 100, 4449);
      set_style(p, "line-height", "2");
      set_style(p, "margin", "0");
      add_location(p, file75, 61, 1, 4350);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      append_dev(p, t0);
      append_dev(p, br);
      append_dev(p, t1);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_215.name,
    type: "slot",
    source: '(61:0) <Dialog bind:this=\\"{dialog5}\\" title=\\"Modal dialog\\" modal>',
    ctx
  });
  return block;
}
function create_default_slot_119(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Confirm");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_119.name,
    type: "slot",
    source: '(65:2) <Button success on:click=\\"{() => dialog5.close()}\\">',
    ctx
  });
  return block;
}
function create_default_slot13(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Cancel");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: '(66:2) <Button text on:click=\\"{() => dialog5.close()}\\">',
    ctx
  });
  return block;
}
function create_footer_slot2(ctx) {
  let div;
  let button0;
  let t;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      success: true,
      $$slots: { default: [create_default_slot_119] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button0.$on(
    "click",
    /*click_handler_6*/
    ctx[18]
  );
  button1 = new Button_default({
    props: {
      text: true,
      $$slots: { default: [create_default_slot13] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1.$on(
    "click",
    /*click_handler_7*/
    ctx[19]
  );
  const block = {
    c: function create() {
      div = element2("div");
      create_component(button0.$$.fragment);
      t = space();
      create_component(button1.$$.fragment);
      attr_dev(div, "slot", "footer");
      add_location(div, file75, 63, 1, 4534);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(button0, div, null);
      append_dev(div, t);
      mount_component(button1, div, null);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(button0);
      destroy_component(button1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_footer_slot2.name,
    type: "slot",
    source: "(64:1) ",
    ctx
  });
  return block;
}
function create_fragment82(ctx) {
  let h2;
  let t1;
  let ul;
  let li0;
  let li1;
  let li2;
  let t5;
  let hr;
  let t6;
  let h3;
  let t8;
  let div;
  let button0;
  let t9;
  let button1;
  let t10;
  let button2;
  let t11;
  let button3;
  let t12;
  let button4;
  let t13;
  let dialog0;
  let t14;
  let dialog1_1;
  let t15;
  let dialog2_1;
  let t16;
  let dialog3_1;
  let t17;
  let dialog4_1;
  let t18;
  let codeexample;
  let t19;
  let api0;
  let t20;
  let api1;
  let current;
  button0 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_163] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button0.$on("click", function() {
    if (is_function(
      /*dialog1*/
      ctx[0].open
    ))
      ctx[0].open.apply(this, arguments);
  });
  button1 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_153] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1.$on("click", function() {
    if (is_function(
      /*dialog2*/
      ctx[1].open
    ))
      ctx[1].open.apply(this, arguments);
  });
  button2 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_143] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button2.$on("click", function() {
    if (is_function(
      /*dialog3*/
      ctx[2].open
    ))
      ctx[2].open.apply(this, arguments);
  });
  button3 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_134] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button3.$on("click", function() {
    if (is_function(
      /*dialog4*/
      ctx[3].open
    ))
      ctx[3].open.apply(this, arguments);
  });
  button4 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_124] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button4.$on("click", function() {
    if (is_function(
      /*dialog5*/
      ctx[4].open
    ))
      ctx[4].open.apply(this, arguments);
  });
  let dialog0_props = {
    title: "Hello",
    $$slots: {
      footer: [create_footer_slot_3],
      default: [create_default_slot_118]
    },
    $$scope: { ctx }
  };
  dialog0 = new Dialog_default({ props: dialog0_props, $$inline: true });
  ctx[9](dialog0);
  let dialog1_1_props = {
    title: "Hello",
    $$slots: { default: [create_default_slot_95] },
    $$scope: { ctx }
  };
  dialog1_1 = new Dialog_default({ props: dialog1_1_props, $$inline: true });
  ctx[10](dialog1_1);
  let dialog2_1_props = {
    $$slots: {
      footer: [create_footer_slot_2],
      default: [create_default_slot_85]
    },
    $$scope: { ctx }
  };
  dialog2_1 = new Dialog_default({ props: dialog2_1_props, $$inline: true });
  ctx[13](dialog2_1);
  let dialog3_1_props = {
    title: "Edit something",
    $$slots: {
      footer: [create_footer_slot_1],
      default: [create_default_slot_56]
    },
    $$scope: { ctx }
  };
  dialog3_1 = new Dialog_default({ props: dialog3_1_props, $$inline: true });
  ctx[17](dialog3_1);
  let dialog4_1_props = {
    title: "Modal dialog",
    modal: true,
    $$slots: {
      footer: [create_footer_slot2],
      default: [create_default_slot_215]
    },
    $$scope: { ctx }
  };
  dialog4_1 = new Dialog_default({ props: dialog4_1_props, $$inline: true });
  ctx[20](dialog4_1);
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[7]
    ) },
    $$inline: true
  });
  api0 = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[5]
    ) },
    $$inline: true
  });
  api1 = new ApiTable_default({
    props: {
      props: (
        /*instanceApiProps*/
        ctx[6]
      ),
      title: "Instance API",
      description: "The component exposes <em>this</em> property, to which a variable can be bound, creating an instance of the component, with the following API"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Dialog";
      t1 = space();
      ul = element2("ul");
      li0 = element2("li");
      li0.textContent = "simple, small, no dependencies\n	";
      li1 = element2("li");
      li1.textContent = "accessible (full keyboard support, focus trap)\n	";
      li2 = element2("li");
      li2.textContent = "configurable";
      t5 = space();
      hr = element2("hr");
      t6 = space();
      h3 = element2("h3");
      h3.textContent = "Typical use-cases";
      t8 = space();
      div = element2("div");
      create_component(button0.$$.fragment);
      t9 = space();
      create_component(button1.$$.fragment);
      t10 = space();
      create_component(button2.$$.fragment);
      t11 = space();
      create_component(button3.$$.fragment);
      t12 = space();
      create_component(button4.$$.fragment);
      t13 = space();
      create_component(dialog0.$$.fragment);
      t14 = space();
      create_component(dialog1_1.$$.fragment);
      t15 = space();
      create_component(dialog2_1.$$.fragment);
      t16 = space();
      create_component(dialog3_1.$$.fragment);
      t17 = space();
      create_component(dialog4_1.$$.fragment);
      t18 = space();
      create_component(codeexample.$$.fragment);
      t19 = space();
      create_component(api0.$$.fragment);
      t20 = space();
      create_component(api1.$$.fragment);
      add_location(h2, file75, 0, 0, 0);
      add_location(li0, file75, 3, 1, 23);
      add_location(li1, file75, 4, 1, 59);
      add_location(li2, file75, 5, 1, 111);
      add_location(ul, file75, 2, 0, 17);
      add_location(hr, file75, 7, 0, 134);
      add_location(h3, file75, 10, 0, 141);
      attr_dev(div, "class", "docs-buttons-row");
      add_location(div, file75, 11, 0, 168);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, ul, anchor);
      append_dev(ul, li0);
      append_dev(ul, li1);
      append_dev(ul, li2);
      insert_dev(target, t5, anchor);
      insert_dev(target, hr, anchor);
      insert_dev(target, t6, anchor);
      insert_dev(target, h3, anchor);
      insert_dev(target, t8, anchor);
      insert_dev(target, div, anchor);
      mount_component(button0, div, null);
      append_dev(div, t9);
      mount_component(button1, div, null);
      append_dev(div, t10);
      mount_component(button2, div, null);
      append_dev(div, t11);
      mount_component(button3, div, null);
      append_dev(div, t12);
      mount_component(button4, div, null);
      insert_dev(target, t13, anchor);
      mount_component(dialog0, target, anchor);
      insert_dev(target, t14, anchor);
      mount_component(dialog1_1, target, anchor);
      insert_dev(target, t15, anchor);
      mount_component(dialog2_1, target, anchor);
      insert_dev(target, t16, anchor);
      mount_component(dialog3_1, target, anchor);
      insert_dev(target, t17, anchor);
      mount_component(dialog4_1, target, anchor);
      insert_dev(target, t18, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t19, anchor);
      mount_component(api0, target, anchor);
      insert_dev(target, t20, anchor);
      mount_component(api1, target, anchor);
      current = true;
    },
    p: function update2(new_ctx, [dirty]) {
      ctx = new_ctx;
      const button0_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button0_changes.$$scope = { dirty, ctx };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button1_changes.$$scope = { dirty, ctx };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button2_changes.$$scope = { dirty, ctx };
      }
      button2.$set(button2_changes);
      const button3_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button3_changes.$$scope = { dirty, ctx };
      }
      button3.$set(button3_changes);
      const button4_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        button4_changes.$$scope = { dirty, ctx };
      }
      button4.$set(button4_changes);
      const dialog0_changes = {};
      if (dirty & /*$$scope, dialog1*/
      2097153) {
        dialog0_changes.$$scope = { dirty, ctx };
      }
      dialog0.$set(dialog0_changes);
      const dialog1_1_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        dialog1_1_changes.$$scope = { dirty, ctx };
      }
      dialog1_1.$set(dialog1_1_changes);
      const dialog2_1_changes = {};
      if (dirty & /*$$scope, dialog3*/
      2097156) {
        dialog2_1_changes.$$scope = { dirty, ctx };
      }
      dialog2_1.$set(dialog2_1_changes);
      const dialog3_1_changes = {};
      if (dirty & /*$$scope, dialog4*/
      2097160) {
        dialog3_1_changes.$$scope = { dirty, ctx };
      }
      dialog3_1.$set(dialog3_1_changes);
      const dialog4_1_changes = {};
      if (dirty & /*$$scope, dialog5*/
      2097168) {
        dialog4_1_changes.$$scope = { dirty, ctx };
      }
      dialog4_1.$set(dialog4_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      transition_in(button4.$$.fragment, local);
      transition_in(dialog0.$$.fragment, local);
      transition_in(dialog1_1.$$.fragment, local);
      transition_in(dialog2_1.$$.fragment, local);
      transition_in(dialog3_1.$$.fragment, local);
      transition_in(dialog4_1.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api0.$$.fragment, local);
      transition_in(api1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      transition_out(button4.$$.fragment, local);
      transition_out(dialog0.$$.fragment, local);
      transition_out(dialog1_1.$$.fragment, local);
      transition_out(dialog2_1.$$.fragment, local);
      transition_out(dialog3_1.$$.fragment, local);
      transition_out(dialog4_1.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api0.$$.fragment, local);
      transition_out(api1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(ul);
        detach_dev(t5);
        detach_dev(hr);
        detach_dev(t6);
        detach_dev(h3);
        detach_dev(t8);
        detach_dev(div);
        detach_dev(t13);
        detach_dev(t14);
        detach_dev(t15);
        detach_dev(t16);
        detach_dev(t17);
        detach_dev(t18);
        detach_dev(t19);
        detach_dev(t20);
      }
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
      destroy_component(button3);
      destroy_component(button4);
      ctx[9](null);
      destroy_component(dialog0, detaching);
      ctx[10](null);
      destroy_component(dialog1_1, detaching);
      ctx[13](null);
      destroy_component(dialog2_1, detaching);
      ctx[17](null);
      destroy_component(dialog3_1, detaching);
      ctx[20](null);
      destroy_component(dialog4_1, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api0, detaching);
      destroy_component(api1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment82.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance82($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Dialog", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component container."
    },
    {
      name: "opened",
      type: ["true", "false"],
      default: "false",
      description: "Set dialog's open state."
    },
    {
      name: "skipFirstFocus",
      type: ["true", "false"],
      default: "false",
      description: "If <i>true</i> - the dialog will not set focus to the first focusable element in the dialog.<br>This is useful if another element in the dialog should be focused first."
    },
    {
      name: "title",
      type: "string",
      description: "Set title for the dialog."
    },
    {
      name: "modal",
      description: "If present - the dialog will not close when the user clicks outside of it or presses Escape."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:this",
      type: "object",
      description: "Exposes the component instance."
    },
    {
      name: "on:close",
      type: "function",
      description: "Triggered after the dialog is closed."
    },
    {
      name: "on:open",
      type: "function",
      description: "Triggered after the dialog is opened."
    }
  ];
  const instanceApiProps = [
    {
      name: "close",
      type: "function",
      description: "Closes the dialog."
    },
    {
      name: "open",
      type: "function",
      description: "Opens the dialog."
    }
  ];
  const exampleHtml = `
<Dialog bind:this="{dialog1}">
    Are you sure?
    <div slot="footer">
        <Button on:click="{() => dialog1.close()}">Close</Button>
    </div>
</Dialog>

<Button on:click="{() => dialog1.open()}">Show dialog</Button>

<script>
    let dialog1;
&lt;/script>
`;
  let dialog1, dialog2, dialog3, dialog4, dialog5;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Dialog> was created with unknown prop '${key}'`);
  });
  const click_handler = () => dialog1.close();
  function dialog0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dialog1 = $$value;
      $$invalidate2(0, dialog1);
    });
  }
  function dialog1_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dialog2 = $$value;
      $$invalidate2(1, dialog2);
    });
  }
  const click_handler_1 = () => dialog3.close();
  const click_handler_2 = () => dialog3.close();
  function dialog2_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dialog3 = $$value;
      $$invalidate2(2, dialog3);
    });
  }
  const click_handler_3 = () => dialog4.close();
  const click_handler_4 = () => dialog4.close();
  const click_handler_5 = () => dialog4.close();
  function dialog3_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dialog4 = $$value;
      $$invalidate2(3, dialog4);
    });
  }
  const click_handler_6 = () => dialog5.close();
  const click_handler_7 = () => dialog5.close();
  function dialog4_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dialog5 = $$value;
      $$invalidate2(4, dialog5);
    });
  }
  $$self2.$capture_state = () => ({
    Button: Button_default,
    Dialog: Dialog_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    instanceApiProps,
    exampleHtml,
    dialog1,
    dialog2,
    dialog3,
    dialog4,
    dialog5
  });
  $$self2.$inject_state = ($$props3) => {
    if ("dialog1" in $$props3)
      $$invalidate2(0, dialog1 = $$props3.dialog1);
    if ("dialog2" in $$props3)
      $$invalidate2(1, dialog2 = $$props3.dialog2);
    if ("dialog3" in $$props3)
      $$invalidate2(2, dialog3 = $$props3.dialog3);
    if ("dialog4" in $$props3)
      $$invalidate2(3, dialog4 = $$props3.dialog4);
    if ("dialog5" in $$props3)
      $$invalidate2(4, dialog5 = $$props3.dialog5);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    dialog1,
    dialog2,
    dialog3,
    dialog4,
    dialog5,
    apiProps,
    instanceApiProps,
    exampleHtml,
    click_handler,
    dialog0_binding,
    dialog1_1_binding,
    click_handler_1,
    click_handler_2,
    dialog2_1_binding,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    dialog3_1_binding,
    click_handler_6,
    click_handler_7,
    dialog4_1_binding
  ];
}
var Dialog_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance82, create_fragment82, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dialog_1",
      options,
      id: create_fragment82.name
    });
  }
};
var Dialog_default2 = Dialog_1;

// docs-src/components/drawer/Drawer.svelte
var file76 = "docs-src/components/drawer/Drawer.svelte";
function create_default_slot_216(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Toggle drawer");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_216.name,
    type: "slot",
    source: '(3:0) <Button on:click=\\"{() => drawer.toggle()}\\">',
    ctx
  });
  return block;
}
function create_default_slot_120(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Close Drawer");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_120.name,
    type: "slot",
    source: '(9:1) <Button on:click=\\"{() => drawer.close()}\\">',
    ctx
  });
  return block;
}
function create_default_slot14(ctx) {
  let t0;
  let br0;
  let t1;
  let br1;
  let t2;
  let br2;
  let t3;
  let button;
  let t4;
  let p0;
  let t6;
  let p1;
  let t8;
  let p2;
  let t10;
  let p3;
  let t12;
  let p4;
  let current;
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_120] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on(
    "click",
    /*click_handler_1*/
    ctx[5]
  );
  const block = {
    c: function create() {
      t0 = text("drawer contents");
      br0 = element2("br");
      t1 = text("\n	Hello world!");
      br1 = element2("br");
      t2 = space();
      br2 = element2("br");
      t3 = space();
      create_component(button.$$.fragment);
      t4 = space();
      p0 = element2("p");
      p0.textContent = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris mollis porttitor justo, eget ornare massa commodo non. Pellentesque semper dictum mauris, id pretium mi mattis in. Proin sodales neque id euismod interdum. Fusce vel blandit orci. Mauris nec ligula aliquam, vestibulum erat nec, ullamcorper nunc. Cras vel lacinia sem. Aenean non tincidunt nisl, vitae consectetur est. Integer id neque tempor, facilisis felis egestas, aliquam turpis. Mauris id consectetur purus. Praesent vehicula, mauris eu hendrerit vehicula, velit tortor fermentum enim, eget malesuada quam eros at quam. Integer mattis egestas tempus.";
      t6 = space();
      p1 = element2("p");
      p1.textContent = "Aliquam et purus enim. Suspendisse potenti. Suspendisse tincidunt ullamcorper nulla non gravida. Morbi at tellus dui. Sed orci ligula, facilisis sit amet odio eu, commodo ultricies lorem. Nullam sagittis sapien metus, eu posuere sem iaculis sed. Duis at nibh feugiat, placerat lectus nec, consectetur elit. In sollicitudin est in ultricies gravida. Ut malesuada ex lacinia, posuere augue eget, imperdiet erat. Phasellus ac dui sit amet ligula condimentum venenatis vitae ornare augue. Vivamus pellentesque felis in orci finibus, a accumsan libero consectetur.";
      t8 = space();
      p2 = element2("p");
      p2.textContent = "Nulla facilisi. Sed in neque hendrerit, convallis neque a, semper sem. Maecenas suscipit ex quis risus mollis, at tincidunt mi faucibus. Pellentesque in faucibus metus. Etiam sollicitudin accumsan arcu interdum sollicitudin. Suspendisse iaculis congue justo id posuere. Ut sed nisi molestie, egestas nulla at, feugiat neque. Nullam vitae libero eu sem ornare tempus vel id tortor. Ut varius ullamcorper nisl et dignissim. Vestibulum sodales massa id odio aliquet ornare. Nunc mollis quis sapien fringilla ullamcorper. Interdum et malesuada fames ac ante ipsum primis in faucibus. Phasellus eget posuere orci.";
      t10 = space();
      p3 = element2("p");
      p3.textContent = "Suspendisse sollicitudin sed ligula nec tempus. Phasellus quis luctus sapien. Nullam nec sapien fringilla, sollicitudin dui sit amet, molestie arcu. Pellentesque id elit et sem pharetra gravida. Donec sed metus ut dui venenatis euismod varius ut libero. Duis ornare odio finibus eros rhoncus ullamcorper. Maecenas auctor lectus volutpat sem pretium volutpat. Mauris blandit quam diam, nec consequat arcu dignissim ut. Donec ac lacus pretium, sollicitudin nisi in, ullamcorper enim. Ut convallis nec eros nec scelerisque. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Mauris non odio a ipsum varius pretium non ut ex. Quisque euismod luctus risus, sit amet venenatis justo vehicula non. Aliquam erat volutpat. Phasellus eu leo ut odio cursus cursus. Pellentesque porta odio id arcu mattis, vitae aliquam risus efficitur.";
      t12 = space();
      p4 = element2("p");
      p4.textContent = "Curabitur nec cursus purus. Nullam scelerisque et odio ut pretium. Donec gravida auctor enim, in venenatis mi viverra sit amet. Integer tincidunt lectus quis sagittis pellentesque. Morbi nec ipsum erat. Donec finibus sit amet lorem et dignissim. Praesent pretium consequat enim, quis rutrum nisl imperdiet ut.";
      add_location(br0, file76, 5, 16, 145);
      add_location(br1, file76, 6, 13, 163);
      add_location(br2, file76, 7, 1, 169);
      add_location(p0, file76, 9, 1, 240);
      add_location(p1, file76, 10, 1, 868);
      add_location(p2, file76, 11, 1, 1436);
      add_location(p3, file76, 12, 1, 2053);
      add_location(p4, file76, 13, 1, 2923);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, br0, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, br1, anchor);
      insert_dev(target, t2, anchor);
      insert_dev(target, br2, anchor);
      insert_dev(target, t3, anchor);
      mount_component(button, target, anchor);
      insert_dev(target, t4, anchor);
      insert_dev(target, p0, anchor);
      insert_dev(target, t6, anchor);
      insert_dev(target, p1, anchor);
      insert_dev(target, t8, anchor);
      insert_dev(target, p2, anchor);
      insert_dev(target, t10, anchor);
      insert_dev(target, p3, anchor);
      insert_dev(target, t12, anchor);
      insert_dev(target, p4, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      128) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(br0);
        detach_dev(t1);
        detach_dev(br1);
        detach_dev(t2);
        detach_dev(br2);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(p0);
        detach_dev(t6);
        detach_dev(p1);
        detach_dev(t8);
        detach_dev(p2);
        detach_dev(t10);
        detach_dev(p3);
        detach_dev(t12);
        detach_dev(p4);
      }
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: '(5:0) <Drawer bind:this=\\"{drawer}\\" title=\\"Drawer\\">',
    ctx
  });
  return block;
}
function create_fragment83(ctx) {
  let h2;
  let t1;
  let button;
  let t2;
  let drawer_1;
  let t3;
  let codeexample;
  let t4;
  let api0;
  let t5;
  let api1;
  let current;
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_216] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[4]
  );
  let drawer_1_props = {
    title: "Drawer",
    $$slots: { default: [create_default_slot14] },
    $$scope: { ctx }
  };
  drawer_1 = new Drawer_default({ props: drawer_1_props, $$inline: true });
  ctx[6](drawer_1);
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[3]
    ) },
    $$inline: true
  });
  api0 = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[1]
    ) },
    $$inline: true
  });
  api1 = new ApiTable_default({
    props: {
      props: (
        /*instanceApiProps*/
        ctx[2]
      ),
      title: "Instance API",
      description: "The component exposes <em>this</em> property, to which a variable can be bound, creating an instance of the component, with the following API"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Drawer";
      t1 = space();
      create_component(button.$$.fragment);
      t2 = space();
      create_component(drawer_1.$$.fragment);
      t3 = space();
      create_component(codeexample.$$.fragment);
      t4 = space();
      create_component(api0.$$.fragment);
      t5 = space();
      create_component(api1.$$.fragment);
      add_location(h2, file76, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      mount_component(button, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(drawer_1, target, anchor);
      insert_dev(target, t3, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t4, anchor);
      mount_component(api0, target, anchor);
      insert_dev(target, t5, anchor);
      mount_component(api1, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      128) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      const drawer_1_changes = {};
      if (dirty & /*$$scope, drawer*/
      129) {
        drawer_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      drawer_1.$set(drawer_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      transition_in(drawer_1.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api0.$$.fragment, local);
      transition_in(api1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      transition_out(drawer_1.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api0.$$.fragment, local);
      transition_out(api1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(t5);
      }
      destroy_component(button, detaching);
      ctx[6](null);
      destroy_component(drawer_1, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api0, detaching);
      destroy_component(api1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment83.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance83($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Drawer", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component container."
    },
    {
      name: "title",
      type: "string",
      description: "Set title for the drawer."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:this",
      type: "object",
      description: "Exposes the component instance."
    },
    {
      name: "on:close",
      type: "function",
      description: "Triggered after the drawer is closed."
    },
    {
      name: "on:open",
      type: "function",
      description: "Triggered after the drawer is opened."
    }
  ];
  const instanceApiProps = [
    {
      name: "close",
      type: "function",
      description: "Closes the drawer."
    },
    {
      name: "open",
      type: "function",
      description: "Opens the drawer."
    },
    {
      name: "toggle",
      type: "function",
      description: "Toggles the open state (opens when closed, closes when open)."
    }
  ];
  const exampleHtml = `
<Drawer bind:this="{drawer1}" title="Drawer">
    Hello world!
    <Button on:click="{() => drawer1.close()}">Close</Button>
</Drawer>

<Button on:click="{() => drawer1.toggle()}">Show dialog</Button>

<script>
    let drawer1;
&lt;/script>
`;
  let drawer;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Drawer> was created with unknown prop '${key}'`);
  });
  const click_handler = () => drawer.toggle();
  const click_handler_1 = () => drawer.close();
  function drawer_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      drawer = $$value;
      $$invalidate2(0, drawer);
    });
  }
  $$self2.$capture_state = () => ({
    Button: Button_default,
    Drawer: Drawer_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    instanceApiProps,
    exampleHtml,
    drawer
  });
  $$self2.$inject_state = ($$props3) => {
    if ("drawer" in $$props3)
      $$invalidate2(0, drawer = $$props3.drawer);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    drawer,
    apiProps,
    instanceApiProps,
    exampleHtml,
    click_handler,
    click_handler_1,
    drawer_1_binding
  ];
}
var Drawer_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance83, create_fragment83, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Drawer_1",
      options,
      id: create_fragment83.name
    });
  }
};
var Drawer_default2 = Drawer_1;

// docs-src/components/panel/Panel.svelte
var file77 = "docs-src/components/panel/Panel.svelte";
function create_default_slot_135(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "This is panel contents";
      add_location(p, file77, 5, 1, 60);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_135.name,
    type: "slot",
    source: '(5:0) <Panel title=\\"Collapsed\\">',
    ctx
  });
  return block;
}
function create_default_slot_125(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "This is panel contents";
      add_location(p, file77, 9, 1, 131);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_125.name,
    type: "slot",
    source: '(9:0) <Panel title=\\"Expanded\\" open>',
    ctx
  });
  return block;
}
function create_default_slot_1110(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "This is panel contents";
      add_location(p, file77, 13, 1, 200);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1110.name,
    type: "slot",
    source: '(13:0) <Panel title=\\"Round\\" round>',
    ctx
  });
  return block;
}
function create_default_slot_105(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "This is panel contents";
      add_location(p, file77, 19, 1, 268);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_105.name,
    type: "slot",
    source: "(19:0) <Panel>",
    ctx
  });
  return block;
}
function create_default_slot_96(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "This is panel contents";
      add_location(p, file77, 23, 1, 323);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_96.name,
    type: "slot",
    source: "(23:0) <Panel round>",
    ctx
  });
  return block;
}
function create_default_slot_86(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "This is panel contents";
      add_location(p, file77, 29, 1, 419);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_86.name,
    type: "slot",
    source: '(29:0) <Panel title=\\"info\\" info>',
    ctx
  });
  return block;
}
function create_default_slot_77(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "This is panel contents";
      add_location(p, file77, 33, 1, 504);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_77.name,
    type: "slot",
    source: '(33:0) <Panel title=\\"success round\\" success round>',
    ctx
  });
  return block;
}
function create_default_slot_67(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "This is panel contents";
      add_location(p, file77, 37, 1, 613);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_67.name,
    type: "slot",
    source: '(37:0) <Panel title=\\"warning round collapsible\\" warning round collapsible>',
    ctx
  });
  return block;
}
function create_default_slot_57(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "This is panel contents";
      add_location(p, file77, 41, 1, 730);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_57.name,
    type: "slot",
    source: '(41:0) <Panel title=\\"danger round collapsible open\\" danger round collapsible open>',
    ctx
  });
  return block;
}
function create_default_slot_410(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "This is panel contents";
      add_location(p, file77, 48, 1, 840);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_410.name,
    type: "slot",
    source: '(48:0) <Panel title=\\"Collapsed\\" round disabled>',
    ctx
  });
  return block;
}
function create_default_slot_315(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "This is panel contents";
      add_location(p, file77, 52, 1, 926);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_315.name,
    type: "slot",
    source: '(52:0) <Panel title=\\"Expanded\\" open round disabled>',
    ctx
  });
  return block;
}
function create_default_slot_217(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "This is panel contents";
      add_location(p, file77, 58, 1, 1033);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_217.name,
    type: "slot",
    source: '(58:0) <Panel title=\\"Collapsed\\" round collapsible>',
    ctx
  });
  return block;
}
function create_default_slot_121(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Action");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_121.name,
    type: "slot",
    source: "(66:1) <Button>",
    ctx
  });
  return block;
}
function create_default_slot15(ctx) {
  let p0;
  let t1;
  let p1;
  let t3;
  let p2;
  let t5;
  let button;
  let current;
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_121] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      p0 = element2("p");
      p0.textContent = "This is panel contents";
      t1 = space();
      p1 = element2("p");
      p1.textContent = "Hello world!";
      t3 = space();
      p2 = element2("p");
      p2.textContent = "This is panel contents";
      t5 = space();
      create_component(button.$$.fragment);
      add_location(p0, file77, 62, 1, 1121);
      add_location(p1, file77, 63, 1, 1152);
      add_location(p2, file77, 64, 1, 1173);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p0, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p1, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, p2, anchor);
      insert_dev(target, t5, anchor);
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p0);
        detach_dev(t1);
        detach_dev(p1);
        detach_dev(t3);
        detach_dev(p2);
        detach_dev(t5);
      }
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot15.name,
    type: "slot",
    source: '(62:0) <Panel title=\\"Panel 2\\" open round collapsible>',
    ctx
  });
  return block;
}
function create_fragment84(ctx) {
  let h2;
  let t1;
  let h30;
  let t3;
  let panel0;
  let t4;
  let panel1;
  let t5;
  let panel2;
  let t6;
  let h31;
  let t8;
  let panel3;
  let t9;
  let panel4;
  let t10;
  let h32;
  let t12;
  let panel5;
  let t13;
  let panel6;
  let t14;
  let panel7;
  let t15;
  let panel8;
  let t16;
  let h33;
  let t18;
  let panel9;
  let t19;
  let panel10;
  let t20;
  let h34;
  let t22;
  let panel11;
  let t23;
  let panel12;
  let t24;
  let codeexample;
  let t25;
  let api;
  let current;
  panel0 = new Panel_default({
    props: {
      title: "Collapsed",
      $$slots: { default: [create_default_slot_135] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  panel1 = new Panel_default({
    props: {
      title: "Expanded",
      open: true,
      $$slots: { default: [create_default_slot_125] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  panel2 = new Panel_default({
    props: {
      title: "Round",
      round: true,
      $$slots: { default: [create_default_slot_1110] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  panel3 = new Panel_default({
    props: {
      $$slots: { default: [create_default_slot_105] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  panel4 = new Panel_default({
    props: {
      round: true,
      $$slots: { default: [create_default_slot_96] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  panel5 = new Panel_default({
    props: {
      title: "info",
      info: true,
      $$slots: { default: [create_default_slot_86] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  panel6 = new Panel_default({
    props: {
      title: "success round",
      success: true,
      round: true,
      $$slots: { default: [create_default_slot_77] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  panel7 = new Panel_default({
    props: {
      title: "warning round collapsible",
      warning: true,
      round: true,
      collapsible: true,
      $$slots: { default: [create_default_slot_67] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  panel8 = new Panel_default({
    props: {
      title: "danger round collapsible open",
      danger: true,
      round: true,
      collapsible: true,
      open: true,
      $$slots: { default: [create_default_slot_57] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  panel9 = new Panel_default({
    props: {
      title: "Collapsed",
      round: true,
      disabled: true,
      $$slots: { default: [create_default_slot_410] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  panel10 = new Panel_default({
    props: {
      title: "Expanded",
      open: true,
      round: true,
      disabled: true,
      $$slots: { default: [create_default_slot_315] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  panel11 = new Panel_default({
    props: {
      title: "Collapsed",
      round: true,
      collapsible: true,
      $$slots: { default: [create_default_slot_217] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  panel12 = new Panel_default({
    props: {
      title: "Panel 2",
      open: true,
      round: true,
      collapsible: true,
      $$slots: { default: [create_default_slot15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[1]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Panel";
      t1 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t3 = space();
      create_component(panel0.$$.fragment);
      t4 = space();
      create_component(panel1.$$.fragment);
      t5 = space();
      create_component(panel2.$$.fragment);
      t6 = space();
      h31 = element2("h3");
      h31.textContent = "No title";
      t8 = space();
      create_component(panel3.$$.fragment);
      t9 = space();
      create_component(panel4.$$.fragment);
      t10 = space();
      h32 = element2("h3");
      h32.textContent = "Types & variations";
      t12 = space();
      create_component(panel5.$$.fragment);
      t13 = space();
      create_component(panel6.$$.fragment);
      t14 = space();
      create_component(panel7.$$.fragment);
      t15 = space();
      create_component(panel8.$$.fragment);
      t16 = space();
      h33 = element2("h3");
      h33.textContent = "Round & disabled";
      t18 = space();
      create_component(panel9.$$.fragment);
      t19 = space();
      create_component(panel10.$$.fragment);
      t20 = space();
      h34 = element2("h3");
      h34.textContent = "Collapsible";
      t22 = space();
      create_component(panel11.$$.fragment);
      t23 = space();
      create_component(panel12.$$.fragment);
      t24 = space();
      create_component(codeexample.$$.fragment);
      t25 = space();
      create_component(api.$$.fragment);
      add_location(h2, file77, 0, 0, 0);
      add_location(h30, file77, 2, 0, 16);
      add_location(h31, file77, 16, 0, 240);
      add_location(h32, file77, 27, 0, 364);
      add_location(h33, file77, 45, 0, 771);
      add_location(h34, file77, 55, 0, 966);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t3, anchor);
      mount_component(panel0, target, anchor);
      insert_dev(target, t4, anchor);
      mount_component(panel1, target, anchor);
      insert_dev(target, t5, anchor);
      mount_component(panel2, target, anchor);
      insert_dev(target, t6, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t8, anchor);
      mount_component(panel3, target, anchor);
      insert_dev(target, t9, anchor);
      mount_component(panel4, target, anchor);
      insert_dev(target, t10, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t12, anchor);
      mount_component(panel5, target, anchor);
      insert_dev(target, t13, anchor);
      mount_component(panel6, target, anchor);
      insert_dev(target, t14, anchor);
      mount_component(panel7, target, anchor);
      insert_dev(target, t15, anchor);
      mount_component(panel8, target, anchor);
      insert_dev(target, t16, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t18, anchor);
      mount_component(panel9, target, anchor);
      insert_dev(target, t19, anchor);
      mount_component(panel10, target, anchor);
      insert_dev(target, t20, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t22, anchor);
      mount_component(panel11, target, anchor);
      insert_dev(target, t23, anchor);
      mount_component(panel12, target, anchor);
      insert_dev(target, t24, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t25, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const panel0_changes = {};
      if (dirty & /*$$scope*/
      4) {
        panel0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel0.$set(panel0_changes);
      const panel1_changes = {};
      if (dirty & /*$$scope*/
      4) {
        panel1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel1.$set(panel1_changes);
      const panel2_changes = {};
      if (dirty & /*$$scope*/
      4) {
        panel2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel2.$set(panel2_changes);
      const panel3_changes = {};
      if (dirty & /*$$scope*/
      4) {
        panel3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel3.$set(panel3_changes);
      const panel4_changes = {};
      if (dirty & /*$$scope*/
      4) {
        panel4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel4.$set(panel4_changes);
      const panel5_changes = {};
      if (dirty & /*$$scope*/
      4) {
        panel5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel5.$set(panel5_changes);
      const panel6_changes = {};
      if (dirty & /*$$scope*/
      4) {
        panel6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel6.$set(panel6_changes);
      const panel7_changes = {};
      if (dirty & /*$$scope*/
      4) {
        panel7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel7.$set(panel7_changes);
      const panel8_changes = {};
      if (dirty & /*$$scope*/
      4) {
        panel8_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel8.$set(panel8_changes);
      const panel9_changes = {};
      if (dirty & /*$$scope*/
      4) {
        panel9_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel9.$set(panel9_changes);
      const panel10_changes = {};
      if (dirty & /*$$scope*/
      4) {
        panel10_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel10.$set(panel10_changes);
      const panel11_changes = {};
      if (dirty & /*$$scope*/
      4) {
        panel11_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel11.$set(panel11_changes);
      const panel12_changes = {};
      if (dirty & /*$$scope*/
      4) {
        panel12_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel12.$set(panel12_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(panel0.$$.fragment, local);
      transition_in(panel1.$$.fragment, local);
      transition_in(panel2.$$.fragment, local);
      transition_in(panel3.$$.fragment, local);
      transition_in(panel4.$$.fragment, local);
      transition_in(panel5.$$.fragment, local);
      transition_in(panel6.$$.fragment, local);
      transition_in(panel7.$$.fragment, local);
      transition_in(panel8.$$.fragment, local);
      transition_in(panel9.$$.fragment, local);
      transition_in(panel10.$$.fragment, local);
      transition_in(panel11.$$.fragment, local);
      transition_in(panel12.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(panel0.$$.fragment, local);
      transition_out(panel1.$$.fragment, local);
      transition_out(panel2.$$.fragment, local);
      transition_out(panel3.$$.fragment, local);
      transition_out(panel4.$$.fragment, local);
      transition_out(panel5.$$.fragment, local);
      transition_out(panel6.$$.fragment, local);
      transition_out(panel7.$$.fragment, local);
      transition_out(panel8.$$.fragment, local);
      transition_out(panel9.$$.fragment, local);
      transition_out(panel10.$$.fragment, local);
      transition_out(panel11.$$.fragment, local);
      transition_out(panel12.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(h30);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(t5);
        detach_dev(t6);
        detach_dev(h31);
        detach_dev(t8);
        detach_dev(t9);
        detach_dev(t10);
        detach_dev(h32);
        detach_dev(t12);
        detach_dev(t13);
        detach_dev(t14);
        detach_dev(t15);
        detach_dev(t16);
        detach_dev(h33);
        detach_dev(t18);
        detach_dev(t19);
        detach_dev(t20);
        detach_dev(h34);
        detach_dev(t22);
        detach_dev(t23);
        detach_dev(t24);
        detach_dev(t25);
      }
      destroy_component(panel0, detaching);
      destroy_component(panel1, detaching);
      destroy_component(panel2, detaching);
      destroy_component(panel3, detaching);
      destroy_component(panel4, detaching);
      destroy_component(panel5, detaching);
      destroy_component(panel6, detaching);
      destroy_component(panel7, detaching);
      destroy_component(panel8, detaching);
      destroy_component(panel9, detaching);
      destroy_component(panel10, detaching);
      destroy_component(panel11, detaching);
      destroy_component(panel12, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment84.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance84($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Panel", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "danger",
      description: "Panel type: danger"
    },
    {
      name: "disabled",
      description: "Make the panel disabled."
    },
    {
      name: "collapsible",
      description: "If present, the panel will expand/collapse on title click or Enter key or Space."
    },
    {
      name: "info",
      description: "Panel type: info"
    },
    {
      name: "open",
      description: "Panel initial open state."
    },
    {
      name: "round",
      description: "Adds rounded corners to the panel."
    },
    {
      name: "success",
      description: "Panel type: success"
    },
    {
      name: "title",
      type: "string",
      description: "Panel title."
    },
    {
      name: "warning",
      description: "Panel type: warning"
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "on:close",
      type: "function",
      description: "Triggered after the panel is closed."
    },
    {
      name: "on:open",
      type: "function",
      description: "Triggered after the panel is opened."
    }
  ];
  const exampleHtml = `
<Panel title="Hello" round collapsible>
	<p>This is panel contents</p>
	<p>Hello world!</p>
	<p>This is panel contents</p>
	<Button>Action</Button>
</Panel>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Panel> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    Panel: Panel_default,
    Button: Button_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    exampleHtml
  });
  return [apiProps, exampleHtml];
}
var Panel_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance84, create_fragment84, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Panel_1",
      options,
      id: create_fragment84.name
    });
  }
};
var Panel_default2 = Panel_1;

// docs-src/components/popover/Popover.svelte
var file78 = "docs-src/components/popover/Popover.svelte";
function create_default_slot_126(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Open popover");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_126.name,
    type: "slot",
    source: '(15:0) <Button on:click=\\"{popover1.open}\\">',
    ctx
  });
  return block;
}
function create_default_slot_1111(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Click me");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1111.name,
    type: "slot",
    source: '(20:1) <Button on:click=\\"{popover1.close}\\">',
    ctx
  });
  return block;
}
function create_default_slot_106(ctx) {
  let h2;
  let t1;
  let p;
  let t3;
  let button;
  let current;
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_1111] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", function() {
    if (is_function(
      /*popover1*/
      ctx[0].close
    ))
      ctx[0].close.apply(this, arguments);
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Context information";
      t1 = space();
      p = element2("p");
      p.textContent = "Some text";
      t3 = space();
      create_component(button.$$.fragment);
      add_location(h2, file78, 16, 1, 705);
      add_location(p, file78, 17, 1, 735);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p, anchor);
      insert_dev(target, t3, anchor);
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p);
        detach_dev(t3);
      }
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_106.name,
    type: "slot",
    source: '(16:0) <Popover bind:this=\\"{popover1}\\">',
    ctx
  });
  return block;
}
function create_default_slot_97(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Open popover");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_97.name,
    type: "slot",
    source: '(34:0) <Button on:click=\\"{popover5.open}\\">',
    ctx
  });
  return block;
}
function create_default_slot_87(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Click me");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_87.name,
    type: "slot",
    source: '(38:1) <Button on:click=\\"{popover5.close}\\">',
    ctx
  });
  return block;
}
function create_default_slot_78(ctx) {
  let h2;
  let t1;
  let p;
  let t3;
  let button;
  let current;
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_87] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", function() {
    if (is_function(
      /*popover5*/
      ctx[4].close
    ))
      ctx[4].close.apply(this, arguments);
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Context information";
      t1 = space();
      p = element2("p");
      p.textContent = "Some text";
      t3 = space();
      create_component(button.$$.fragment);
      add_location(h2, file78, 35, 1, 1365);
      add_location(p, file78, 36, 1, 1395);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p, anchor);
      insert_dev(target, t3, anchor);
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p);
        detach_dev(t3);
      }
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_78.name,
    type: "slot",
    source: '(35:0) <Popover hideTip bind:this=\\"{popover5}\\">',
    ctx
  });
  return block;
}
function create_default_slot_68(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Open popover");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_68.name,
    type: "slot",
    source: '(43:0) <Button on:click=\\"{popover2.open}\\">',
    ctx
  });
  return block;
}
function create_default_slot_58(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Smaller offset");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_58.name,
    type: "slot",
    source: '(44:0) <Popover bind:this=\\"{popover2}\\" offset=\\"-20\\">',
    ctx
  });
  return block;
}
function create_default_slot_411(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Open popover");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_411.name,
    type: "slot",
    source: '(46:0) <Button on:click=\\"{popover3.open}\\">',
    ctx
  });
  return block;
}
function create_default_slot_316(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Bigger offset");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_316.name,
    type: "slot",
    source: '(47:0) <Popover bind:this=\\"{popover3}\\" offset=\\"20\\">',
    ctx
  });
  return block;
}
function create_default_slot_218(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Update content");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_218.name,
    type: "slot",
    source: '(54:1) <Button success on:click=\\"{updateContent}\\">',
    ctx
  });
  return block;
}
function create_default_slot_127(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Close");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_127.name,
    type: "slot",
    source: '(55:1) <Button on:click=\\"{popover4.close}\\">',
    ctx
  });
  return block;
}
function create_default_slot16(ctx) {
  let html_tag;
  let t0;
  let button0;
  let t1;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      success: true,
      $$slots: { default: [create_default_slot_218] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button0.$on(
    "click",
    /*updateContent*/
    ctx[6]
  );
  button1 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_127] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1.$on("click", function() {
    if (is_function(
      /*popover4*/
      ctx[3].close
    ))
      ctx[3].close.apply(this, arguments);
  });
  const block = {
    c: function create() {
      html_tag = new HtmlTag(false);
      t0 = space();
      create_component(button0.$$.fragment);
      t1 = space();
      create_component(button1.$$.fragment);
      html_tag.a = t0;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*content*/
        ctx[5],
        target,
        anchor
      );
      insert_dev(target, t0, anchor);
      mount_component(button0, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*content*/
      32)
        html_tag.p(
          /*content*/
          ctx[5]
        );
      const button0_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button0_changes.$$scope = { dirty, ctx };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button1_changes.$$scope = { dirty, ctx };
      }
      button1.$set(button1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        html_tag.d();
        detach_dev(t0);
        detach_dev(t1);
      }
      destroy_component(button0, detaching);
      destroy_component(button1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot16.name,
    type: "slot",
    source: '(52:0) <Popover bind:this=\\"{popover4}\\" position=\\"top\\">',
    ctx
  });
  return block;
}
function create_fragment85(ctx) {
  let h2;
  let t1;
  let p0;
  let t2;
  let em0;
  let t4;
  let em1;
  let t6;
  let t7;
  let ul;
  let li0;
  let li1;
  let li2;
  let li3;
  let li4;
  let t13;
  let hr;
  let t14;
  let h30;
  let t16;
  let button0;
  let t17;
  let popover0;
  let t18;
  let h31;
  let t20;
  let div;
  let button1;
  let t21;
  let h32;
  let t23;
  let p1;
  let t25;
  let button2;
  let t26;
  let popover1_1;
  let t27;
  let h33;
  let t29;
  let button3;
  let t30;
  let popover2_1;
  let t31;
  let button4;
  let t32;
  let popover3_1;
  let t33;
  let h34;
  let t35;
  let button5;
  let t36;
  let popover4_1;
  let t37;
  let codeexample;
  let t38;
  let api0;
  let t39;
  let api1;
  let current;
  button0 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_126] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button0.$on("click", function() {
    if (is_function(
      /*popover1*/
      ctx[0].open
    ))
      ctx[0].open.apply(this, arguments);
  });
  let popover0_props = {
    $$slots: { default: [create_default_slot_106] },
    $$scope: { ctx }
  };
  popover0 = new Popover_default({ props: popover0_props, $$inline: true });
  ctx[10](popover0);
  button1 = new Button_default({
    props: { round: true, icon: "cog" },
    $$inline: true
  });
  button1.$on("click", function() {
    if (is_function(
      /*popover1*/
      ctx[0].open
    ))
      ctx[0].open.apply(this, arguments);
  });
  button2 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_97] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button2.$on("click", function() {
    if (is_function(
      /*popover5*/
      ctx[4].open
    ))
      ctx[4].open.apply(this, arguments);
  });
  let popover1_1_props = {
    hideTip: true,
    $$slots: { default: [create_default_slot_78] },
    $$scope: { ctx }
  };
  popover1_1 = new Popover_default({ props: popover1_1_props, $$inline: true });
  ctx[11](popover1_1);
  button3 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_68] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button3.$on("click", function() {
    if (is_function(
      /*popover2*/
      ctx[1].open
    ))
      ctx[1].open.apply(this, arguments);
  });
  let popover2_1_props = {
    offset: "-20",
    $$slots: { default: [create_default_slot_58] },
    $$scope: { ctx }
  };
  popover2_1 = new Popover_default({ props: popover2_1_props, $$inline: true });
  ctx[12](popover2_1);
  button4 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_411] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button4.$on("click", function() {
    if (is_function(
      /*popover3*/
      ctx[2].open
    ))
      ctx[2].open.apply(this, arguments);
  });
  let popover3_1_props = {
    offset: "20",
    $$slots: { default: [create_default_slot_316] },
    $$scope: { ctx }
  };
  popover3_1 = new Popover_default({ props: popover3_1_props, $$inline: true });
  ctx[13](popover3_1);
  button5 = new Button_default({
    props: { round: true, icon: "help" },
    $$inline: true
  });
  button5.$on("click", function() {
    if (is_function(
      /*popover4*/
      ctx[3].open
    ))
      ctx[3].open.apply(this, arguments);
  });
  let popover4_1_props = {
    position: "top",
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx }
  };
  popover4_1 = new Popover_default({ props: popover4_1_props, $$inline: true });
  ctx[14](popover4_1);
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[9]
    ) },
    $$inline: true
  });
  api0 = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[7]
    ) },
    $$inline: true
  });
  api1 = new ApiTable_default({
    props: {
      props: (
        /*instanceApiProps*/
        ctx[8]
      ),
      title: "Instance API",
      description: "The component exposes <em>this</em> property, to which a variable can be bound, creating an instance of the component, with the following API"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Popover";
      t1 = space();
      p0 = element2("p");
      t2 = text("If a ");
      em0 = element2("em");
      em0.textContent = "Dialog";
      t4 = text(" and ");
      em1 = element2("em");
      em1.textContent = "Tooltip";
      t6 = text(" had a child - this would be it.");
      t7 = space();
      ul = element2("ul");
      li0 = element2("li");
      li0.textContent = "It's a container that can be opened like a dialog, but will be attached to the target element, like a tooltip.\n	";
      li1 = element2("li");
      li1.textContent = "It's a great way to display additional information or actions for a specific element on the page.\n	";
      li2 = element2("li");
      li2.textContent = "It can contain other components (e.g. buttons) and can serve as a free-form menu.\n	";
      li3 = element2("li");
      li3.textContent = "It has focus-trap (like dialog), so once it's opened - focus goes in and user can not tab-out of it.\n	";
      li4 = element2("li");
      li4.textContent = "It can be closed using Escape key or by clicking outside of it.";
      t13 = space();
      hr = element2("hr");
      t14 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t16 = space();
      create_component(button0.$$.fragment);
      t17 = space();
      create_component(popover0.$$.fragment);
      t18 = space();
      h31 = element2("h3");
      h31.textContent = "Target at the edge - tip should remain aligned";
      t20 = space();
      div = element2("div");
      create_component(button1.$$.fragment);
      t21 = space();
      h32 = element2("h3");
      h32.textContent = "No tip";
      t23 = space();
      p1 = element2("p");
      p1.textContent = "Styling is different than the normal popover, because the use-case for no-tip popover\n	is more similar to a dropdown rather than a tooltip or a popover,\n	so it makes sense that it also looks for the role.";
      t25 = space();
      create_component(button2.$$.fragment);
      t26 = space();
      create_component(popover1_1.$$.fragment);
      t27 = space();
      h33 = element2("h3");
      h33.textContent = "Custom offset";
      t29 = space();
      create_component(button3.$$.fragment);
      t30 = space();
      create_component(popover2_1.$$.fragment);
      t31 = space();
      create_component(button4.$$.fragment);
      t32 = space();
      create_component(popover3_1.$$.fragment);
      t33 = space();
      h34 = element2("h3");
      h34.textContent = "Update contents";
      t35 = space();
      create_component(button5.$$.fragment);
      t36 = space();
      create_component(popover4_1.$$.fragment);
      t37 = space();
      create_component(codeexample.$$.fragment);
      t38 = space();
      create_component(api0.$$.fragment);
      t39 = space();
      create_component(api1.$$.fragment);
      add_location(h2, file78, 0, 0, 0);
      add_location(em0, file78, 2, 8, 26);
      add_location(em1, file78, 2, 28, 46);
      add_location(p0, file78, 2, 0, 18);
      add_location(li0, file78, 4, 1, 105);
      add_location(li1, file78, 5, 1, 221);
      add_location(li2, file78, 6, 1, 324);
      add_location(li3, file78, 7, 1, 411);
      add_location(li4, file78, 8, 1, 517);
      add_location(ul, file78, 3, 0, 99);
      add_location(hr, file78, 11, 0, 592);
      add_location(h30, file78, 13, 0, 598);
      add_location(h31, file78, 23, 0, 821);
      set_style(div, "display", "flex");
      set_style(div, "justify-content", "flex-end");
      set_style(div, "padding", "1rem");
      set_style(div, "background-color", "#0003");
      add_location(div, file78, 24, 0, 877);
      add_location(h32, file78, 28, 0, 1037);
      add_location(p1, file78, 29, 0, 1053);
      add_location(h33, file78, 41, 0, 1480);
      add_location(h34, file78, 49, 0, 1758);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p0, anchor);
      append_dev(p0, t2);
      append_dev(p0, em0);
      append_dev(p0, t4);
      append_dev(p0, em1);
      append_dev(p0, t6);
      insert_dev(target, t7, anchor);
      insert_dev(target, ul, anchor);
      append_dev(ul, li0);
      append_dev(ul, li1);
      append_dev(ul, li2);
      append_dev(ul, li3);
      append_dev(ul, li4);
      insert_dev(target, t13, anchor);
      insert_dev(target, hr, anchor);
      insert_dev(target, t14, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t16, anchor);
      mount_component(button0, target, anchor);
      insert_dev(target, t17, anchor);
      mount_component(popover0, target, anchor);
      insert_dev(target, t18, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t20, anchor);
      insert_dev(target, div, anchor);
      mount_component(button1, div, null);
      insert_dev(target, t21, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t23, anchor);
      insert_dev(target, p1, anchor);
      insert_dev(target, t25, anchor);
      mount_component(button2, target, anchor);
      insert_dev(target, t26, anchor);
      mount_component(popover1_1, target, anchor);
      insert_dev(target, t27, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t29, anchor);
      mount_component(button3, target, anchor);
      insert_dev(target, t30, anchor);
      mount_component(popover2_1, target, anchor);
      insert_dev(target, t31, anchor);
      mount_component(button4, target, anchor);
      insert_dev(target, t32, anchor);
      mount_component(popover3_1, target, anchor);
      insert_dev(target, t33, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t35, anchor);
      mount_component(button5, target, anchor);
      insert_dev(target, t36, anchor);
      mount_component(popover4_1, target, anchor);
      insert_dev(target, t37, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t38, anchor);
      mount_component(api0, target, anchor);
      insert_dev(target, t39, anchor);
      mount_component(api1, target, anchor);
      current = true;
    },
    p: function update2(new_ctx, [dirty]) {
      ctx = new_ctx;
      const button0_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button0_changes.$$scope = { dirty, ctx };
      }
      button0.$set(button0_changes);
      const popover0_changes = {};
      if (dirty & /*$$scope, popover1*/
      32769) {
        popover0_changes.$$scope = { dirty, ctx };
      }
      popover0.$set(popover0_changes);
      const button2_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button2_changes.$$scope = { dirty, ctx };
      }
      button2.$set(button2_changes);
      const popover1_1_changes = {};
      if (dirty & /*$$scope, popover5*/
      32784) {
        popover1_1_changes.$$scope = { dirty, ctx };
      }
      popover1_1.$set(popover1_1_changes);
      const button3_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button3_changes.$$scope = { dirty, ctx };
      }
      button3.$set(button3_changes);
      const popover2_1_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        popover2_1_changes.$$scope = { dirty, ctx };
      }
      popover2_1.$set(popover2_1_changes);
      const button4_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        button4_changes.$$scope = { dirty, ctx };
      }
      button4.$set(button4_changes);
      const popover3_1_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        popover3_1_changes.$$scope = { dirty, ctx };
      }
      popover3_1.$set(popover3_1_changes);
      const popover4_1_changes = {};
      if (dirty & /*$$scope, popover4, content*/
      32808) {
        popover4_1_changes.$$scope = { dirty, ctx };
      }
      popover4_1.$set(popover4_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(popover0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(popover1_1.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      transition_in(popover2_1.$$.fragment, local);
      transition_in(button4.$$.fragment, local);
      transition_in(popover3_1.$$.fragment, local);
      transition_in(button5.$$.fragment, local);
      transition_in(popover4_1.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api0.$$.fragment, local);
      transition_in(api1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(popover0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(popover1_1.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      transition_out(popover2_1.$$.fragment, local);
      transition_out(button4.$$.fragment, local);
      transition_out(popover3_1.$$.fragment, local);
      transition_out(button5.$$.fragment, local);
      transition_out(popover4_1.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api0.$$.fragment, local);
      transition_out(api1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p0);
        detach_dev(t7);
        detach_dev(ul);
        detach_dev(t13);
        detach_dev(hr);
        detach_dev(t14);
        detach_dev(h30);
        detach_dev(t16);
        detach_dev(t17);
        detach_dev(t18);
        detach_dev(h31);
        detach_dev(t20);
        detach_dev(div);
        detach_dev(t21);
        detach_dev(h32);
        detach_dev(t23);
        detach_dev(p1);
        detach_dev(t25);
        detach_dev(t26);
        detach_dev(t27);
        detach_dev(h33);
        detach_dev(t29);
        detach_dev(t30);
        detach_dev(t31);
        detach_dev(t32);
        detach_dev(t33);
        detach_dev(h34);
        detach_dev(t35);
        detach_dev(t36);
        detach_dev(t37);
        detach_dev(t38);
        detach_dev(t39);
      }
      destroy_component(button0, detaching);
      ctx[10](null);
      destroy_component(popover0, detaching);
      destroy_component(button1);
      destroy_component(button2, detaching);
      ctx[11](null);
      destroy_component(popover1_1, detaching);
      destroy_component(button3, detaching);
      ctx[12](null);
      destroy_component(popover2_1, detaching);
      destroy_component(button4, detaching);
      ctx[13](null);
      destroy_component(popover3_1, detaching);
      destroy_component(button5, detaching);
      ctx[14](null);
      destroy_component(popover4_1, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api0, detaching);
      destroy_component(api1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment85.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance85($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Popover", slots2, []);
  let popover1, popover2, popover3, popover4, popover5;
  let content = "<h2>Context information</h2><p>Some text</p>";
  function updateContent() {
    $$invalidate2(5, content = "<h2>Updated content</h2><p>Some text</p><p>Some more text</p>");
  }
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "dontHideOnTargetClick",
      description: "When present, it will keep the popover open when the target is clicked again."
    },
    {
      name: "hideTip",
      description: "Display just the container, without the tip (small triangle pointing at the target)."
    },
    {
      name: "offset",
      type: "number",
      default: "2",
      description: "Customize popover offset. Use negative number for smaller offset or positive for bigger"
    },
    {
      name: "position",
      type: ["top", "bottom"],
      default: "bottom",
      description: "Prefer the position of the popover to be above (top) or below (bottom) the target element."
    },
    {
      name: "setMinWidthToTarget",
      description: "When present, it will make the popover min-width the same as the target."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "bind:contentElement",
      type: "element",
      description: "Exposes the HTML element of the content div."
    }
  ];
  const instanceApiProps = [
    {
      name: "close",
      type: "function",
      description: "Closes the popover."
    },
    {
      name: "open",
      type: "function",
      description: "Opens the popover."
    },
    {
      name: "isOpened",
      type: "function",
      description: "Returns the opened state."
    },
    {
      name: "updatePosition",
      type: "function",
      description: "Recalculates the position of the popover."
    }
  ];
  const exampleHtml = `
<Button on:click="{popover1.open}">Open popover</Button>
<Popover bind:this="{popover1}">
	<h2>Context information</h2>
	<p>Some text</p>
	<Button on:click="{popover1.close}">Click me</Button>
</Popover>

<script>
	let popover1;
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Popover> was created with unknown prop '${key}'`);
  });
  function popover0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popover1 = $$value;
      $$invalidate2(0, popover1);
    });
  }
  function popover1_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popover5 = $$value;
      $$invalidate2(4, popover5);
    });
  }
  function popover2_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popover2 = $$value;
      $$invalidate2(1, popover2);
    });
  }
  function popover3_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popover3 = $$value;
      $$invalidate2(2, popover3);
    });
  }
  function popover4_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popover4 = $$value;
      $$invalidate2(3, popover4);
    });
  }
  $$self2.$capture_state = () => ({
    Popover: Popover_default,
    Button: Button_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    popover1,
    popover2,
    popover3,
    popover4,
    popover5,
    content,
    updateContent,
    apiProps,
    instanceApiProps,
    exampleHtml
  });
  $$self2.$inject_state = ($$props3) => {
    if ("popover1" in $$props3)
      $$invalidate2(0, popover1 = $$props3.popover1);
    if ("popover2" in $$props3)
      $$invalidate2(1, popover2 = $$props3.popover2);
    if ("popover3" in $$props3)
      $$invalidate2(2, popover3 = $$props3.popover3);
    if ("popover4" in $$props3)
      $$invalidate2(3, popover4 = $$props3.popover4);
    if ("popover5" in $$props3)
      $$invalidate2(4, popover5 = $$props3.popover5);
    if ("content" in $$props3)
      $$invalidate2(5, content = $$props3.content);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    popover1,
    popover2,
    popover3,
    popover4,
    popover5,
    content,
    updateContent,
    apiProps,
    instanceApiProps,
    exampleHtml,
    popover0_binding,
    popover1_1_binding,
    popover2_1_binding,
    popover3_1_binding,
    popover4_1_binding
  ];
}
var Popover_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance85, create_fragment85, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popover_1",
      options,
      id: create_fragment85.name
    });
  }
};
var Popover_default2 = Popover_1;

// docs-src/components/grid/Grid.svelte
var { console: console_114 } = globals;
var file79 = "docs-src/components/grid/Grid.svelte";
function create_fragment86(ctx) {
  let h2;
  let t1;
  let p;
  let t3;
  let div;
  let grid;
  let t4;
  let codeexample;
  let t5;
  let api;
  let current;
  grid = new Grid_default({
    props: {
      round: true,
      title: "Grid with data",
      columns: (
        /*columns*/
        ctx[1]
      ),
      data: (
        /*data*/
        ctx[2]
      ),
      multiselect: true
    },
    $$inline: true
  });
  grid.$on("select", onclick2);
  grid.$on("click", onclick2);
  grid.$on("dblclick", onclick2);
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[3]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Grid [alpha version]";
      t1 = space();
      p = element2("p");
      p.textContent = "Grid component is basically a table on steroids.";
      t3 = space();
      div = element2("div");
      create_component(grid.$$.fragment);
      t4 = space();
      create_component(codeexample.$$.fragment);
      t5 = space();
      create_component(api.$$.fragment);
      add_location(h2, file79, 0, 0, 0);
      add_location(p, file79, 1, 0, 30);
      attr_dev(div, "class", "grid-viewport");
      add_location(div, file79, 2, 0, 87);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, div, anchor);
      mount_component(grid, div, null);
      insert_dev(target, t4, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t5, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(grid.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(grid.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p);
        detach_dev(t3);
        detach_dev(div);
        detach_dev(t4);
        detach_dev(t5);
      }
      destroy_component(grid);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment86.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function onclick2(e) {
  console.log(e.type);
}
function instance86($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Grid", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "columns",
      type: "array",
      description: "Array of columns definition. Each objects defines and describes a column in the grid."
    },
    {
      name: "data",
      type: "array",
      description: "Array of items (each would constitute 1 row of the grid)."
    },
    {
      name: "round",
      description: "Adds rounded corners to the table."
    },
    {
      name: "rowSelector",
      type: "string",
      default: "tbody tr",
      description: "A selector for a table row.<br>This is useful if a table needs row groups, in which case it would have a mix of TRs and TBODYs for rows. Both can have the same class, e.g. <em>.row</em> and this selector should then be provided here."
    },
    {
      name: "scrollContainer",
      type: ["string", "Element"],
      default: "table wrapper",
      description: "Selector or HTML Element to the scroll container. If table wrapper's height is not set to 100% of the container, and is taller than the container - the container will have to be scrollable, and in this case it must be provided here."
    },
    {
      name: "scrollCorrectionOffset",
      type: "number",
      default: "0",
      description: "If an external <em>scrollContainer</em> is used - it is possible that it will have non-zero padding set, thus the table wrapper will be offset from the beginning of the container. This offset should be set here, so that the sticky headers work correctly."
    },
    {
      name: "interactive",
      type: ["true", "false"],
      description: "Makes table rows selectable with mouse and adds keyboard navigation."
    },
    {
      name: "multiselect",
      type: ["true", "false"],
      description: "If true - a column with checkboxes will be added to the grid."
    },
    {
      name: "title",
      type: "string",
      description: "Ads header with title on top of the grid."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "on:click",
      type: "function",
      description: "Triggered after a row has been clicked."
    },
    {
      name: "on:dblclick",
      type: "function",
      description: "Triggered after a row has been double-clicked."
    },
    {
      name: "on:keydown",
      type: "function",
      description: "Triggered after key has been pressed."
    },
    {
      name: "on:select",
      type: "function",
      description: "Triggered after a row selection has changed."
    }
  ];
  const columns = [
    {
      field: "name",
      label: "Name",
      sortable: true,
      renderer: (item) => `<a href="#Grid/${item.id}">${item.name}</a>`
    },
    {
      field: "date",
      label: "Date",
      width: 200,
      sortable: true
    },
    {
      field: "price",
      label: "Price",
      width: 200,
      sortable: true,
      total: true,
      renderer: (item) => `\u20AC${item.price}`
    }
  ];
  const data = [
    {
      id: 1,
      name: "John Doe",
      date: "2020-01-01",
      price: 100
    },
    {
      id: 2,
      name: "Jane Doe",
      date: "2020-01-02",
      price: 200
    },
    {
      id: 3,
      name: "Jim Doe",
      date: "2020-01-03",
      price: 300
    },
    {
      id: 4,
      name: "Jill Doe",
      date: "2020-01-04",
      price: 400
    },
    {
      id: 5,
      name: "Jack Doe",
      date: "2020-01-05",
      price: 500
    },
    {
      id: 6,
      name: "John Smith",
      date: "2023-01-01",
      price: 100
    },
    {
      id: 7,
      name: "Jane Smith",
      date: "2023-01-02",
      price: 200
    },
    {
      id: 8,
      name: "Jim Smith",
      date: "2023-01-03",
      price: 300
    },
    {
      id: 9,
      name: "Jill Smith",
      date: "2023-01-04",
      price: 400
    },
    {
      id: 10,
      name: "Jack Smith",
      date: "2023-01-05",
      price: 500
    },
    {
      id: 11,
      name: "John Doe",
      date: "2020-01-01",
      price: 100
    },
    {
      id: 12,
      name: "Jane Doe",
      date: "2020-01-02",
      price: 200
    },
    {
      id: 13,
      name: "Jim Doe",
      date: "2020-01-03",
      price: 300
    },
    {
      id: 14,
      name: "Jill Doe",
      date: "2020-01-04",
      price: 400
    },
    {
      id: 15,
      name: "Jack Doe",
      date: "2020-01-05",
      price: 500
    },
    {
      id: 16,
      name: "John Smith",
      date: "2023-01-01",
      price: 100
    },
    {
      id: 17,
      name: "Jane Smith",
      date: "2023-01-02",
      price: 200
    },
    {
      id: 18,
      name: "Jim Smith",
      date: "2023-01-03",
      price: 300
    },
    {
      id: 19,
      name: "Jill Smith",
      date: "2023-01-04",
      price: 400
    },
    {
      id: 20,
      name: "Jack Smith",
      date: "2023-01-05",
      price: 500
    }
  ];
  const exampleHtml = `
<Grid {data} {columns} on:click="{onclick}"/>

<script>
import { Grid } from '@perfect-things/ui';

const columns = [
	{ field: 'name', label: 'Name', sortable: true },
	{ field: 'date', label: 'Date', width: 200, sortable: true },
	{ field: 'price', label: 'Price', width: 200, sortable: true, total: true,
		renderer: (item) => \`\u20AC\${item.price}\`
	}
];
const data = [
	{ id: 1, name: 'John Doe', date: '2020-01-01', price: 100 },
	{ id: 2, name: 'Jane Doe', date: '2020-01-02', price: 200 },
	{ id: 3, name: 'Jim Doe', date: '2020-01-03', price: 300 },
	{ id: 4, name: 'Jill Doe', date: '2020-01-04', price: 400 },
	{ id: 5, name: 'Jack Doe', date: '2020-01-05', price: 500 }
];

function onclick (e) {
	console.log(e.type);
}

&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_114.warn(`<Grid> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    Grid: Grid_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    columns,
    data,
    onclick: onclick2,
    exampleHtml
  });
  return [apiProps, columns, data, exampleHtml];
}
var Grid_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance86, create_fragment86, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Grid_1",
      options,
      id: create_fragment86.name
    });
  }
};
var Grid_default2 = Grid_1;

// docs-src/components/table/Table.svelte
var { console: console_115 } = globals;
var file80 = "docs-src/components/table/Table.svelte";
function create_default_slot17(ctx) {
  let thead0;
  let tr0;
  let th0;
  let th1;
  let th2;
  let t3;
  let thead1;
  let tr1;
  let th3;
  let t5;
  let tbody0;
  let tr2;
  let td0;
  let td1;
  let td2;
  let t9;
  let tr3;
  let td3;
  let td4;
  let td5;
  let t13;
  let tr4;
  let td6;
  let td7;
  let td8;
  let t17;
  let tr5;
  let td9;
  let td10;
  let td11;
  let t21;
  let tr6;
  let td12;
  let td13;
  let td14;
  let t25;
  let tr7;
  let td15;
  let td16;
  let td17;
  let t29;
  let tbody1;
  let tr8;
  let td18;
  let td19;
  let td20;
  let t33;
  let tr9;
  let td21;
  let td22;
  let td23;
  let t37;
  let tbody2;
  let tr10;
  let td24;
  let td25;
  let td26;
  let t41;
  let tr11;
  let td27;
  let td28;
  let td29;
  let t45;
  let tr12;
  let td30;
  let td31;
  let td32;
  let t49;
  let tr13;
  let td33;
  let td34;
  let td35;
  let t53;
  let tr14;
  let td36;
  let td37;
  let td38;
  let t57;
  let tr15;
  let td39;
  let td40;
  let td41;
  let t61;
  let tr16;
  let td42;
  let td43;
  let td44;
  let t65;
  let thead2;
  let tr17;
  let th4;
  let t67;
  let tbody3;
  let tr18;
  let td45;
  let td46;
  let td47;
  let t71;
  let tr19;
  let td48;
  let td49;
  let td50;
  let t75;
  let tr20;
  let td51;
  let td52;
  let td53;
  let t79;
  let tr21;
  let td54;
  let td55;
  let td56;
  let t83;
  let tr22;
  let td57;
  let td58;
  let td59;
  let t87;
  let tr23;
  let td60;
  let td61;
  let td62;
  let t91;
  let tr24;
  let td63;
  let td64;
  let td65;
  let t95;
  let tr25;
  let td66;
  let td67;
  let td68;
  let t99;
  let tr26;
  let td69;
  let td70;
  let td71;
  let t103;
  let tr27;
  let td72;
  let td73;
  let td74;
  let t107;
  let tr28;
  let td75;
  let td76;
  let td77;
  let t111;
  let tr29;
  let td78;
  let td79;
  let td80;
  let t115;
  let thead3;
  let tr30;
  let th5;
  let t117;
  let tbody4;
  let tr31;
  let td81;
  let td82;
  let td83;
  let t121;
  let tr32;
  let td84;
  let td85;
  let td86;
  let t125;
  let tr33;
  let td87;
  let td88;
  let td89;
  let t129;
  let tr34;
  let td90;
  let td91;
  let td92;
  let t133;
  let tr35;
  let td93;
  let td94;
  let td95;
  let t137;
  let tr36;
  let td96;
  let td97;
  let td98;
  let t141;
  let tr37;
  let td99;
  let td100;
  let td101;
  let t145;
  let tr38;
  let td102;
  let td103;
  let td104;
  let t149;
  let tr39;
  let td105;
  let td106;
  let td107;
  let t153;
  let tr40;
  let td108;
  let td109;
  let td110;
  let t157;
  let tr41;
  let td111;
  let td112;
  let td113;
  let t161;
  let tr42;
  let td114;
  let td115;
  let td116;
  let t165;
  let thead4;
  let tr43;
  let th6;
  let t167;
  let tbody5;
  let tr44;
  let td117;
  let td118;
  let td119;
  let t171;
  let tr45;
  let td120;
  let td121;
  let td122;
  let t175;
  let tr46;
  let td123;
  let td124;
  let td125;
  let t179;
  let tr47;
  let td126;
  let td127;
  let td128;
  let t183;
  let tr48;
  let td129;
  let td130;
  let td131;
  let t187;
  let tr49;
  let td132;
  let td133;
  let td134;
  let t191;
  let tr50;
  let td135;
  let td136;
  let td137;
  let t195;
  let tr51;
  let td138;
  let td139;
  let td140;
  let t199;
  let tr52;
  let td141;
  let td142;
  let td143;
  let t203;
  let tr53;
  let td144;
  let td145;
  let td146;
  let t207;
  let tr54;
  let td147;
  let td148;
  let td149;
  let t211;
  let tr55;
  let td150;
  let td151;
  let td152;
  let t215;
  let thead5;
  let tr56;
  let th7;
  let t217;
  let tbody6;
  let tr57;
  let td153;
  let td154;
  let td155;
  let t221;
  let tr58;
  let td156;
  let td157;
  let td158;
  let t225;
  let tr59;
  let td159;
  let td160;
  let td161;
  let t229;
  let tr60;
  let td162;
  let td163;
  let td164;
  let t233;
  let tr61;
  let td165;
  let td166;
  let td167;
  let t237;
  let tr62;
  let td168;
  let td169;
  let td170;
  let t241;
  let tr63;
  let td171;
  let td172;
  let td173;
  let t245;
  let tr64;
  let td174;
  let td175;
  let td176;
  let t249;
  let tr65;
  let td177;
  let td178;
  let td179;
  let t253;
  let tr66;
  let td180;
  let td181;
  let td182;
  let t257;
  let tr67;
  let td183;
  let td184;
  let td185;
  let t261;
  let tr68;
  let td186;
  let td187;
  let td188;
  let t265;
  let tfoot;
  let tr69;
  let td189;
  let td190;
  const block = {
    c: function create() {
      thead0 = element2("thead");
      tr0 = element2("tr");
      th0 = element2("th");
      th0.textContent = "Year";
      th1 = element2("th");
      th1.textContent = "Month";
      th2 = element2("th");
      th2.textContent = "Price";
      t3 = space();
      thead1 = element2("thead");
      tr1 = element2("tr");
      th3 = element2("th");
      th3.textContent = "Year: 2021";
      t5 = space();
      tbody0 = element2("tbody");
      tr2 = element2("tr");
      td0 = element2("td");
      td0.textContent = "2021";
      td1 = element2("td");
      td1.textContent = "January";
      td2 = element2("td");
      td2.textContent = "$100";
      t9 = space();
      tr3 = element2("tr");
      td3 = element2("td");
      td3.textContent = "2021";
      td4 = element2("td");
      td4.textContent = "February";
      td5 = element2("td");
      td5.textContent = "$80";
      t13 = space();
      tr4 = element2("tr");
      td6 = element2("td");
      td6.textContent = "2021";
      td7 = element2("td");
      td7.textContent = "March";
      td8 = element2("td");
      td8.textContent = "$80";
      t17 = space();
      tr5 = element2("tr");
      td9 = element2("td");
      td9.textContent = "2021";
      td10 = element2("td");
      td10.textContent = "April";
      td11 = element2("td");
      td11.textContent = "$80";
      t21 = space();
      tr6 = element2("tr");
      td12 = element2("td");
      td12.textContent = "2021";
      td13 = element2("td");
      td13.textContent = "May";
      td14 = element2("td");
      td14.textContent = "$80";
      t25 = space();
      tr7 = element2("tr");
      td15 = element2("td");
      td15.textContent = "2021";
      td16 = element2("td");
      td16.textContent = "June";
      td17 = element2("td");
      td17.textContent = "$80";
      t29 = space();
      tbody1 = element2("tbody");
      tr8 = element2("tr");
      td18 = element2("td");
      td18.textContent = "2021";
      td19 = element2("td");
      td19.textContent = "April 1";
      td20 = element2("td");
      td20.textContent = "$80";
      t33 = space();
      tr9 = element2("tr");
      td21 = element2("td");
      td21.textContent = "2021";
      td22 = element2("td");
      td22.textContent = "April 2";
      td23 = element2("td");
      td23.textContent = "$80";
      t37 = space();
      tbody2 = element2("tbody");
      tr10 = element2("tr");
      td24 = element2("td");
      td24.textContent = "2021";
      td25 = element2("td");
      td25.textContent = "May";
      td26 = element2("td");
      td26.textContent = "$80";
      t41 = space();
      tr11 = element2("tr");
      td27 = element2("td");
      td27.textContent = "2021";
      td28 = element2("td");
      td28.textContent = "July";
      td29 = element2("td");
      td29.textContent = "$80";
      t45 = space();
      tr12 = element2("tr");
      td30 = element2("td");
      td30.textContent = "2021";
      td31 = element2("td");
      td31.textContent = "August";
      td32 = element2("td");
      td32.textContent = "$80";
      t49 = space();
      tr13 = element2("tr");
      td33 = element2("td");
      td33.textContent = "2021";
      td34 = element2("td");
      td34.textContent = "September";
      td35 = element2("td");
      td35.textContent = "$80";
      t53 = space();
      tr14 = element2("tr");
      td36 = element2("td");
      td36.textContent = "2021";
      td37 = element2("td");
      td37.textContent = "October";
      td38 = element2("td");
      td38.textContent = "$80";
      t57 = space();
      tr15 = element2("tr");
      td39 = element2("td");
      td39.textContent = "2021";
      td40 = element2("td");
      td40.textContent = "November";
      td41 = element2("td");
      td41.textContent = "$80";
      t61 = space();
      tr16 = element2("tr");
      td42 = element2("td");
      td42.textContent = "2021";
      td43 = element2("td");
      td43.textContent = "December";
      td44 = element2("td");
      td44.textContent = "$80";
      t65 = space();
      thead2 = element2("thead");
      tr17 = element2("tr");
      th4 = element2("th");
      th4.textContent = "Year: 2020";
      t67 = space();
      tbody3 = element2("tbody");
      tr18 = element2("tr");
      td45 = element2("td");
      td45.textContent = "2020";
      td46 = element2("td");
      td46.textContent = "January";
      td47 = element2("td");
      td47.textContent = "$100";
      t71 = space();
      tr19 = element2("tr");
      td48 = element2("td");
      td48.textContent = "2020";
      td49 = element2("td");
      td49.textContent = "February";
      td50 = element2("td");
      td50.textContent = "$80";
      t75 = space();
      tr20 = element2("tr");
      td51 = element2("td");
      td51.textContent = "2020";
      td52 = element2("td");
      td52.textContent = "March";
      td53 = element2("td");
      td53.textContent = "$80";
      t79 = space();
      tr21 = element2("tr");
      td54 = element2("td");
      td54.textContent = "2020";
      td55 = element2("td");
      td55.textContent = "April";
      td56 = element2("td");
      td56.textContent = "$80";
      t83 = space();
      tr22 = element2("tr");
      td57 = element2("td");
      td57.textContent = "2020";
      td58 = element2("td");
      td58.textContent = "May";
      td59 = element2("td");
      td59.textContent = "$80";
      t87 = space();
      tr23 = element2("tr");
      td60 = element2("td");
      td60.textContent = "2020";
      td61 = element2("td");
      td61.textContent = "June";
      td62 = element2("td");
      td62.textContent = "$80";
      t91 = space();
      tr24 = element2("tr");
      td63 = element2("td");
      td63.textContent = "2020";
      td64 = element2("td");
      td64.textContent = "July";
      td65 = element2("td");
      td65.textContent = "$80";
      t95 = space();
      tr25 = element2("tr");
      td66 = element2("td");
      td66.textContent = "2020";
      td67 = element2("td");
      td67.textContent = "August";
      td68 = element2("td");
      td68.textContent = "$80";
      t99 = space();
      tr26 = element2("tr");
      td69 = element2("td");
      td69.textContent = "2020";
      td70 = element2("td");
      td70.textContent = "September";
      td71 = element2("td");
      td71.textContent = "$80";
      t103 = space();
      tr27 = element2("tr");
      td72 = element2("td");
      td72.textContent = "2020";
      td73 = element2("td");
      td73.textContent = "October";
      td74 = element2("td");
      td74.textContent = "$80";
      t107 = space();
      tr28 = element2("tr");
      td75 = element2("td");
      td75.textContent = "2020";
      td76 = element2("td");
      td76.textContent = "November";
      td77 = element2("td");
      td77.textContent = "$80";
      t111 = space();
      tr29 = element2("tr");
      td78 = element2("td");
      td78.textContent = "2020";
      td79 = element2("td");
      td79.textContent = "December";
      td80 = element2("td");
      td80.textContent = "$80";
      t115 = space();
      thead3 = element2("thead");
      tr30 = element2("tr");
      th5 = element2("th");
      th5.textContent = "Year: 2019";
      t117 = space();
      tbody4 = element2("tbody");
      tr31 = element2("tr");
      td81 = element2("td");
      td81.textContent = "2019";
      td82 = element2("td");
      td82.textContent = "January";
      td83 = element2("td");
      td83.textContent = "$100";
      t121 = space();
      tr32 = element2("tr");
      td84 = element2("td");
      td84.textContent = "2019";
      td85 = element2("td");
      td85.textContent = "February";
      td86 = element2("td");
      td86.textContent = "$80";
      t125 = space();
      tr33 = element2("tr");
      td87 = element2("td");
      td87.textContent = "2019";
      td88 = element2("td");
      td88.textContent = "March";
      td89 = element2("td");
      td89.textContent = "$80";
      t129 = space();
      tr34 = element2("tr");
      td90 = element2("td");
      td90.textContent = "2019";
      td91 = element2("td");
      td91.textContent = "April";
      td92 = element2("td");
      td92.textContent = "$80";
      t133 = space();
      tr35 = element2("tr");
      td93 = element2("td");
      td93.textContent = "2019";
      td94 = element2("td");
      td94.textContent = "May";
      td95 = element2("td");
      td95.textContent = "$80";
      t137 = space();
      tr36 = element2("tr");
      td96 = element2("td");
      td96.textContent = "2019";
      td97 = element2("td");
      td97.textContent = "June";
      td98 = element2("td");
      td98.textContent = "$80";
      t141 = space();
      tr37 = element2("tr");
      td99 = element2("td");
      td99.textContent = "2019";
      td100 = element2("td");
      td100.textContent = "July";
      td101 = element2("td");
      td101.textContent = "$80";
      t145 = space();
      tr38 = element2("tr");
      td102 = element2("td");
      td102.textContent = "2019";
      td103 = element2("td");
      td103.textContent = "August";
      td104 = element2("td");
      td104.textContent = "$80";
      t149 = space();
      tr39 = element2("tr");
      td105 = element2("td");
      td105.textContent = "2019";
      td106 = element2("td");
      td106.textContent = "September";
      td107 = element2("td");
      td107.textContent = "$80";
      t153 = space();
      tr40 = element2("tr");
      td108 = element2("td");
      td108.textContent = "2019";
      td109 = element2("td");
      td109.textContent = "October";
      td110 = element2("td");
      td110.textContent = "$80";
      t157 = space();
      tr41 = element2("tr");
      td111 = element2("td");
      td111.textContent = "2019";
      td112 = element2("td");
      td112.textContent = "November";
      td113 = element2("td");
      td113.textContent = "$80";
      t161 = space();
      tr42 = element2("tr");
      td114 = element2("td");
      td114.textContent = "2019";
      td115 = element2("td");
      td115.textContent = "December";
      td116 = element2("td");
      td116.textContent = "$80";
      t165 = space();
      thead4 = element2("thead");
      tr43 = element2("tr");
      th6 = element2("th");
      th6.textContent = "Year: 2018";
      t167 = space();
      tbody5 = element2("tbody");
      tr44 = element2("tr");
      td117 = element2("td");
      td117.textContent = "2018";
      td118 = element2("td");
      td118.textContent = "January";
      td119 = element2("td");
      td119.textContent = "$100";
      t171 = space();
      tr45 = element2("tr");
      td120 = element2("td");
      td120.textContent = "2018";
      td121 = element2("td");
      td121.textContent = "February";
      td122 = element2("td");
      td122.textContent = "$80";
      t175 = space();
      tr46 = element2("tr");
      td123 = element2("td");
      td123.textContent = "2018";
      td124 = element2("td");
      td124.textContent = "March";
      td125 = element2("td");
      td125.textContent = "$80";
      t179 = space();
      tr47 = element2("tr");
      td126 = element2("td");
      td126.textContent = "2018";
      td127 = element2("td");
      td127.textContent = "April";
      td128 = element2("td");
      td128.textContent = "$80";
      t183 = space();
      tr48 = element2("tr");
      td129 = element2("td");
      td129.textContent = "2018";
      td130 = element2("td");
      td130.textContent = "May";
      td131 = element2("td");
      td131.textContent = "$80";
      t187 = space();
      tr49 = element2("tr");
      td132 = element2("td");
      td132.textContent = "2018";
      td133 = element2("td");
      td133.textContent = "June";
      td134 = element2("td");
      td134.textContent = "$80";
      t191 = space();
      tr50 = element2("tr");
      td135 = element2("td");
      td135.textContent = "2018";
      td136 = element2("td");
      td136.textContent = "July";
      td137 = element2("td");
      td137.textContent = "$80";
      t195 = space();
      tr51 = element2("tr");
      td138 = element2("td");
      td138.textContent = "2018";
      td139 = element2("td");
      td139.textContent = "August";
      td140 = element2("td");
      td140.textContent = "$80";
      t199 = space();
      tr52 = element2("tr");
      td141 = element2("td");
      td141.textContent = "2018";
      td142 = element2("td");
      td142.textContent = "September";
      td143 = element2("td");
      td143.textContent = "$80";
      t203 = space();
      tr53 = element2("tr");
      td144 = element2("td");
      td144.textContent = "2018";
      td145 = element2("td");
      td145.textContent = "October";
      td146 = element2("td");
      td146.textContent = "$80";
      t207 = space();
      tr54 = element2("tr");
      td147 = element2("td");
      td147.textContent = "2018";
      td148 = element2("td");
      td148.textContent = "November";
      td149 = element2("td");
      td149.textContent = "$80";
      t211 = space();
      tr55 = element2("tr");
      td150 = element2("td");
      td150.textContent = "2018";
      td151 = element2("td");
      td151.textContent = "December";
      td152 = element2("td");
      td152.textContent = "$80";
      t215 = space();
      thead5 = element2("thead");
      tr56 = element2("tr");
      th7 = element2("th");
      th7.textContent = "Year: 2017";
      t217 = space();
      tbody6 = element2("tbody");
      tr57 = element2("tr");
      td153 = element2("td");
      td153.textContent = "2017";
      td154 = element2("td");
      td154.textContent = "January";
      td155 = element2("td");
      td155.textContent = "$100";
      t221 = space();
      tr58 = element2("tr");
      td156 = element2("td");
      td156.textContent = "2017";
      td157 = element2("td");
      td157.textContent = "February";
      td158 = element2("td");
      td158.textContent = "$80";
      t225 = space();
      tr59 = element2("tr");
      td159 = element2("td");
      td159.textContent = "2017";
      td160 = element2("td");
      td160.textContent = "March";
      td161 = element2("td");
      td161.textContent = "$80";
      t229 = space();
      tr60 = element2("tr");
      td162 = element2("td");
      td162.textContent = "2017";
      td163 = element2("td");
      td163.textContent = "April";
      td164 = element2("td");
      td164.textContent = "$80";
      t233 = space();
      tr61 = element2("tr");
      td165 = element2("td");
      td165.textContent = "2017";
      td166 = element2("td");
      td166.textContent = "May";
      td167 = element2("td");
      td167.textContent = "$80";
      t237 = space();
      tr62 = element2("tr");
      td168 = element2("td");
      td168.textContent = "2017";
      td169 = element2("td");
      td169.textContent = "June";
      td170 = element2("td");
      td170.textContent = "$80";
      t241 = space();
      tr63 = element2("tr");
      td171 = element2("td");
      td171.textContent = "2017";
      td172 = element2("td");
      td172.textContent = "July";
      td173 = element2("td");
      td173.textContent = "$80";
      t245 = space();
      tr64 = element2("tr");
      td174 = element2("td");
      td174.textContent = "2017";
      td175 = element2("td");
      td175.textContent = "August";
      td176 = element2("td");
      td176.textContent = "$80";
      t249 = space();
      tr65 = element2("tr");
      td177 = element2("td");
      td177.textContent = "2017";
      td178 = element2("td");
      td178.textContent = "September";
      td179 = element2("td");
      td179.textContent = "$80";
      t253 = space();
      tr66 = element2("tr");
      td180 = element2("td");
      td180.textContent = "2017";
      td181 = element2("td");
      td181.textContent = "October";
      td182 = element2("td");
      td182.textContent = "$80";
      t257 = space();
      tr67 = element2("tr");
      td183 = element2("td");
      td183.textContent = "2017";
      td184 = element2("td");
      td184.textContent = "November";
      td185 = element2("td");
      td185.textContent = "$80";
      t261 = space();
      tr68 = element2("tr");
      td186 = element2("td");
      td186.textContent = "2017";
      td187 = element2("td");
      td187.textContent = "December";
      td188 = element2("td");
      td188.textContent = "$80";
      t265 = space();
      tfoot = element2("tfoot");
      tr69 = element2("tr");
      td189 = element2("td");
      td189.textContent = "Sum";
      td190 = element2("td");
      td190.textContent = "$180";
      add_location(th0, file80, 9, 7, 177);
      add_location(th1, file80, 9, 20, 190);
      add_location(th2, file80, 9, 34, 204);
      add_location(tr0, file80, 9, 3, 173);
      add_location(thead0, file80, 8, 2, 162);
      attr_dev(th3, "colspan", "3");
      add_location(th3, file80, 12, 7, 252);
      add_location(tr1, file80, 12, 3, 248);
      add_location(thead1, file80, 11, 2, 237);
      add_location(td0, file80, 15, 23, 333);
      add_location(td1, file80, 15, 36, 346);
      add_location(td2, file80, 15, 52, 362);
      attr_dev(tr2, "class", "row-sel");
      add_location(tr2, file80, 15, 3, 313);
      add_location(td3, file80, 16, 23, 404);
      add_location(td4, file80, 16, 36, 417);
      add_location(td5, file80, 16, 53, 434);
      attr_dev(tr3, "class", "row-sel");
      add_location(tr3, file80, 16, 3, 384);
      add_location(td6, file80, 17, 23, 475);
      add_location(td7, file80, 17, 36, 488);
      add_location(td8, file80, 17, 50, 502);
      attr_dev(tr4, "class", "row-sel");
      add_location(tr4, file80, 17, 3, 455);
      add_location(td9, file80, 18, 23, 543);
      add_location(td10, file80, 18, 36, 556);
      add_location(td11, file80, 18, 50, 570);
      attr_dev(tr5, "class", "row-sel");
      add_location(tr5, file80, 18, 3, 523);
      add_location(td12, file80, 19, 23, 611);
      add_location(td13, file80, 19, 36, 624);
      add_location(td14, file80, 19, 48, 636);
      attr_dev(tr6, "class", "row-sel");
      add_location(tr6, file80, 19, 3, 591);
      add_location(td15, file80, 20, 23, 677);
      add_location(td16, file80, 20, 36, 690);
      add_location(td17, file80, 20, 49, 703);
      attr_dev(tr7, "class", "row-sel");
      add_location(tr7, file80, 20, 3, 657);
      add_location(tbody0, file80, 14, 2, 302);
      add_location(td18, file80, 23, 7, 775);
      add_location(td19, file80, 23, 20, 788);
      add_location(td20, file80, 23, 36, 804);
      add_location(tr8, file80, 23, 3, 771);
      add_location(td21, file80, 24, 7, 829);
      add_location(td22, file80, 24, 20, 842);
      add_location(td23, file80, 24, 36, 858);
      add_location(tr9, file80, 24, 3, 825);
      attr_dev(tbody1, "class", "row-sel row-group");
      add_location(tbody1, file80, 22, 2, 734);
      add_location(td24, file80, 27, 23, 920);
      add_location(td25, file80, 27, 36, 933);
      add_location(td26, file80, 27, 48, 945);
      attr_dev(tr10, "class", "row-sel");
      add_location(tr10, file80, 27, 3, 900);
      add_location(td27, file80, 28, 23, 986);
      add_location(td28, file80, 28, 36, 999);
      add_location(td29, file80, 28, 49, 1012);
      attr_dev(tr11, "class", "row-sel");
      add_location(tr11, file80, 28, 3, 966);
      add_location(td30, file80, 29, 23, 1053);
      add_location(td31, file80, 29, 36, 1066);
      add_location(td32, file80, 29, 51, 1081);
      attr_dev(tr12, "class", "row-sel");
      add_location(tr12, file80, 29, 3, 1033);
      add_location(td33, file80, 30, 23, 1122);
      add_location(td34, file80, 30, 36, 1135);
      add_location(td35, file80, 30, 54, 1153);
      attr_dev(tr13, "class", "row-sel");
      add_location(tr13, file80, 30, 3, 1102);
      add_location(td36, file80, 31, 23, 1194);
      add_location(td37, file80, 31, 36, 1207);
      add_location(td38, file80, 31, 52, 1223);
      attr_dev(tr14, "class", "row-sel");
      add_location(tr14, file80, 31, 3, 1174);
      add_location(td39, file80, 32, 23, 1264);
      add_location(td40, file80, 32, 36, 1277);
      add_location(td41, file80, 32, 53, 1294);
      attr_dev(tr15, "class", "row-sel");
      add_location(tr15, file80, 32, 3, 1244);
      add_location(td42, file80, 33, 23, 1335);
      add_location(td43, file80, 33, 36, 1348);
      add_location(td44, file80, 33, 53, 1365);
      attr_dev(tr16, "class", "row-sel");
      add_location(tr16, file80, 33, 3, 1315);
      add_location(tbody2, file80, 26, 2, 889);
      attr_dev(th4, "colspan", "3");
      add_location(th4, file80, 36, 7, 1411);
      add_location(tr17, file80, 36, 3, 1407);
      add_location(thead2, file80, 35, 2, 1396);
      add_location(td45, file80, 39, 23, 1492);
      add_location(td46, file80, 39, 36, 1505);
      add_location(td47, file80, 39, 52, 1521);
      attr_dev(tr18, "class", "row-sel");
      add_location(tr18, file80, 39, 3, 1472);
      add_location(td48, file80, 40, 23, 1563);
      add_location(td49, file80, 40, 36, 1576);
      add_location(td50, file80, 40, 53, 1593);
      attr_dev(tr19, "class", "row-sel");
      add_location(tr19, file80, 40, 3, 1543);
      add_location(td51, file80, 41, 23, 1634);
      add_location(td52, file80, 41, 36, 1647);
      add_location(td53, file80, 41, 50, 1661);
      attr_dev(tr20, "class", "row-sel");
      add_location(tr20, file80, 41, 3, 1614);
      add_location(td54, file80, 42, 23, 1702);
      add_location(td55, file80, 42, 36, 1715);
      add_location(td56, file80, 42, 50, 1729);
      attr_dev(tr21, "class", "row-sel");
      add_location(tr21, file80, 42, 3, 1682);
      add_location(td57, file80, 43, 23, 1770);
      add_location(td58, file80, 43, 36, 1783);
      add_location(td59, file80, 43, 48, 1795);
      attr_dev(tr22, "class", "row-sel");
      add_location(tr22, file80, 43, 3, 1750);
      add_location(td60, file80, 44, 23, 1836);
      add_location(td61, file80, 44, 36, 1849);
      add_location(td62, file80, 44, 49, 1862);
      attr_dev(tr23, "class", "row-sel");
      add_location(tr23, file80, 44, 3, 1816);
      add_location(td63, file80, 45, 23, 1903);
      add_location(td64, file80, 45, 36, 1916);
      add_location(td65, file80, 45, 49, 1929);
      attr_dev(tr24, "class", "row-sel");
      add_location(tr24, file80, 45, 3, 1883);
      add_location(td66, file80, 46, 23, 1970);
      add_location(td67, file80, 46, 36, 1983);
      add_location(td68, file80, 46, 51, 1998);
      attr_dev(tr25, "class", "row-sel");
      add_location(tr25, file80, 46, 3, 1950);
      add_location(td69, file80, 47, 23, 2039);
      add_location(td70, file80, 47, 36, 2052);
      add_location(td71, file80, 47, 54, 2070);
      attr_dev(tr26, "class", "row-sel");
      add_location(tr26, file80, 47, 3, 2019);
      add_location(td72, file80, 48, 23, 2111);
      add_location(td73, file80, 48, 36, 2124);
      add_location(td74, file80, 48, 52, 2140);
      attr_dev(tr27, "class", "row-sel");
      add_location(tr27, file80, 48, 3, 2091);
      add_location(td75, file80, 49, 23, 2181);
      add_location(td76, file80, 49, 36, 2194);
      add_location(td77, file80, 49, 53, 2211);
      attr_dev(tr28, "class", "row-sel");
      add_location(tr28, file80, 49, 3, 2161);
      add_location(td78, file80, 50, 23, 2252);
      add_location(td79, file80, 50, 36, 2265);
      add_location(td80, file80, 50, 53, 2282);
      attr_dev(tr29, "class", "row-sel");
      add_location(tr29, file80, 50, 3, 2232);
      add_location(tbody3, file80, 38, 2, 1461);
      attr_dev(th5, "colspan", "3");
      add_location(th5, file80, 53, 7, 2328);
      add_location(tr30, file80, 53, 3, 2324);
      add_location(thead3, file80, 52, 2, 2313);
      add_location(td81, file80, 56, 23, 2409);
      add_location(td82, file80, 56, 36, 2422);
      add_location(td83, file80, 56, 52, 2438);
      attr_dev(tr31, "class", "row-sel");
      add_location(tr31, file80, 56, 3, 2389);
      add_location(td84, file80, 57, 23, 2480);
      add_location(td85, file80, 57, 36, 2493);
      add_location(td86, file80, 57, 53, 2510);
      attr_dev(tr32, "class", "row-sel");
      add_location(tr32, file80, 57, 3, 2460);
      add_location(td87, file80, 58, 23, 2551);
      add_location(td88, file80, 58, 36, 2564);
      add_location(td89, file80, 58, 50, 2578);
      attr_dev(tr33, "class", "row-sel");
      add_location(tr33, file80, 58, 3, 2531);
      add_location(td90, file80, 59, 23, 2619);
      add_location(td91, file80, 59, 36, 2632);
      add_location(td92, file80, 59, 50, 2646);
      attr_dev(tr34, "class", "row-sel");
      add_location(tr34, file80, 59, 3, 2599);
      add_location(td93, file80, 60, 23, 2687);
      add_location(td94, file80, 60, 36, 2700);
      add_location(td95, file80, 60, 48, 2712);
      attr_dev(tr35, "class", "row-sel");
      add_location(tr35, file80, 60, 3, 2667);
      add_location(td96, file80, 61, 23, 2753);
      add_location(td97, file80, 61, 36, 2766);
      add_location(td98, file80, 61, 49, 2779);
      attr_dev(tr36, "class", "row-sel");
      add_location(tr36, file80, 61, 3, 2733);
      add_location(td99, file80, 62, 23, 2820);
      add_location(td100, file80, 62, 36, 2833);
      add_location(td101, file80, 62, 49, 2846);
      attr_dev(tr37, "class", "row-sel");
      add_location(tr37, file80, 62, 3, 2800);
      add_location(td102, file80, 63, 23, 2887);
      add_location(td103, file80, 63, 36, 2900);
      add_location(td104, file80, 63, 51, 2915);
      attr_dev(tr38, "class", "row-sel");
      add_location(tr38, file80, 63, 3, 2867);
      add_location(td105, file80, 64, 23, 2956);
      add_location(td106, file80, 64, 36, 2969);
      add_location(td107, file80, 64, 54, 2987);
      attr_dev(tr39, "class", "row-sel");
      add_location(tr39, file80, 64, 3, 2936);
      add_location(td108, file80, 65, 23, 3028);
      add_location(td109, file80, 65, 36, 3041);
      add_location(td110, file80, 65, 52, 3057);
      attr_dev(tr40, "class", "row-sel");
      add_location(tr40, file80, 65, 3, 3008);
      add_location(td111, file80, 66, 23, 3098);
      add_location(td112, file80, 66, 36, 3111);
      add_location(td113, file80, 66, 53, 3128);
      attr_dev(tr41, "class", "row-sel");
      add_location(tr41, file80, 66, 3, 3078);
      add_location(td114, file80, 67, 23, 3169);
      add_location(td115, file80, 67, 36, 3182);
      add_location(td116, file80, 67, 53, 3199);
      attr_dev(tr42, "class", "row-sel");
      add_location(tr42, file80, 67, 3, 3149);
      add_location(tbody4, file80, 55, 2, 2378);
      attr_dev(th6, "colspan", "3");
      add_location(th6, file80, 70, 7, 3245);
      add_location(tr43, file80, 70, 3, 3241);
      add_location(thead4, file80, 69, 2, 3230);
      add_location(td117, file80, 73, 23, 3326);
      add_location(td118, file80, 73, 36, 3339);
      add_location(td119, file80, 73, 52, 3355);
      attr_dev(tr44, "class", "row-sel");
      add_location(tr44, file80, 73, 3, 3306);
      add_location(td120, file80, 74, 23, 3397);
      add_location(td121, file80, 74, 36, 3410);
      add_location(td122, file80, 74, 53, 3427);
      attr_dev(tr45, "class", "row-sel");
      add_location(tr45, file80, 74, 3, 3377);
      add_location(td123, file80, 75, 23, 3468);
      add_location(td124, file80, 75, 36, 3481);
      add_location(td125, file80, 75, 50, 3495);
      attr_dev(tr46, "class", "row-sel");
      add_location(tr46, file80, 75, 3, 3448);
      add_location(td126, file80, 76, 23, 3536);
      add_location(td127, file80, 76, 36, 3549);
      add_location(td128, file80, 76, 50, 3563);
      attr_dev(tr47, "class", "row-sel");
      add_location(tr47, file80, 76, 3, 3516);
      add_location(td129, file80, 77, 23, 3604);
      add_location(td130, file80, 77, 36, 3617);
      add_location(td131, file80, 77, 48, 3629);
      attr_dev(tr48, "class", "row-sel");
      add_location(tr48, file80, 77, 3, 3584);
      add_location(td132, file80, 78, 23, 3670);
      add_location(td133, file80, 78, 36, 3683);
      add_location(td134, file80, 78, 49, 3696);
      attr_dev(tr49, "class", "row-sel");
      add_location(tr49, file80, 78, 3, 3650);
      add_location(td135, file80, 79, 23, 3737);
      add_location(td136, file80, 79, 36, 3750);
      add_location(td137, file80, 79, 49, 3763);
      attr_dev(tr50, "class", "row-sel");
      add_location(tr50, file80, 79, 3, 3717);
      add_location(td138, file80, 80, 23, 3804);
      add_location(td139, file80, 80, 36, 3817);
      add_location(td140, file80, 80, 51, 3832);
      attr_dev(tr51, "class", "row-sel");
      add_location(tr51, file80, 80, 3, 3784);
      add_location(td141, file80, 81, 23, 3873);
      add_location(td142, file80, 81, 36, 3886);
      add_location(td143, file80, 81, 54, 3904);
      attr_dev(tr52, "class", "row-sel");
      add_location(tr52, file80, 81, 3, 3853);
      add_location(td144, file80, 82, 23, 3945);
      add_location(td145, file80, 82, 36, 3958);
      add_location(td146, file80, 82, 52, 3974);
      attr_dev(tr53, "class", "row-sel");
      add_location(tr53, file80, 82, 3, 3925);
      add_location(td147, file80, 83, 23, 4015);
      add_location(td148, file80, 83, 36, 4028);
      add_location(td149, file80, 83, 53, 4045);
      attr_dev(tr54, "class", "row-sel");
      add_location(tr54, file80, 83, 3, 3995);
      add_location(td150, file80, 84, 23, 4086);
      add_location(td151, file80, 84, 36, 4099);
      add_location(td152, file80, 84, 53, 4116);
      attr_dev(tr55, "class", "row-sel");
      add_location(tr55, file80, 84, 3, 4066);
      add_location(tbody5, file80, 72, 2, 3295);
      attr_dev(th7, "colspan", "3");
      add_location(th7, file80, 87, 7, 4162);
      add_location(tr56, file80, 87, 3, 4158);
      add_location(thead5, file80, 86, 2, 4147);
      add_location(td153, file80, 90, 23, 4243);
      add_location(td154, file80, 90, 36, 4256);
      add_location(td155, file80, 90, 52, 4272);
      attr_dev(tr57, "class", "row-sel");
      add_location(tr57, file80, 90, 3, 4223);
      add_location(td156, file80, 91, 23, 4314);
      add_location(td157, file80, 91, 36, 4327);
      add_location(td158, file80, 91, 53, 4344);
      attr_dev(tr58, "class", "row-sel");
      add_location(tr58, file80, 91, 3, 4294);
      add_location(td159, file80, 92, 23, 4385);
      add_location(td160, file80, 92, 36, 4398);
      add_location(td161, file80, 92, 50, 4412);
      attr_dev(tr59, "class", "row-sel");
      add_location(tr59, file80, 92, 3, 4365);
      add_location(td162, file80, 93, 23, 4453);
      add_location(td163, file80, 93, 36, 4466);
      add_location(td164, file80, 93, 50, 4480);
      attr_dev(tr60, "class", "row-sel");
      add_location(tr60, file80, 93, 3, 4433);
      add_location(td165, file80, 94, 23, 4521);
      add_location(td166, file80, 94, 36, 4534);
      add_location(td167, file80, 94, 48, 4546);
      attr_dev(tr61, "class", "row-sel");
      add_location(tr61, file80, 94, 3, 4501);
      add_location(td168, file80, 95, 23, 4587);
      add_location(td169, file80, 95, 36, 4600);
      add_location(td170, file80, 95, 49, 4613);
      attr_dev(tr62, "class", "row-sel");
      add_location(tr62, file80, 95, 3, 4567);
      add_location(td171, file80, 96, 23, 4654);
      add_location(td172, file80, 96, 36, 4667);
      add_location(td173, file80, 96, 49, 4680);
      attr_dev(tr63, "class", "row-sel");
      add_location(tr63, file80, 96, 3, 4634);
      add_location(td174, file80, 97, 23, 4721);
      add_location(td175, file80, 97, 36, 4734);
      add_location(td176, file80, 97, 51, 4749);
      attr_dev(tr64, "class", "row-sel");
      add_location(tr64, file80, 97, 3, 4701);
      add_location(td177, file80, 98, 23, 4790);
      add_location(td178, file80, 98, 36, 4803);
      add_location(td179, file80, 98, 54, 4821);
      attr_dev(tr65, "class", "row-sel");
      add_location(tr65, file80, 98, 3, 4770);
      add_location(td180, file80, 99, 23, 4862);
      add_location(td181, file80, 99, 36, 4875);
      add_location(td182, file80, 99, 52, 4891);
      attr_dev(tr66, "class", "row-sel");
      add_location(tr66, file80, 99, 3, 4842);
      add_location(td183, file80, 100, 23, 4932);
      add_location(td184, file80, 100, 36, 4945);
      add_location(td185, file80, 100, 53, 4962);
      attr_dev(tr67, "class", "row-sel");
      add_location(tr67, file80, 100, 3, 4912);
      add_location(td186, file80, 101, 23, 5003);
      add_location(td187, file80, 101, 36, 5016);
      add_location(td188, file80, 101, 53, 5033);
      attr_dev(tr68, "class", "row-sel");
      add_location(tr68, file80, 101, 3, 4983);
      add_location(tbody6, file80, 89, 2, 4212);
      attr_dev(td189, "colspan", "2");
      add_location(td189, file80, 104, 7, 5079);
      add_location(td190, file80, 104, 31, 5103);
      add_location(tr69, file80, 104, 3, 5075);
      add_location(tfoot, file80, 103, 2, 5064);
    },
    m: function mount(target, anchor) {
      insert_dev(target, thead0, anchor);
      append_dev(thead0, tr0);
      append_dev(tr0, th0);
      append_dev(tr0, th1);
      append_dev(tr0, th2);
      insert_dev(target, t3, anchor);
      insert_dev(target, thead1, anchor);
      append_dev(thead1, tr1);
      append_dev(tr1, th3);
      insert_dev(target, t5, anchor);
      insert_dev(target, tbody0, anchor);
      append_dev(tbody0, tr2);
      append_dev(tr2, td0);
      append_dev(tr2, td1);
      append_dev(tr2, td2);
      append_dev(tbody0, t9);
      append_dev(tbody0, tr3);
      append_dev(tr3, td3);
      append_dev(tr3, td4);
      append_dev(tr3, td5);
      append_dev(tbody0, t13);
      append_dev(tbody0, tr4);
      append_dev(tr4, td6);
      append_dev(tr4, td7);
      append_dev(tr4, td8);
      append_dev(tbody0, t17);
      append_dev(tbody0, tr5);
      append_dev(tr5, td9);
      append_dev(tr5, td10);
      append_dev(tr5, td11);
      append_dev(tbody0, t21);
      append_dev(tbody0, tr6);
      append_dev(tr6, td12);
      append_dev(tr6, td13);
      append_dev(tr6, td14);
      append_dev(tbody0, t25);
      append_dev(tbody0, tr7);
      append_dev(tr7, td15);
      append_dev(tr7, td16);
      append_dev(tr7, td17);
      insert_dev(target, t29, anchor);
      insert_dev(target, tbody1, anchor);
      append_dev(tbody1, tr8);
      append_dev(tr8, td18);
      append_dev(tr8, td19);
      append_dev(tr8, td20);
      append_dev(tbody1, t33);
      append_dev(tbody1, tr9);
      append_dev(tr9, td21);
      append_dev(tr9, td22);
      append_dev(tr9, td23);
      insert_dev(target, t37, anchor);
      insert_dev(target, tbody2, anchor);
      append_dev(tbody2, tr10);
      append_dev(tr10, td24);
      append_dev(tr10, td25);
      append_dev(tr10, td26);
      append_dev(tbody2, t41);
      append_dev(tbody2, tr11);
      append_dev(tr11, td27);
      append_dev(tr11, td28);
      append_dev(tr11, td29);
      append_dev(tbody2, t45);
      append_dev(tbody2, tr12);
      append_dev(tr12, td30);
      append_dev(tr12, td31);
      append_dev(tr12, td32);
      append_dev(tbody2, t49);
      append_dev(tbody2, tr13);
      append_dev(tr13, td33);
      append_dev(tr13, td34);
      append_dev(tr13, td35);
      append_dev(tbody2, t53);
      append_dev(tbody2, tr14);
      append_dev(tr14, td36);
      append_dev(tr14, td37);
      append_dev(tr14, td38);
      append_dev(tbody2, t57);
      append_dev(tbody2, tr15);
      append_dev(tr15, td39);
      append_dev(tr15, td40);
      append_dev(tr15, td41);
      append_dev(tbody2, t61);
      append_dev(tbody2, tr16);
      append_dev(tr16, td42);
      append_dev(tr16, td43);
      append_dev(tr16, td44);
      insert_dev(target, t65, anchor);
      insert_dev(target, thead2, anchor);
      append_dev(thead2, tr17);
      append_dev(tr17, th4);
      insert_dev(target, t67, anchor);
      insert_dev(target, tbody3, anchor);
      append_dev(tbody3, tr18);
      append_dev(tr18, td45);
      append_dev(tr18, td46);
      append_dev(tr18, td47);
      append_dev(tbody3, t71);
      append_dev(tbody3, tr19);
      append_dev(tr19, td48);
      append_dev(tr19, td49);
      append_dev(tr19, td50);
      append_dev(tbody3, t75);
      append_dev(tbody3, tr20);
      append_dev(tr20, td51);
      append_dev(tr20, td52);
      append_dev(tr20, td53);
      append_dev(tbody3, t79);
      append_dev(tbody3, tr21);
      append_dev(tr21, td54);
      append_dev(tr21, td55);
      append_dev(tr21, td56);
      append_dev(tbody3, t83);
      append_dev(tbody3, tr22);
      append_dev(tr22, td57);
      append_dev(tr22, td58);
      append_dev(tr22, td59);
      append_dev(tbody3, t87);
      append_dev(tbody3, tr23);
      append_dev(tr23, td60);
      append_dev(tr23, td61);
      append_dev(tr23, td62);
      append_dev(tbody3, t91);
      append_dev(tbody3, tr24);
      append_dev(tr24, td63);
      append_dev(tr24, td64);
      append_dev(tr24, td65);
      append_dev(tbody3, t95);
      append_dev(tbody3, tr25);
      append_dev(tr25, td66);
      append_dev(tr25, td67);
      append_dev(tr25, td68);
      append_dev(tbody3, t99);
      append_dev(tbody3, tr26);
      append_dev(tr26, td69);
      append_dev(tr26, td70);
      append_dev(tr26, td71);
      append_dev(tbody3, t103);
      append_dev(tbody3, tr27);
      append_dev(tr27, td72);
      append_dev(tr27, td73);
      append_dev(tr27, td74);
      append_dev(tbody3, t107);
      append_dev(tbody3, tr28);
      append_dev(tr28, td75);
      append_dev(tr28, td76);
      append_dev(tr28, td77);
      append_dev(tbody3, t111);
      append_dev(tbody3, tr29);
      append_dev(tr29, td78);
      append_dev(tr29, td79);
      append_dev(tr29, td80);
      insert_dev(target, t115, anchor);
      insert_dev(target, thead3, anchor);
      append_dev(thead3, tr30);
      append_dev(tr30, th5);
      insert_dev(target, t117, anchor);
      insert_dev(target, tbody4, anchor);
      append_dev(tbody4, tr31);
      append_dev(tr31, td81);
      append_dev(tr31, td82);
      append_dev(tr31, td83);
      append_dev(tbody4, t121);
      append_dev(tbody4, tr32);
      append_dev(tr32, td84);
      append_dev(tr32, td85);
      append_dev(tr32, td86);
      append_dev(tbody4, t125);
      append_dev(tbody4, tr33);
      append_dev(tr33, td87);
      append_dev(tr33, td88);
      append_dev(tr33, td89);
      append_dev(tbody4, t129);
      append_dev(tbody4, tr34);
      append_dev(tr34, td90);
      append_dev(tr34, td91);
      append_dev(tr34, td92);
      append_dev(tbody4, t133);
      append_dev(tbody4, tr35);
      append_dev(tr35, td93);
      append_dev(tr35, td94);
      append_dev(tr35, td95);
      append_dev(tbody4, t137);
      append_dev(tbody4, tr36);
      append_dev(tr36, td96);
      append_dev(tr36, td97);
      append_dev(tr36, td98);
      append_dev(tbody4, t141);
      append_dev(tbody4, tr37);
      append_dev(tr37, td99);
      append_dev(tr37, td100);
      append_dev(tr37, td101);
      append_dev(tbody4, t145);
      append_dev(tbody4, tr38);
      append_dev(tr38, td102);
      append_dev(tr38, td103);
      append_dev(tr38, td104);
      append_dev(tbody4, t149);
      append_dev(tbody4, tr39);
      append_dev(tr39, td105);
      append_dev(tr39, td106);
      append_dev(tr39, td107);
      append_dev(tbody4, t153);
      append_dev(tbody4, tr40);
      append_dev(tr40, td108);
      append_dev(tr40, td109);
      append_dev(tr40, td110);
      append_dev(tbody4, t157);
      append_dev(tbody4, tr41);
      append_dev(tr41, td111);
      append_dev(tr41, td112);
      append_dev(tr41, td113);
      append_dev(tbody4, t161);
      append_dev(tbody4, tr42);
      append_dev(tr42, td114);
      append_dev(tr42, td115);
      append_dev(tr42, td116);
      insert_dev(target, t165, anchor);
      insert_dev(target, thead4, anchor);
      append_dev(thead4, tr43);
      append_dev(tr43, th6);
      insert_dev(target, t167, anchor);
      insert_dev(target, tbody5, anchor);
      append_dev(tbody5, tr44);
      append_dev(tr44, td117);
      append_dev(tr44, td118);
      append_dev(tr44, td119);
      append_dev(tbody5, t171);
      append_dev(tbody5, tr45);
      append_dev(tr45, td120);
      append_dev(tr45, td121);
      append_dev(tr45, td122);
      append_dev(tbody5, t175);
      append_dev(tbody5, tr46);
      append_dev(tr46, td123);
      append_dev(tr46, td124);
      append_dev(tr46, td125);
      append_dev(tbody5, t179);
      append_dev(tbody5, tr47);
      append_dev(tr47, td126);
      append_dev(tr47, td127);
      append_dev(tr47, td128);
      append_dev(tbody5, t183);
      append_dev(tbody5, tr48);
      append_dev(tr48, td129);
      append_dev(tr48, td130);
      append_dev(tr48, td131);
      append_dev(tbody5, t187);
      append_dev(tbody5, tr49);
      append_dev(tr49, td132);
      append_dev(tr49, td133);
      append_dev(tr49, td134);
      append_dev(tbody5, t191);
      append_dev(tbody5, tr50);
      append_dev(tr50, td135);
      append_dev(tr50, td136);
      append_dev(tr50, td137);
      append_dev(tbody5, t195);
      append_dev(tbody5, tr51);
      append_dev(tr51, td138);
      append_dev(tr51, td139);
      append_dev(tr51, td140);
      append_dev(tbody5, t199);
      append_dev(tbody5, tr52);
      append_dev(tr52, td141);
      append_dev(tr52, td142);
      append_dev(tr52, td143);
      append_dev(tbody5, t203);
      append_dev(tbody5, tr53);
      append_dev(tr53, td144);
      append_dev(tr53, td145);
      append_dev(tr53, td146);
      append_dev(tbody5, t207);
      append_dev(tbody5, tr54);
      append_dev(tr54, td147);
      append_dev(tr54, td148);
      append_dev(tr54, td149);
      append_dev(tbody5, t211);
      append_dev(tbody5, tr55);
      append_dev(tr55, td150);
      append_dev(tr55, td151);
      append_dev(tr55, td152);
      insert_dev(target, t215, anchor);
      insert_dev(target, thead5, anchor);
      append_dev(thead5, tr56);
      append_dev(tr56, th7);
      insert_dev(target, t217, anchor);
      insert_dev(target, tbody6, anchor);
      append_dev(tbody6, tr57);
      append_dev(tr57, td153);
      append_dev(tr57, td154);
      append_dev(tr57, td155);
      append_dev(tbody6, t221);
      append_dev(tbody6, tr58);
      append_dev(tr58, td156);
      append_dev(tr58, td157);
      append_dev(tr58, td158);
      append_dev(tbody6, t225);
      append_dev(tbody6, tr59);
      append_dev(tr59, td159);
      append_dev(tr59, td160);
      append_dev(tr59, td161);
      append_dev(tbody6, t229);
      append_dev(tbody6, tr60);
      append_dev(tr60, td162);
      append_dev(tr60, td163);
      append_dev(tr60, td164);
      append_dev(tbody6, t233);
      append_dev(tbody6, tr61);
      append_dev(tr61, td165);
      append_dev(tr61, td166);
      append_dev(tr61, td167);
      append_dev(tbody6, t237);
      append_dev(tbody6, tr62);
      append_dev(tr62, td168);
      append_dev(tr62, td169);
      append_dev(tr62, td170);
      append_dev(tbody6, t241);
      append_dev(tbody6, tr63);
      append_dev(tr63, td171);
      append_dev(tr63, td172);
      append_dev(tr63, td173);
      append_dev(tbody6, t245);
      append_dev(tbody6, tr64);
      append_dev(tr64, td174);
      append_dev(tr64, td175);
      append_dev(tr64, td176);
      append_dev(tbody6, t249);
      append_dev(tbody6, tr65);
      append_dev(tr65, td177);
      append_dev(tr65, td178);
      append_dev(tr65, td179);
      append_dev(tbody6, t253);
      append_dev(tbody6, tr66);
      append_dev(tr66, td180);
      append_dev(tr66, td181);
      append_dev(tr66, td182);
      append_dev(tbody6, t257);
      append_dev(tbody6, tr67);
      append_dev(tr67, td183);
      append_dev(tr67, td184);
      append_dev(tr67, td185);
      append_dev(tbody6, t261);
      append_dev(tbody6, tr68);
      append_dev(tr68, td186);
      append_dev(tr68, td187);
      append_dev(tr68, td188);
      insert_dev(target, t265, anchor);
      insert_dev(target, tfoot, anchor);
      append_dev(tfoot, tr69);
      append_dev(tr69, td189);
      append_dev(tr69, td190);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(thead0);
        detach_dev(t3);
        detach_dev(thead1);
        detach_dev(t5);
        detach_dev(tbody0);
        detach_dev(t29);
        detach_dev(tbody1);
        detach_dev(t37);
        detach_dev(tbody2);
        detach_dev(t65);
        detach_dev(thead2);
        detach_dev(t67);
        detach_dev(tbody3);
        detach_dev(t115);
        detach_dev(thead3);
        detach_dev(t117);
        detach_dev(tbody4);
        detach_dev(t165);
        detach_dev(thead4);
        detach_dev(t167);
        detach_dev(tbody5);
        detach_dev(t215);
        detach_dev(thead5);
        detach_dev(t217);
        detach_dev(tbody6);
        detach_dev(t265);
        detach_dev(tfoot);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot17.name,
    type: "slot",
    source: '(4:1) <Table round   rowSelector=\\".row-sel\\"   on:keydown=\\"{onKey}\\"   on:dblclick=\\"{onSelect}\\"   on:select=\\"{onSelect}\\">',
    ctx
  });
  return block;
}
function create_fragment87(ctx) {
  let h2;
  let t1;
  let div;
  let table;
  let t2;
  let codeexample;
  let t3;
  let api;
  let current;
  table = new Table_default({
    props: {
      round: true,
      rowSelector: ".row-sel",
      $$slots: { default: [create_default_slot17] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  table.$on("keydown", onKey);
  table.$on("dblclick", onSelect);
  table.$on("select", onSelect);
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[1]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Table";
      t1 = space();
      div = element2("div");
      create_component(table.$$.fragment);
      t2 = space();
      create_component(codeexample.$$.fragment);
      t3 = space();
      create_component(api.$$.fragment);
      add_location(h2, file80, 0, 0, 0);
      attr_dev(div, "class", "table-viewport");
      add_location(div, file80, 2, 0, 16);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, div, anchor);
      mount_component(table, div, null);
      insert_dev(target, t2, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t3, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const table_changes = {};
      if (dirty & /*$$scope*/
      4) {
        table_changes.$$scope = { dirty, ctx: ctx2 };
      }
      table.$set(table_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(table.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(table.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(div);
        detach_dev(t2);
        detach_dev(t3);
      }
      destroy_component(table);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment87.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function onKey(e) {
  const { event, selectedItem } = e.detail;
  if (event.key === "Enter")
    console.log(selectedItem);
}
function onSelect(e) {
  const { selectedItem } = e.detail;
  console.log(e.type, selectedItem);
}
function instance87($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Table", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "data",
      type: "object",
      description: "Props to attach to the element's <em>dataset</em> attribute."
    },
    {
      name: "round",
      description: "Adds rounded corners to the table."
    },
    {
      name: "rowSelector",
      type: "string",
      default: "tbody tr",
      description: "A selector for a table row.<br>This is useful if a table needs row groups, in which case it would have a mix of TRs and TBODYs for rows. Both can have the same class, e.g. <em>.row</em> and this selector should then be provided here."
    },
    {
      name: "scrollContainer",
      type: ["string", "Element"],
      default: "table wrapper",
      description: "Selector or HTML Element to the scroll container. If table wrapper's height is not set to 100% of the container, and is taller than the container - the container will have to be scrollable, and in this case it must be provided here."
    },
    {
      name: "scrollCorrectionOffset",
      type: "number",
      default: "0",
      description: "If an external <em>scrollContainer</em> is used - it is possible that it will have non-zero padding set, thus the table wrapper will be offset from the beginning of the container. This offset should be set here, so that the sticky headers work correctly."
    },
    {
      name: "selectable",
      type: ["true", "false"],
      description: "Makes table rows selectable with mouse and adds keyboard navigation."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "on:click",
      type: "function",
      description: "Triggered after a row has been clicked."
    },
    {
      name: "on:dblclick",
      type: "function",
      description: "Triggered after a row has been double-clicked."
    },
    {
      name: "on:keydown",
      type: "function",
      description: "Triggered after key has been pressed."
    },
    {
      name: "on:select",
      type: "function",
      description: "Triggered after a row selection has changed."
    }
  ];
  const exampleHtml = `
<Table rowSelector=".row-sel" round data="{{ id: 'table-id-1' }}">
		<thead>
			<tr><th>Year</th><th>Month</th><th>Price</th></tr>
		</thead>
		<thead>
			<tr><th colspan="3">Year: 2021</th></tr>
		</thead>
		<tbody>
			<tr class="row-sel"><td>2021</td><td>January</td><td>$100</td></tr>
			<tr class="row-sel"><td>2021</td><td>February</td><td>$80</td></tr>
			<tr class="row-sel"><td>2021</td><td>March</td><td>$80</td></tr>
			<tr class="row-sel"><td>2021</td><td>April</td><td>$80</td></tr>
			<tr class="row-sel"><td>2021</td><td>May</td><td>$80</td></tr>
			<tr class="row-sel"><td>2021</td><td>June</td><td>$80</td></tr>
		</tbody>
		<tbody class="row-sel row-group">
			<tr><td>2021</td><td>April 1</td><td>$80</td></tr>
			<tr><td>2021</td><td>April 2</td><td>$80</td></tr>
		</tbody>
		<tbody>
			<tr class="row-sel"><td>2021</td><td>May</td><td>$80</td></tr>
			<tr class="row-sel"><td>2021</td><td>July</td><td>$80</td></tr>
			<tr class="row-sel"><td>2021</td><td>August</td><td>$80</td></tr>
			<tr class="row-sel"><td>2021</td><td>September</td><td>$80</td></tr>
			<tr class="row-sel"><td>2021</td><td>October</td><td>$80</td></tr>
			<tr class="row-sel"><td>2021</td><td>November</td><td>$80</td></tr>
			<tr class="row-sel"><td>2021</td><td>December</td><td>$80</td></tr>
		</tbody>
		<thead>
			<tr><th colspan="3">Year: 2020</th></tr>
		</thead>
		<tbody>
			...
		</tbody>
		<tfoot>
			<tr><td colspan="2">Sum</td><td>$180</td></tr>
		</tfoot>
	</Table>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_115.warn(`<Table> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    Table: Table_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    exampleHtml,
    onKey,
    onSelect
  });
  return [apiProps, exampleHtml];
}
var Table_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance87, create_fragment87, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table_1",
      options,
      id: create_fragment87.name
    });
  }
};
var Table_default2 = Table_1;

// docs-src/components/tree/Tree.svelte
var { console: console_116 } = globals;
var file81 = "docs-src/components/tree/Tree.svelte";
function create_fragment88(ctx) {
  let h2;
  let t1;
  let div;
  let tree;
  let t2;
  let codeexample;
  let t3;
  let api;
  let current;
  tree = new Tree_default({
    props: { items: (
      /*items*/
      ctx[2]
    ) },
    $$inline: true
  });
  tree.$on("select", onSelect2);
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[1]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Tree";
      t1 = space();
      div = element2("div");
      create_component(tree.$$.fragment);
      t2 = space();
      create_component(codeexample.$$.fragment);
      t3 = space();
      create_component(api.$$.fragment);
      add_location(h2, file81, 0, 0, 0);
      set_style(div, "display", "inline-block");
      set_style(div, "width", "200px");
      add_location(div, file81, 2, 0, 15);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, div, anchor);
      mount_component(tree, div, null);
      insert_dev(target, t2, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t3, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(tree.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tree.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(div);
        detach_dev(t2);
        detach_dev(t3);
      }
      destroy_component(tree);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment88.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function onSelect2(e) {
  console.log(e.detail);
}
function instance88($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Tree", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "title",
      type: "string",
      description: "Title of the component."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "on:select",
      type: "function",
      description: "Triggered after an item was selected."
    }
  ];
  const exampleHtml = `
<Tree {items} on:select="{onSelect}"/>

<script>
const items = [
	{ id: 1, name: 'One' },
	{ id: 2, name: 'Two', items: [
		{ id: 21, name: 'One' },
		{ id: 22, name: 'Two' },
		{ id: 23, name: 'Three', items: [
			{ id: 231, name: 'One' },
			{ id: 232, name: 'Two' },
		] },
		{ id: 24, name: 'Four' },
	] },
	{ id: 3, name: 'Three' },
];

function onSelect (e) {
	console.log(e.detail);
}
&lt;/script>
`;
  const items = [
    { id: 1, name: "One" },
    { id: 2, name: "Two" },
    { id: 3, name: "Three" },
    {
      id: 4,
      name: "Four",
      items: [
        { id: 41, name: "One" },
        { id: 42, name: "Two" },
        { id: 43, name: "Three" },
        {
          id: 44,
          name: "Four",
          items: [
            { id: 441, name: "One" },
            { id: 442, name: "Two" },
            { id: 443, name: "Three" },
            { id: 444, name: "Four" },
            { id: 445, name: "Five" },
            { id: 446, name: "Six" },
            {
              id: 447,
              name: "Seven",
              items: [
                { id: 4471, name: "One" },
                { id: 4472, name: "Two" },
                { id: 4473, name: "Three" },
                { id: 4474, name: "Four" },
                { id: 4475, name: "Five" },
                { id: 4476, name: "Six" },
                { id: 4477, name: "Seven" },
                { id: 4478, name: "Eight" },
                { id: 4479, name: "Nine" },
                { id: 44710, name: "Ten" }
              ]
            },
            { id: 448, name: "Eight" },
            { id: 449, name: "Nine" },
            { id: 4410, name: "Ten" }
          ]
        },
        { id: 45, name: "Five" },
        { id: 46, name: "Six" },
        { id: 47, name: "Seven" },
        { id: 48, name: "Eight" },
        { id: 49, name: "Nine" },
        { id: 410, name: "Ten" }
      ]
    },
    { id: 5, name: "Five" },
    { id: 6, name: "Six" },
    {
      id: 7,
      name: "Seven",
      items: [
        { id: 71, name: "One" },
        { id: 72, name: "Two" },
        { id: 73, name: "Three" },
        { id: 74, name: "Four" },
        { id: 75, name: "Five" },
        { id: 76, name: "Six" },
        { id: 77, name: "Seven" },
        { id: 78, name: "Eight" },
        { id: 79, name: "Nine" },
        { id: 710, name: "Ten" }
      ]
    },
    { id: 8, name: "Eight" },
    { id: 9, name: "Nine" },
    { id: 10, name: "Ten" }
  ];
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_116.warn(`<Tree> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    Tree: Tree_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    exampleHtml,
    onSelect: onSelect2,
    items
  });
  return [apiProps, exampleHtml, items];
}
var Tree_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance88, create_fragment88, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tree_1",
      options,
      id: create_fragment88.name
    });
  }
};
var Tree_default2 = Tree_1;

// docs-src/components/menu/Menu.svelte
var { console: console_117 } = globals;
var file82 = "docs-src/components/menu/Menu.svelte";
function create_default_slot_362(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show menu");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_362.name,
    type: "slot",
    source: '(5:1) <Button data-name=\\"show-menu-button\\" on:click=\\"{thingsMenu.open}\\">',
    ctx
  });
  return block;
}
function create_default_slot_352(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show menu aligned to the center of the button");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_352.name,
    type: "slot",
    source: '(6:1) <Button data-name=\\"show-menu-button\\" on:click=\\"{thingsMenu1.open}\\">',
    ctx
  });
  return block;
}
function create_default_slot_342(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Show menu aligned to the right side of the button");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_342.name,
    type: "slot",
    source: '(7:1) <Button data-name=\\"show-menu-button\\" on:click=\\"{thingsMenu2.open}\\">',
    ctx
  });
  return block;
}
function create_default_slot_332(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Add a thing (success)");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_332.name,
    type: "slot",
    source: '(11:1) <MenuItem success icon=\\"plus\\" data-value=\\"add-something\\" on:click=\\"{onMenuClick}\\">',
    ctx
  });
  return block;
}
function create_default_slot_323(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Add another one");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_323.name,
    type: "slot",
    source: "(12:1) <MenuItem>",
    ctx
  });
  return block;
}
function create_default_slot_317(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Third option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_317.name,
    type: "slot",
    source: '(14:1) <MenuItem shortcut=\\"cmd+shift+c\\">',
    ctx
  });
  return block;
}
function create_default_slot_302(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Fourth menu item");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_302.name,
    type: "slot",
    source: '(15:1) <MenuItem shortcut=\\"cmd+alt+d\\">',
    ctx
  });
  return block;
}
function create_default_slot_292(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Fifth element");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_292.name,
    type: "slot",
    source: '(16:1) <MenuItem shortcut=\\"cmd+c\\">',
    ctx
  });
  return block;
}
function create_default_slot_282(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Sixth one, to make it longer");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_282.name,
    type: "slot",
    source: '(17:1) <MenuItem shortcut=\\"cmd+enter\\">',
    ctx
  });
  return block;
}
function create_default_slot_272(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Seventh. Menu supports type-ahead");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_272.name,
    type: "slot",
    source: '(18:1) <MenuItem shortcut=\\"backspace\\">',
    ctx
  });
  return block;
}
function create_default_slot_262(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Eight, so go ahead and try typing");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_262.name,
    type: "slot",
    source: '(19:1) <MenuItem shortcut=\\"escape\\">',
    ctx
  });
  return block;
}
function create_default_slot_253(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Ninth, the beginning of the menu item text");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_253.name,
    type: "slot",
    source: '(20:1) <MenuItem shortcut=\\"cmd+option+s\\">',
    ctx
  });
  return block;
}
function create_default_slot_243(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Tenth, and it should be focused");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_243.name,
    type: "slot",
    source: "(21:1) <MenuItem>",
    ctx
  });
  return block;
}
function create_default_slot_233(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("A disabled option too");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_233.name,
    type: "slot",
    source: "(22:1) <MenuItem disabled>",
    ctx
  });
  return block;
}
function create_default_slot_224(ctx) {
  let t0;
  let t1;
  const block = {
    c: function create() {
      t0 = text(
        /*closeThingsText*/
        ctx[6]
      );
      t1 = text(" (danger)");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*closeThingsText*/
      64)
        set_data_dev(
          t0,
          /*closeThingsText*/
          ctx2[6]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_224.name,
    type: "slot",
    source: '(24:1) <MenuItem danger icon=\\"close\\" on:click=\\"{menuCloseThings}\\">',
    ctx
  });
  return block;
}
function create_default_slot_219(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuseparator0;
  let t2;
  let menuitem2;
  let t3;
  let menuitem3;
  let t4;
  let menuitem4;
  let t5;
  let menuitem5;
  let t6;
  let menuitem6;
  let t7;
  let menuitem7;
  let t8;
  let menuitem8;
  let t9;
  let menuitem9;
  let t10;
  let menuitem10;
  let t11;
  let menuseparator1;
  let t12;
  let menuitem11;
  let current;
  menuitem0 = new MenuItem_default({
    props: {
      success: true,
      icon: "plus",
      "data-value": "add-something",
      $$slots: { default: [create_default_slot_332] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem0.$on("click", onMenuClick);
  menuitem1 = new MenuItem_default({
    props: {
      $$slots: { default: [create_default_slot_323] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuseparator0 = new MenuSeparator_default({ $$inline: true });
  menuitem2 = new MenuItem_default({
    props: {
      shortcut: "cmd+shift+c",
      $$slots: { default: [create_default_slot_317] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem3 = new MenuItem_default({
    props: {
      shortcut: "cmd+alt+d",
      $$slots: { default: [create_default_slot_302] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem4 = new MenuItem_default({
    props: {
      shortcut: "cmd+c",
      $$slots: { default: [create_default_slot_292] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem5 = new MenuItem_default({
    props: {
      shortcut: "cmd+enter",
      $$slots: { default: [create_default_slot_282] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem6 = new MenuItem_default({
    props: {
      shortcut: "backspace",
      $$slots: { default: [create_default_slot_272] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem7 = new MenuItem_default({
    props: {
      shortcut: "escape",
      $$slots: { default: [create_default_slot_262] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem8 = new MenuItem_default({
    props: {
      shortcut: "cmd+option+s",
      $$slots: { default: [create_default_slot_253] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem9 = new MenuItem_default({
    props: {
      $$slots: { default: [create_default_slot_243] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem10 = new MenuItem_default({
    props: {
      disabled: true,
      $$slots: { default: [create_default_slot_233] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuseparator1 = new MenuSeparator_default({ $$inline: true });
  menuitem11 = new MenuItem_default({
    props: {
      danger: true,
      icon: "close",
      $$slots: { default: [create_default_slot_224] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem11.$on(
    "click",
    /*menuCloseThings*/
    ctx[12]
  );
  const block = {
    c: function create() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuseparator0.$$.fragment);
      t2 = space();
      create_component(menuitem2.$$.fragment);
      t3 = space();
      create_component(menuitem3.$$.fragment);
      t4 = space();
      create_component(menuitem4.$$.fragment);
      t5 = space();
      create_component(menuitem5.$$.fragment);
      t6 = space();
      create_component(menuitem6.$$.fragment);
      t7 = space();
      create_component(menuitem7.$$.fragment);
      t8 = space();
      create_component(menuitem8.$$.fragment);
      t9 = space();
      create_component(menuitem9.$$.fragment);
      t10 = space();
      create_component(menuitem10.$$.fragment);
      t11 = space();
      create_component(menuseparator1.$$.fragment);
      t12 = space();
      create_component(menuitem11.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(menuseparator0, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(menuitem2, target, anchor);
      insert_dev(target, t3, anchor);
      mount_component(menuitem3, target, anchor);
      insert_dev(target, t4, anchor);
      mount_component(menuitem4, target, anchor);
      insert_dev(target, t5, anchor);
      mount_component(menuitem5, target, anchor);
      insert_dev(target, t6, anchor);
      mount_component(menuitem6, target, anchor);
      insert_dev(target, t7, anchor);
      mount_component(menuitem7, target, anchor);
      insert_dev(target, t8, anchor);
      mount_component(menuitem8, target, anchor);
      insert_dev(target, t9, anchor);
      mount_component(menuitem9, target, anchor);
      insert_dev(target, t10, anchor);
      mount_component(menuitem10, target, anchor);
      insert_dev(target, t11, anchor);
      mount_component(menuseparator1, target, anchor);
      insert_dev(target, t12, anchor);
      mount_component(menuitem11, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem2.$set(menuitem2_changes);
      const menuitem3_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem3.$set(menuitem3_changes);
      const menuitem4_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem4.$set(menuitem4_changes);
      const menuitem5_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem5.$set(menuitem5_changes);
      const menuitem6_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem6.$set(menuitem6_changes);
      const menuitem7_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem7.$set(menuitem7_changes);
      const menuitem8_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem8_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem8.$set(menuitem8_changes);
      const menuitem9_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem9_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem9.$set(menuitem9_changes);
      const menuitem10_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem10_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem10.$set(menuitem10_changes);
      const menuitem11_changes = {};
      if (dirty & /*$$scope, closeThingsText*/
      268435520) {
        menuitem11_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem11.$set(menuitem11_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuseparator0.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      transition_in(menuitem3.$$.fragment, local);
      transition_in(menuitem4.$$.fragment, local);
      transition_in(menuitem5.$$.fragment, local);
      transition_in(menuitem6.$$.fragment, local);
      transition_in(menuitem7.$$.fragment, local);
      transition_in(menuitem8.$$.fragment, local);
      transition_in(menuitem9.$$.fragment, local);
      transition_in(menuitem10.$$.fragment, local);
      transition_in(menuseparator1.$$.fragment, local);
      transition_in(menuitem11.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuseparator0.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      transition_out(menuitem3.$$.fragment, local);
      transition_out(menuitem4.$$.fragment, local);
      transition_out(menuitem5.$$.fragment, local);
      transition_out(menuitem6.$$.fragment, local);
      transition_out(menuitem7.$$.fragment, local);
      transition_out(menuitem8.$$.fragment, local);
      transition_out(menuitem9.$$.fragment, local);
      transition_out(menuitem10.$$.fragment, local);
      transition_out(menuseparator1.$$.fragment, local);
      transition_out(menuitem11.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(t5);
        detach_dev(t6);
        detach_dev(t7);
        detach_dev(t8);
        detach_dev(t9);
        detach_dev(t10);
        detach_dev(t11);
        detach_dev(t12);
      }
      destroy_component(menuitem0, detaching);
      destroy_component(menuitem1, detaching);
      destroy_component(menuseparator0, detaching);
      destroy_component(menuitem2, detaching);
      destroy_component(menuitem3, detaching);
      destroy_component(menuitem4, detaching);
      destroy_component(menuitem5, detaching);
      destroy_component(menuitem6, detaching);
      destroy_component(menuitem7, detaching);
      destroy_component(menuitem8, detaching);
      destroy_component(menuitem9, detaching);
      destroy_component(menuitem10, detaching);
      destroy_component(menuseparator1, detaching);
      destroy_component(menuitem11, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_219.name,
    type: "slot",
    source: '(10:0) <Menu bind:this=\\"{thingsMenu}\\">',
    ctx
  });
  return block;
}
function create_default_slot_203(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Add a thing (success)");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_203.name,
    type: "slot",
    source: '(29:1) <MenuItem success icon=\\"plus\\" data-value=\\"add-something\\" on:click=\\"{onMenuClick}\\">',
    ctx
  });
  return block;
}
function create_default_slot_193(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Add another one");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_193.name,
    type: "slot",
    source: "(30:1) <MenuItem>",
    ctx
  });
  return block;
}
function create_default_slot_183(ctx) {
  let t0;
  let t1;
  const block = {
    c: function create() {
      t0 = text(
        /*closeThingsText*/
        ctx[6]
      );
      t1 = text(" (danger)");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*closeThingsText*/
      64)
        set_data_dev(
          t0,
          /*closeThingsText*/
          ctx2[6]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_183.name,
    type: "slot",
    source: '(32:1) <MenuItem danger icon=\\"close\\" on:click=\\"{menuCloseThings}\\">',
    ctx
  });
  return block;
}
function create_default_slot_173(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuseparator;
  let t2;
  let menuitem2;
  let current;
  menuitem0 = new MenuItem_default({
    props: {
      success: true,
      icon: "plus",
      "data-value": "add-something",
      $$slots: { default: [create_default_slot_203] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem0.$on("click", onMenuClick);
  menuitem1 = new MenuItem_default({
    props: {
      $$slots: { default: [create_default_slot_193] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuseparator = new MenuSeparator_default({ $$inline: true });
  menuitem2 = new MenuItem_default({
    props: {
      danger: true,
      icon: "close",
      $$slots: { default: [create_default_slot_183] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem2.$on(
    "click",
    /*menuCloseThings*/
    ctx[12]
  );
  const block = {
    c: function create() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuseparator.$$.fragment);
      t2 = space();
      create_component(menuitem2.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(menuseparator, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(menuitem2, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty & /*$$scope, closeThingsText*/
      268435520) {
        menuitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem2.$set(menuitem2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuseparator.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuseparator.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
      destroy_component(menuitem0, detaching);
      destroy_component(menuitem1, detaching);
      destroy_component(menuseparator, detaching);
      destroy_component(menuitem2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_173.name,
    type: "slot",
    source: '(28:0) <Menu align=\\"center\\" bind:this=\\"{thingsMenu1}\\">',
    ctx
  });
  return block;
}
function create_default_slot_164(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Add a thing (success)");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_164.name,
    type: "slot",
    source: '(37:1) <MenuItem success icon=\\"plus\\" data-value=\\"add-something\\" on:click=\\"{onMenuClick}\\">',
    ctx
  });
  return block;
}
function create_default_slot_154(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Add another one");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_154.name,
    type: "slot",
    source: "(38:1) <MenuItem>",
    ctx
  });
  return block;
}
function create_default_slot_144(ctx) {
  let t0;
  let t1;
  const block = {
    c: function create() {
      t0 = text(
        /*closeThingsText*/
        ctx[6]
      );
      t1 = text(" (danger)");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*closeThingsText*/
      64)
        set_data_dev(
          t0,
          /*closeThingsText*/
          ctx2[6]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_144.name,
    type: "slot",
    source: '(40:1) <MenuItem danger icon=\\"close\\" on:click=\\"{menuCloseThings}\\">',
    ctx
  });
  return block;
}
function create_default_slot_136(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuseparator;
  let t2;
  let menuitem2;
  let current;
  menuitem0 = new MenuItem_default({
    props: {
      success: true,
      icon: "plus",
      "data-value": "add-something",
      $$slots: { default: [create_default_slot_164] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem0.$on("click", onMenuClick);
  menuitem1 = new MenuItem_default({
    props: {
      $$slots: { default: [create_default_slot_154] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuseparator = new MenuSeparator_default({ $$inline: true });
  menuitem2 = new MenuItem_default({
    props: {
      danger: true,
      icon: "close",
      $$slots: { default: [create_default_slot_144] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem2.$on(
    "click",
    /*menuCloseThings*/
    ctx[12]
  );
  const block = {
    c: function create() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuseparator.$$.fragment);
      t2 = space();
      create_component(menuitem2.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(menuseparator, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(menuitem2, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty & /*$$scope, closeThingsText*/
      268435520) {
        menuitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem2.$set(menuitem2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuseparator.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuseparator.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
      destroy_component(menuitem0, detaching);
      destroy_component(menuitem1, detaching);
      destroy_component(menuseparator, detaching);
      destroy_component(menuitem2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_136.name,
    type: "slot",
    source: '(36:0) <Menu align=\\"right\\" bind:this=\\"{thingsMenu2}\\">',
    ctx
  });
  return block;
}
function create_default_slot_128(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Right edge");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_128.name,
    type: "slot",
    source: '(48:1) <Button on:click=\\"{someMenu3.open}\\">',
    ctx
  });
  return block;
}
function create_default_slot_1112(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("A very long text");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1112.name,
    type: "slot",
    source: '(52:1) <MenuItem icon=\\"plus\\">',
    ctx
  });
  return block;
}
function create_default_slot_107(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Another very long text");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_107.name,
    type: "slot",
    source: "(53:1) <MenuItem>",
    ctx
  });
  return block;
}
function create_default_slot_98(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Probably the longest text in the world!");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_98.name,
    type: "slot",
    source: '(55:1) <MenuItem icon=\\"close\\">',
    ctx
  });
  return block;
}
function create_default_slot_88(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuseparator;
  let t2;
  let menuitem2;
  let current;
  menuitem0 = new MenuItem_default({
    props: {
      icon: "plus",
      $$slots: { default: [create_default_slot_1112] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem1 = new MenuItem_default({
    props: {
      $$slots: { default: [create_default_slot_107] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuseparator = new MenuSeparator_default({ $$inline: true });
  menuitem2 = new MenuItem_default({
    props: {
      icon: "close",
      $$slots: { default: [create_default_slot_98] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuseparator.$$.fragment);
      t2 = space();
      create_component(menuitem2.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(menuseparator, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(menuitem2, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem2.$set(menuitem2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuseparator.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuseparator.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
      destroy_component(menuitem0, detaching);
      destroy_component(menuitem1, detaching);
      destroy_component(menuseparator, detaching);
      destroy_component(menuitem2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_88.name,
    type: "slot",
    source: '(51:0) <Menu bind:this=\\"{someMenu3}\\">',
    ctx
  });
  return block;
}
function create_default_slot_79(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("New Tab");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_79.name,
    type: "slot",
    source: '(72:1) <MenuItem shortcut=\\"cmd+t\\" on:click=\\"{newTab}\\" icon=\\"plus\\">',
    ctx
  });
  return block;
}
function create_default_slot_69(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("New Private Tab");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_69.name,
    type: "slot",
    source: '(73:1) <MenuItem shortcut=\\"cmd+shift+t\\" on:click=\\"{newPrivateTab}\\">',
    ctx
  });
  return block;
}
function create_default_slot_59(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*closeTabsText*/
        ctx[7]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*closeTabsText*/
      128)
        set_data_dev(
          t,
          /*closeTabsText*/
          ctx2[7]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_59.name,
    type: "slot",
    source: '(75:1) <MenuItem shortcut=\\"cmd+shift+w\\" icon=\\"close\\" on:click=\\"{closeTabs}\\">',
    ctx
  });
  return block;
}
function create_default_slot_412(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuseparator;
  let t2;
  let menuitem2;
  let current;
  menuitem0 = new MenuItem_default({
    props: {
      shortcut: "cmd+t",
      icon: "plus",
      $$slots: { default: [create_default_slot_79] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem0.$on(
    "click",
    /*newTab*/
    ctx[13]
  );
  menuitem1 = new MenuItem_default({
    props: {
      shortcut: "cmd+shift+t",
      $$slots: { default: [create_default_slot_69] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem1.$on(
    "click",
    /*newPrivateTab*/
    ctx[14]
  );
  menuseparator = new MenuSeparator_default({ $$inline: true });
  menuitem2 = new MenuItem_default({
    props: {
      shortcut: "cmd+shift+w",
      icon: "close",
      $$slots: { default: [create_default_slot_59] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem2.$on(
    "click",
    /*closeTabs*/
    ctx[15]
  );
  const block = {
    c: function create() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuseparator.$$.fragment);
      t2 = space();
      create_component(menuitem2.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(menuseparator, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(menuitem2, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty & /*$$scope, closeTabsText*/
      268435584) {
        menuitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem2.$set(menuitem2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuseparator.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuseparator.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
      destroy_component(menuitem0, detaching);
      destroy_component(menuitem1, detaching);
      destroy_component(menuseparator, detaching);
      destroy_component(menuitem2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_412.name,
    type: "slot",
    source: '(71:0) <Menu type=\\"context\\" targetSelector=\\".div1\\" bind:this=\\"{tabsMenu}\\" on:close=\\"{onTabsMenuClose}\\">',
    ctx
  });
  return block;
}
function create_default_slot_318(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("New window");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_318.name,
    type: "slot",
    source: '(79:1) <MenuItem shortcut=\\"cmd+n\\" on:click=\\"{newWindow}\\">',
    ctx
  });
  return block;
}
function create_default_slot_220(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("New private window");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_220.name,
    type: "slot",
    source: '(80:1) <MenuItem shortcut=\\"cmd+shift+n\\" on:click=\\"{newPrivateWindow}\\">',
    ctx
  });
  return block;
}
function create_default_slot_129(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Close All Windows");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_129.name,
    type: "slot",
    source: '(82:1) <MenuItem shortcut=\\"cmd+shift+q\\" on:click=\\"{closeWindows}\\">',
    ctx
  });
  return block;
}
function create_default_slot18(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuseparator;
  let t2;
  let menuitem2;
  let current;
  menuitem0 = new MenuItem_default({
    props: {
      shortcut: "cmd+n",
      $$slots: { default: [create_default_slot_318] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem0.$on(
    "click",
    /*newWindow*/
    ctx[17]
  );
  menuitem1 = new MenuItem_default({
    props: {
      shortcut: "cmd+shift+n",
      $$slots: { default: [create_default_slot_220] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem1.$on(
    "click",
    /*newPrivateWindow*/
    ctx[18]
  );
  menuseparator = new MenuSeparator_default({ $$inline: true });
  menuitem2 = new MenuItem_default({
    props: {
      shortcut: "cmd+shift+q",
      $$slots: { default: [create_default_slot_129] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  menuitem2.$on(
    "click",
    /*closeWindows*/
    ctx[19]
  );
  const block = {
    c: function create() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuseparator.$$.fragment);
      t2 = space();
      create_component(menuitem2.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(menuseparator, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(menuitem2, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menuitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem2.$set(menuitem2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuseparator.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuseparator.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
      destroy_component(menuitem0, detaching);
      destroy_component(menuitem1, detaching);
      destroy_component(menuseparator, detaching);
      destroy_component(menuitem2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot18.name,
    type: "slot",
    source: '(78:0) <Menu type=\\"context\\" targetSelector=\\".div2\\" bind:this=\\"{windowsMenu}\\">',
    ctx
  });
  return block;
}
function create_fragment89(ctx) {
  let h2;
  let t1;
  let h30;
  let t3;
  let div0;
  let button0;
  let t4;
  let button1;
  let t5;
  let button2;
  let t6;
  let menu0;
  let t7;
  let menu1;
  let t8;
  let menu2;
  let t9;
  let h31;
  let t11;
  let div1;
  let button3;
  let t12;
  let menu3;
  let t13;
  let h32;
  let t15;
  let p;
  let t17;
  let ul;
  let li0;
  let li1;
  let t20;
  let div2;
  let t22;
  let div3;
  let t24;
  let menu4;
  let t25;
  let menu5;
  let t26;
  let codeexample;
  let t27;
  let api0;
  let t28;
  let api1;
  let t29;
  let api2;
  let current;
  button0 = new Button_default({
    props: {
      "data-name": "show-menu-button",
      $$slots: { default: [create_default_slot_362] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button0.$on("click", function() {
    if (is_function(
      /*thingsMenu*/
      ctx[1].open
    ))
      ctx[1].open.apply(this, arguments);
  });
  button1 = new Button_default({
    props: {
      "data-name": "show-menu-button",
      $$slots: { default: [create_default_slot_352] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1.$on("click", function() {
    if (is_function(
      /*thingsMenu1*/
      ctx[2].open
    ))
      ctx[2].open.apply(this, arguments);
  });
  button2 = new Button_default({
    props: {
      "data-name": "show-menu-button",
      $$slots: { default: [create_default_slot_342] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button2.$on("click", function() {
    if (is_function(
      /*thingsMenu2*/
      ctx[3].open
    ))
      ctx[3].open.apply(this, arguments);
  });
  let menu0_props = {
    $$slots: { default: [create_default_slot_219] },
    $$scope: { ctx }
  };
  menu0 = new Menu_default({ props: menu0_props, $$inline: true });
  ctx[20](menu0);
  let menu1_props = {
    align: "center",
    $$slots: { default: [create_default_slot_173] },
    $$scope: { ctx }
  };
  menu1 = new Menu_default({ props: menu1_props, $$inline: true });
  ctx[21](menu1);
  let menu2_props = {
    align: "right",
    $$slots: { default: [create_default_slot_136] },
    $$scope: { ctx }
  };
  menu2 = new Menu_default({ props: menu2_props, $$inline: true });
  ctx[22](menu2);
  button3 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_128] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button3.$on("click", function() {
    if (is_function(
      /*someMenu3*/
      ctx[0].open
    ))
      ctx[0].open.apply(this, arguments);
  });
  let menu3_props = {
    $$slots: { default: [create_default_slot_88] },
    $$scope: { ctx }
  };
  menu3 = new Menu_default({ props: menu3_props, $$inline: true });
  ctx[23](menu3);
  let menu4_props = {
    type: "context",
    targetSelector: ".div1",
    $$slots: { default: [create_default_slot_412] },
    $$scope: { ctx }
  };
  menu4 = new Menu_default({ props: menu4_props, $$inline: true });
  ctx[24](menu4);
  menu4.$on(
    "close",
    /*onTabsMenuClose*/
    ctx[16]
  );
  let menu5_props = {
    type: "context",
    targetSelector: ".div2",
    $$slots: { default: [create_default_slot18] },
    $$scope: { ctx }
  };
  menu5 = new Menu_default({ props: menu5_props, $$inline: true });
  ctx[25](menu5);
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[11]
    ) },
    $$inline: true
  });
  api0 = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[8]
    ) },
    $$inline: true
  });
  api1 = new ApiTable_default({
    props: {
      props: (
        /*instanceApiProps*/
        ctx[9]
      ),
      title: "Menu Instance API",
      description: "The component exposes <em>this</em> property, to which a variable can be bound, creating an instance of the component, with the following API"
    },
    $$inline: true
  });
  api2 = new ApiTable_default({
    props: {
      props: (
        /*itemApiProps*/
        ctx[10]
      ),
      title: "Item API"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Menu";
      t1 = space();
      h30 = element2("h3");
      h30.textContent = "Normal menu";
      t3 = space();
      div0 = element2("div");
      create_component(button0.$$.fragment);
      t4 = space();
      create_component(button1.$$.fragment);
      t5 = space();
      create_component(button2.$$.fragment);
      t6 = space();
      create_component(menu0.$$.fragment);
      t7 = space();
      create_component(menu1.$$.fragment);
      t8 = space();
      create_component(menu2.$$.fragment);
      t9 = space();
      h31 = element2("h3");
      h31.textContent = "Close to the edge of the screen";
      t11 = space();
      div1 = element2("div");
      create_component(button3.$$.fragment);
      t12 = space();
      create_component(menu3.$$.fragment);
      t13 = space();
      h32 = element2("h3");
      h32.textContent = "Context menu";
      t15 = space();
      p = element2("p");
      p.textContent = "To open the context menu:";
      t17 = space();
      ul = element2("ul");
      li0 = element2("li");
      li0.textContent = "Desktop: right-click on the boxes below\n	";
      li1 = element2("li");
      li1.textContent = "Mobile: long-press on them";
      t20 = space();
      div2 = element2("div");
      div2.textContent = "Tab";
      t22 = space();
      div3 = element2("div");
      div3.textContent = "Window";
      t24 = space();
      create_component(menu4.$$.fragment);
      t25 = space();
      create_component(menu5.$$.fragment);
      t26 = space();
      create_component(codeexample.$$.fragment);
      t27 = space();
      create_component(api0.$$.fragment);
      t28 = space();
      create_component(api1.$$.fragment);
      t29 = space();
      create_component(api2.$$.fragment);
      add_location(h2, file82, 0, 0, 0);
      add_location(h30, file82, 2, 0, 15);
      attr_dev(div0, "class", "docs-buttons-row");
      add_location(div0, file82, 3, 0, 36);
      add_location(h31, file82, 45, 0, 1992);
      attr_dev(div1, "class", "docs-menu-align-right");
      add_location(div1, file82, 46, 0, 2033);
      add_location(h32, file82, 60, 0, 2367);
      add_location(p, file82, 61, 0, 2389);
      add_location(li0, file82, 63, 1, 2428);
      add_location(li1, file82, 64, 1, 2473);
      add_location(ul, file82, 62, 0, 2422);
      attr_dev(div2, "class", "div div1");
      add_location(div2, file82, 67, 0, 2511);
      attr_dev(div3, "class", "div div2");
      add_location(div3, file82, 68, 0, 2543);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, div0, anchor);
      mount_component(button0, div0, null);
      append_dev(div0, t4);
      mount_component(button1, div0, null);
      append_dev(div0, t5);
      mount_component(button2, div0, null);
      insert_dev(target, t6, anchor);
      mount_component(menu0, target, anchor);
      insert_dev(target, t7, anchor);
      mount_component(menu1, target, anchor);
      insert_dev(target, t8, anchor);
      mount_component(menu2, target, anchor);
      insert_dev(target, t9, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t11, anchor);
      insert_dev(target, div1, anchor);
      mount_component(button3, div1, null);
      insert_dev(target, t12, anchor);
      mount_component(menu3, target, anchor);
      insert_dev(target, t13, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t15, anchor);
      insert_dev(target, p, anchor);
      insert_dev(target, t17, anchor);
      insert_dev(target, ul, anchor);
      append_dev(ul, li0);
      append_dev(ul, li1);
      insert_dev(target, t20, anchor);
      insert_dev(target, div2, anchor);
      insert_dev(target, t22, anchor);
      insert_dev(target, div3, anchor);
      insert_dev(target, t24, anchor);
      mount_component(menu4, target, anchor);
      insert_dev(target, t25, anchor);
      mount_component(menu5, target, anchor);
      insert_dev(target, t26, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t27, anchor);
      mount_component(api0, target, anchor);
      insert_dev(target, t28, anchor);
      mount_component(api1, target, anchor);
      insert_dev(target, t29, anchor);
      mount_component(api2, target, anchor);
      current = true;
    },
    p: function update2(new_ctx, [dirty]) {
      ctx = new_ctx;
      const button0_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        button0_changes.$$scope = { dirty, ctx };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        button1_changes.$$scope = { dirty, ctx };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        button2_changes.$$scope = { dirty, ctx };
      }
      button2.$set(button2_changes);
      const menu0_changes = {};
      if (dirty & /*$$scope, closeThingsText*/
      268435520) {
        menu0_changes.$$scope = { dirty, ctx };
      }
      menu0.$set(menu0_changes);
      const menu1_changes = {};
      if (dirty & /*$$scope, closeThingsText*/
      268435520) {
        menu1_changes.$$scope = { dirty, ctx };
      }
      menu1.$set(menu1_changes);
      const menu2_changes = {};
      if (dirty & /*$$scope, closeThingsText*/
      268435520) {
        menu2_changes.$$scope = { dirty, ctx };
      }
      menu2.$set(menu2_changes);
      const button3_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        button3_changes.$$scope = { dirty, ctx };
      }
      button3.$set(button3_changes);
      const menu3_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menu3_changes.$$scope = { dirty, ctx };
      }
      menu3.$set(menu3_changes);
      const menu4_changes = {};
      if (dirty & /*$$scope, closeTabsText*/
      268435584) {
        menu4_changes.$$scope = { dirty, ctx };
      }
      menu4.$set(menu4_changes);
      const menu5_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        menu5_changes.$$scope = { dirty, ctx };
      }
      menu5.$set(menu5_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(menu0.$$.fragment, local);
      transition_in(menu1.$$.fragment, local);
      transition_in(menu2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      transition_in(menu3.$$.fragment, local);
      transition_in(menu4.$$.fragment, local);
      transition_in(menu5.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api0.$$.fragment, local);
      transition_in(api1.$$.fragment, local);
      transition_in(api2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(menu0.$$.fragment, local);
      transition_out(menu1.$$.fragment, local);
      transition_out(menu2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      transition_out(menu3.$$.fragment, local);
      transition_out(menu4.$$.fragment, local);
      transition_out(menu5.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api0.$$.fragment, local);
      transition_out(api1.$$.fragment, local);
      transition_out(api2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(h30);
        detach_dev(t3);
        detach_dev(div0);
        detach_dev(t6);
        detach_dev(t7);
        detach_dev(t8);
        detach_dev(t9);
        detach_dev(h31);
        detach_dev(t11);
        detach_dev(div1);
        detach_dev(t12);
        detach_dev(t13);
        detach_dev(h32);
        detach_dev(t15);
        detach_dev(p);
        detach_dev(t17);
        detach_dev(ul);
        detach_dev(t20);
        detach_dev(div2);
        detach_dev(t22);
        detach_dev(div3);
        detach_dev(t24);
        detach_dev(t25);
        detach_dev(t26);
        detach_dev(t27);
        detach_dev(t28);
        detach_dev(t29);
      }
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
      ctx[20](null);
      destroy_component(menu0, detaching);
      ctx[21](null);
      destroy_component(menu1, detaching);
      ctx[22](null);
      destroy_component(menu2, detaching);
      destroy_component(button3);
      ctx[23](null);
      destroy_component(menu3, detaching);
      ctx[24](null);
      destroy_component(menu4, detaching);
      ctx[25](null);
      destroy_component(menu5, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api0, detaching);
      destroy_component(api1, detaching);
      destroy_component(api2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment89.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function onMenuClick(e) {
  const { target, button } = e.detail;
  console.log(target.dataset, button.dataset);
}
function instance89($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Menu", slots2, []);
  const apiProps = [
    {
      name: "align",
      type: ["left", "right", "center"],
      default: "left",
      description: 'Align horizontally with the target.<br>Context menus will default to "center" on mobile.'
    },
    {
      name: "valign",
      type: ["top", "bottom"],
      default: "bottom",
      description: 'Show the menu above or below the target.<br>Context menus will default to "top" on mobile.<br>This may be overridden to ensure that the menu remains within the visible screen area.'
    },
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "closeOnClick",
      type: ["true", "false"],
      default: "true",
      description: "By default - menu will close when an item is clicked. Setting this property false will disable auto-closing."
    },
    {
      name: "targetSelector",
      type: "string",
      required: true,
      description: "This is only required when menu type is <em>context</em>.<br>It provides a selector to an element, in which the menu will appear (on mouse right-click)."
    },
    {
      name: "type",
      type: "context",
      description: "If type is set to <em>context</em> the menu will behave as context-menu."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "on:close",
      type: "function",
      description: "Triggered after the menu is closed."
    },
    {
      name: "on:open",
      type: "function",
      description: "Triggered after the menu is opened."
    }
  ];
  const instanceApiProps = [
    {
      name: "close",
      type: "function",
      description: "Closes the menu."
    },
    {
      name: "open",
      type: "function",
      description: "Opens the menu."
    }
  ];
  const itemApiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the menu item."
    },
    {
      name: "danger",
      description: "Button type: danger"
    },
    {
      name: "data-",
      description: "Dataset attribute allows to pass some data of a primitive type (string, number, boolean), which will be accessible in the <em>on:click</em> event listener, via button reference."
    },
    {
      name: "disabled",
      description: "Makes the menu item (button) <i>disabled</i>"
    },
    {
      name: "icon",
      type: "string",
      description: 'Adds an icon, with this name, to the button (see <a href="#Icon">icons</a> section for icon names)'
    },
    {
      name: "id",
      type: "string",
      description: "Assign ID to the underlying button"
    },
    {
      name: "shortcut",
      type: "string",
      description: "A string representation of a keyboard shortcut. e.g. <em>cmd+alt+c</em>.<br>Keys should be separated by a <em>+</em> sign (which will be hidden in the rendered item).<br>Special keys (like cmd, alt, ctrl, shift, escape, enter, etc.) will be replaced by a corresponding symbol.<br>Keyboard handling must be done elsewhere."
    },
    {
      name: "success",
      description: "Button type: success"
    },
    {
      name: "title",
      type: "string",
      description: "Assign title to the underlying button"
    },
    {
      name: "warning",
      description: "Button type: warning"
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "on:click",
      type: "function",
      description: "Triggered when the menu item was clicked.<br>The event handler function receives 1 argument - the click event.<br>By calling <em>event.preventDefault();</em> it is possible to prevent menu from auto closing when the item was clicked.<br><em>event.detail</em> will contain a <em>button</em> and <em>target</em> properties, that are references to the corresponding html elements.<br>It is possible to pass the data using <em>data-</em> attributes on the <em>target</em> element and on the <em>MenuItem</em>."
    }
  ];
  const exampleHtml = `
<!-- Regular menu -->
<Menu bind:this="{menu1}">
    <MenuItem data-value="add-something"><Icon name="plus"/> Add some</MenuItem>
    <MenuItem>Add some more</MenuItem>
    <MenuSeparator />
    <MenuItem on:click="{closeSomething}"><Icon name="close"/> Close something</MenuItem>
</Menu>

<Button data-name="button-with-menu" on:click="{menu1.open}">Show menu</Button>

<!-- Context menu -->
<div class="div1">Tab</div>
<Menu type="context" targetSelector=".div1" bind:this="{menu2}">
    <MenuItem shortcut="cmd+n" on:click="{action1}">New window</MenuItem>
    <MenuItem shortcut="cmd+shift+n" on:click="{action2}">New private window</MenuItem>
    <MenuSeparator />
    <MenuItem shortcut="cmd+shift+q" on:click="{action3}">Close All Windows</MenuItem>
</Menu>

<script>
    let menu1, menu2;
    function closeSomething (e) {
        e.preventDefault();   // prevents menu auto-closing
        menu1.close();       // manually close the menu
    }
    function onMenuClick (e) {
        const { target, button } = e.detail;
        console.log(target.dataset, button.dataset);
    }
&lt;/script>
`;
  let someMenu3, thingsMenu, thingsMenu1, thingsMenu2, tabsMenu, windowsMenu;
  let closeThingsText = "Close all things";
  let closeTabsText = "Close all tabs";
  let thingsMenuTimer, tabsMenutimer;
  function menuCloseThings(e) {
    if (e)
      e.preventDefault();
    const initial = "Close all things";
    const confrm = "Confirm Closing";
    if (closeThingsText === initial) {
      $$invalidate2(6, closeThingsText = confrm);
      thingsMenuTimer = setTimeout(() => $$invalidate2(6, closeThingsText = initial), 2e3);
    } else {
      Promise.all([thingsMenu.close(), thingsMenu1.close(), thingsMenu2.close()]).then(() => {
        $$invalidate2(6, closeThingsText = initial);
        if (thingsMenuTimer)
          clearTimeout(thingsMenuTimer);
        alert("Closed all things!");
      });
    }
  }
  function newTab() {
    tabsMenu.close().then(() => alert("New Tab clicked"));
  }
  function newPrivateTab() {
    tabsMenu.close().then(() => alert("New Private Tab clicked"));
  }
  function closeTabs(e) {
    if (e)
      e.preventDefault();
    const initial = "Close all tabs";
    const confrm = "Confirm Closing";
    if (closeTabsText === initial) {
      $$invalidate2(7, closeTabsText = confrm);
      tabsMenutimer = setTimeout(() => $$invalidate2(7, closeTabsText = initial), 2e3);
    } else
      tabsMenu.close().then(() => alert("Closed all tabs!"));
  }
  function onTabsMenuClose() {
    $$invalidate2(7, closeTabsText = "Close all tabs");
    if (tabsMenutimer)
      clearTimeout(tabsMenutimer);
  }
  function newWindow() {
    windowsMenu.close().then(() => alert("New Window clicked"));
  }
  function newPrivateWindow() {
    windowsMenu.close().then(() => alert("New Private Window clicked"));
  }
  function closeWindows() {
    windowsMenu.close().then(() => alert("Windows closed!"));
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_117.warn(`<Menu> was created with unknown prop '${key}'`);
  });
  function menu0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      thingsMenu = $$value;
      $$invalidate2(1, thingsMenu);
    });
  }
  function menu1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      thingsMenu1 = $$value;
      $$invalidate2(2, thingsMenu1);
    });
  }
  function menu2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      thingsMenu2 = $$value;
      $$invalidate2(3, thingsMenu2);
    });
  }
  function menu3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      someMenu3 = $$value;
      $$invalidate2(0, someMenu3);
    });
  }
  function menu4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tabsMenu = $$value;
      $$invalidate2(4, tabsMenu);
    });
  }
  function menu5_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      windowsMenu = $$value;
      $$invalidate2(5, windowsMenu);
    });
  }
  $$self2.$capture_state = () => ({
    Button: Button_default,
    Menu: Menu_default,
    MenuItem: MenuItem_default,
    MenuSeparator: MenuSeparator_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    instanceApiProps,
    itemApiProps,
    exampleHtml,
    someMenu3,
    thingsMenu,
    thingsMenu1,
    thingsMenu2,
    tabsMenu,
    windowsMenu,
    closeThingsText,
    closeTabsText,
    thingsMenuTimer,
    tabsMenutimer,
    onMenuClick,
    menuCloseThings,
    newTab,
    newPrivateTab,
    closeTabs,
    onTabsMenuClose,
    newWindow,
    newPrivateWindow,
    closeWindows
  });
  $$self2.$inject_state = ($$props3) => {
    if ("someMenu3" in $$props3)
      $$invalidate2(0, someMenu3 = $$props3.someMenu3);
    if ("thingsMenu" in $$props3)
      $$invalidate2(1, thingsMenu = $$props3.thingsMenu);
    if ("thingsMenu1" in $$props3)
      $$invalidate2(2, thingsMenu1 = $$props3.thingsMenu1);
    if ("thingsMenu2" in $$props3)
      $$invalidate2(3, thingsMenu2 = $$props3.thingsMenu2);
    if ("tabsMenu" in $$props3)
      $$invalidate2(4, tabsMenu = $$props3.tabsMenu);
    if ("windowsMenu" in $$props3)
      $$invalidate2(5, windowsMenu = $$props3.windowsMenu);
    if ("closeThingsText" in $$props3)
      $$invalidate2(6, closeThingsText = $$props3.closeThingsText);
    if ("closeTabsText" in $$props3)
      $$invalidate2(7, closeTabsText = $$props3.closeTabsText);
    if ("thingsMenuTimer" in $$props3)
      thingsMenuTimer = $$props3.thingsMenuTimer;
    if ("tabsMenutimer" in $$props3)
      tabsMenutimer = $$props3.tabsMenutimer;
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    someMenu3,
    thingsMenu,
    thingsMenu1,
    thingsMenu2,
    tabsMenu,
    windowsMenu,
    closeThingsText,
    closeTabsText,
    apiProps,
    instanceApiProps,
    itemApiProps,
    exampleHtml,
    menuCloseThings,
    newTab,
    newPrivateTab,
    closeTabs,
    onTabsMenuClose,
    newWindow,
    newPrivateWindow,
    closeWindows,
    menu0_binding,
    menu1_binding,
    menu2_binding,
    menu3_binding,
    menu4_binding,
    menu5_binding
  ];
}
var Menu_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance89, create_fragment89, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu_1",
      options,
      id: create_fragment89.name
    });
  }
};
var Menu_default2 = Menu_1;

// docs-src/components/icon/Icon.svelte
var { Object: Object_15 } = globals;
var file83 = "docs-src/components/icon/Icon.svelte";
function get_each_context18(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function get_each_context_15(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_each_block_15(ctx) {
  let div2;
  let div0;
  let icon_1;
  let t0;
  let div1;
  let div2_title_value;
  let current;
  icon_1 = new Icon_default({
    props: { name: (
      /*icon*/
      ctx[4]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      div2 = element2("div");
      div0 = element2("div");
      create_component(icon_1.$$.fragment);
      t0 = space();
      div1 = element2("div");
      div1.textContent = `${/*icon*/
      ctx[4]}`;
      attr_dev(div0, "class", "icon-block-icon");
      add_location(div0, file83, 4, 3, 116);
      attr_dev(div1, "class", "icon-block-name");
      add_location(div1, file83, 5, 3, 176);
      attr_dev(div2, "class", "icon-block");
      attr_dev(div2, "title", div2_title_value = /*icon*/
      ctx[4]);
      add_location(div2, file83, 3, 2, 73);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      mount_component(icon_1, div0, null);
      append_dev(div2, t0);
      append_dev(div2, div1);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(icon_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_15.name,
    type: "each",
    source: "(3:1) {#each Object.keys(icons) as icon}",
    ctx
  });
  return block;
}
function create_each_block18(ctx) {
  let div2;
  let div0;
  let icon_1;
  let t0;
  let div1;
  let t2;
  let div2_title_value;
  let current;
  icon_1 = new Icon_default({
    props: { name: (
      /*icon*/
      ctx[4]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      div2 = element2("div");
      div0 = element2("div");
      create_component(icon_1.$$.fragment);
      t0 = space();
      div1 = element2("div");
      div1.textContent = `${/*icon*/
      ctx[4]}`;
      t2 = space();
      attr_dev(div0, "class", "icon-block-icon");
      add_location(div0, file83, 10, 3, 323);
      attr_dev(div1, "class", "icon-block-name");
      add_location(div1, file83, 11, 3, 383);
      attr_dev(div2, "class", "icon-block");
      attr_dev(div2, "title", div2_title_value = /*icon*/
      ctx[4]);
      add_location(div2, file83, 9, 2, 280);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      mount_component(icon_1, div0, null);
      append_dev(div2, t0);
      append_dev(div2, div1);
      append_dev(div2, t2);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(icon_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block18.name,
    type: "each",
    source: "(9:1) {#each Object.keys(customIcons) as icon}",
    ctx
  });
  return block;
}
function create_default_slot19(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Custom Icon Button");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot19.name,
    type: "slot",
    source: '(18:0) <Button icon=\\"customIcon\\">',
    ctx
  });
  return block;
}
function create_fragment90(ctx) {
  let h20;
  let t1;
  let div;
  let t2;
  let t3;
  let h21;
  let t5;
  let button;
  let t6;
  let codeexample;
  let t7;
  let api0;
  let t8;
  let api1;
  let t9;
  let api2;
  let current;
  let each_value_1 = ensure_array_like_dev(Object.keys(icons));
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_15(get_each_context_15(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let each_value = ensure_array_like_dev(Object.keys(customIcons));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block18(get_each_context18(ctx, each_value, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  button = new Button_default({
    props: {
      icon: "customIcon",
      $$slots: { default: [create_default_slot19] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[3]
    ) },
    $$inline: true
  });
  api0 = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  api1 = new ApiTable_default({
    props: {
      props: (
        /*addIconAPI*/
        ctx[1]
      ),
      title: "addIcon function",
      description: "The component exports a global <em>addIcon</em> function with the following arguments:"
    },
    $$inline: true
  });
  api2 = new ApiTable_default({
    props: {
      props: (
        /*getIconAPI*/
        ctx[2]
      ),
      title: "getIcon function",
      description: "The component exports a global <em>getIcon</em> function that can be used to retrieve the icon's svg code (as string). The function accepts the following argument:"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      h20 = element2("h2");
      h20.textContent = "Icons";
      t1 = space();
      div = element2("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      h21 = element2("h2");
      h21.textContent = "Custom Icon";
      t5 = space();
      create_component(button.$$.fragment);
      t6 = space();
      create_component(codeexample.$$.fragment);
      t7 = space();
      create_component(api0.$$.fragment);
      t8 = space();
      create_component(api1.$$.fragment);
      t9 = space();
      create_component(api2.$$.fragment);
      add_location(h20, file83, 0, 0, 0);
      attr_dev(div, "class", "icons");
      add_location(div, file83, 1, 0, 15);
      add_location(h21, file83, 16, 0, 451);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h20, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div, null);
        }
      }
      append_dev(div, t2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      insert_dev(target, t3, anchor);
      insert_dev(target, h21, anchor);
      insert_dev(target, t5, anchor);
      mount_component(button, target, anchor);
      insert_dev(target, t6, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t7, anchor);
      mount_component(api0, target, anchor);
      insert_dev(target, t8, anchor);
      mount_component(api1, target, anchor);
      insert_dev(target, t9, anchor);
      mount_component(api2, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      if (dirty & /*Object*/
      0) {
        each_value_1 = ensure_array_like_dev(Object.keys(icons));
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_15(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_15(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(div, t2);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (dirty & /*Object*/
      0) {
        each_value = ensure_array_like_dev(Object.keys(customIcons));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context18(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block18(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
      const button_changes = {};
      if (dirty & /*$$scope*/
      512) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(button.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api0.$$.fragment, local);
      transition_in(api1.$$.fragment, local);
      transition_in(api2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(button.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api0.$$.fragment, local);
      transition_out(api1.$$.fragment, local);
      transition_out(api2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h20);
        detach_dev(t1);
        detach_dev(div);
        detach_dev(t3);
        detach_dev(h21);
        detach_dev(t5);
        detach_dev(t6);
        detach_dev(t7);
        detach_dev(t8);
        detach_dev(t9);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      destroy_component(button, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api0, detaching);
      destroy_component(api1, detaching);
      destroy_component(api2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment90.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance90($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Icon", slots2, []);
  addIcon("customIcon", "<[CUSTOM ICON]>");
  const apiProps = [
    {
      name: "name",
      type: "string",
      description: "Name of the icon."
    }
  ];
  const addIconAPI = [
    {
      name: "name",
      type: "string",
      description: "Name of the custom icon."
    },
    {
      name: "svg",
      type: "string",
      description: "SVG code."
    }
  ];
  const getIconAPI = [
    {
      name: "name",
      type: "string",
      description: "Name of the icon."
    }
  ];
  const exampleHtml = `
<Icon name="alert"/>
<Icon name="customIcon"/>

<script>
	import { addIcon } from '@perfectthings/ui';

	addIcon('customIcon', '<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24">...</svg>');
&lt;/script>
`;
  const writable_props = [];
  Object_15.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Icon> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    Icon: Icon_default,
    icons,
    customIcons,
    addIcon,
    Button: Button_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    addIconAPI,
    getIconAPI,
    exampleHtml
  });
  return [apiProps, addIconAPI, getIconAPI, exampleHtml];
}
var Icon_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance90, create_fragment90, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icon_1",
      options,
      id: create_fragment90.name
    });
  }
};
var Icon_default2 = Icon_1;

// docs-src/components/tag/Tag.svelte
var file84 = "docs-src/components/tag/Tag.svelte";
function create_default_slot_99(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Tag 123");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_99.name,
    type: "slot",
    source: "(4:0) <Tag>",
    ctx
  });
  return block;
}
function create_default_slot_89(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Closable tag");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_89.name,
    type: "slot",
    source: '(8:0) <Tag icon=\\"close\\">',
    ctx
  });
  return block;
}
function create_default_slot_710(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Add tag");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_710.name,
    type: "slot",
    source: '(9:0) <Tag icon=\\"plus\\">',
    ctx
  });
  return block;
}
function create_default_slot_610(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Info");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_610.name,
    type: "slot",
    source: '(13:0) <Tag color=\\"info\\">',
    ctx
  });
  return block;
}
function create_default_slot_510(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Warning");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_510.name,
    type: "slot",
    source: '(14:0) <Tag color=\\"warning\\">',
    ctx
  });
  return block;
}
function create_default_slot_413(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Danger");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_413.name,
    type: "slot",
    source: '(15:0) <Tag color=\\"danger\\">',
    ctx
  });
  return block;
}
function create_default_slot_319(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Success");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_319.name,
    type: "slot",
    source: '(16:0) <Tag color=\\"success\\">',
    ctx
  });
  return block;
}
function create_default_slot_221(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Custom color");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_221.name,
    type: "slot",
    source: '(17:0) <Tag color=\\"#ac6453\\">',
    ctx
  });
  return block;
}
function create_default_slot_130(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Round tag");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_130.name,
    type: "slot",
    source: "(21:0) <Tag round>",
    ctx
  });
  return block;
}
function create_default_slot20(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Click me");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot20.name,
    type: "slot",
    source: '(25:0) <Tag clickable on:click=\\"{onclick}\\">',
    ctx
  });
  return block;
}
function create_fragment91(ctx) {
  let h2;
  let t1;
  let h30;
  let t3;
  let tag0;
  let t4;
  let h31;
  let t6;
  let tag1;
  let t7;
  let tag2;
  let t8;
  let h32;
  let t10;
  let tag3;
  let t11;
  let tag4;
  let t12;
  let tag5;
  let t13;
  let tag6;
  let t14;
  let tag7;
  let t15;
  let h33;
  let t17;
  let tag8;
  let t18;
  let h34;
  let t20;
  let tag9;
  let t21;
  let codeexample;
  let t22;
  let api;
  let current;
  tag0 = new Tag_default({
    props: {
      $$slots: { default: [create_default_slot_99] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tag1 = new Tag_default({
    props: {
      icon: "close",
      $$slots: { default: [create_default_slot_89] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tag2 = new Tag_default({
    props: {
      icon: "plus",
      $$slots: { default: [create_default_slot_710] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tag3 = new Tag_default({
    props: {
      color: "info",
      $$slots: { default: [create_default_slot_610] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tag4 = new Tag_default({
    props: {
      color: "warning",
      $$slots: { default: [create_default_slot_510] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tag5 = new Tag_default({
    props: {
      color: "danger",
      $$slots: { default: [create_default_slot_413] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tag6 = new Tag_default({
    props: {
      color: "success",
      $$slots: { default: [create_default_slot_319] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tag7 = new Tag_default({
    props: {
      color: "#ac6453",
      $$slots: { default: [create_default_slot_221] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tag8 = new Tag_default({
    props: {
      round: true,
      $$slots: { default: [create_default_slot_130] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tag9 = new Tag_default({
    props: {
      clickable: true,
      $$slots: { default: [create_default_slot20] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tag9.$on("click", onclick3);
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[1]
    ) },
    $$inline: true
  });
  api = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Tag";
      t1 = space();
      h30 = element2("h3");
      h30.textContent = "Normal";
      t3 = space();
      create_component(tag0.$$.fragment);
      t4 = space();
      h31 = element2("h3");
      h31.textContent = "With icon";
      t6 = space();
      create_component(tag1.$$.fragment);
      t7 = space();
      create_component(tag2.$$.fragment);
      t8 = space();
      h32 = element2("h3");
      h32.textContent = "Colourful";
      t10 = space();
      create_component(tag3.$$.fragment);
      t11 = space();
      create_component(tag4.$$.fragment);
      t12 = space();
      create_component(tag5.$$.fragment);
      t13 = space();
      create_component(tag6.$$.fragment);
      t14 = space();
      create_component(tag7.$$.fragment);
      t15 = space();
      h33 = element2("h3");
      h33.textContent = "Round";
      t17 = space();
      create_component(tag8.$$.fragment);
      t18 = space();
      h34 = element2("h3");
      h34.textContent = "With click action";
      t20 = space();
      create_component(tag9.$$.fragment);
      t21 = space();
      create_component(codeexample.$$.fragment);
      t22 = space();
      create_component(api.$$.fragment);
      add_location(h2, file84, 0, 0, 0);
      add_location(h30, file84, 2, 0, 14);
      add_location(h31, file84, 6, 0, 51);
      add_location(h32, file84, 11, 0, 140);
      add_location(h33, file84, 19, 0, 333);
      add_location(h34, file84, 23, 0, 377);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t3, anchor);
      mount_component(tag0, target, anchor);
      insert_dev(target, t4, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t6, anchor);
      mount_component(tag1, target, anchor);
      insert_dev(target, t7, anchor);
      mount_component(tag2, target, anchor);
      insert_dev(target, t8, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t10, anchor);
      mount_component(tag3, target, anchor);
      insert_dev(target, t11, anchor);
      mount_component(tag4, target, anchor);
      insert_dev(target, t12, anchor);
      mount_component(tag5, target, anchor);
      insert_dev(target, t13, anchor);
      mount_component(tag6, target, anchor);
      insert_dev(target, t14, anchor);
      mount_component(tag7, target, anchor);
      insert_dev(target, t15, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t17, anchor);
      mount_component(tag8, target, anchor);
      insert_dev(target, t18, anchor);
      insert_dev(target, h34, anchor);
      insert_dev(target, t20, anchor);
      mount_component(tag9, target, anchor);
      insert_dev(target, t21, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t22, anchor);
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const tag0_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tag0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag0.$set(tag0_changes);
      const tag1_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tag1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag1.$set(tag1_changes);
      const tag2_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tag2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag2.$set(tag2_changes);
      const tag3_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tag3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag3.$set(tag3_changes);
      const tag4_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tag4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag4.$set(tag4_changes);
      const tag5_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tag5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag5.$set(tag5_changes);
      const tag6_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tag6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag6.$set(tag6_changes);
      const tag7_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tag7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag7.$set(tag7_changes);
      const tag8_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tag8_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag8.$set(tag8_changes);
      const tag9_changes = {};
      if (dirty & /*$$scope*/
      4) {
        tag9_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag9.$set(tag9_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tag0.$$.fragment, local);
      transition_in(tag1.$$.fragment, local);
      transition_in(tag2.$$.fragment, local);
      transition_in(tag3.$$.fragment, local);
      transition_in(tag4.$$.fragment, local);
      transition_in(tag5.$$.fragment, local);
      transition_in(tag6.$$.fragment, local);
      transition_in(tag7.$$.fragment, local);
      transition_in(tag8.$$.fragment, local);
      transition_in(tag9.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tag0.$$.fragment, local);
      transition_out(tag1.$$.fragment, local);
      transition_out(tag2.$$.fragment, local);
      transition_out(tag3.$$.fragment, local);
      transition_out(tag4.$$.fragment, local);
      transition_out(tag5.$$.fragment, local);
      transition_out(tag6.$$.fragment, local);
      transition_out(tag7.$$.fragment, local);
      transition_out(tag8.$$.fragment, local);
      transition_out(tag9.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(h30);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(h31);
        detach_dev(t6);
        detach_dev(t7);
        detach_dev(t8);
        detach_dev(h32);
        detach_dev(t10);
        detach_dev(t11);
        detach_dev(t12);
        detach_dev(t13);
        detach_dev(t14);
        detach_dev(t15);
        detach_dev(h33);
        detach_dev(t17);
        detach_dev(t18);
        detach_dev(h34);
        detach_dev(t20);
        detach_dev(t21);
        detach_dev(t22);
      }
      destroy_component(tag0, detaching);
      destroy_component(tag1, detaching);
      destroy_component(tag2, detaching);
      destroy_component(tag3, detaching);
      destroy_component(tag4, detaching);
      destroy_component(tag5, detaching);
      destroy_component(tag6, detaching);
      destroy_component(tag7, detaching);
      destroy_component(tag8, detaching);
      destroy_component(tag9, detaching);
      destroy_component(codeexample, detaching);
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment91.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function onclick3() {
  alert("Clicked!");
}
function instance91($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Tag", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "clickable",
      description: "When passed, the tag will be interactive."
    },
    {
      name: "color",
      type: "string",
      description: "Tag color. Standard variations are included (info, warning, danger, success). A color hash or name can also be provided."
    },
    {
      name: "disabled",
      description: "Makes the tag <i>disabled</i>"
    },
    {
      name: "icon",
      type: "string",
      description: "Icon name to display in the tag."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "on:click",
      type: "function",
      description: "Triggered when the tag is clicked."
    }
  ];
  const exampleHtml = `
<Tag icon="close">Closable tag</Tag>
<Tag color="success">Success</Tag>
<Tag color="#132231">Custom color</Tag>
<Tag on:click="{onclick}">Click me</Tag>

<script>
	function onclick () {
		alert('Clicked!');
	}
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tag> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    Tag: Tag_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    exampleHtml,
    onclick: onclick3
  });
  return [apiProps, exampleHtml];
}
var Tag_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance91, create_fragment91, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tag_1",
      options,
      id: create_fragment91.name
    });
  }
};
var Tag_default2 = Tag_1;

// docs-src/components/utils/functions/index.js
var functions_exports = {};
__export(functions_exports, {
  alignItem: () => align_item_default,
  animate: () => animate_default,
  blink: () => blink_default,
  debounce: () => debounce_default,
  empty: () => empty_default,
  formatDate: () => format_date_default,
  fuzzy: () => fuzzy_default,
  getMouseX: () => get_mouse_x_svelte_default,
  getMouseXY: () => get_mouse_xy_svelte_default,
  getMouseY: () => get_mouse_y_svelte_default,
  guid: () => guid_default,
  isColorDark: () => is_color_dark_default,
  isInScrollable: () => is_in_scrollable_default,
  isMobile: () => is_mobile_default,
  isset: () => isset_default,
  pluck: () => pluck_default,
  roundAmount: () => round_amount_default,
  throttle: () => throttle_default,
  timeAgo: () => time_ago_default
});

// docs-src/components/utils/Util.svelte
var file85 = "docs-src/components/utils/Util.svelte";
function create_if_block_18(ctx) {
  let api_1;
  let current;
  api_1 = new ApiTable_default({
    props: {
      props: (
        /*api*/
        ctx[3]
      ),
      title: "Config object schema"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(api_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(api_1, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const api_1_changes = {};
      if (dirty & /*api*/
      8)
        api_1_changes.props = /*api*/
        ctx2[3];
      api_1.$set(api_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(api_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(api_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(api_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(6:1) {#if api}",
    ctx
  });
  return block;
}
function create_if_block31(ctx) {
  let codeexample;
  let current;
  codeexample = new CodeExample_default({
    props: { nohr: true, html: (
      /*example*/
      ctx[2]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(codeexample.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(codeexample, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const codeexample_changes = {};
      if (dirty & /*example*/
      4)
        codeexample_changes.html = /*example*/
        ctx2[2];
      codeexample.$set(codeexample_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(codeexample.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(codeexample.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(codeexample, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block31.name,
    type: "if",
    source: "(10:1) {#if example}",
    ctx
  });
  return block;
}
function create_fragment92(ctx) {
  let div;
  let h3;
  let a;
  let t0;
  let a_href_value;
  let t1;
  let t2;
  let t3;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let if_block0 = (
    /*api*/
    ctx[3] && create_if_block_18(ctx)
  );
  let if_block1 = (
    /*example*/
    ctx[2] && create_if_block31(ctx)
  );
  const block = {
    c: function create() {
      div = element2("div");
      h3 = element2("h3");
      a = element2("a");
      t0 = text(
        /*name*/
        ctx[1]
      );
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr_dev(a, "href", a_href_value = "#Utils/" + /*id*/
      ctx[0]);
      add_location(a, file85, 1, 10, 32);
      attr_dev(
        h3,
        "id",
        /*id*/
        ctx[0]
      );
      add_location(h3, file85, 1, 1, 23);
      attr_dev(div, "class", "utility");
      add_location(div, file85, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, h3);
      append_dev(h3, a);
      append_dev(a, t0);
      append_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(div, t2);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      if (!current || dirty & /*name*/
      2)
        set_data_dev(
          t0,
          /*name*/
          ctx2[1]
        );
      if (!current || dirty & /*id*/
      1 && a_href_value !== (a_href_value = "#Utils/" + /*id*/
      ctx2[0])) {
        attr_dev(a, "href", a_href_value);
      }
      if (!current || dirty & /*id*/
      1) {
        attr_dev(
          h3,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*api*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*api*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_18(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*example*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*example*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block31(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment92.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance92($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Util", slots2, ["default"]);
  let { id: id2 = "" } = $$props2;
  let { name: name2 = "" } = $$props2;
  let { example = void 0 } = $$props2;
  let { api = void 0 } = $$props2;
  const writable_props = ["id", "name", "example", "api"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Util> was created with unknown prop '${key}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("id" in $$props3)
      $$invalidate2(0, id2 = $$props3.id);
    if ("name" in $$props3)
      $$invalidate2(1, name2 = $$props3.name);
    if ("example" in $$props3)
      $$invalidate2(2, example = $$props3.example);
    if ("api" in $$props3)
      $$invalidate2(3, api = $$props3.api);
    if ("$$scope" in $$props3)
      $$invalidate2(4, $$scope2 = $$props3.$$scope);
  };
  $$self2.$capture_state = () => ({ CodeExample: CodeExample_default, API: ApiTable_default, id: id2, name: name2, example, api });
  $$self2.$inject_state = ($$props3) => {
    if ("id" in $$props3)
      $$invalidate2(0, id2 = $$props3.id);
    if ("name" in $$props3)
      $$invalidate2(1, name2 = $$props3.name);
    if ("example" in $$props3)
      $$invalidate2(2, example = $$props3.example);
    if ("api" in $$props3)
      $$invalidate2(3, api = $$props3.api);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [id2, name2, example, api, $$scope2, slots2];
}
var Util = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance92, create_fragment92, safe_not_equal, { id: 0, name: 1, example: 2, api: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Util",
      options,
      id: create_fragment92.name
    });
  }
  get id() {
    throw new Error("<Util>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value2) {
    throw new Error("<Util>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Util>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value2) {
    throw new Error("<Util>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get example() {
    throw new Error("<Util>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set example(value2) {
    throw new Error("<Util>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get api() {
    throw new Error("<Util>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set api(value2) {
    throw new Error("<Util>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Util_default = Util;

// docs-src/components/utils/functions/align-item.svelte
var file86 = "docs-src/components/utils/functions/align-item.svelte";
function create_default_slot21(ctx) {
  let p;
  let t1;
  let ul;
  let li0;
  let em0;
  let t3;
  let li1;
  let t4;
  let em1;
  let t6;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "Aligns an element to another element,\n		ensuring that the aligned element remains within the viewport.";
      t1 = space();
      ul = element2("ul");
      li0 = element2("li");
      em0 = element2("em");
      em0.textContent = "config";
      t3 = text(" - an object with the configuration (see below).\n		");
      li1 = element2("li");
      t4 = text("Returns ");
      em1 = element2("em");
      em1.textContent = "position";
      t6 = text(" - whether the aligned item is above (top) or below (bottom) the target.");
      add_location(p, file86, 1, 1, 64);
      add_location(em0, file86, 5, 6, 188);
      add_location(li0, file86, 5, 2, 184);
      add_location(em1, file86, 6, 14, 266);
      add_location(li1, file86, 6, 2, 254);
      add_location(ul, file86, 4, 1, 177);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, ul, anchor);
      append_dev(ul, li0);
      append_dev(li0, em0);
      append_dev(li0, t3);
      append_dev(ul, li1);
      append_dev(li1, t4);
      append_dev(li1, em1);
      append_dev(li1, t6);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
        detach_dev(t1);
        detach_dev(ul);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot21.name,
    type: "slot",
    source: '(1:0) <Util id=\\"alignItem\\" name=\\"alignItem(config)\\" {example} {api}>',
    ctx
  });
  return block;
}
function create_fragment93(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "alignItem",
      name: "alignItem(config)",
      example: (
        /*example*/
        ctx[0]
      ),
      api: (
        /*api*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot21] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      4) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment93.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance93($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Align_item", slots2, []);
  const example = `
<script>
	const button = document.querySelector('.button1');
	const popup = document.querySelector('.popup1');
	const pos = alignItem({
		element: popup,
		target: button,
		alignH: 'left',
		alignV: 'bottom',
	});
	// it may happen that there is not enough space to align the popup as requested
	// in this case, the popup will be aligned to the opposite side
	console.log('position:', pos); // 'top'
&lt;/script>
`;
  const api = [
    {
      name: "element",
      type: "HTMLElement",
      description: "main element that will be aligned."
    },
    {
      name: "target",
      type: "HTMLElement",
      description: "target element to align to."
    },
    {
      name: "alignH",
      type: ["left", "right", "center"],
      default: "left",
      description: "Horizontal position"
    },
    {
      name: "offsetH",
      type: "number",
      default: 0,
      description: "horizontal offset of the aligned position (in pixels)."
    },
    {
      name: "alignV",
      type: ["top", "bottom"],
      default: "bottom",
      description: "Vertical position"
    },
    {
      name: "offsetV",
      type: "number",
      default: 2,
      description: "vertical offset of the aligned position (in pixels)."
    },
    {
      name: "viewportPadding",
      type: "number",
      default: 10,
      description: "padding from the viewport (in pixels)."
    },
    {
      name: "setMinWidthToTarget",
      type: "boolean",
      default: false,
      description: "whether to set the minWidth of the element to the width of the target."
    }
  ];
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Align_item> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example, api });
  return [example, api];
}
var Align_item = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance93, create_fragment93, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Align_item",
      options,
      id: create_fragment93.name
    });
  }
};
var align_item_default = Align_item;

// docs-src/components/utils/functions/animate.svelte
var file87 = "docs-src/components/utils/functions/animate.svelte";
function create_default_slot22(ctx) {
  let p0;
  let t1;
  let p1;
  const block = {
    c: function create() {
      p0 = element2("p");
      p0.textContent = "Animates an element from one state to another. Shortcut & wrapper for the native javascript animation.";
      t1 = space();
      p1 = element2("p");
      p1.textContent = "Returns a promise which resolves when the animation finishes.";
      add_location(p0, file87, 1, 1, 81);
      add_location(p1, file87, 2, 1, 192);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p0, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p0);
        detach_dev(t1);
        detach_dev(p1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot22.name,
    type: "slot",
    source: '(1:0) <Util id=\\"animate\\" name=\\"animate(element, from, to, options?)\\" {example} {api}>',
    ctx
  });
  return block;
}
function create_fragment94(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "animate",
      name: "animate(element, from, to, options?)",
      example: (
        /*example*/
        ctx[0]
      ),
      api: (
        /*api*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot22] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      4) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment94.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance94($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Animate", slots2, []);
  const example = `
	<script>
		const el = document.querySelector('.some-div');
		animate(el, { opacity: 0 }, { opacity: 1 }, { duration: 1000 })
			.then(() => console.log('animation finished'));
	&lt;/script>
	`;
  const api = [
    {
      name: "element",
      type: "HTMLElement",
      description: "An element that will be animated."
    },
    {
      name: "from",
      type: "object",
      description: "object of properties to animate from, e.g. <em>&lbrace; opacity: 0 &rbrace;</em>"
    },
    {
      name: "to",
      type: "object",
      description: "object of properties to animate to, e.g. <em>&lbrace; opacity: 1 &rbrace;</em>"
    },
    {
      name: "options",
      type: "object",
      description: 'optional object of animation options: duration, easing, fill (see more at <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect/KeyframeEffect#options">MDN</a>).'
    }
  ];
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Animate> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example, api });
  return [example, api];
}
var Animate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance94, create_fragment94, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Animate",
      options,
      id: create_fragment94.name
    });
  }
};
var animate_default = Animate;

// docs-src/components/utils/functions/blink.svelte
var file88 = "docs-src/components/utils/functions/blink.svelte";
function create_default_slot23(ctx) {
  let p;
  let t1;
  let ul;
  let li0;
  let em0;
  let t3;
  let li1;
  let em1;
  let t5;
  let li2;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "Animates an element by changing its opacity from 0.5 to 1.";
      t1 = space();
      ul = element2("ul");
      li0 = element2("li");
      em0 = element2("em");
      em0.textContent = "element";
      t3 = text(" - HTMLElement to animate\n		");
      li1 = element2("li");
      em1 = element2("em");
      em1.textContent = "duration";
      t5 = text(" - how long to animate (in ms).\n		");
      li2 = element2("li");
      li2.textContent = "Returns a promise which resolves when the animation finishes.";
      add_location(p, file88, 1, 1, 67);
      add_location(em0, file88, 3, 6, 145);
      add_location(li0, file88, 3, 2, 141);
      add_location(em1, file88, 4, 6, 193);
      add_location(li1, file88, 4, 2, 189);
      add_location(li2, file88, 5, 2, 244);
      add_location(ul, file88, 2, 1, 134);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, ul, anchor);
      append_dev(ul, li0);
      append_dev(li0, em0);
      append_dev(li0, t3);
      append_dev(ul, li1);
      append_dev(li1, em1);
      append_dev(li1, t5);
      append_dev(ul, li2);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
        detach_dev(t1);
        detach_dev(ul);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot23.name,
    type: "slot",
    source: '(1:0) <Util id=\\"blink\\" name=\\"blink(element, duration = 160)\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment95(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "blink",
      name: "blink(element, duration = 160)",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot23] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment95.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance95($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Blink", slots2, []);
  const example = `
<script>
	const el = document.querySelector('.some-div');
	blink(el).then(() => console.log('animation finished'));
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Blink> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Blink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance95, create_fragment95, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Blink",
      options,
      id: create_fragment95.name
    });
  }
};
var blink_default = Blink;

// docs-src/components/utils/functions/debounce.svelte
var file89 = "docs-src/components/utils/functions/debounce.svelte";
function create_default_slot24(ctx) {
  let p0;
  let t0;
  let em0;
  let t2;
  let t3;
  let ul;
  let li0;
  let em1;
  let t5;
  let li1;
  let em2;
  let t7;
  let em3;
  let t9;
  let t10;
  let p1;
  let t11;
  let br;
  let t12;
  let em4;
  let t14;
  const block = {
    c: function create() {
      p0 = element2("p");
      t0 = text('The "debounced" function will only be called after it has not been called for ');
      em0 = element2("em");
      em0.textContent = "timeout";
      t2 = text(" milliseconds.");
      t3 = space();
      ul = element2("ul");
      li0 = element2("li");
      em1 = element2("em");
      em1.textContent = "fn";
      t5 = text(" - function to debounce.\n		");
      li1 = element2("li");
      em2 = element2("em");
      em2.textContent = "timeout";
      t7 = text(" - milliseconds to wait before calling ");
      em3 = element2("em");
      em3.textContent = "fn";
      t9 = text(".");
      t10 = space();
      p1 = element2("p");
      t11 = text("This is a useful e.g. when attaching an event listener to an event that is fired repeatedly & quickly (like scroll or resize).");
      br = element2("br");
      t12 = text("\n		Attaching a heavy function to such an event can cause performance issues, so debouncing it will ensure\n		that the function is only called after it has not been called for ");
      em4 = element2("em");
      em4.textContent = "timeout";
      t14 = text(" milliseconds.");
      add_location(em0, file89, 1, 82, 148);
      add_location(p0, file89, 1, 1, 67);
      add_location(em1, file89, 3, 6, 195);
      add_location(li0, file89, 3, 2, 191);
      add_location(em2, file89, 4, 6, 237);
      add_location(em3, file89, 4, 61, 292);
      add_location(li1, file89, 4, 2, 233);
      add_location(ul, file89, 2, 1, 184);
      add_location(br, file89, 7, 130, 443);
      add_location(em4, file89, 9, 68, 621);
      add_location(p1, file89, 7, 1, 314);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p0, anchor);
      append_dev(p0, t0);
      append_dev(p0, em0);
      append_dev(p0, t2);
      insert_dev(target, t3, anchor);
      insert_dev(target, ul, anchor);
      append_dev(ul, li0);
      append_dev(li0, em1);
      append_dev(li0, t5);
      append_dev(ul, li1);
      append_dev(li1, em2);
      append_dev(li1, t7);
      append_dev(li1, em3);
      append_dev(li1, t9);
      insert_dev(target, t10, anchor);
      insert_dev(target, p1, anchor);
      append_dev(p1, t11);
      append_dev(p1, br);
      append_dev(p1, t12);
      append_dev(p1, em4);
      append_dev(p1, t14);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p0);
        detach_dev(t3);
        detach_dev(ul);
        detach_dev(t10);
        detach_dev(p1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot24.name,
    type: "slot",
    source: '(1:0) <Util id=\\"debounce\\" name=\\"debounce(fn, timeout = 300)\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment96(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "debounce",
      name: "debounce(fn, timeout = 300)",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot24] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment96.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance96($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Debounce", slots2, []);
  const example = `
<script>
	function original() {
		console.log('resizing has stopped for 300ms');
	}
	const debounced = debounce(original);
	window.addEventListener('resize', debounced);
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Debounce> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Debounce = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance96, create_fragment96, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Debounce",
      options,
      id: create_fragment96.name
    });
  }
};
var debounce_default = Debounce;

// docs-src/components/utils/functions/empty.svelte
var file90 = "docs-src/components/utils/functions/empty.svelte";
function create_default_slot25(ctx) {
  let p0;
  let t0;
  let em0;
  let t2;
  let t3;
  let ul0;
  let li0;
  let em1;
  let t5;
  let t6;
  let p1;
  let t7;
  let em2;
  let t9;
  let t10;
  let ul1;
  let li1;
  let em3;
  let t12;
  let li2;
  let em4;
  let t14;
  let li3;
  let em5;
  let t16;
  let li4;
  let em6;
  let t18;
  let li5;
  let em7;
  const block = {
    c: function create() {
      p0 = element2("p");
      t0 = text("Similar to PHP's ");
      em0 = element2("em");
      em0.textContent = "empty";
      t2 = text(" - returns true if a value is empty.");
      t3 = space();
      ul0 = element2("ul");
      li0 = element2("li");
      em1 = element2("em");
      em1.textContent = "value";
      t5 = text(" - any data type.");
      t6 = space();
      p1 = element2("p");
      t7 = text("Empty will return true if the ");
      em2 = element2("em");
      em2.textContent = "value";
      t9 = text(" is one of the following:");
      t10 = space();
      ul1 = element2("ul");
      li1 = element2("li");
      em3 = element2("em");
      em3.textContent = "undefined";
      t12 = space();
      li2 = element2("li");
      em4 = element2("em");
      em4.textContent = "null";
      t14 = space();
      li3 = element2("li");
      em5 = element2("em");
      em5.textContent = "empty string";
      t16 = space();
      li4 = element2("li");
      em6 = element2("em");
      em6.textContent = "empty array";
      t18 = space();
      li5 = element2("li");
      em7 = element2("em");
      em7.textContent = "empty object";
      add_location(em0, file90, 1, 21, 69);
      add_location(p0, file90, 1, 1, 49);
      add_location(em1, file90, 3, 6, 136);
      add_location(li0, file90, 3, 2, 132);
      add_location(ul0, file90, 2, 1, 125);
      add_location(em2, file90, 6, 34, 210);
      add_location(p1, file90, 6, 1, 177);
      add_location(em3, file90, 8, 6, 266);
      add_location(li1, file90, 8, 2, 262);
      add_location(em4, file90, 9, 6, 291);
      add_location(li2, file90, 9, 2, 287);
      add_location(em5, file90, 10, 6, 311);
      add_location(li3, file90, 10, 2, 307);
      add_location(em6, file90, 11, 6, 339);
      add_location(li4, file90, 11, 2, 335);
      add_location(em7, file90, 12, 6, 366);
      add_location(li5, file90, 12, 2, 362);
      add_location(ul1, file90, 7, 1, 255);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p0, anchor);
      append_dev(p0, t0);
      append_dev(p0, em0);
      append_dev(p0, t2);
      insert_dev(target, t3, anchor);
      insert_dev(target, ul0, anchor);
      append_dev(ul0, li0);
      append_dev(li0, em1);
      append_dev(li0, t5);
      insert_dev(target, t6, anchor);
      insert_dev(target, p1, anchor);
      append_dev(p1, t7);
      append_dev(p1, em2);
      append_dev(p1, t9);
      insert_dev(target, t10, anchor);
      insert_dev(target, ul1, anchor);
      append_dev(ul1, li1);
      append_dev(li1, em3);
      append_dev(li1, t12);
      append_dev(ul1, li2);
      append_dev(li2, em4);
      append_dev(li2, t14);
      append_dev(ul1, li3);
      append_dev(li3, em5);
      append_dev(li3, t16);
      append_dev(ul1, li4);
      append_dev(li4, em6);
      append_dev(li4, t18);
      append_dev(ul1, li5);
      append_dev(li5, em7);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p0);
        detach_dev(t3);
        detach_dev(ul0);
        detach_dev(t6);
        detach_dev(p1);
        detach_dev(t10);
        detach_dev(ul1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot25.name,
    type: "slot",
    source: '(1:0) <Util id=\\"empty\\" name=\\"empty(value)\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment97(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "empty",
      name: "empty(value)",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot25] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment97.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance97($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Empty", slots2, []);
  const example = `
<script>
	empty();        // true
	empty(null);    // true
	empty('');      // true
	empty([]);      // true
	empty({});      // true

	empty(0);       // false
	empty(false);   // false
	empty('0');     // false
	empty([0]);     // false
	empty({a: 0});  // false
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Empty> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Empty = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance97, create_fragment97, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Empty",
      options,
      id: create_fragment97.name
    });
  }
};
var empty_default = Empty;

// docs-src/components/utils/functions/isset.svelte
var file91 = "docs-src/components/utils/functions/isset.svelte";
function create_default_slot26(ctx) {
  let p;
  let t0;
  let em0;
  let t2;
  let em1;
  let t4;
  const block = {
    c: function create() {
      p = element2("p");
      t0 = text("Checks if a variable is ");
      em0 = element2("em");
      em0.textContent = "defined";
      t2 = text(" and not ");
      em1 = element2("em");
      em1.textContent = "null";
      t4 = text(".");
      add_location(em0, file91, 1, 28, 71);
      add_location(em1, file91, 1, 53, 96);
      add_location(p, file91, 1, 1, 44);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      append_dev(p, t0);
      append_dev(p, em0);
      append_dev(p, t2);
      append_dev(p, em1);
      append_dev(p, t4);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot26.name,
    type: "slot",
    source: '(1:0) <Util id=\\"isset\\" name=\\"isset()\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment98(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "isset",
      name: "isset()",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot26] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment98.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance98($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Isset", slots2, []);
  const example = `
<script>
	if (isset(a)) {
		console.log('a is set');
	} else {
		console.log('a is not set');
	}
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Isset> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Isset = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance98, create_fragment98, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Isset",
      options,
      id: create_fragment98.name
    });
  }
};
var isset_default = Isset;

// docs-src/components/utils/functions/format-date.svelte
var file92 = "docs-src/components/utils/functions/format-date.svelte";
function create_default_slot27(ctx) {
  let p;
  let t0;
  let em;
  let t2;
  const block = {
    c: function create() {
      p = element2("p");
      t0 = text("Converts date to a string in the format: ");
      em = element2("em");
      em.textContent = "YYYY-MM-DD HH:mm";
      t2 = text(".");
      add_location(em, file92, 1, 45, 102);
      add_location(p, file92, 1, 1, 58);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      append_dev(p, t0);
      append_dev(p, em);
      append_dev(p, t2);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot27.name,
    type: "slot",
    source: '(1:0) <Util id=\\"formatDate\\" name=\\"formatDate(date)\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment99(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "formatDate",
      name: "formatDate(date)",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot27] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment99.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance99($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Format_date", slots2, []);
  const example = `
<script>
	formatDate(new Date()); // 2020-01-01 12:00
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Format_date> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Format_date = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance99, create_fragment99, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Format_date",
      options,
      id: create_fragment99.name
    });
  }
};
var format_date_default = Format_date;

// docs-src/components/utils/functions/fuzzy.svelte
var file93 = "docs-src/components/utils/functions/fuzzy.svelte";
function create_default_slot28(ctx) {
  let p0;
  let t0;
  let em0;
  let t2;
  let em1;
  let t4;
  let t5;
  let ul;
  let li0;
  let em2;
  let t7;
  let li1;
  let em3;
  let t9;
  let t10;
  let p1;
  const block = {
    c: function create() {
      p0 = element2("p");
      t0 = text("Fuzzy finds if ");
      em0 = element2("em");
      em0.textContent = "haystack";
      t2 = text(" contains characters from the ");
      em1 = element2("em");
      em1.textContent = "needle";
      t4 = text(" in the same order.");
      t5 = space();
      ul = element2("ul");
      li0 = element2("li");
      em2 = element2("em");
      em2.textContent = "haystack";
      t7 = text(" - a string to be searched in.\n		");
      li1 = element2("li");
      em3 = element2("em");
      em3.textContent = "needle";
      t9 = text(" - a string to search for.");
      t10 = space();
      p1 = element2("p");
      p1.textContent = "It's useful for filtering lists of items by a search string.";
      add_location(em0, file93, 1, 19, 88);
      add_location(em1, file93, 1, 66, 135);
      add_location(p0, file93, 1, 1, 70);
      add_location(em2, file93, 3, 6, 186);
      add_location(li0, file93, 3, 2, 182);
      add_location(em3, file93, 4, 6, 240);
      add_location(li1, file93, 4, 2, 236);
      add_location(ul, file93, 2, 1, 175);
      add_location(p1, file93, 7, 1, 291);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p0, anchor);
      append_dev(p0, t0);
      append_dev(p0, em0);
      append_dev(p0, t2);
      append_dev(p0, em1);
      append_dev(p0, t4);
      insert_dev(target, t5, anchor);
      insert_dev(target, ul, anchor);
      append_dev(ul, li0);
      append_dev(li0, em2);
      append_dev(li0, t7);
      append_dev(ul, li1);
      append_dev(li1, em3);
      append_dev(li1, t9);
      insert_dev(target, t10, anchor);
      insert_dev(target, p1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p0);
        detach_dev(t5);
        detach_dev(ul);
        detach_dev(t10);
        detach_dev(p1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot28.name,
    type: "slot",
    source: `(1:0) <Util id=\\"fuzzy\\" name=\\"fuzzy(haystack = '', needle = '')\\" {example}>`,
    ctx
  });
  return block;
}
function create_fragment100(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "fuzzy",
      name: "fuzzy(haystack = '', needle = '')",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot28] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment100.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance100($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Fuzzy", slots2, []);
  const example = `
<script>
	fuzzy('hello world', 'hell');    // true
	fuzzy('hello world', 'helloo');  // true
	fuzzy('hello world', 'helll');   // true
	fuzzy('hello world', 'hellooo'); // false
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Fuzzy> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Fuzzy = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance100, create_fragment100, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fuzzy",
      options,
      id: create_fragment100.name
    });
  }
};
var fuzzy_default = Fuzzy;

// docs-src/components/utils/functions/get-mouse-x.svelte.svelte
var file94 = "docs-src/components/utils/functions/get-mouse-x.svelte.svelte";
function create_default_slot29(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "Returns the mouse X position. Event is standardised across platforms (touch & pointer)";
      add_location(p, file94, 1, 1, 57);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot29.name,
    type: "slot",
    source: '(1:0) <Util id=\\"getMouseX\\" name=\\"getMouseX(event)\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment101(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "getMouseX",
      name: "getMouseX(event)",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot29] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment101.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance101($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Get_mouse_x_svelte", slots2, []);
  const example = `
<script>
	document.addEventListener('mousedown', e => {
		const x = getMouseX(e);
		console.log(x);
	});
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Get_mouse_x_svelte> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Get_mouse_x_svelte = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance101, create_fragment101, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Get_mouse_x_svelte",
      options,
      id: create_fragment101.name
    });
  }
};
var get_mouse_x_svelte_default = Get_mouse_x_svelte;

// docs-src/components/utils/functions/get-mouse-xy.svelte.svelte
var file95 = "docs-src/components/utils/functions/get-mouse-xy.svelte.svelte";
function create_default_slot30(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "Returns the mouse XY position (as an array: [x, y]). Event is standardised across platforms (touch & pointer)";
      add_location(p, file95, 1, 1, 59);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot30.name,
    type: "slot",
    source: '(1:0) <Util id=\\"getMouseXY\\" name=\\"getMouseXY(event)\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment102(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "getMouseXY",
      name: "getMouseXY(event)",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot30] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment102.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance102($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Get_mouse_xy_svelte", slots2, []);
  const example = `
<script>
	document.addEventListener('mousedown', e => {
		const [x, y] = getMouseXY(e);
		console.log(x, y);
	});
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Get_mouse_xy_svelte> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Get_mouse_xy_svelte = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance102, create_fragment102, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Get_mouse_xy_svelte",
      options,
      id: create_fragment102.name
    });
  }
};
var get_mouse_xy_svelte_default = Get_mouse_xy_svelte;

// docs-src/components/utils/functions/get-mouse-y.svelte.svelte
var file96 = "docs-src/components/utils/functions/get-mouse-y.svelte.svelte";
function create_default_slot31(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "Returns the mouse Y position. Event is standardised across platforms (touch & pointer)";
      add_location(p, file96, 1, 1, 57);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot31.name,
    type: "slot",
    source: '(1:0) <Util id=\\"getMouseY\\" name=\\"getMouseY(event)\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment103(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "getMouseY",
      name: "getMouseY(event)",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot31] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment103.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance103($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Get_mouse_y_svelte", slots2, []);
  const example = `
<script>
	document.addEventListener('mousedown', e => {
		const y = getMouseY(e);
		console.log(y);
	});
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Get_mouse_y_svelte> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Get_mouse_y_svelte = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance103, create_fragment103, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Get_mouse_y_svelte",
      options,
      id: create_fragment103.name
    });
  }
};
var get_mouse_y_svelte_default = Get_mouse_y_svelte;

// docs-src/components/utils/functions/guid.svelte
var file97 = "docs-src/components/utils/functions/guid.svelte";
function create_default_slot32(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "Generates a globally unique identifier.";
      add_location(p, file97, 1, 1, 42);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot32.name,
    type: "slot",
    source: '(1:0) <Util id=\\"guid\\" name=\\"guid()\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment104(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "guid",
      name: "guid()",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot32] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment104.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance104($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Guid", slots2, []);
  const example = `
<script>
	const id = guid();
	console.log(id);	// 9748bb50-0e54-4f4d-b6a2-c0ea0d576cd4
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Guid> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Guid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance104, create_fragment104, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Guid",
      options,
      id: create_fragment104.name
    });
  }
};
var guid_default = Guid;

// docs-src/components/utils/functions/is-in-scrollable.svelte
var file98 = "docs-src/components/utils/functions/is-in-scrollable.svelte";
function create_default_slot33(ctx) {
  let p0;
  let t1;
  let p1;
  let t2;
  let br;
  let t3;
  const block = {
    c: function create() {
      p0 = element2("p");
      p0.textContent = "Checks whether the given node is inside a scrollable element.";
      t1 = space();
      p1 = element2("p");
      t2 = text("This function is useful when determining whether a swipe event should be allowed\n		to start on a given element.");
      br = element2("br");
      t3 = text("\n		If an element is inside a scrollable element, the swipe event will not start,\n		allowing the browser to trigger the normal scrolling.");
      add_location(p0, file98, 1, 1, 66);
      add_location(br, file98, 3, 30, 250);
      add_location(p1, file98, 2, 1, 136);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p0, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p1, anchor);
      append_dev(p1, t2);
      append_dev(p1, br);
      append_dev(p1, t3);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p0);
        detach_dev(t1);
        detach_dev(p1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot33.name,
    type: "slot",
    source: '(1:0) <Util id=\\"isInScrollable\\" name=\\"isInScrollable(node)\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment105(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "isInScrollable",
      name: "isInScrollable(node)",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot33] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment105.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance105($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Is_in_scrollable", slots2, []);
  const example = `
<script>
	const isInScrl = isInScrollable(document.querySelector('.element'));
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Is_in_scrollable> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Is_in_scrollable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance105, create_fragment105, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Is_in_scrollable",
      options,
      id: create_fragment105.name
    });
  }
};
var is_in_scrollable_default = Is_in_scrollable;

// docs-src/components/utils/functions/is-mobile.svelte
var file99 = "docs-src/components/utils/functions/is-mobile.svelte";
function create_default_slot34(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "Checks if the current platform is mobile.";
      add_location(p, file99, 1, 1, 50);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot34.name,
    type: "slot",
    source: '(1:0) <Util id=\\"isMobile\\" name=\\"isMobile()\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment106(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "isMobile",
      name: "isMobile()",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot34] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment106.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance106($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Is_mobile", slots2, []);
  const example = `
<script>
	const mob = isMobile();
	console.log(mob);  // false
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Is_mobile> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Is_mobile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance106, create_fragment106, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Is_mobile",
      options,
      id: create_fragment106.name
    });
  }
};
var is_mobile_default = Is_mobile;

// docs-src/components/utils/functions/is-color-dark.svelte
var file100 = "docs-src/components/utils/functions/is-color-dark.svelte";
function create_default_slot35(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "Checks if a colour is dark or light (so that e.g. a text colour can have a better contrast against the background).";
      add_location(p, file100, 1, 1, 59);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot35.name,
    type: "slot",
    source: '(1:0) <Util id=\\"isColorDark\\" name=\\"isColorDark(hex)\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment107(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "isColorDark",
      name: "isColorDark(hex)",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot35] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment107.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance107($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Is_color_dark", slots2, []);
  const example = `
<script>
	isColorDark('#fff'); // false
	isColorDark('#000'); // true
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Is_color_dark> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Is_color_dark = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance107, create_fragment107, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Is_color_dark",
      options,
      id: create_fragment107.name
    });
  }
};
var is_color_dark_default = Is_color_dark;

// docs-src/components/utils/functions/pluck.svelte
var file101 = "docs-src/components/utils/functions/pluck.svelte";
function create_default_slot36(ctx) {
  let p;
  let t1;
  let ul;
  let li0;
  let em0;
  let t3;
  let li1;
  let em1;
  let t5;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "Creates a new object with only the plucked properties from the original object..";
      t1 = space();
      ul = element2("ul");
      li0 = element2("li");
      em0 = element2("em");
      em0.textContent = "object";
      t3 = text(" - object to pluck from.\n		");
      li1 = element2("li");
      em1 = element2("em");
      em1.textContent = "props";
      t5 = text(" - an array of property names.");
      add_location(p, file101, 1, 1, 57);
      add_location(em0, file101, 3, 6, 157);
      add_location(li0, file101, 3, 2, 153);
      add_location(em1, file101, 4, 6, 203);
      add_location(li1, file101, 4, 2, 199);
      add_location(ul, file101, 2, 1, 146);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, ul, anchor);
      append_dev(ul, li0);
      append_dev(li0, em0);
      append_dev(li0, t3);
      append_dev(ul, li1);
      append_dev(li1, em1);
      append_dev(li1, t5);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
        detach_dev(t1);
        detach_dev(ul);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot36.name,
    type: "slot",
    source: '(1:0) <Util id=\\"pluck\\" name=\\"pluck(object, props)\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment108(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "pluck",
      name: "pluck(object, props)",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot36] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment108.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance108($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Pluck", slots2, []);
  const example = `
<script>
	pluck({ a: 1, b: 2, c: 3 }, ['a', 'b']);	// { a: 1, b: 2 }
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Pluck> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Pluck = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance108, create_fragment108, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pluck",
      options,
      id: create_fragment108.name
    });
  }
};
var pluck_default = Pluck;

// docs-src/components/utils/functions/round-amount.svelte
var file102 = "docs-src/components/utils/functions/round-amount.svelte";
function create_default_slot37(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "Rounds a number to 2 decimal places (by default).";
      add_location(p, file102, 1, 1, 76);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot37.name,
    type: "slot",
    source: '(1:0) <Util id=\\"roundAmount\\" name=\\"roundAmount(value, precision = 2)\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment109(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "roundAmount",
      name: "roundAmount(value, precision = 2)",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot37] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment109.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance109($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Round_amount", slots2, []);
  const example = `
<script>
	roundAmount(123.456789); // 123.46
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Round_amount> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Round_amount = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance109, create_fragment109, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Round_amount",
      options,
      id: create_fragment109.name
    });
  }
};
var round_amount_default = Round_amount;

// docs-src/components/utils/functions/throttle.svelte
var file103 = "docs-src/components/utils/functions/throttle.svelte";
function create_default_slot38(ctx) {
  let p0;
  let t0;
  let em0;
  let t2;
  let t3;
  let ul0;
  let li0;
  let em1;
  let t5;
  let li1;
  let em2;
  let t7;
  let em3;
  let t9;
  let t10;
  let p1;
  let t11;
  let em4;
  let t13;
  let br;
  let t14;
  let t15;
  let p2;
  let t17;
  let ul1;
  let li2;
  let li3;
  let li4;
  let li5;
  let li6;
  const block = {
    c: function create() {
      p0 = element2("p");
      t0 = text('The "throttled" function will only be called once every ');
      em0 = element2("em");
      em0.textContent = "timeout";
      t2 = text(" milliseconds.");
      t3 = space();
      ul0 = element2("ul");
      li0 = element2("li");
      em1 = element2("em");
      em1.textContent = "fn";
      t5 = text(" - function to debounce.\n		");
      li1 = element2("li");
      em2 = element2("em");
      em2.textContent = "timeout";
      t7 = text(" - milliseconds to wait before calling ");
      em3 = element2("em");
      em3.textContent = "fn";
      t9 = text(".");
      t10 = space();
      p1 = element2("p");
      t11 = text("This is slightly different to ");
      em4 = element2("em");
      em4.textContent = "debounce";
      t13 = text(" but serves a similar purpose - performance optimization.");
      br = element2("br");
      t14 = text("\n		It's useful when a heavy event handler function would be to costly to call on every event.");
      t15 = space();
      p2 = element2("p");
      p2.textContent = "One caveat is that the throttled function will be called once every x miliseconds, so if an event would stop firing\n		before the function is called the next time - the function will not be called at the end. E.g.:";
      t17 = space();
      ul1 = element2("ul");
      li2 = element2("li");
      li2.textContent = "we would like to update a position of a tooltip when the window is resizing.\n		";
      li3 = element2("li");
      li3.textContent = "we don't want to call the function on every resize event, because it's heavy and resize events are fired with every pixel of the window size change.\n		";
      li4 = element2("li");
      li4.textContent = "we also don't want to call the function only once at the end of the resize, because the tooltip would be in the wrong place for the whole duration of the resize.\n		";
      li5 = element2("li");
      li5.textContent = "throttle is a good option here, but the caveat mentioned above may cause the tooltip to be in the wrong place at the end of the resize.\n		";
      li6 = element2("li");
      li6.textContent = "in this case it is a good idea to use both: throttle and debounce: throttle the function to be called every 300ms, but also debounce it to be called at the end of the resize.";
      add_location(em0, file103, 1, 60, 126);
      add_location(p0, file103, 1, 1, 67);
      add_location(em1, file103, 3, 6, 173);
      add_location(li0, file103, 3, 2, 169);
      add_location(em2, file103, 4, 6, 215);
      add_location(em3, file103, 4, 61, 270);
      add_location(li1, file103, 4, 2, 211);
      add_location(ul0, file103, 2, 1, 162);
      add_location(em4, file103, 7, 34, 325);
      add_location(br, file103, 7, 108, 399);
      add_location(p1, file103, 7, 1, 292);
      add_location(p2, file103, 10, 1, 504);
      add_location(li2, file103, 14, 2, 735);
      add_location(li3, file103, 15, 2, 818);
      add_location(li4, file103, 16, 2, 973);
      add_location(li5, file103, 17, 2, 1141);
      add_location(li6, file103, 18, 2, 1283);
      add_location(ul1, file103, 13, 1, 728);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p0, anchor);
      append_dev(p0, t0);
      append_dev(p0, em0);
      append_dev(p0, t2);
      insert_dev(target, t3, anchor);
      insert_dev(target, ul0, anchor);
      append_dev(ul0, li0);
      append_dev(li0, em1);
      append_dev(li0, t5);
      append_dev(ul0, li1);
      append_dev(li1, em2);
      append_dev(li1, t7);
      append_dev(li1, em3);
      append_dev(li1, t9);
      insert_dev(target, t10, anchor);
      insert_dev(target, p1, anchor);
      append_dev(p1, t11);
      append_dev(p1, em4);
      append_dev(p1, t13);
      append_dev(p1, br);
      append_dev(p1, t14);
      insert_dev(target, t15, anchor);
      insert_dev(target, p2, anchor);
      insert_dev(target, t17, anchor);
      insert_dev(target, ul1, anchor);
      append_dev(ul1, li2);
      append_dev(ul1, li3);
      append_dev(ul1, li4);
      append_dev(ul1, li5);
      append_dev(ul1, li6);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p0);
        detach_dev(t3);
        detach_dev(ul0);
        detach_dev(t10);
        detach_dev(p1);
        detach_dev(t15);
        detach_dev(p2);
        detach_dev(t17);
        detach_dev(ul1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot38.name,
    type: "slot",
    source: '(1:0) <Util id=\\"throttle\\" name=\\"throttle(fn, timeout = 300)\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment110(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "throttle",
      name: "throttle(fn, timeout = 300)",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot38] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment110.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance110($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Throttle", slots2, []);
  const example = `
<script>
	function updatePosition () {
		console.log('updating...');
	}
	const throttled = throttle(updatePosition);
	const debounced = debounce(updatePosition);
	window.addEventListener('resize', () => {
		throttled();
		debounced();
	});
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Throttle> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Throttle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance110, create_fragment110, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Throttle",
      options,
      id: create_fragment110.name
    });
  }
};
var throttle_default = Throttle;

// docs-src/components/utils/functions/time-ago.svelte
var file104 = "docs-src/components/utils/functions/time-ago.svelte";
function create_default_slot39(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element2("p");
      p.textContent = "Converts date to a string describing how long time ago was the given date.";
      add_location(p, file104, 1, 1, 57);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot39.name,
    type: "slot",
    source: '(1:0) <Util id=\\"timeAgo\\" name=\\"timeAgo(date, now)\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment111(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "timeAgo",
      name: "timeAgo(date, now)",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot39] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment111.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance111($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Time_ago", slots2, []);
  const example = `
<script>
	timeAgo(date0); // just now
	timeAgo(date1); // 1 minute ago
	timeAgo(date2); // 1 hour ago
	timeAgo(date3); // 1 day ago
	timeAgo(date4); // 1 week ago
	timeAgo(date5); // 1 month ago
	timeAgo(date6); // 1 year ago
	timeAgo(date7); // 2000-01-01 12:00
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Time_ago> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Time_ago = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance111, create_fragment111, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Time_ago",
      options,
      id: create_fragment111.name
    });
  }
};
var time_ago_default = Time_ago;

// docs-src/components/utils/properties/index.js
var properties_exports = {};
__export(properties_exports, {
  AnimationSpeed: () => animation_speed_default,
  FocusableSelector: () => focusable_selector_default,
  PrefersDark: () => prefers_dark_default
});

// docs-src/components/utils/properties/animation-speed.svelte
var file105 = "docs-src/components/utils/properties/animation-speed.svelte";
function create_default_slot40(ctx) {
  let ul;
  let li0;
  let t0;
  let em0;
  let t2;
  let li1;
  let li2;
  let t4;
  let b;
  let t6;
  let li3;
  let t7;
  let em1;
  let t9;
  const block = {
    c: function create() {
      ul = element2("ul");
      li0 = element2("li");
      t0 = text("Svelte store");
      em0 = element2("em");
      em0.textContent = "*";
      t2 = space();
      li1 = element2("li");
      li1.textContent = "Type: number\n		";
      li2 = element2("li");
      t4 = text("Returns a number of milliseconds that the default animation duration should last (default is ");
      b = element2("b");
      b.textContent = "300";
      t6 = text(").\n		");
      li3 = element2("li");
      t7 = text("If the user has set ");
      em1 = element2("em");
      em1.textContent = "prefers-reduced-motion: reduce";
      t9 = text(" in the OS, the value will be 0.");
      add_location(em0, file105, 2, 18, 84);
      add_location(li0, file105, 2, 2, 68);
      add_location(li1, file105, 3, 2, 97);
      add_location(b, file105, 4, 99, 213);
      add_location(li2, file105, 4, 2, 116);
      add_location(em1, file105, 5, 26, 252);
      add_location(li3, file105, 5, 2, 228);
      add_location(ul, file105, 1, 1, 61);
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      append_dev(ul, li0);
      append_dev(li0, t0);
      append_dev(li0, em0);
      append_dev(li0, t2);
      append_dev(ul, li1);
      append_dev(ul, li2);
      append_dev(li2, t4);
      append_dev(li2, b);
      append_dev(li2, t6);
      append_dev(ul, li3);
      append_dev(li3, t7);
      append_dev(li3, em1);
      append_dev(li3, t9);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot40.name,
    type: "slot",
    source: '(1:0) <Util id=\\"AnimationSpeed\\" name=\\"ANIMATION_SPEED\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment112(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "AnimationSpeed",
      name: "ANIMATION_SPEED",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot40] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment112.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance112($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Animation_speed", slots2, []);
  const example = `
<script>
	import { ANIMATION_SPEED } from '@perfectthings/ui';
	console.log($ANIMATION_SPEED);
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Animation_speed> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Animation_speed = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance112, create_fragment112, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Animation_speed",
      options,
      id: create_fragment112.name
    });
  }
};
var animation_speed_default = Animation_speed;

// docs-src/components/utils/properties/focusable-selector.svelte
var file106 = "docs-src/components/utils/properties/focusable-selector.svelte";
function create_default_slot41(ctx) {
  let ul;
  let li0;
  let li1;
  const block = {
    c: function create() {
      ul = element2("ul");
      li0 = element2("li");
      li0.textContent = "Type: string\n		";
      li1 = element2("li");
      li1.textContent = "Returns a list of selectors that can be focused.";
      add_location(li0, file106, 2, 2, 74);
      add_location(li1, file106, 3, 2, 93);
      add_location(ul, file106, 1, 1, 67);
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      append_dev(ul, li0);
      append_dev(ul, li1);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot41.name,
    type: "slot",
    source: '(1:0) <Util id=\\"FocusableSelector\\" name=\\"FOCUSABLE_SELECTOR\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment113(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "FocusableSelector",
      name: "FOCUSABLE_SELECTOR",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot41] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment113.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance113($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Focusable_selector", slots2, []);
  const example = `
<script>
	import { FOCUSABLE_SELECTOR } from '@perfectthings/ui';

	const focusableElements = document.querySelectorAll(FOCUSABLE_SELECTOR);
	console.log(focusableElements);
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Focusable_selector> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Focusable_selector = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance113, create_fragment113, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Focusable_selector",
      options,
      id: create_fragment113.name
    });
  }
};
var focusable_selector_default = Focusable_selector;

// docs-src/components/utils/properties/prefers-dark.svelte
var file107 = "docs-src/components/utils/properties/prefers-dark.svelte";
function create_default_slot42(ctx) {
  let ul;
  let li0;
  let t0;
  let em;
  let t2;
  let li1;
  let li2;
  let li3;
  const block = {
    c: function create() {
      ul = element2("ul");
      li0 = element2("li");
      t0 = text("Svelte store");
      em = element2("em");
      em.textContent = "*";
      t2 = space();
      li1 = element2("li");
      li1.textContent = "Type: boolean\n		";
      li2 = element2("li");
      li2.textContent = "Updates on system theme change.\n		";
      li3 = element2("li");
      li3.textContent = "Returns user preference for dark mode.";
      add_location(em, file107, 2, 18, 78);
      add_location(li0, file107, 2, 2, 62);
      add_location(li1, file107, 3, 2, 91);
      add_location(li2, file107, 4, 2, 111);
      add_location(li3, file107, 5, 2, 149);
      add_location(ul, file107, 1, 1, 55);
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      append_dev(ul, li0);
      append_dev(li0, t0);
      append_dev(li0, em);
      append_dev(li0, t2);
      append_dev(ul, li1);
      append_dev(ul, li2);
      append_dev(ul, li3);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot42.name,
    type: "slot",
    source: '(1:0) <Util id=\\"PrefersDark\\" name=\\"PREFERS_DARK\\" {example}>',
    ctx
  });
  return block;
}
function create_fragment114(ctx) {
  let util;
  let current;
  util = new Util_default({
    props: {
      id: "PrefersDark",
      name: "PREFERS_DARK",
      example: (
        /*example*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot42] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(util.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(util, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const util_changes = {};
      if (dirty & /*$$scope*/
      2) {
        util_changes.$$scope = { dirty, ctx: ctx2 };
      }
      util.$set(util_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(util.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(util.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(util, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment114.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance114($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Prefers_dark", slots2, []);
  const example = `
<script>
	import { PREFERS_DARK } from '@perfectthings/ui';

	console.log($PREFERS_DARK ? 'dark mode' : 'light mode');
&lt;/script>
`;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Prefers_dark> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Util: Util_default, example });
  return [example];
}
var Prefers_dark = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance114, create_fragment114, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Prefers_dark",
      options,
      id: create_fragment114.name
    });
  }
};
var prefers_dark_default = Prefers_dark;

// docs-src/components/utils/Utils.svelte
var { Object: Object_16 } = globals;
var file108 = "docs-src/components/utils/Utils.svelte";
function get_each_context19(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function get_each_context_16(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_each_block_3(ctx) {
  let li;
  let a;
  let t0_value = (
    /*item*/
    ctx[2] + ""
  );
  let t0;
  let a_href_value;
  let t1;
  const block = {
    c: function create() {
      li = element2("li");
      a = element2("a");
      t0 = text(t0_value);
      t1 = space();
      attr_dev(a, "href", a_href_value = "#Utils/" + /*item*/
      ctx[2]);
      add_location(a, file108, 4, 7, 107);
      add_location(li, file108, 4, 3, 103);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, a);
      append_dev(a, t0);
      append_dev(li, t1);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(4:2) {#each props as item}",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let li;
  let a;
  let t0_value = (
    /*item*/
    ctx[2] + ""
  );
  let t0;
  let a_href_value;
  let t1;
  const block = {
    c: function create() {
      li = element2("li");
      a = element2("a");
      t0 = text(t0_value);
      t1 = space();
      attr_dev(a, "href", a_href_value = "#Utils/" + /*item*/
      ctx[2]);
      add_location(a, file108, 11, 7, 223);
      add_location(li, file108, 11, 3, 219);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, a);
      append_dev(a, t0);
      append_dev(li, t1);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(11:2) {#each fns as item}",
    ctx
  });
  return block;
}
function create_each_block_16(ctx) {
  let switch_instance;
  let br;
  let current;
  var switch_value = properties_exports[
    /*item*/
    ctx[2]
  ];
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      br = element2("br");
      add_location(br, file108, 19, 48, 419);
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, br, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (switch_value !== (switch_value = properties_exports[
        /*item*/
        ctx2[2]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, br.parentNode, br);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(br);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_16.name,
    type: "each",
    source: "(19:1) {#each props as item}",
    ctx
  });
  return block;
}
function create_each_block19(ctx) {
  let switch_instance;
  let br;
  let current;
  var switch_value = functions_exports[
    /*item*/
    ctx[2]
  ];
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      br = element2("br");
      add_location(br, file108, 31, 47, 811);
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, br, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (switch_value !== (switch_value = functions_exports[
        /*item*/
        ctx2[2]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, br.parentNode, br);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(br);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block19.name,
    type: "each",
    source: "(31:1) {#each fns as item}",
    ctx
  });
  return block;
}
function create_fragment115(ctx) {
  let div0;
  let h30;
  let t1;
  let ul0;
  let t2;
  let h31;
  let t4;
  let ul1;
  let t5;
  let div1;
  let h20;
  let t7;
  let t8;
  let p;
  let em0;
  let t10;
  let a;
  let t12;
  let em1;
  let t14;
  let em2;
  let t16;
  let t17;
  let div2;
  let h21;
  let t19;
  let current;
  let each_value_3 = ensure_array_like_dev(
    /*props*/
    ctx[0]
  );
  let each_blocks_3 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_3[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  let each_value_2 = ensure_array_like_dev(
    /*fns*/
    ctx[1]
  );
  let each_blocks_2 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let each_value_1 = ensure_array_like_dev(
    /*props*/
    ctx[0]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_16(get_each_context_16(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let each_value = ensure_array_like_dev(
    /*fns*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block19(get_each_context19(ctx, each_value, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div0 = element2("div");
      h30 = element2("h3");
      h30.textContent = "Utility properties";
      t1 = space();
      ul0 = element2("ul");
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        each_blocks_3[i].c();
      }
      t2 = space();
      h31 = element2("h3");
      h31.textContent = "Utility Functions";
      t4 = space();
      ul1 = element2("ul");
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        each_blocks_2[i].c();
      }
      t5 = space();
      div1 = element2("div");
      h20 = element2("h2");
      h20.textContent = "Utility properties";
      t7 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t8 = space();
      p = element2("p");
      em0 = element2("em");
      em0.textContent = "*";
      t10 = space();
      a = element2("a");
      a.textContent = "svelte store variables";
      t12 = text(" - when reading the value, add ");
      em1 = element2("em");
      em1.textContent = "$";
      t14 = text(" to the name, e.g.\n		");
      em2 = element2("em");
      em2.textContent = "$ANIMATION_SPEED";
      t16 = text(".");
      t17 = space();
      div2 = element2("div");
      h21 = element2("h2");
      h21.textContent = "Utility Functions";
      t19 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      add_location(h30, file108, 1, 1, 42);
      add_location(ul0, file108, 2, 1, 71);
      add_location(h31, file108, 8, 1, 161);
      add_location(ul1, file108, 9, 1, 189);
      attr_dev(div0, "class", "sticky-block utilities-nav");
      add_location(div0, file108, 0, 0, 0);
      add_location(h20, file108, 17, 1, 320);
      add_location(em0, file108, 22, 2, 440);
      attr_dev(a, "href", "https://svelte.dev/docs/svelte-components#script-4-prefix-stores-with-$-to-access-their-values");
      add_location(a, file108, 22, 13, 451);
      add_location(em1, file108, 23, 59, 616);
      add_location(em2, file108, 24, 2, 647);
      add_location(p, file108, 21, 1, 434);
      attr_dev(div1, "class", "sticky-block");
      attr_dev(div1, "id", "top");
      add_location(div1, file108, 16, 0, 283);
      add_location(h21, file108, 29, 1, 716);
      attr_dev(div2, "class", "sticky-block");
      add_location(div2, file108, 28, 0, 688);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div0, anchor);
      append_dev(div0, h30);
      append_dev(div0, t1);
      append_dev(div0, ul0);
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        if (each_blocks_3[i]) {
          each_blocks_3[i].m(ul0, null);
        }
      }
      append_dev(div0, t2);
      append_dev(div0, h31);
      append_dev(div0, t4);
      append_dev(div0, ul1);
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        if (each_blocks_2[i]) {
          each_blocks_2[i].m(ul1, null);
        }
      }
      insert_dev(target, t5, anchor);
      insert_dev(target, div1, anchor);
      append_dev(div1, h20);
      append_dev(div1, t7);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div1, null);
        }
      }
      append_dev(div1, t8);
      append_dev(div1, p);
      append_dev(p, em0);
      append_dev(p, t10);
      append_dev(p, a);
      append_dev(p, t12);
      append_dev(p, em1);
      append_dev(p, t14);
      append_dev(p, em2);
      append_dev(p, t16);
      insert_dev(target, t17, anchor);
      insert_dev(target, div2, anchor);
      append_dev(div2, h21);
      append_dev(div2, t19);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      if (dirty & /*props*/
      1) {
        each_value_3 = ensure_array_like_dev(
          /*props*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks_3[i]) {
            each_blocks_3[i].p(child_ctx, dirty);
          } else {
            each_blocks_3[i] = create_each_block_3(child_ctx);
            each_blocks_3[i].c();
            each_blocks_3[i].m(ul0, null);
          }
        }
        for (; i < each_blocks_3.length; i += 1) {
          each_blocks_3[i].d(1);
        }
        each_blocks_3.length = each_value_3.length;
      }
      if (dirty & /*fns*/
      2) {
        each_value_2 = ensure_array_like_dev(
          /*fns*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks_2[i]) {
            each_blocks_2[i].p(child_ctx, dirty);
          } else {
            each_blocks_2[i] = create_each_block_2(child_ctx);
            each_blocks_2[i].c();
            each_blocks_2[i].m(ul1, null);
          }
        }
        for (; i < each_blocks_2.length; i += 1) {
          each_blocks_2[i].d(1);
        }
        each_blocks_2.length = each_value_2.length;
      }
      if (dirty & /*props*/
      1) {
        each_value_1 = ensure_array_like_dev(
          /*props*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_16(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_16(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(div1, t8);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (dirty & /*fns*/
      2) {
        each_value = ensure_array_like_dev(
          /*fns*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context19(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block19(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div2, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div0);
        detach_dev(t5);
        detach_dev(div1);
        detach_dev(t17);
        detach_dev(div2);
      }
      destroy_each(each_blocks_3, detaching);
      destroy_each(each_blocks_2, detaching);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment115.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance115($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Utils", slots2, []);
  const props = Object.keys(properties_exports);
  const fns = Object.keys(functions_exports);
  const writable_props = [];
  Object_16.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Utils> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ Functions: functions_exports, Properties: properties_exports, props, fns });
  return [props, fns];
}
var Utils = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance115, create_fragment115, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Utils",
      options,
      id: create_fragment115.name
    });
  }
};
var Utils_default = Utils;

// docs-src/components/splitter/Splitter.svelte
var { console: console_118 } = globals;
var file109 = "docs-src/components/splitter/Splitter.svelte";
function create_default_slot43(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Toggle");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot43.name,
    type: "slot",
    source: '(10:0) <Button on:click=\\"{toggle}\\">',
    ctx
  });
  return block;
}
function create_fragment116(ctx) {
  let h2;
  let t1;
  let p;
  let t3;
  let ul;
  let li0;
  let t4;
  let em0;
  let t6;
  let li1;
  let t7;
  let em1;
  let t9;
  let em2;
  let t11;
  let t12;
  let hr;
  let t13;
  let button;
  let t14;
  let div2;
  let div0;
  let t16;
  let splitter0;
  let t17;
  let div1;
  let t19;
  let br;
  let t20;
  let div5;
  let div3;
  let t22;
  let splitter1_1;
  let t23;
  let div4;
  let t25;
  let codeexample;
  let t26;
  let api0;
  let t27;
  let api1;
  let current;
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot43] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on(
    "click",
    /*toggle*/
    ctx[5]
  );
  let splitter0_props = {};
  splitter0 = new Splitter_default({ props: splitter0_props, $$inline: true });
  ctx[6](splitter0);
  splitter0.$on("changed", onchange4);
  let splitter1_1_props = {};
  splitter1_1 = new Splitter_default({ props: splitter1_1_props, $$inline: true });
  ctx[7](splitter1_1);
  splitter1_1.$on("changed", onchange4);
  codeexample = new CodeExample_default({
    props: { html: (
      /*exampleHtml*/
      ctx[4]
    ) },
    $$inline: true
  });
  api0 = new ApiTable_default({
    props: { props: (
      /*apiProps*/
      ctx[2]
    ) },
    $$inline: true
  });
  api1 = new ApiTable_default({
    props: {
      props: (
        /*instanceApiProps*/
        ctx[3]
      ),
      title: "Instance API",
      description: "The component exposes <em>this</em> property, to which a variable can be bound, creating an instance of the component, with the following API"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Splitter";
      t1 = space();
      p = element2("p");
      p.textContent = "Resizable splitter component.";
      t3 = space();
      ul = element2("ul");
      li0 = element2("li");
      t4 = text("It uses ");
      em0 = element2("em");
      em0.textContent = "flex flow";
      t6 = text(" property to determine the direction of resizing (row=horizontal, column=vertical).\n	");
      li1 = element2("li");
      t7 = text("It uses ");
      em1 = element2("em");
      em1.textContent = "min-width";
      t9 = text(" and ");
      em2 = element2("em");
      em2.textContent = "max-width";
      t11 = text(" props to determine how much to resize;");
      t12 = space();
      hr = element2("hr");
      t13 = space();
      create_component(button.$$.fragment);
      t14 = space();
      div2 = element2("div");
      div0 = element2("div");
      div0.textContent = "Left";
      t16 = space();
      create_component(splitter0.$$.fragment);
      t17 = space();
      div1 = element2("div");
      div1.textContent = "Right";
      t19 = space();
      br = element2("br");
      t20 = space();
      div5 = element2("div");
      div3 = element2("div");
      div3.textContent = "Top";
      t22 = space();
      create_component(splitter1_1.$$.fragment);
      t23 = space();
      div4 = element2("div");
      div4.textContent = "Bottom";
      t25 = space();
      create_component(codeexample.$$.fragment);
      t26 = space();
      create_component(api0.$$.fragment);
      t27 = space();
      create_component(api1.$$.fragment);
      add_location(h2, file109, 0, 0, 0);
      add_location(p, file109, 1, 0, 18);
      add_location(em0, file109, 3, 13, 73);
      add_location(li0, file109, 3, 1, 61);
      add_location(em1, file109, 4, 13, 188);
      add_location(em2, file109, 4, 36, 211);
      add_location(li1, file109, 4, 1, 176);
      add_location(ul, file109, 2, 0, 55);
      add_location(hr, file109, 7, 0, 276);
      attr_dev(div0, "class", "split-box min-w");
      add_location(div0, file109, 11, 1, 352);
      attr_dev(div1, "class", "split-box");
      add_location(div1, file109, 13, 1, 452);
      attr_dev(div2, "class", "split-wrap");
      add_location(div2, file109, 10, 0, 326);
      add_location(br, file109, 15, 0, 494);
      attr_dev(div3, "class", "split-box min-h");
      add_location(div3, file109, 17, 1, 538);
      attr_dev(div4, "class", "split-box");
      add_location(div4, file109, 19, 1, 637);
      attr_dev(div5, "class", "split-wrap split-wrap-v");
      add_location(div5, file109, 16, 0, 499);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, p, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, ul, anchor);
      append_dev(ul, li0);
      append_dev(li0, t4);
      append_dev(li0, em0);
      append_dev(li0, t6);
      append_dev(ul, li1);
      append_dev(li1, t7);
      append_dev(li1, em1);
      append_dev(li1, t9);
      append_dev(li1, em2);
      append_dev(li1, t11);
      insert_dev(target, t12, anchor);
      insert_dev(target, hr, anchor);
      insert_dev(target, t13, anchor);
      mount_component(button, target, anchor);
      insert_dev(target, t14, anchor);
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      append_dev(div2, t16);
      mount_component(splitter0, div2, null);
      append_dev(div2, t17);
      append_dev(div2, div1);
      insert_dev(target, t19, anchor);
      insert_dev(target, br, anchor);
      insert_dev(target, t20, anchor);
      insert_dev(target, div5, anchor);
      append_dev(div5, div3);
      append_dev(div5, t22);
      mount_component(splitter1_1, div5, null);
      append_dev(div5, t23);
      append_dev(div5, div4);
      insert_dev(target, t25, anchor);
      mount_component(codeexample, target, anchor);
      insert_dev(target, t26, anchor);
      mount_component(api0, target, anchor);
      insert_dev(target, t27, anchor);
      mount_component(api1, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      256) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      const splitter0_changes = {};
      splitter0.$set(splitter0_changes);
      const splitter1_1_changes = {};
      splitter1_1.$set(splitter1_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      transition_in(splitter0.$$.fragment, local);
      transition_in(splitter1_1.$$.fragment, local);
      transition_in(codeexample.$$.fragment, local);
      transition_in(api0.$$.fragment, local);
      transition_in(api1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      transition_out(splitter0.$$.fragment, local);
      transition_out(splitter1_1.$$.fragment, local);
      transition_out(codeexample.$$.fragment, local);
      transition_out(api0.$$.fragment, local);
      transition_out(api1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(p);
        detach_dev(t3);
        detach_dev(ul);
        detach_dev(t12);
        detach_dev(hr);
        detach_dev(t13);
        detach_dev(t14);
        detach_dev(div2);
        detach_dev(t19);
        detach_dev(br);
        detach_dev(t20);
        detach_dev(div5);
        detach_dev(t25);
        detach_dev(t26);
        detach_dev(t27);
      }
      destroy_component(button, detaching);
      ctx[6](null);
      destroy_component(splitter0);
      ctx[7](null);
      destroy_component(splitter1_1);
      destroy_component(codeexample, detaching);
      destroy_component(api0, detaching);
      destroy_component(api1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment116.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function onchange4(e) {
  console.log(e.detail);
}
function instance116($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Splitter", slots2, []);
  const apiProps = [
    {
      name: "class",
      type: "string",
      description: "Additional css class name to be added to the component."
    },
    {
      name: "bind:element",
      type: "element",
      description: "Exposes the HTML element of the component."
    },
    {
      name: "on:change",
      type: "function",
      description: "Triggered during the resizing (mousemove)."
    },
    {
      name: "on:changed",
      type: "function",
      description: "Triggered when resizing finished (mouseup)."
    }
  ];
  const instanceApiProps = [
    {
      name: "collapse",
      type: "function",
      description: "Set the size to the <em>min-width</em> of the previous div."
    },
    {
      name: "expand",
      type: "function",
      description: "Set the size to the <em>max-width</em> of the previous div."
    },
    {
      name: "setSize",
      type: "function",
      description: 'Set the split size.<br>Function accepts 2 arguments:<br><em>to</em> [string|number] - use number for pixel size, or predefined strings like "min", "max" or "default"<br><em>withAnimation</em> [boolean] - set to true to enable animation. Defaults to false.'
    },
    {
      name: "toggle",
      type: "function",
      description: "Toggle between collapsed and expanded state."
    }
  ];
  const exampleHtml = `
<Button on:click="{toggle}">Toggle</Button>
<div style="flex-flow:row">
	<div>Left</div>
	<Splitter on:changed={onchanged} bind:this="{splitter1}" />
	<div>Right</div>
</div>

<script>
let splitter1;

function toggle () {
	splitter1.toggle();
}

function onchanged (e) {
	// logs current height/width in px and collapsed state
	console.log(e.detail);
}
&lt;/script>
`;
  let splitter1, splitter2;
  function toggle() {
    splitter1.toggle();
    splitter2.toggle();
  }
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_118.warn(`<Splitter> was created with unknown prop '${key}'`);
  });
  function splitter0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      splitter1 = $$value;
      $$invalidate2(0, splitter1);
    });
  }
  function splitter1_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      splitter2 = $$value;
      $$invalidate2(1, splitter2);
    });
  }
  $$self2.$capture_state = () => ({
    Splitter: Splitter_default,
    Button: Button_default,
    API: ApiTable_default,
    CodeExample: CodeExample_default,
    apiProps,
    instanceApiProps,
    exampleHtml,
    splitter1,
    splitter2,
    onchange: onchange4,
    toggle
  });
  $$self2.$inject_state = ($$props3) => {
    if ("splitter1" in $$props3)
      $$invalidate2(0, splitter1 = $$props3.splitter1);
    if ("splitter2" in $$props3)
      $$invalidate2(1, splitter2 = $$props3.splitter2);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    splitter1,
    splitter2,
    apiProps,
    instanceApiProps,
    exampleHtml,
    toggle,
    splitter0_binding,
    splitter1_1_binding
  ];
}
var Splitter_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance116, create_fragment116, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Splitter_1",
      options,
      id: create_fragment116.name
    });
  }
};
var Splitter_default2 = Splitter_1;

// docs-src/components/color-palette/ColorPaletteBox.svelte
var file110 = "docs-src/components/color-palette/ColorPaletteBox.svelte";
function create_fragment117(ctx) {
  let div;
  let t0;
  let t1;
  let br;
  let t2;
  let t3;
  const block = {
    c: function create() {
      div = element2("div");
      t0 = text("background: --ui-");
      t1 = text(
        /*bg*/
        ctx[0]
      );
      br = element2("br");
      t2 = text("\n	text: --ui-");
      t3 = text(
        /*text*/
        ctx[1]
      );
      add_location(br, file110, 1, 22, 114);
      attr_dev(div, "class", "palette-box");
      set_style(div, "background-color", "var(--ui-" + /*bg*/
      ctx[0] + ")");
      set_style(div, "color", "var(--ui-" + /*text*/
      ctx[1] + ")");
      add_location(div, file110, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      append_dev(div, br);
      append_dev(div, t2);
      append_dev(div, t3);
    },
    p: function update2(ctx2, [dirty]) {
      if (dirty & /*bg*/
      1)
        set_data_dev(
          t1,
          /*bg*/
          ctx2[0]
        );
      if (dirty & /*text*/
      2)
        set_data_dev(
          t3,
          /*text*/
          ctx2[1]
        );
      if (dirty & /*bg*/
      1) {
        set_style(div, "background-color", "var(--ui-" + /*bg*/
        ctx2[0] + ")");
      }
      if (dirty & /*text*/
      2) {
        set_style(div, "color", "var(--ui-" + /*text*/
        ctx2[1] + ")");
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment117.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance117($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("ColorPaletteBox", slots2, []);
  let { bg = "color-background" } = $$props2;
  let { text: text2 = "color-text" } = $$props2;
  const writable_props = ["bg", "text"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ColorPaletteBox> was created with unknown prop '${key}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("bg" in $$props3)
      $$invalidate2(0, bg = $$props3.bg);
    if ("text" in $$props3)
      $$invalidate2(1, text2 = $$props3.text);
  };
  $$self2.$capture_state = () => ({ bg, text: text2 });
  $$self2.$inject_state = ($$props3) => {
    if ("bg" in $$props3)
      $$invalidate2(0, bg = $$props3.bg);
    if ("text" in $$props3)
      $$invalidate2(1, text2 = $$props3.text);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [bg, text2];
}
var ColorPaletteBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance117, create_fragment117, safe_not_equal, { bg: 0, text: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ColorPaletteBox",
      options,
      id: create_fragment117.name
    });
  }
  get bg() {
    throw new Error("<ColorPaletteBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bg(value2) {
    throw new Error("<ColorPaletteBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<ColorPaletteBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value2) {
    throw new Error("<ColorPaletteBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ColorPaletteBox_default = ColorPaletteBox;

// docs-src/components/color-palette/ColorPalette.svelte
var file111 = "docs-src/components/color-palette/ColorPalette.svelte";
function create_fragment118(ctx) {
  let h2;
  let t1;
  let h30;
  let t3;
  let h40;
  let t5;
  let div0;
  let palettebox0;
  let t6;
  let palettebox1;
  let t7;
  let h41;
  let t9;
  let div1;
  let palettebox2;
  let t10;
  let palettebox3;
  let t11;
  let h42;
  let t13;
  let div2;
  let palettebox4;
  let t14;
  let palettebox5;
  let t15;
  let h43;
  let t17;
  let div3;
  let palettebox6;
  let t18;
  let palettebox7;
  let t19;
  let h44;
  let t21;
  let div4;
  let palettebox8;
  let t22;
  let palettebox9;
  let t23;
  let h45;
  let t25;
  let div5;
  let palettebox10;
  let t26;
  let palettebox11;
  let t27;
  let h31;
  let t29;
  let div6;
  let palettebox12;
  let t30;
  let palettebox13;
  let t31;
  let palettebox14;
  let t32;
  let h32;
  let t34;
  let div7;
  let palettebox15;
  let t35;
  let palettebox16;
  let t36;
  let palettebox17;
  let t37;
  let palettebox18;
  let t38;
  let palettebox19;
  let t39;
  let h33;
  let t41;
  let div8;
  let palettebox20;
  let t42;
  let palettebox21;
  let t43;
  let palettebox22;
  let t44;
  let palettebox23;
  let current;
  palettebox0 = new ColorPaletteBox_default({
    props: { bg: "color-accent" },
    $$inline: true
  });
  palettebox1 = new ColorPaletteBox_default({
    props: { bg: "color-accent-semi" },
    $$inline: true
  });
  palettebox2 = new ColorPaletteBox_default({
    props: { bg: "color-secondary" },
    $$inline: true
  });
  palettebox3 = new ColorPaletteBox_default({
    props: { bg: "color-secondary-semi" },
    $$inline: true
  });
  palettebox4 = new ColorPaletteBox_default({
    props: { bg: "color-info" },
    $$inline: true
  });
  palettebox5 = new ColorPaletteBox_default({
    props: { bg: "color-info-semi" },
    $$inline: true
  });
  palettebox6 = new ColorPaletteBox_default({
    props: { bg: "color-success" },
    $$inline: true
  });
  palettebox7 = new ColorPaletteBox_default({
    props: { bg: "color-success-semi" },
    $$inline: true
  });
  palettebox8 = new ColorPaletteBox_default({
    props: { bg: "color-warning" },
    $$inline: true
  });
  palettebox9 = new ColorPaletteBox_default({
    props: { bg: "color-warning-semi" },
    $$inline: true
  });
  palettebox10 = new ColorPaletteBox_default({
    props: { bg: "color-danger" },
    $$inline: true
  });
  palettebox11 = new ColorPaletteBox_default({
    props: { bg: "color-danger-semi" },
    $$inline: true
  });
  palettebox12 = new ColorPaletteBox_default({
    props: { bg: "color-highlight" },
    $$inline: true
  });
  palettebox13 = new ColorPaletteBox_default({
    props: { bg: "color-highlight-semi" },
    $$inline: true
  });
  palettebox14 = new ColorPaletteBox_default({
    props: { bg: "color-highlight-1" },
    $$inline: true
  });
  palettebox15 = new ColorPaletteBox_default({
    props: { bg: "color-background" },
    $$inline: true
  });
  palettebox16 = new ColorPaletteBox_default({
    props: { bg: "color-background-semi" },
    $$inline: true
  });
  palettebox17 = new ColorPaletteBox_default({
    props: { bg: "color-background-input" },
    $$inline: true
  });
  palettebox18 = new ColorPaletteBox_default({
    props: { bg: "color-background-1" },
    $$inline: true
  });
  palettebox19 = new ColorPaletteBox_default({
    props: { bg: "color-background-2" },
    $$inline: true
  });
  palettebox20 = new ColorPaletteBox_default({
    props: { text: "color-text" },
    $$inline: true
  });
  palettebox21 = new ColorPaletteBox_default({
    props: { text: "color-text-semi" },
    $$inline: true
  });
  palettebox22 = new ColorPaletteBox_default({
    props: { text: "color-text-1" },
    $$inline: true
  });
  palettebox23 = new ColorPaletteBox_default({
    props: { text: "color-text-2" },
    $$inline: true
  });
  const block = {
    c: function create() {
      h2 = element2("h2");
      h2.textContent = "Color Palette";
      t1 = space();
      h30 = element2("h3");
      h30.textContent = "Special colors";
      t3 = space();
      h40 = element2("h4");
      h40.textContent = "Accent";
      t5 = space();
      div0 = element2("div");
      create_component(palettebox0.$$.fragment);
      t6 = space();
      create_component(palettebox1.$$.fragment);
      t7 = space();
      h41 = element2("h4");
      h41.textContent = "Secondary";
      t9 = space();
      div1 = element2("div");
      create_component(palettebox2.$$.fragment);
      t10 = space();
      create_component(palettebox3.$$.fragment);
      t11 = space();
      h42 = element2("h4");
      h42.textContent = "Info";
      t13 = space();
      div2 = element2("div");
      create_component(palettebox4.$$.fragment);
      t14 = space();
      create_component(palettebox5.$$.fragment);
      t15 = space();
      h43 = element2("h4");
      h43.textContent = "Success";
      t17 = space();
      div3 = element2("div");
      create_component(palettebox6.$$.fragment);
      t18 = space();
      create_component(palettebox7.$$.fragment);
      t19 = space();
      h44 = element2("h4");
      h44.textContent = "Warning";
      t21 = space();
      div4 = element2("div");
      create_component(palettebox8.$$.fragment);
      t22 = space();
      create_component(palettebox9.$$.fragment);
      t23 = space();
      h45 = element2("h4");
      h45.textContent = "Danger";
      t25 = space();
      div5 = element2("div");
      create_component(palettebox10.$$.fragment);
      t26 = space();
      create_component(palettebox11.$$.fragment);
      t27 = space();
      h31 = element2("h3");
      h31.textContent = "Highlight colors";
      t29 = space();
      div6 = element2("div");
      create_component(palettebox12.$$.fragment);
      t30 = space();
      create_component(palettebox13.$$.fragment);
      t31 = space();
      create_component(palettebox14.$$.fragment);
      t32 = space();
      h32 = element2("h3");
      h32.textContent = "Background colors";
      t34 = space();
      div7 = element2("div");
      create_component(palettebox15.$$.fragment);
      t35 = space();
      create_component(palettebox16.$$.fragment);
      t36 = space();
      create_component(palettebox17.$$.fragment);
      t37 = space();
      create_component(palettebox18.$$.fragment);
      t38 = space();
      create_component(palettebox19.$$.fragment);
      t39 = space();
      h33 = element2("h3");
      h33.textContent = "Text colors";
      t41 = space();
      div8 = element2("div");
      create_component(palettebox20.$$.fragment);
      t42 = space();
      create_component(palettebox21.$$.fragment);
      t43 = space();
      create_component(palettebox22.$$.fragment);
      t44 = space();
      create_component(palettebox23.$$.fragment);
      add_location(h2, file111, 0, 0, 0);
      add_location(h30, file111, 2, 0, 24);
      add_location(h40, file111, 4, 0, 49);
      attr_dev(div0, "class", "group");
      add_location(div0, file111, 5, 0, 65);
      add_location(h41, file111, 10, 0, 166);
      attr_dev(div1, "class", "group");
      add_location(div1, file111, 11, 0, 185);
      add_location(h42, file111, 16, 0, 292);
      attr_dev(div2, "class", "group");
      add_location(div2, file111, 17, 0, 306);
      add_location(h43, file111, 22, 0, 403);
      attr_dev(div3, "class", "group");
      add_location(div3, file111, 23, 0, 420);
      add_location(h44, file111, 28, 0, 523);
      attr_dev(div4, "class", "group");
      add_location(div4, file111, 29, 0, 540);
      add_location(h45, file111, 34, 0, 643);
      attr_dev(div5, "class", "group");
      add_location(div5, file111, 35, 0, 659);
      add_location(h31, file111, 40, 0, 760);
      attr_dev(div6, "class", "group");
      add_location(div6, file111, 41, 0, 786);
      add_location(h32, file111, 47, 0, 932);
      attr_dev(div7, "class", "group");
      add_location(div7, file111, 48, 0, 959);
      add_location(h33, file111, 57, 0, 1193);
      attr_dev(div8, "class", "group");
      add_location(div8, file111, 58, 0, 1214);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, h30, anchor);
      insert_dev(target, t3, anchor);
      insert_dev(target, h40, anchor);
      insert_dev(target, t5, anchor);
      insert_dev(target, div0, anchor);
      mount_component(palettebox0, div0, null);
      append_dev(div0, t6);
      mount_component(palettebox1, div0, null);
      insert_dev(target, t7, anchor);
      insert_dev(target, h41, anchor);
      insert_dev(target, t9, anchor);
      insert_dev(target, div1, anchor);
      mount_component(palettebox2, div1, null);
      append_dev(div1, t10);
      mount_component(palettebox3, div1, null);
      insert_dev(target, t11, anchor);
      insert_dev(target, h42, anchor);
      insert_dev(target, t13, anchor);
      insert_dev(target, div2, anchor);
      mount_component(palettebox4, div2, null);
      append_dev(div2, t14);
      mount_component(palettebox5, div2, null);
      insert_dev(target, t15, anchor);
      insert_dev(target, h43, anchor);
      insert_dev(target, t17, anchor);
      insert_dev(target, div3, anchor);
      mount_component(palettebox6, div3, null);
      append_dev(div3, t18);
      mount_component(palettebox7, div3, null);
      insert_dev(target, t19, anchor);
      insert_dev(target, h44, anchor);
      insert_dev(target, t21, anchor);
      insert_dev(target, div4, anchor);
      mount_component(palettebox8, div4, null);
      append_dev(div4, t22);
      mount_component(palettebox9, div4, null);
      insert_dev(target, t23, anchor);
      insert_dev(target, h45, anchor);
      insert_dev(target, t25, anchor);
      insert_dev(target, div5, anchor);
      mount_component(palettebox10, div5, null);
      append_dev(div5, t26);
      mount_component(palettebox11, div5, null);
      insert_dev(target, t27, anchor);
      insert_dev(target, h31, anchor);
      insert_dev(target, t29, anchor);
      insert_dev(target, div6, anchor);
      mount_component(palettebox12, div6, null);
      append_dev(div6, t30);
      mount_component(palettebox13, div6, null);
      append_dev(div6, t31);
      mount_component(palettebox14, div6, null);
      insert_dev(target, t32, anchor);
      insert_dev(target, h32, anchor);
      insert_dev(target, t34, anchor);
      insert_dev(target, div7, anchor);
      mount_component(palettebox15, div7, null);
      append_dev(div7, t35);
      mount_component(palettebox16, div7, null);
      append_dev(div7, t36);
      mount_component(palettebox17, div7, null);
      append_dev(div7, t37);
      mount_component(palettebox18, div7, null);
      append_dev(div7, t38);
      mount_component(palettebox19, div7, null);
      insert_dev(target, t39, anchor);
      insert_dev(target, h33, anchor);
      insert_dev(target, t41, anchor);
      insert_dev(target, div8, anchor);
      mount_component(palettebox20, div8, null);
      append_dev(div8, t42);
      mount_component(palettebox21, div8, null);
      append_dev(div8, t43);
      mount_component(palettebox22, div8, null);
      append_dev(div8, t44);
      mount_component(palettebox23, div8, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(palettebox0.$$.fragment, local);
      transition_in(palettebox1.$$.fragment, local);
      transition_in(palettebox2.$$.fragment, local);
      transition_in(palettebox3.$$.fragment, local);
      transition_in(palettebox4.$$.fragment, local);
      transition_in(palettebox5.$$.fragment, local);
      transition_in(palettebox6.$$.fragment, local);
      transition_in(palettebox7.$$.fragment, local);
      transition_in(palettebox8.$$.fragment, local);
      transition_in(palettebox9.$$.fragment, local);
      transition_in(palettebox10.$$.fragment, local);
      transition_in(palettebox11.$$.fragment, local);
      transition_in(palettebox12.$$.fragment, local);
      transition_in(palettebox13.$$.fragment, local);
      transition_in(palettebox14.$$.fragment, local);
      transition_in(palettebox15.$$.fragment, local);
      transition_in(palettebox16.$$.fragment, local);
      transition_in(palettebox17.$$.fragment, local);
      transition_in(palettebox18.$$.fragment, local);
      transition_in(palettebox19.$$.fragment, local);
      transition_in(palettebox20.$$.fragment, local);
      transition_in(palettebox21.$$.fragment, local);
      transition_in(palettebox22.$$.fragment, local);
      transition_in(palettebox23.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(palettebox0.$$.fragment, local);
      transition_out(palettebox1.$$.fragment, local);
      transition_out(palettebox2.$$.fragment, local);
      transition_out(palettebox3.$$.fragment, local);
      transition_out(palettebox4.$$.fragment, local);
      transition_out(palettebox5.$$.fragment, local);
      transition_out(palettebox6.$$.fragment, local);
      transition_out(palettebox7.$$.fragment, local);
      transition_out(palettebox8.$$.fragment, local);
      transition_out(palettebox9.$$.fragment, local);
      transition_out(palettebox10.$$.fragment, local);
      transition_out(palettebox11.$$.fragment, local);
      transition_out(palettebox12.$$.fragment, local);
      transition_out(palettebox13.$$.fragment, local);
      transition_out(palettebox14.$$.fragment, local);
      transition_out(palettebox15.$$.fragment, local);
      transition_out(palettebox16.$$.fragment, local);
      transition_out(palettebox17.$$.fragment, local);
      transition_out(palettebox18.$$.fragment, local);
      transition_out(palettebox19.$$.fragment, local);
      transition_out(palettebox20.$$.fragment, local);
      transition_out(palettebox21.$$.fragment, local);
      transition_out(palettebox22.$$.fragment, local);
      transition_out(palettebox23.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
        detach_dev(t1);
        detach_dev(h30);
        detach_dev(t3);
        detach_dev(h40);
        detach_dev(t5);
        detach_dev(div0);
        detach_dev(t7);
        detach_dev(h41);
        detach_dev(t9);
        detach_dev(div1);
        detach_dev(t11);
        detach_dev(h42);
        detach_dev(t13);
        detach_dev(div2);
        detach_dev(t15);
        detach_dev(h43);
        detach_dev(t17);
        detach_dev(div3);
        detach_dev(t19);
        detach_dev(h44);
        detach_dev(t21);
        detach_dev(div4);
        detach_dev(t23);
        detach_dev(h45);
        detach_dev(t25);
        detach_dev(div5);
        detach_dev(t27);
        detach_dev(h31);
        detach_dev(t29);
        detach_dev(div6);
        detach_dev(t32);
        detach_dev(h32);
        detach_dev(t34);
        detach_dev(div7);
        detach_dev(t39);
        detach_dev(h33);
        detach_dev(t41);
        detach_dev(div8);
      }
      destroy_component(palettebox0);
      destroy_component(palettebox1);
      destroy_component(palettebox2);
      destroy_component(palettebox3);
      destroy_component(palettebox4);
      destroy_component(palettebox5);
      destroy_component(palettebox6);
      destroy_component(palettebox7);
      destroy_component(palettebox8);
      destroy_component(palettebox9);
      destroy_component(palettebox10);
      destroy_component(palettebox11);
      destroy_component(palettebox12);
      destroy_component(palettebox13);
      destroy_component(palettebox14);
      destroy_component(palettebox15);
      destroy_component(palettebox16);
      destroy_component(palettebox17);
      destroy_component(palettebox18);
      destroy_component(palettebox19);
      destroy_component(palettebox20);
      destroy_component(palettebox21);
      destroy_component(palettebox22);
      destroy_component(palettebox23);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment118.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance118($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("ColorPalette", slots2, []);
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ColorPalette> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({ PaletteBox: ColorPaletteBox_default });
  return [];
}
var ColorPalette = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance118, create_fragment118, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ColorPalette",
      options,
      id: create_fragment118.name
    });
  }
};
var ColorPalette_default = ColorPalette;

// docs-src/nav/Nav.svelte
var { window: window_1 } = globals;
var file112 = "docs-src/nav/Nav.svelte";
function create_fragment119(ctx) {
  let uibutton0;
  let updating_element;
  let t0;
  let aside;
  let menu;
  let h30;
  let t2;
  let navitem0;
  let t3;
  let navitem1;
  let t4;
  let h31;
  let t6;
  let navitem2;
  let t7;
  let navitem3;
  let t8;
  let navitem4;
  let t9;
  let h32;
  let t11;
  let navitem5;
  let t12;
  let navitem6;
  let t13;
  let navitem7;
  let t14;
  let navitem8;
  let t15;
  let navitem9;
  let t16;
  let navitem10;
  let t17;
  let navitem11;
  let t18;
  let navitem12;
  let t19;
  let navitem13;
  let t20;
  let navitem14;
  let t21;
  let navitem15;
  let t22;
  let navitem16;
  let t23;
  let navitem17;
  let t24;
  let navitem18;
  let t25;
  let navitem19;
  let t26;
  let navitem20;
  let t27;
  let navitem21;
  let t28;
  let h33;
  let t30;
  let navitem22;
  let t31;
  let navitem23;
  let t32;
  let navitem24;
  let t33;
  let navitem25;
  let t34;
  let h34;
  let t36;
  let navitem26;
  let t37;
  let navitem27;
  let t38;
  let navitem28;
  let t39;
  let navitem29;
  let t40;
  let navitem30;
  let t41;
  let navitem31;
  let t42;
  let navitem32;
  let t43;
  let h35;
  let t45;
  let navitem33;
  let t46;
  let navitem34;
  let t47;
  let navitem35;
  let t48;
  let navitem36;
  let t49;
  let navitem37;
  let t50;
  let uibutton1;
  let current;
  let mounted;
  let dispose;
  function uibutton0_element_binding(value2) {
    ctx[11](value2);
  }
  let uibutton0_props = {
    text: true,
    round: true,
    icon: "sidebarLeft",
    class: "nav-toggler " + /*expanded*/
    (ctx[2] ? "expanded" : "") + " " + /*swiping*/
    (ctx[3] ? "swiping" : "")
  };
  if (
    /*navTogglerBtn*/
    ctx[5] !== void 0
  ) {
    uibutton0_props.element = /*navTogglerBtn*/
    ctx[5];
  }
  uibutton0 = new Button_default({ props: uibutton0_props, $$inline: true });
  binding_callbacks.push(() => bind(uibutton0, "element", uibutton0_element_binding));
  uibutton0.$on(
    "click",
    /*toggleNav*/
    ctx[6]
  );
  navitem0 = new NavItem_default({
    props: {
      name: "Get Started",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem1 = new NavItem_default({
    props: {
      name: "Changelog",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem2 = new NavItem_default({
    props: {
      name: "Button",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem3 = new NavItem_default({
    props: {
      name: "Push Button",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem4 = new NavItem_default({
    props: {
      name: "Button Group",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem5 = new NavItem_default({
    props: {
      name: "Button Toggle",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem6 = new NavItem_default({
    props: {
      name: "Checkbox",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem7 = new NavItem_default({
    props: {
      name: "Combobox",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem8 = new NavItem_default({
    props: {
      name: "Input Date",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem9 = new NavItem_default({
    props: {
      name: "Input Math",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem10 = new NavItem_default({
    props: {
      name: "Input Number",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem11 = new NavItem_default({
    props: {
      name: "Input Password",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem12 = new NavItem_default({
    props: {
      name: "Input Rating",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem13 = new NavItem_default({
    props: {
      name: "Input Search",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem14 = new NavItem_default({
    props: {
      name: "Input Tag",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem15 = new NavItem_default({
    props: {
      name: "Input Text",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem16 = new NavItem_default({
    props: {
      name: "Input Time",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem17 = new NavItem_default({
    props: { name: "Radio", active: (
      /*active*/
      ctx[0]
    ) },
    $$inline: true
  });
  navitem18 = new NavItem_default({
    props: { name: "Range", active: (
      /*active*/
      ctx[0]
    ) },
    $$inline: true
  });
  navitem19 = new NavItem_default({
    props: {
      name: "Select",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem20 = new NavItem_default({
    props: {
      name: "Textarea",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem21 = new NavItem_default({
    props: {
      name: "Toggle",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem22 = new NavItem_default({
    props: {
      name: "InfoBar",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem23 = new NavItem_default({
    props: {
      name: "Notification Center",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem24 = new NavItem_default({
    props: {
      name: "MessageBox",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem25 = new NavItem_default({
    props: {
      name: "Tooltip",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem26 = new NavItem_default({
    props: {
      name: "Dialog",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem27 = new NavItem_default({
    props: {
      name: "Drawer",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem28 = new NavItem_default({
    props: { name: "Grid", active: (
      /*active*/
      ctx[0]
    ) },
    $$inline: true
  });
  navitem29 = new NavItem_default({
    props: { name: "Panel", active: (
      /*active*/
      ctx[0]
    ) },
    $$inline: true
  });
  navitem30 = new NavItem_default({
    props: {
      name: "Popover",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  navitem31 = new NavItem_default({
    props: { name: "Table", active: (
      /*active*/
      ctx[0]
    ) },
    $$inline: true
  });
  navitem32 = new NavItem_default({
    props: { name: "Tree", active: (
      /*active*/
      ctx[0]
    ) },
    $$inline: true
  });
  navitem33 = new NavItem_default({
    props: { name: "Menu", active: (
      /*active*/
      ctx[0]
    ) },
    $$inline: true
  });
  navitem34 = new NavItem_default({
    props: { name: "Tag", active: (
      /*active*/
      ctx[0]
    ) },
    $$inline: true
  });
  navitem35 = new NavItem_default({
    props: { name: "Icon", active: (
      /*active*/
      ctx[0]
    ) },
    $$inline: true
  });
  navitem36 = new NavItem_default({
    props: { name: "Utils", active: (
      /*active*/
      ctx[0]
    ) },
    $$inline: true
  });
  navitem37 = new NavItem_default({
    props: {
      name: "Color Palette",
      active: (
        /*active*/
        ctx[0]
      )
    },
    $$inline: true
  });
  uibutton1 = new Button_default({
    props: {
      round: true,
      info: true,
      icon: "arrowNarrowUp",
      class: "btn-scroll-top " + /*showScrollTopBtn*/
      (ctx[1] ? "" : "hidden"),
      title: "Scroll to the top"
    },
    $$inline: true
  });
  uibutton1.$on("click", scrollToTop);
  const block = {
    c: function create() {
      create_component(uibutton0.$$.fragment);
      t0 = space();
      aside = element2("aside");
      menu = element2("menu");
      h30 = element2("h3");
      h30.textContent = "Intro";
      t2 = space();
      create_component(navitem0.$$.fragment);
      t3 = space();
      create_component(navitem1.$$.fragment);
      t4 = space();
      h31 = element2("h3");
      h31.textContent = "Buttons";
      t6 = space();
      create_component(navitem2.$$.fragment);
      t7 = space();
      create_component(navitem3.$$.fragment);
      t8 = space();
      create_component(navitem4.$$.fragment);
      t9 = space();
      h32 = element2("h3");
      h32.textContent = "Inputs";
      t11 = space();
      create_component(navitem5.$$.fragment);
      t12 = space();
      create_component(navitem6.$$.fragment);
      t13 = space();
      create_component(navitem7.$$.fragment);
      t14 = space();
      create_component(navitem8.$$.fragment);
      t15 = space();
      create_component(navitem9.$$.fragment);
      t16 = space();
      create_component(navitem10.$$.fragment);
      t17 = space();
      create_component(navitem11.$$.fragment);
      t18 = space();
      create_component(navitem12.$$.fragment);
      t19 = space();
      create_component(navitem13.$$.fragment);
      t20 = space();
      create_component(navitem14.$$.fragment);
      t21 = space();
      create_component(navitem15.$$.fragment);
      t22 = space();
      create_component(navitem16.$$.fragment);
      t23 = space();
      create_component(navitem17.$$.fragment);
      t24 = space();
      create_component(navitem18.$$.fragment);
      t25 = space();
      create_component(navitem19.$$.fragment);
      t26 = space();
      create_component(navitem20.$$.fragment);
      t27 = space();
      create_component(navitem21.$$.fragment);
      t28 = space();
      h33 = element2("h3");
      h33.textContent = "Messaging";
      t30 = space();
      create_component(navitem22.$$.fragment);
      t31 = space();
      create_component(navitem23.$$.fragment);
      t32 = space();
      create_component(navitem24.$$.fragment);
      t33 = space();
      create_component(navitem25.$$.fragment);
      t34 = space();
      h34 = element2("h3");
      h34.textContent = "Containers";
      t36 = space();
      create_component(navitem26.$$.fragment);
      t37 = space();
      create_component(navitem27.$$.fragment);
      t38 = space();
      create_component(navitem28.$$.fragment);
      t39 = space();
      create_component(navitem29.$$.fragment);
      t40 = space();
      create_component(navitem30.$$.fragment);
      t41 = space();
      create_component(navitem31.$$.fragment);
      t42 = space();
      create_component(navitem32.$$.fragment);
      t43 = space();
      h35 = element2("h3");
      h35.textContent = "Generic";
      t45 = space();
      create_component(navitem33.$$.fragment);
      t46 = space();
      create_component(navitem34.$$.fragment);
      t47 = space();
      create_component(navitem35.$$.fragment);
      t48 = space();
      create_component(navitem36.$$.fragment);
      t49 = space();
      create_component(navitem37.$$.fragment);
      t50 = space();
      create_component(uibutton1.$$.fragment);
      add_location(h30, file112, 8, 2, 248);
      add_location(h31, file112, 12, 2, 348);
      add_location(h32, file112, 17, 2, 490);
      add_location(h33, file112, 37, 2, 1195);
      add_location(h34, file112, 44, 2, 1385);
      add_location(h35, file112, 54, 2, 1663);
      add_location(menu, file112, 7, 1, 239);
      toggle_class(
        aside,
        "expanded",
        /*expanded*/
        ctx[2]
      );
      toggle_class(
        aside,
        "swiping",
        /*swiping*/
        ctx[3]
      );
      add_location(aside, file112, 6, 0, 177);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(uibutton0, target, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, aside, anchor);
      append_dev(aside, menu);
      append_dev(menu, h30);
      append_dev(menu, t2);
      mount_component(navitem0, menu, null);
      append_dev(menu, t3);
      mount_component(navitem1, menu, null);
      append_dev(menu, t4);
      append_dev(menu, h31);
      append_dev(menu, t6);
      mount_component(navitem2, menu, null);
      append_dev(menu, t7);
      mount_component(navitem3, menu, null);
      append_dev(menu, t8);
      mount_component(navitem4, menu, null);
      append_dev(menu, t9);
      append_dev(menu, h32);
      append_dev(menu, t11);
      mount_component(navitem5, menu, null);
      append_dev(menu, t12);
      mount_component(navitem6, menu, null);
      append_dev(menu, t13);
      mount_component(navitem7, menu, null);
      append_dev(menu, t14);
      mount_component(navitem8, menu, null);
      append_dev(menu, t15);
      mount_component(navitem9, menu, null);
      append_dev(menu, t16);
      mount_component(navitem10, menu, null);
      append_dev(menu, t17);
      mount_component(navitem11, menu, null);
      append_dev(menu, t18);
      mount_component(navitem12, menu, null);
      append_dev(menu, t19);
      mount_component(navitem13, menu, null);
      append_dev(menu, t20);
      mount_component(navitem14, menu, null);
      append_dev(menu, t21);
      mount_component(navitem15, menu, null);
      append_dev(menu, t22);
      mount_component(navitem16, menu, null);
      append_dev(menu, t23);
      mount_component(navitem17, menu, null);
      append_dev(menu, t24);
      mount_component(navitem18, menu, null);
      append_dev(menu, t25);
      mount_component(navitem19, menu, null);
      append_dev(menu, t26);
      mount_component(navitem20, menu, null);
      append_dev(menu, t27);
      mount_component(navitem21, menu, null);
      append_dev(menu, t28);
      append_dev(menu, h33);
      append_dev(menu, t30);
      mount_component(navitem22, menu, null);
      append_dev(menu, t31);
      mount_component(navitem23, menu, null);
      append_dev(menu, t32);
      mount_component(navitem24, menu, null);
      append_dev(menu, t33);
      mount_component(navitem25, menu, null);
      append_dev(menu, t34);
      append_dev(menu, h34);
      append_dev(menu, t36);
      mount_component(navitem26, menu, null);
      append_dev(menu, t37);
      mount_component(navitem27, menu, null);
      append_dev(menu, t38);
      mount_component(navitem28, menu, null);
      append_dev(menu, t39);
      mount_component(navitem29, menu, null);
      append_dev(menu, t40);
      mount_component(navitem30, menu, null);
      append_dev(menu, t41);
      mount_component(navitem31, menu, null);
      append_dev(menu, t42);
      mount_component(navitem32, menu, null);
      append_dev(menu, t43);
      append_dev(menu, h35);
      append_dev(menu, t45);
      mount_component(navitem33, menu, null);
      append_dev(menu, t46);
      mount_component(navitem34, menu, null);
      append_dev(menu, t47);
      mount_component(navitem35, menu, null);
      append_dev(menu, t48);
      mount_component(navitem36, menu, null);
      append_dev(menu, t49);
      mount_component(navitem37, menu, null);
      ctx[12](aside);
      insert_dev(target, t50, anchor);
      mount_component(uibutton1, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window_1,
            "hashchange",
            /*onhashchange*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "popstate",
            /*onpopstate*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      const uibutton0_changes = {};
      if (dirty & /*expanded, swiping*/
      12)
        uibutton0_changes.class = "nav-toggler " + /*expanded*/
        (ctx2[2] ? "expanded" : "") + " " + /*swiping*/
        (ctx2[3] ? "swiping" : "");
      if (!updating_element && dirty & /*navTogglerBtn*/
      32) {
        updating_element = true;
        uibutton0_changes.element = /*navTogglerBtn*/
        ctx2[5];
        add_flush_callback(() => updating_element = false);
      }
      uibutton0.$set(uibutton0_changes);
      const navitem0_changes = {};
      if (dirty & /*active*/
      1)
        navitem0_changes.active = /*active*/
        ctx2[0];
      navitem0.$set(navitem0_changes);
      const navitem1_changes = {};
      if (dirty & /*active*/
      1)
        navitem1_changes.active = /*active*/
        ctx2[0];
      navitem1.$set(navitem1_changes);
      const navitem2_changes = {};
      if (dirty & /*active*/
      1)
        navitem2_changes.active = /*active*/
        ctx2[0];
      navitem2.$set(navitem2_changes);
      const navitem3_changes = {};
      if (dirty & /*active*/
      1)
        navitem3_changes.active = /*active*/
        ctx2[0];
      navitem3.$set(navitem3_changes);
      const navitem4_changes = {};
      if (dirty & /*active*/
      1)
        navitem4_changes.active = /*active*/
        ctx2[0];
      navitem4.$set(navitem4_changes);
      const navitem5_changes = {};
      if (dirty & /*active*/
      1)
        navitem5_changes.active = /*active*/
        ctx2[0];
      navitem5.$set(navitem5_changes);
      const navitem6_changes = {};
      if (dirty & /*active*/
      1)
        navitem6_changes.active = /*active*/
        ctx2[0];
      navitem6.$set(navitem6_changes);
      const navitem7_changes = {};
      if (dirty & /*active*/
      1)
        navitem7_changes.active = /*active*/
        ctx2[0];
      navitem7.$set(navitem7_changes);
      const navitem8_changes = {};
      if (dirty & /*active*/
      1)
        navitem8_changes.active = /*active*/
        ctx2[0];
      navitem8.$set(navitem8_changes);
      const navitem9_changes = {};
      if (dirty & /*active*/
      1)
        navitem9_changes.active = /*active*/
        ctx2[0];
      navitem9.$set(navitem9_changes);
      const navitem10_changes = {};
      if (dirty & /*active*/
      1)
        navitem10_changes.active = /*active*/
        ctx2[0];
      navitem10.$set(navitem10_changes);
      const navitem11_changes = {};
      if (dirty & /*active*/
      1)
        navitem11_changes.active = /*active*/
        ctx2[0];
      navitem11.$set(navitem11_changes);
      const navitem12_changes = {};
      if (dirty & /*active*/
      1)
        navitem12_changes.active = /*active*/
        ctx2[0];
      navitem12.$set(navitem12_changes);
      const navitem13_changes = {};
      if (dirty & /*active*/
      1)
        navitem13_changes.active = /*active*/
        ctx2[0];
      navitem13.$set(navitem13_changes);
      const navitem14_changes = {};
      if (dirty & /*active*/
      1)
        navitem14_changes.active = /*active*/
        ctx2[0];
      navitem14.$set(navitem14_changes);
      const navitem15_changes = {};
      if (dirty & /*active*/
      1)
        navitem15_changes.active = /*active*/
        ctx2[0];
      navitem15.$set(navitem15_changes);
      const navitem16_changes = {};
      if (dirty & /*active*/
      1)
        navitem16_changes.active = /*active*/
        ctx2[0];
      navitem16.$set(navitem16_changes);
      const navitem17_changes = {};
      if (dirty & /*active*/
      1)
        navitem17_changes.active = /*active*/
        ctx2[0];
      navitem17.$set(navitem17_changes);
      const navitem18_changes = {};
      if (dirty & /*active*/
      1)
        navitem18_changes.active = /*active*/
        ctx2[0];
      navitem18.$set(navitem18_changes);
      const navitem19_changes = {};
      if (dirty & /*active*/
      1)
        navitem19_changes.active = /*active*/
        ctx2[0];
      navitem19.$set(navitem19_changes);
      const navitem20_changes = {};
      if (dirty & /*active*/
      1)
        navitem20_changes.active = /*active*/
        ctx2[0];
      navitem20.$set(navitem20_changes);
      const navitem21_changes = {};
      if (dirty & /*active*/
      1)
        navitem21_changes.active = /*active*/
        ctx2[0];
      navitem21.$set(navitem21_changes);
      const navitem22_changes = {};
      if (dirty & /*active*/
      1)
        navitem22_changes.active = /*active*/
        ctx2[0];
      navitem22.$set(navitem22_changes);
      const navitem23_changes = {};
      if (dirty & /*active*/
      1)
        navitem23_changes.active = /*active*/
        ctx2[0];
      navitem23.$set(navitem23_changes);
      const navitem24_changes = {};
      if (dirty & /*active*/
      1)
        navitem24_changes.active = /*active*/
        ctx2[0];
      navitem24.$set(navitem24_changes);
      const navitem25_changes = {};
      if (dirty & /*active*/
      1)
        navitem25_changes.active = /*active*/
        ctx2[0];
      navitem25.$set(navitem25_changes);
      const navitem26_changes = {};
      if (dirty & /*active*/
      1)
        navitem26_changes.active = /*active*/
        ctx2[0];
      navitem26.$set(navitem26_changes);
      const navitem27_changes = {};
      if (dirty & /*active*/
      1)
        navitem27_changes.active = /*active*/
        ctx2[0];
      navitem27.$set(navitem27_changes);
      const navitem28_changes = {};
      if (dirty & /*active*/
      1)
        navitem28_changes.active = /*active*/
        ctx2[0];
      navitem28.$set(navitem28_changes);
      const navitem29_changes = {};
      if (dirty & /*active*/
      1)
        navitem29_changes.active = /*active*/
        ctx2[0];
      navitem29.$set(navitem29_changes);
      const navitem30_changes = {};
      if (dirty & /*active*/
      1)
        navitem30_changes.active = /*active*/
        ctx2[0];
      navitem30.$set(navitem30_changes);
      const navitem31_changes = {};
      if (dirty & /*active*/
      1)
        navitem31_changes.active = /*active*/
        ctx2[0];
      navitem31.$set(navitem31_changes);
      const navitem32_changes = {};
      if (dirty & /*active*/
      1)
        navitem32_changes.active = /*active*/
        ctx2[0];
      navitem32.$set(navitem32_changes);
      const navitem33_changes = {};
      if (dirty & /*active*/
      1)
        navitem33_changes.active = /*active*/
        ctx2[0];
      navitem33.$set(navitem33_changes);
      const navitem34_changes = {};
      if (dirty & /*active*/
      1)
        navitem34_changes.active = /*active*/
        ctx2[0];
      navitem34.$set(navitem34_changes);
      const navitem35_changes = {};
      if (dirty & /*active*/
      1)
        navitem35_changes.active = /*active*/
        ctx2[0];
      navitem35.$set(navitem35_changes);
      const navitem36_changes = {};
      if (dirty & /*active*/
      1)
        navitem36_changes.active = /*active*/
        ctx2[0];
      navitem36.$set(navitem36_changes);
      const navitem37_changes = {};
      if (dirty & /*active*/
      1)
        navitem37_changes.active = /*active*/
        ctx2[0];
      navitem37.$set(navitem37_changes);
      if (!current || dirty & /*expanded*/
      4) {
        toggle_class(
          aside,
          "expanded",
          /*expanded*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*swiping*/
      8) {
        toggle_class(
          aside,
          "swiping",
          /*swiping*/
          ctx2[3]
        );
      }
      const uibutton1_changes = {};
      if (dirty & /*showScrollTopBtn*/
      2)
        uibutton1_changes.class = "btn-scroll-top " + /*showScrollTopBtn*/
        (ctx2[1] ? "" : "hidden");
      uibutton1.$set(uibutton1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(uibutton0.$$.fragment, local);
      transition_in(navitem0.$$.fragment, local);
      transition_in(navitem1.$$.fragment, local);
      transition_in(navitem2.$$.fragment, local);
      transition_in(navitem3.$$.fragment, local);
      transition_in(navitem4.$$.fragment, local);
      transition_in(navitem5.$$.fragment, local);
      transition_in(navitem6.$$.fragment, local);
      transition_in(navitem7.$$.fragment, local);
      transition_in(navitem8.$$.fragment, local);
      transition_in(navitem9.$$.fragment, local);
      transition_in(navitem10.$$.fragment, local);
      transition_in(navitem11.$$.fragment, local);
      transition_in(navitem12.$$.fragment, local);
      transition_in(navitem13.$$.fragment, local);
      transition_in(navitem14.$$.fragment, local);
      transition_in(navitem15.$$.fragment, local);
      transition_in(navitem16.$$.fragment, local);
      transition_in(navitem17.$$.fragment, local);
      transition_in(navitem18.$$.fragment, local);
      transition_in(navitem19.$$.fragment, local);
      transition_in(navitem20.$$.fragment, local);
      transition_in(navitem21.$$.fragment, local);
      transition_in(navitem22.$$.fragment, local);
      transition_in(navitem23.$$.fragment, local);
      transition_in(navitem24.$$.fragment, local);
      transition_in(navitem25.$$.fragment, local);
      transition_in(navitem26.$$.fragment, local);
      transition_in(navitem27.$$.fragment, local);
      transition_in(navitem28.$$.fragment, local);
      transition_in(navitem29.$$.fragment, local);
      transition_in(navitem30.$$.fragment, local);
      transition_in(navitem31.$$.fragment, local);
      transition_in(navitem32.$$.fragment, local);
      transition_in(navitem33.$$.fragment, local);
      transition_in(navitem34.$$.fragment, local);
      transition_in(navitem35.$$.fragment, local);
      transition_in(navitem36.$$.fragment, local);
      transition_in(navitem37.$$.fragment, local);
      transition_in(uibutton1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(uibutton0.$$.fragment, local);
      transition_out(navitem0.$$.fragment, local);
      transition_out(navitem1.$$.fragment, local);
      transition_out(navitem2.$$.fragment, local);
      transition_out(navitem3.$$.fragment, local);
      transition_out(navitem4.$$.fragment, local);
      transition_out(navitem5.$$.fragment, local);
      transition_out(navitem6.$$.fragment, local);
      transition_out(navitem7.$$.fragment, local);
      transition_out(navitem8.$$.fragment, local);
      transition_out(navitem9.$$.fragment, local);
      transition_out(navitem10.$$.fragment, local);
      transition_out(navitem11.$$.fragment, local);
      transition_out(navitem12.$$.fragment, local);
      transition_out(navitem13.$$.fragment, local);
      transition_out(navitem14.$$.fragment, local);
      transition_out(navitem15.$$.fragment, local);
      transition_out(navitem16.$$.fragment, local);
      transition_out(navitem17.$$.fragment, local);
      transition_out(navitem18.$$.fragment, local);
      transition_out(navitem19.$$.fragment, local);
      transition_out(navitem20.$$.fragment, local);
      transition_out(navitem21.$$.fragment, local);
      transition_out(navitem22.$$.fragment, local);
      transition_out(navitem23.$$.fragment, local);
      transition_out(navitem24.$$.fragment, local);
      transition_out(navitem25.$$.fragment, local);
      transition_out(navitem26.$$.fragment, local);
      transition_out(navitem27.$$.fragment, local);
      transition_out(navitem28.$$.fragment, local);
      transition_out(navitem29.$$.fragment, local);
      transition_out(navitem30.$$.fragment, local);
      transition_out(navitem31.$$.fragment, local);
      transition_out(navitem32.$$.fragment, local);
      transition_out(navitem33.$$.fragment, local);
      transition_out(navitem34.$$.fragment, local);
      transition_out(navitem35.$$.fragment, local);
      transition_out(navitem36.$$.fragment, local);
      transition_out(navitem37.$$.fragment, local);
      transition_out(uibutton1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(aside);
        detach_dev(t50);
      }
      destroy_component(uibutton0, detaching);
      destroy_component(navitem0);
      destroy_component(navitem1);
      destroy_component(navitem2);
      destroy_component(navitem3);
      destroy_component(navitem4);
      destroy_component(navitem5);
      destroy_component(navitem6);
      destroy_component(navitem7);
      destroy_component(navitem8);
      destroy_component(navitem9);
      destroy_component(navitem10);
      destroy_component(navitem11);
      destroy_component(navitem12);
      destroy_component(navitem13);
      destroy_component(navitem14);
      destroy_component(navitem15);
      destroy_component(navitem16);
      destroy_component(navitem17);
      destroy_component(navitem18);
      destroy_component(navitem19);
      destroy_component(navitem20);
      destroy_component(navitem21);
      destroy_component(navitem22);
      destroy_component(navitem23);
      destroy_component(navitem24);
      destroy_component(navitem25);
      destroy_component(navitem26);
      destroy_component(navitem27);
      destroy_component(navitem28);
      destroy_component(navitem29);
      destroy_component(navitem30);
      destroy_component(navitem31);
      destroy_component(navitem32);
      destroy_component(navitem33);
      destroy_component(navitem34);
      destroy_component(navitem35);
      destroy_component(navitem36);
      destroy_component(navitem37);
      ctx[12](null);
      destroy_component(uibutton1, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment119.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var SIDEBAR_WIDTH = 220;
var swipeSlowDownFactor = 2.5;
function scrollToTop() {
  document.scrollingElement.scrollTo({ top: 0, behavior: "smooth" });
  setTimeout(
    () => {
      let section = location.hash.substring(1);
      if (section.includes("/"))
        section = section.substr(0, section.indexOf("/"));
      location.hash = section;
    },
    300
  );
}
function waitForElementAndScroll(selector, count = 10) {
  if (count === 0)
    return;
  const el = document.getElementById(selector);
  if (!el)
    return setTimeout(() => waitForElementAndScroll(selector, count - 1), 200);
  el.scrollIntoView({ behavior: "smooth" });
}
function getSection() {
  let [_section, _heading] = location.hash.substr(1).split("/");
  _section = _section || "GetStarted";
  _heading = _heading || "top";
  document.body.className = "section-" + _section.toLocaleLowerCase();
  return [_section, _heading];
}
function instance119($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Nav", slots2, []);
  const components = { GetStarted: start_default, Changelog: changelog_default, ...components_exports };
  let [active2, heading] = getSection();
  let { component = components[active2] } = $$props2;
  const onScroll = debounce(checkScrollOffset);
  let showScrollTopBtn = false;
  let expanded = false;
  let wasExpanded = false;
  let swiping = false;
  let sidebarEl, navTogglerBtn;
  onMount(() => {
    const swiper = new import_vanilla_swipe.default({
      element: document.body,
      delta: 3,
      mouseTrackingEnabled: true,
      preventTrackingOnMouseleave: true,
      onSwipeStart,
      onSwiping: onSwipe,
      onSwiped: onSwipeEnd,
      onTap
    });
    swiper.init();
    $$invalidate2(0, [active2, heading] = getSection(), active2, $$invalidate2(10, heading));
    window.addEventListener("scroll", onScroll);
  });
  onDestroy(() => {
    window.removeEventListener("scroll", onScroll);
  });
  function onSwipeStart(e) {
    if (window.innerWidth > 700)
      return;
    if (isInScrollable(e.target))
      return false;
    const untouchables = 'input, button, .toggle, .dialog-backdrop, .notification, .popover, [aria-haspopup="true"]';
    if (e.target.closest(untouchables))
      return;
    wasExpanded = expanded;
    $$invalidate2(3, swiping = true);
  }
  function onSwipe(e, data) {
    if (window.innerWidth > 700)
      return;
    if (!swiping)
      return;
    if (Math.abs(data.deltaY) > Math.abs(data.deltaX)) {
      $$invalidate2(4, sidebarEl.style.transform = "", sidebarEl);
      $$invalidate2(5, navTogglerBtn.style.transform = "", navTogglerBtn);
      return;
    }
    e.preventDefault();
    let sidebarX = 0;
    if (wasExpanded) {
      sidebarX = 0;
      if (data.deltaX > 0)
        sidebarX += data.deltaX * Math.exp(-swipeSlowDownFactor);
      else
        sidebarX += data.deltaX;
    } else {
      sidebarX = -SIDEBAR_WIDTH;
      if (data.deltaX > 0) {
        if (data.deltaX < SIDEBAR_WIDTH)
          sidebarX += data.deltaX;
        else
          sidebarX = (sidebarX + data.deltaX) * Math.exp(-swipeSlowDownFactor);
      }
    }
    $$invalidate2(4, sidebarEl.style.transform = `translateX(${sidebarX}px)`, sidebarEl);
    let btnX = sidebarX + 180;
    btnX = Math.max(10, btnX);
    $$invalidate2(5, navTogglerBtn.style.transform = `translateX(${btnX}px)`, navTogglerBtn);
  }
  function onSwipeEnd(e, data) {
    if (window.innerWidth > 700)
      return;
    if (!swiping)
      return;
    $$invalidate2(3, swiping = false);
    if (Math.abs(data.deltaY) > Math.abs(data.deltaX)) {
      $$invalidate2(4, sidebarEl.style.transform = "", sidebarEl);
      $$invalidate2(5, navTogglerBtn.style.transform = "", navTogglerBtn);
      $$invalidate2(2, expanded = wasExpanded);
      return;
    }
    if (data.directionX === "LEFT" && !wasExpanded) {
      $$invalidate2(4, sidebarEl.style.transform = "", sidebarEl);
      $$invalidate2(5, navTogglerBtn.style.transform = "", navTogglerBtn);
      $$invalidate2(2, expanded = wasExpanded);
      return;
    }
    if (data.directionX === "RIGHT" && wasExpanded) {
      $$invalidate2(4, sidebarEl.style.transform = "", sidebarEl);
      $$invalidate2(5, navTogglerBtn.style.transform = "", navTogglerBtn);
      $$invalidate2(2, expanded = wasExpanded);
      return;
    }
    const delta = Math.abs(data.deltaX) + data.velocity * 50;
    const half = SIDEBAR_WIDTH / 2;
    if (delta > half)
      $$invalidate2(2, expanded = !wasExpanded);
    wasExpanded = expanded;
    $$invalidate2(4, sidebarEl.style.transform = "", sidebarEl);
    $$invalidate2(5, navTogglerBtn.style.transform = "", navTogglerBtn);
    requestAnimationFrame(() => document.body.focus());
  }
  function onTap(e) {
    if (window.innerWidth > 700)
      return;
    if (e.target.closest("aside,.nav-toggler"))
      return;
    if (wasExpanded)
      $$invalidate2(2, expanded = false);
    wasExpanded = expanded;
  }
  function toggleNav() {
    $$invalidate2(2, expanded = !expanded);
    wasExpanded = expanded;
  }
  function onhashchange() {
    $$invalidate2(0, [active2, heading] = getSection(), active2, $$invalidate2(10, heading));
    $$invalidate2(9, component = components[active2]);
    if (window.Prism)
      requestAnimationFrame(() => window.Prism.highlightAll());
    document.scrollingElement.scrollTop = 0;
  }
  function onpopstate() {
    $$invalidate2(2, expanded = false);
    wasExpanded = expanded;
  }
  function checkScrollOffset() {
    $$invalidate2(1, showScrollTopBtn = document.scrollingElement.scrollTop > 200);
  }
  const writable_props = ["component"];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Nav> was created with unknown prop '${key}'`);
  });
  function uibutton0_element_binding(value2) {
    navTogglerBtn = value2;
    $$invalidate2(5, navTogglerBtn);
  }
  function aside_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      sidebarEl = $$value;
      $$invalidate2(4, sidebarEl);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("component" in $$props3)
      $$invalidate2(9, component = $$props3.component);
  };
  $$self2.$capture_state = () => ({
    onDestroy,
    onMount,
    UIButton: Button_default,
    isInScrollable,
    debounce,
    VanillaSwipe: import_vanilla_swipe.default,
    NavItem: NavItem_default,
    GetStarted: start_default,
    Changelog: changelog_default,
    TestComponents: components_exports,
    components,
    active: active2,
    heading,
    component,
    SIDEBAR_WIDTH,
    swipeSlowDownFactor,
    onScroll,
    showScrollTopBtn,
    expanded,
    wasExpanded,
    swiping,
    sidebarEl,
    navTogglerBtn,
    onSwipeStart,
    onSwipe,
    onSwipeEnd,
    onTap,
    toggleNav,
    scrollToTop,
    waitForElementAndScroll,
    getSection,
    onhashchange,
    onpopstate,
    checkScrollOffset
  });
  $$self2.$inject_state = ($$props3) => {
    if ("active" in $$props3)
      $$invalidate2(0, active2 = $$props3.active);
    if ("heading" in $$props3)
      $$invalidate2(10, heading = $$props3.heading);
    if ("component" in $$props3)
      $$invalidate2(9, component = $$props3.component);
    if ("showScrollTopBtn" in $$props3)
      $$invalidate2(1, showScrollTopBtn = $$props3.showScrollTopBtn);
    if ("expanded" in $$props3)
      $$invalidate2(2, expanded = $$props3.expanded);
    if ("wasExpanded" in $$props3)
      wasExpanded = $$props3.wasExpanded;
    if ("swiping" in $$props3)
      $$invalidate2(3, swiping = $$props3.swiping);
    if ("sidebarEl" in $$props3)
      $$invalidate2(4, sidebarEl = $$props3.sidebarEl);
    if ("navTogglerBtn" in $$props3)
      $$invalidate2(5, navTogglerBtn = $$props3.navTogglerBtn);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*heading*/
    1024) {
      $: {
        waitForElementAndScroll(heading);
      }
    }
  };
  return [
    active2,
    showScrollTopBtn,
    expanded,
    swiping,
    sidebarEl,
    navTogglerBtn,
    toggleNav,
    onhashchange,
    onpopstate,
    component,
    heading,
    uibutton0_element_binding,
    aside_binding
  ];
}
var Nav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance119, create_fragment119, safe_not_equal, { component: 9 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Nav",
      options,
      id: create_fragment119.name
    });
  }
  get component() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value2) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Nav_default = Nav;

// docs-src/header/Header.svelte
function create_fragment120(ctx) {
  let buttontoggle;
  let current;
  buttontoggle = new ButtonToggle_default({
    props: {
      round: true,
      class: "dark-mode-switch",
      title: "Dark mode toggle",
      items: (
        /*themes*/
        ctx[1]
      ),
      value: (
        /*$PREFERS_DARK*/
        ctx[0]
      )
    },
    $$inline: true
  });
  buttontoggle.$on("change", switchColorMode);
  const block = {
    c: function create() {
      create_component(buttontoggle.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(buttontoggle, target, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const buttontoggle_changes = {};
      if (dirty & /*$PREFERS_DARK*/
      1)
        buttontoggle_changes.value = /*$PREFERS_DARK*/
        ctx2[0];
      buttontoggle.$set(buttontoggle_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(buttontoggle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttontoggle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(buttontoggle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment120.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function switchColorMode(e) {
  document.documentElement.className = e.detail ? "theme-dark" : "theme-light";
}
function instance120($$self2, $$props2, $$invalidate2) {
  let $PREFERS_DARK;
  validate_store(PREFERS_DARK, "PREFERS_DARK");
  component_subscribe($$self2, PREFERS_DARK, ($$value) => $$invalidate2(0, $PREFERS_DARK = $$value));
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Header", slots2, []);
  const themes = [{ value: false, icon: "sun" }, { value: true, icon: "moon" }];
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Header> was created with unknown prop '${key}'`);
  });
  $$self2.$capture_state = () => ({
    ButtonToggle: ButtonToggle_default,
    PREFERS_DARK,
    themes,
    switchColorMode,
    $PREFERS_DARK
  });
  return [$PREFERS_DARK, themes];
}
var Header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance120, create_fragment120, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Header",
      options,
      id: create_fragment120.name
    });
  }
};
var Header_default = Header;

// docs-src/app/App.svelte
var file113 = "docs-src/app/App.svelte";
function create_fragment121(ctx) {
  let nav;
  let updating_component;
  let t0;
  let main;
  let header;
  let t1;
  let switch_instance;
  let current;
  function nav_component_binding(value2) {
    ctx[2](value2);
  }
  let nav_props = {};
  if (
    /*component*/
    ctx[0] !== void 0
  ) {
    nav_props.component = /*component*/
    ctx[0];
  }
  nav = new Nav_default({ props: nav_props, $$inline: true });
  binding_callbacks.push(() => bind(nav, "component", nav_component_binding));
  header = new Header_default({ $$inline: true });
  var switch_value = (
    /*component*/
    ctx[0]
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      create_component(nav.$$.fragment);
      t0 = space();
      main = element2("main");
      create_component(header.$$.fragment);
      t1 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr_dev(
        main,
        "class",
        /*pageName*/
        ctx[1]
      );
      add_location(main, file113, 1, 0, 37);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(nav, target, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, main, anchor);
      mount_component(header, main, null);
      append_dev(main, t1);
      if (switch_instance)
        mount_component(switch_instance, main, null);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      const nav_changes = {};
      if (!updating_component && dirty & /*component*/
      1) {
        updating_component = true;
        nav_changes.component = /*component*/
        ctx2[0];
        add_flush_callback(() => updating_component = false);
      }
      nav.$set(nav_changes);
      if (dirty & /*component*/
      1 && switch_value !== (switch_value = /*component*/
      ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, main, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if (!current || dirty & /*pageName*/
      2) {
        attr_dev(
          main,
          "class",
          /*pageName*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(nav.$$.fragment, local);
      transition_in(header.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(nav.$$.fragment, local);
      transition_out(header.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(main);
      }
      destroy_component(nav, detaching);
      destroy_component(header);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment121.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance121($$self2, $$props2, $$invalidate2) {
  let pageName;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("App", slots2, []);
  let component = void 0;
  const writable_props = [];
  Object.keys($$props2).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<App> was created with unknown prop '${key}'`);
  });
  function nav_component_binding(value2) {
    component = value2;
    $$invalidate2(0, component);
  }
  $$self2.$capture_state = () => ({ Nav: Nav_default, Header: Header_default, component, pageName });
  $$self2.$inject_state = ($$props3) => {
    if ("component" in $$props3)
      $$invalidate2(0, component = $$props3.component);
    if ("pageName" in $$props3)
      $$invalidate2(1, pageName = $$props3.pageName);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*component*/
    1) {
      $:
        $$invalidate2(1, pageName = (component && component.name || "").toLowerCase());
    }
  };
  return [component, pageName, nav_component_binding];
}
var App = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance121, create_fragment121, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "App",
      options,
      id: create_fragment121.name
    });
  }
};
var App_default = App;

// docs-src/index.js
var import_prismjs = __toESM(require_prism(), 1);

// node_modules/prism-svelte/index.js
var blocks = "(if|else if|await|then|catch|each|html|debug)";
Prism.languages.svelte = Prism.languages.extend("markup", {
  each: {
    pattern: new RegExp(
      "{[#/]each(?:(?:\\{(?:(?:\\{(?:[^{}])*\\})|(?:[^{}]))*\\})|(?:[^{}]))*}"
    ),
    inside: {
      "language-javascript": [
        {
          pattern: /(as[\s\S]*)\([\s\S]*\)(?=\s*\})/,
          lookbehind: true,
          inside: Prism.languages["javascript"]
        },
        {
          pattern: /(as[\s]*)[\s\S]*(?=\s*)/,
          lookbehind: true,
          inside: Prism.languages["javascript"]
        },
        {
          pattern: /(#each[\s]*)[\s\S]*(?=as)/,
          lookbehind: true,
          inside: Prism.languages["javascript"]
        }
      ],
      keyword: /[#/]each|as/,
      punctuation: /{|}/
    }
  },
  block: {
    pattern: new RegExp(
      "{[#:/@]/s" + blocks + "(?:(?:\\{(?:(?:\\{(?:[^{}])*\\})|(?:[^{}]))*\\})|(?:[^{}]))*}"
    ),
    inside: {
      punctuation: /^{|}$/,
      keyword: [new RegExp("[#:/@]" + blocks + "( )*"), /as/, /then/],
      "language-javascript": {
        pattern: /[\s\S]*/,
        inside: Prism.languages["javascript"]
      }
    }
  },
  tag: {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?:"[^"]*"|'[^']*'|{[\s\S]+?}(?=[\s/>])))|(?=[\s/>])))+)?\s*\/?>/i,
    greedy: true,
    inside: {
      tag: {
        pattern: /^<\/?[^\s>\/]+/i,
        inside: {
          punctuation: /^<\/?/,
          namespace: /^[^\s>\/:]+:/
        }
      },
      "language-javascript": {
        pattern: /\{(?:(?:\{(?:(?:\{(?:[^{}])*\})|(?:[^{}]))*\})|(?:[^{}]))*\}/,
        inside: Prism.languages["javascript"]
      },
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/i,
        inside: {
          punctuation: [
            /^=/,
            {
              pattern: /^(\s*)["']|["']$/,
              lookbehind: true
            }
          ],
          "language-javascript": {
            pattern: /{[\s\S]+}/,
            inside: Prism.languages["javascript"]
          }
        }
      },
      punctuation: /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          namespace: /^[^\s>\/:]+:/
        }
      }
    }
  },
  "language-javascript": {
    pattern: /\{(?:(?:\{(?:(?:\{(?:[^{}])*\})|(?:[^{}]))*\})|(?:[^{}]))*\}/,
    lookbehind: true,
    inside: Prism.languages["javascript"]
  }
});
Prism.languages.svelte["tag"].inside["attr-value"].inside["entity"] = Prism.languages.svelte["entity"];
Prism.hooks.add("wrap", (env) => {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.svelte.tag, "addInlined", {
  value: function addInlined(tagName, lang) {
    const includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    const inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    const def = {};
    def[tagName] = {
      pattern: RegExp(
        /(<__[\s\S]*?>)(?:<!\[CDATA\[[\s\S]*?\]\]>\s*|[\s\S])*?(?=<\/__>)/.source.replace(
          /__/g,
          tagName
        ),
        "i"
      ),
      lookbehind: true,
      greedy: true,
      inside
    };
    Prism.languages.insertBefore("svelte", "cdata", def);
  }
});
Prism.languages.svelte.tag.addInlined("style", "css");
Prism.languages.svelte.tag.addInlined("script", "javascript");

// node_modules/prismjs/components/prism-json.js
Prism.languages.json = {
  "property": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "comment": {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "punctuation": /[{}[\],]/,
  "operator": /:/,
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
Prism.languages.webmanifest = Prism.languages.json;

// node_modules/prismjs/components/prism-bash.js
(function(Prism2) {
  var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
  var commandAfterHeredoc = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: "punctuation",
    // this looks reasonably well in all themes
    inside: null
    // see below
  };
  var insideString = {
    "bash": commandAfterHeredoc,
    "environment": {
      pattern: RegExp("\\$" + envVars),
      alias: "constant"
    },
    "variable": [
      // [0]: Arithmetic Environment
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: true,
        inside: {
          // If there is a $ sign at the beginning highlight $(( and )) as variable
          "variable": [
            {
              pattern: /(^\$\(\([\s\S]+)\)\)/,
              lookbehind: true
            },
            /^\$\(\(/
          ],
          "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
          "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          // If there is no $ sign at the beginning highlight (( and )) as punctuation
          "punctuation": /\(\(?|\)\)?|,|;/
        }
      },
      // [1]: Command Substitution
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: true,
        inside: {
          "variable": /^\$\(|^`|\)$|`$/
        }
      },
      // [2]: Brace expansion
      {
        pattern: /\$\{[^}]+\}/,
        greedy: true,
        inside: {
          "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          "punctuation": /[\[\]]/,
          "environment": {
            pattern: RegExp("(\\{)" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  Prism2.languages.bash = {
    "shebang": {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    "comment": {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: true
    },
    "function-name": [
      // a) function foo {
      // b) foo() {
      // c) function foo() {
      // but not foo {
      {
        // a) and c)
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: true,
        alias: "function"
      },
      {
        // b)
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    // Highlight variable names as variables in for and select beginnings.
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: true
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (= and +=).
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
      inside: {
        "environment": {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
          lookbehind: true,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: true
    },
    // Highlight parameter names as variables
    "parameter": {
      pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
      alias: "variable",
      lookbehind: true
    },
    "string": [
      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      // Here-document with quotes around the tag
      //  No expansion (so no inside).
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: true,
        greedy: true,
        inside: {
          "bash": commandAfterHeredoc
        }
      },
      // Normal string
      {
        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: true,
        greedy: true
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: {
          "entity": insideString.entity
        }
      }
    ],
    "environment": {
      pattern: RegExp("\\$?" + envVars),
      alias: "constant"
    },
    "variable": insideString.variable,
    "function": {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "keyword": {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    "builtin": {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: true,
      // Alias added to make those easier to distinguish from strings.
      alias: "class-name"
    },
    "boolean": {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    "operator": {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    "number": {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  };
  commandAfterHeredoc.inside = Prism2.languages.bash;
  var toBeCopied = [
    "comment",
    "function-name",
    "for-or-select",
    "assign-left",
    "parameter",
    "string",
    "environment",
    "function",
    "keyword",
    "builtin",
    "boolean",
    "file-descriptor",
    "operator",
    "punctuation",
    "number"
  ];
  var inside = insideString.variable[1].inside;
  for (var i = 0; i < toBeCopied.length; i++) {
    inside[toBeCopied[i]] = Prism2.languages.bash[toBeCopied[i]];
  }
  Prism2.languages.sh = Prism2.languages.bash;
  Prism2.languages.shell = Prism2.languages.bash;
})(Prism);

// docs-src/index.js
var import_prism_normalize_whitespace = __toESM(require_prism_normalize_whitespace(), 1);
var docs_src_default = new App_default({ target: document.querySelector("#app") });
export {
  docs_src_default as default
};
//# sourceMappingURL=docs.js.map
